"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const React = require("react");
const ReactDOM = require("react-dom");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
const ReactDOM__namespace = /* @__PURE__ */ _interopNamespaceDefault(ReactDOM);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign;
var hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2["_" + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from2;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
      from2 = Object(arguments[s]);
      for (var key in from2) {
        if (hasOwnProperty2.call(from2, key)) {
          to[key] = from2[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from2);
        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from2, symbols[i])) {
            to[symbols[i]] = from2[symbols[i]];
          }
        }
      }
    }
    return to;
  };
  return objectAssign;
}
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  requireObjectAssign();
  var f = React, g = 60103;
  reactJsxRuntime_production_min.Fragment = 60107;
  if ("function" === typeof Symbol && Symbol.for) {
    var h = Symbol.for;
    g = h("react.element");
    reactJsxRuntime_production_min.Fragment = h("react.fragment");
  }
  var m = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n = Object.prototype.hasOwnProperty, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, k) {
    var b, d = {}, e = null, l = null;
    void 0 !== k && (e = "" + k);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (l = a.ref);
    for (b in a)
      n.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps)
      for (b in a = c.defaultProps, a)
        void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: g, type: c, key: e, ref: l, props: d, _owner: m.current };
  }
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development)
    return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  (function(exports2) {
    if (process.env.NODE_ENV !== "production") {
      (function() {
        var React$1 = React;
        var _assign = requireObjectAssign();
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        exports2.Fragment = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          exports2.Fragment = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          symbolFor("react.scope");
          symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === exports2.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case exports2.Fragment:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentName(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix2;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix2 === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match2 = x.stack.trim().match(/\n( *(at )?)/);
                prefix2 = match2 && match2[1] || "";
              }
            }
            return "\n" + prefix2 + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values2, location2, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty2.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty2.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self2) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config, maybeKey, source, self2) {
          {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              key = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self2);
            }
            for (propName in config) {
              if (hasOwnProperty2.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps2 = type.defaultProps;
              for (propName in defaultProps2) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps2[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentName(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node2, parentType) {
          {
            if (typeof node2 !== "object") {
              return;
            }
            if (Array.isArray(node2)) {
              for (var i = 0; i < node2.length; i++) {
                var child = node2[i];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node2)) {
              if (node2._store) {
                node2._store.validated = true;
              }
            } else if (node2) {
              var iteratorFn = getIteratorFn(node2);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node2.entries) {
                  var iterator = iteratorFn.call(node2);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentName(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentName(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i = 0; i < keys2.length; i++) {
              var key = keys2[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (Array.isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props, key, source, self2);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (Array.isArray(children)) {
                    for (var i = 0; i < children.length; i++) {
                      validateChildKeys(children[i], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type);
                }
              }
            }
            if (type === exports2.Fragment) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, true);
          }
        }
        function jsxWithValidationDynamic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, false);
          }
        }
        var jsx3 = jsxWithValidationDynamic;
        var jsxs = jsxWithValidationStatic;
        exports2.jsx = jsx3;
        exports2.jsxs = jsxs;
      })();
    }
  })(reactJsxRuntime_development);
  return reactJsxRuntime_development;
}
if (process.env.NODE_ENV === "production") {
  jsxRuntime.exports = requireReactJsxRuntime_production_min();
} else {
  jsxRuntime.exports = requireReactJsxRuntime_development();
}
var jsxRuntimeExports = jsxRuntime.exports;
/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
var XLSX = {};
XLSX.version = "0.19.3";
var current_codepage = 1200;
var $cptable;
var VALID_ANSI = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4];
var CS2CP = {
  /*::[*/
  0: 1252,
  /* ANSI */
  /*::[*/
  1: 65001,
  /* DEFAULT */
  /*::[*/
  2: 65001,
  /* SYMBOL */
  /*::[*/
  77: 1e4,
  /* MAC */
  /*::[*/
  128: 932,
  /* SHIFTJIS */
  /*::[*/
  129: 949,
  /* HANGUL */
  /*::[*/
  130: 1361,
  /* JOHAB */
  /*::[*/
  134: 936,
  /* GB2312 */
  /*::[*/
  136: 950,
  /* CHINESEBIG5 */
  /*::[*/
  161: 1253,
  /* GREEK */
  /*::[*/
  162: 1254,
  /* TURKISH */
  /*::[*/
  163: 1258,
  /* VIETNAMESE */
  /*::[*/
  177: 1255,
  /* HEBREW */
  /*::[*/
  178: 1256,
  /* ARABIC */
  /*::[*/
  186: 1257,
  /* BALTIC */
  /*::[*/
  204: 1251,
  /* RUSSIAN */
  /*::[*/
  222: 874,
  /* THAI */
  /*::[*/
  238: 1250,
  /* EASTEUROPE */
  /*::[*/
  255: 1252,
  /* OEM */
  /*::[*/
  69: 6969
  /* MISC */
};
var set_ansi = function(cp) {
  if (VALID_ANSI.indexOf(cp) == -1)
    return;
  CS2CP[0] = cp;
};
function reset_ansi() {
  set_ansi(1252);
}
var set_cp = function(cp) {
  current_codepage = cp;
  set_ansi(cp);
};
function reset_cp() {
  set_cp(1200);
  reset_ansi();
}
function char_codes(data) {
  var o = [];
  for (var i = 0, len = data.length; i < len; ++i)
    o[i] = data.charCodeAt(i);
  return o;
}
function utf16leread(data) {
  var o = [];
  for (var i = 0; i < data.length >> 1; ++i)
    o[i] = String.fromCharCode(data.charCodeAt(2 * i) + (data.charCodeAt(2 * i + 1) << 8));
  return o.join("");
}
function utf16lereadu(data) {
  var o = [];
  for (var i = 0; i < data.length >> 1; ++i)
    o[i] = String.fromCharCode(data[2 * i] + (data[2 * i + 1] << 8));
  return o.join("");
}
function utf16beread(data) {
  var o = [];
  for (var i = 0; i < data.length >> 1; ++i)
    o[i] = String.fromCharCode(data.charCodeAt(2 * i + 1) + (data.charCodeAt(2 * i) << 8));
  return o.join("");
}
var debom = function(data) {
  var c1 = data.charCodeAt(0), c2 = data.charCodeAt(1);
  if (c1 == 255 && c2 == 254)
    return utf16leread(data.slice(2));
  if (c1 == 254 && c2 == 255)
    return utf16beread(data.slice(2));
  if (c1 == 65279)
    return data.slice(1);
  return data;
};
var _getchar = function _gc1(x) {
  return String.fromCharCode(x);
};
var _getansi = function _ga1(x) {
  return String.fromCharCode(x);
};
var DENSE = null;
var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function Base64_encode(input) {
  var o = "";
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
  for (var i = 0; i < input.length; ) {
    c1 = input.charCodeAt(i++);
    e1 = c1 >> 2;
    c2 = input.charCodeAt(i++);
    e2 = (c1 & 3) << 4 | c2 >> 4;
    c3 = input.charCodeAt(i++);
    e3 = (c2 & 15) << 2 | c3 >> 6;
    e4 = c3 & 63;
    if (isNaN(c2)) {
      e3 = e4 = 64;
    } else if (isNaN(c3)) {
      e4 = 64;
    }
    o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
  }
  return o;
}
function Base64_encode_pass(input) {
  var o = "";
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
  for (var i = 0; i < input.length; ) {
    c1 = input.charCodeAt(i++);
    if (c1 > 255)
      c1 = 95;
    e1 = c1 >> 2;
    c2 = input.charCodeAt(i++);
    if (c2 > 255)
      c2 = 95;
    e2 = (c1 & 3) << 4 | c2 >> 4;
    c3 = input.charCodeAt(i++);
    if (c3 > 255)
      c3 = 95;
    e3 = (c2 & 15) << 2 | c3 >> 6;
    e4 = c3 & 63;
    if (isNaN(c2)) {
      e3 = e4 = 64;
    } else if (isNaN(c3)) {
      e4 = 64;
    }
    o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
  }
  return o;
}
function Base64_decode(input) {
  var o = "";
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
  input = input.replace(/^data:([^\/]+\/[^\/]+)?;base64\,/, "").replace(/[^\w\+\/\=]/g, "");
  for (var i = 0; i < input.length; ) {
    e1 = Base64_map.indexOf(input.charAt(i++));
    e2 = Base64_map.indexOf(input.charAt(i++));
    c1 = e1 << 2 | e2 >> 4;
    o += String.fromCharCode(c1);
    e3 = Base64_map.indexOf(input.charAt(i++));
    c2 = (e2 & 15) << 4 | e3 >> 2;
    if (e3 !== 64) {
      o += String.fromCharCode(c2);
    }
    e4 = Base64_map.indexOf(input.charAt(i++));
    c3 = (e3 & 3) << 6 | e4;
    if (e4 !== 64) {
      o += String.fromCharCode(c3);
    }
  }
  return o;
}
var has_buf = /* @__PURE__ */ function() {
  return typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && !!process.versions.node;
}();
var Buffer_from = /* @__PURE__ */ function() {
  if (typeof Buffer !== "undefined") {
    var nbfs = !Buffer.from;
    if (!nbfs)
      try {
        Buffer.from("foo", "utf8");
      } catch (e) {
        nbfs = true;
      }
    return nbfs ? function(buf, enc) {
      return enc ? new Buffer(buf, enc) : new Buffer(buf);
    } : Buffer.from.bind(Buffer);
  }
  return function() {
  };
}();
var buf_utf16le = /* @__PURE__ */ function() {
  if (typeof Buffer === "undefined")
    return false;
  var x = Buffer_from([65, 0]);
  if (!x)
    return false;
  var o = x.toString("utf16le");
  return o.length == 1;
}();
function new_raw_buf(len) {
  if (has_buf)
    return Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);
  return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
}
function new_unsafe_buf(len) {
  if (has_buf)
    return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
  return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
}
var s2a = function s2a2(s) {
  if (has_buf)
    return Buffer_from(s, "binary");
  return s.split("").map(function(x) {
    return x.charCodeAt(0) & 255;
  });
};
function s2ab(s) {
  if (typeof ArrayBuffer === "undefined")
    return s2a(s);
  var buf = new ArrayBuffer(s.length), view = new Uint8Array(buf);
  for (var i = 0; i != s.length; ++i)
    view[i] = s.charCodeAt(i) & 255;
  return buf;
}
function a2s(data) {
  if (Array.isArray(data))
    return data.map(function(c) {
      return String.fromCharCode(c);
    }).join("");
  var o = [];
  for (var i = 0; i < data.length; ++i)
    o[i] = String.fromCharCode(data[i]);
  return o.join("");
}
function a2u(data) {
  if (typeof Uint8Array === "undefined")
    throw new Error("Unsupported");
  return new Uint8Array(data);
}
function ab2a(data) {
  if (typeof ArrayBuffer == "undefined")
    throw new Error("Unsupported");
  if (data instanceof ArrayBuffer)
    return ab2a(new Uint8Array(data));
  var o = new Array(data.length);
  for (var i = 0; i < data.length; ++i)
    o[i] = data[i];
  return o;
}
var bconcat = has_buf ? function(bufs) {
  return Buffer.concat(bufs.map(function(buf) {
    return Buffer.isBuffer(buf) ? buf : Buffer_from(buf);
  }));
} : function(bufs) {
  if (typeof Uint8Array !== "undefined") {
    var i = 0, maxlen = 0;
    for (i = 0; i < bufs.length; ++i)
      maxlen += bufs[i].length;
    var o = new Uint8Array(maxlen);
    var len = 0;
    for (i = 0, maxlen = 0; i < bufs.length; maxlen += len, ++i) {
      len = bufs[i].length;
      if (bufs[i] instanceof Uint8Array)
        o.set(bufs[i], maxlen);
      else if (typeof bufs[i] == "string")
        o.set(new Uint8Array(s2a(bufs[i])), maxlen);
      else
        o.set(new Uint8Array(bufs[i]), maxlen);
    }
    return o;
  }
  return [].concat.apply([], bufs.map(function(buf) {
    return Array.isArray(buf) ? buf : [].slice.call(buf);
  }));
};
function utf8decode(content) {
  var out = [], widx = 0, L = content.length + 250;
  var o = new_raw_buf(content.length + 255);
  for (var ridx = 0; ridx < content.length; ++ridx) {
    var c = content.charCodeAt(ridx);
    if (c < 128)
      o[widx++] = c;
    else if (c < 2048) {
      o[widx++] = 192 | c >> 6 & 31;
      o[widx++] = 128 | c & 63;
    } else if (c >= 55296 && c < 57344) {
      c = (c & 1023) + 64;
      var d = content.charCodeAt(++ridx) & 1023;
      o[widx++] = 240 | c >> 8 & 7;
      o[widx++] = 128 | c >> 2 & 63;
      o[widx++] = 128 | d >> 6 & 15 | (c & 3) << 4;
      o[widx++] = 128 | d & 63;
    } else {
      o[widx++] = 224 | c >> 12 & 15;
      o[widx++] = 128 | c >> 6 & 63;
      o[widx++] = 128 | c & 63;
    }
    if (widx > L) {
      out.push(o.slice(0, widx));
      widx = 0;
      o = new_raw_buf(65535);
      L = 65530;
    }
  }
  out.push(o.slice(0, widx));
  return bconcat(out);
}
var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
function _strrev(x) {
  var o = "", i = x.length - 1;
  while (i >= 0)
    o += x.charAt(i--);
  return o;
}
function pad0(v, d) {
  var t = "" + v;
  return t.length >= d ? t : fill("0", d - t.length) + t;
}
function pad_(v, d) {
  var t = "" + v;
  return t.length >= d ? t : fill(" ", d - t.length) + t;
}
function rpad_(v, d) {
  var t = "" + v;
  return t.length >= d ? t : t + fill(" ", d - t.length);
}
function pad0r1(v, d) {
  var t = "" + Math.round(v);
  return t.length >= d ? t : fill("0", d - t.length) + t;
}
function pad0r2(v, d) {
  var t = "" + v;
  return t.length >= d ? t : fill("0", d - t.length) + t;
}
var p2_32 = /* @__PURE__ */ Math.pow(2, 32);
function pad0r(v, d) {
  if (v > p2_32 || v < -p2_32)
    return pad0r1(v, d);
  var i = Math.round(v);
  return pad0r2(i, d);
}
function SSF_isgeneral(s, i) {
  i = i || 0;
  return s.length >= 7 + i && (s.charCodeAt(i) | 32) === 103 && (s.charCodeAt(i + 1) | 32) === 101 && (s.charCodeAt(i + 2) | 32) === 110 && (s.charCodeAt(i + 3) | 32) === 101 && (s.charCodeAt(i + 4) | 32) === 114 && (s.charCodeAt(i + 5) | 32) === 97 && (s.charCodeAt(i + 6) | 32) === 108;
}
var days = [
  ["Sun", "Sunday"],
  ["Mon", "Monday"],
  ["Tue", "Tuesday"],
  ["Wed", "Wednesday"],
  ["Thu", "Thursday"],
  ["Fri", "Friday"],
  ["Sat", "Saturday"]
];
var months = [
  ["J", "Jan", "January"],
  ["F", "Feb", "February"],
  ["M", "Mar", "March"],
  ["A", "Apr", "April"],
  ["M", "May", "May"],
  ["J", "Jun", "June"],
  ["J", "Jul", "July"],
  ["A", "Aug", "August"],
  ["S", "Sep", "September"],
  ["O", "Oct", "October"],
  ["N", "Nov", "November"],
  ["D", "Dec", "December"]
];
function SSF_init_table(t) {
  if (!t)
    t = {};
  t[0] = "General";
  t[1] = "0";
  t[2] = "0.00";
  t[3] = "#,##0";
  t[4] = "#,##0.00";
  t[9] = "0%";
  t[10] = "0.00%";
  t[11] = "0.00E+00";
  t[12] = "# ?/?";
  t[13] = "# ??/??";
  t[14] = "m/d/yy";
  t[15] = "d-mmm-yy";
  t[16] = "d-mmm";
  t[17] = "mmm-yy";
  t[18] = "h:mm AM/PM";
  t[19] = "h:mm:ss AM/PM";
  t[20] = "h:mm";
  t[21] = "h:mm:ss";
  t[22] = "m/d/yy h:mm";
  t[37] = "#,##0 ;(#,##0)";
  t[38] = "#,##0 ;[Red](#,##0)";
  t[39] = "#,##0.00;(#,##0.00)";
  t[40] = "#,##0.00;[Red](#,##0.00)";
  t[45] = "mm:ss";
  t[46] = "[h]:mm:ss";
  t[47] = "mmss.0";
  t[48] = "##0.0E+0";
  t[49] = "@";
  t[56] = '"上午/下午 "hh"時"mm"分"ss"秒 "';
  return t;
}
var table_fmt = {
  0: "General",
  1: "0",
  2: "0.00",
  3: "#,##0",
  4: "#,##0.00",
  9: "0%",
  10: "0.00%",
  11: "0.00E+00",
  12: "# ?/?",
  13: "# ??/??",
  14: "m/d/yy",
  15: "d-mmm-yy",
  16: "d-mmm",
  17: "mmm-yy",
  18: "h:mm AM/PM",
  19: "h:mm:ss AM/PM",
  20: "h:mm",
  21: "h:mm:ss",
  22: "m/d/yy h:mm",
  37: "#,##0 ;(#,##0)",
  38: "#,##0 ;[Red](#,##0)",
  39: "#,##0.00;(#,##0.00)",
  40: "#,##0.00;[Red](#,##0.00)",
  45: "mm:ss",
  46: "[h]:mm:ss",
  47: "mmss.0",
  48: "##0.0E+0",
  49: "@",
  56: '"上午/下午 "hh"時"mm"分"ss"秒 "'
};
var SSF_default_map = {
  5: 37,
  6: 38,
  7: 39,
  8: 40,
  //  5 -> 37 ...  8 -> 40
  23: 0,
  24: 0,
  25: 0,
  26: 0,
  // 23 ->  0 ... 26 ->  0
  27: 14,
  28: 14,
  29: 14,
  30: 14,
  31: 14,
  // 27 -> 14 ... 31 -> 14
  50: 14,
  51: 14,
  52: 14,
  53: 14,
  54: 14,
  // 50 -> 14 ... 58 -> 14
  55: 14,
  56: 14,
  57: 14,
  58: 14,
  59: 1,
  60: 2,
  61: 3,
  62: 4,
  // 59 ->  1 ... 62 ->  4
  67: 9,
  68: 10,
  // 67 ->  9 ... 68 -> 10
  69: 12,
  70: 13,
  71: 14,
  // 69 -> 12 ... 71 -> 14
  72: 14,
  73: 15,
  74: 16,
  75: 17,
  // 72 -> 14 ... 75 -> 17
  76: 20,
  77: 21,
  78: 22,
  // 76 -> 20 ... 78 -> 22
  79: 45,
  80: 46,
  81: 47,
  // 79 -> 45 ... 81 -> 47
  82: 0
  // 82 ->  0 ... 65536 -> 0 (omitted)
};
var SSF_default_str = {
  //  5 -- Currency,   0 decimal, black negative
  5: '"$"#,##0_);\\("$"#,##0\\)',
  63: '"$"#,##0_);\\("$"#,##0\\)',
  //  6 -- Currency,   0 decimal, red   negative
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  //  7 -- Currency,   2 decimal, black negative
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  //  8 -- Currency,   2 decimal, red   negative
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  // 41 -- Accounting, 0 decimal, No Symbol
  41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
  // 42 -- Accounting, 0 decimal, $  Symbol
  42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
  // 43 -- Accounting, 2 decimal, No Symbol
  43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
  // 44 -- Accounting, 2 decimal, $  Symbol
  44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function SSF_frac(x, D, mixed) {
  var sgn = x < 0 ? -1 : 1;
  var B = x * sgn;
  var P_2 = 0, P_1 = 1, P = 0;
  var Q_2 = 1, Q_1 = 0, Q = 0;
  var A = Math.floor(B);
  while (Q_1 < D) {
    A = Math.floor(B);
    P = A * P_1 + P_2;
    Q = A * Q_1 + Q_2;
    if (B - A < 5e-8)
      break;
    B = 1 / (B - A);
    P_2 = P_1;
    P_1 = P;
    Q_2 = Q_1;
    Q_1 = Q;
  }
  if (Q > D) {
    if (Q_1 > D) {
      Q = Q_2;
      P = P_2;
    } else {
      Q = Q_1;
      P = P_1;
    }
  }
  if (!mixed)
    return [0, sgn * P, Q];
  var q = Math.floor(sgn * P / Q);
  return [q, sgn * P - q * Q, Q];
}
function SSF_parse_date_code(v, opts, b2) {
  if (v > 2958465 || v < 0)
    return null;
  var date = v | 0, time = Math.floor(86400 * (v - date)), dow = 0;
  var dout = [];
  var out = { D: date, T: time, u: 86400 * (v - date) - time, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
  if (Math.abs(out.u) < 1e-6)
    out.u = 0;
  if (opts && opts.date1904)
    date += 1462;
  if (out.u > 0.9999) {
    out.u = 0;
    if (++time == 86400) {
      out.T = time = 0;
      ++date;
      ++out.D;
    }
  }
  if (date === 60) {
    dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
    dow = 3;
  } else if (date === 0) {
    dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
    dow = 6;
  } else {
    if (date > 60)
      --date;
    var d = new Date(1900, 0, 1);
    d.setDate(d.getDate() + date - 1);
    dout = [d.getFullYear(), d.getMonth() + 1, d.getDate()];
    dow = d.getDay();
    if (date < 60)
      dow = (dow + 6) % 7;
    if (b2)
      dow = SSF_fix_hijri(d, dout);
  }
  out.y = dout[0];
  out.m = dout[1];
  out.d = dout[2];
  out.S = time % 60;
  time = Math.floor(time / 60);
  out.M = time % 60;
  time = Math.floor(time / 60);
  out.H = time;
  out.q = dow;
  return out;
}
var SSFbasedate = /* @__PURE__ */ new Date(1899, 11, 31, 0, 0, 0);
var SSFdnthresh = /* @__PURE__ */ SSFbasedate.getTime();
var SSFbase1904 = /* @__PURE__ */ new Date(1900, 2, 1, 0, 0, 0);
function datenum_local(v, date1904) {
  var epoch = /* @__PURE__ */ v.getTime();
  if (date1904)
    epoch -= 1461 * 24 * 60 * 60 * 1e3;
  else if (v >= SSFbase1904)
    epoch += 24 * 60 * 60 * 1e3;
  return (epoch - (SSFdnthresh + (/* @__PURE__ */ v.getTimezoneOffset() - /* @__PURE__ */ SSFbasedate.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
}
function SSF_strip_decimal(o) {
  return o.indexOf(".") == -1 ? o : o.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
}
function SSF_normalize_exp(o) {
  if (o.indexOf("E") == -1)
    return o;
  return o.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
}
function SSF_small_exp(v) {
  var w2 = v < 0 ? 12 : 11;
  var o = SSF_strip_decimal(v.toFixed(12));
  if (o.length <= w2)
    return o;
  o = v.toPrecision(10);
  if (o.length <= w2)
    return o;
  return v.toExponential(5);
}
function SSF_large_exp(v) {
  var o = SSF_strip_decimal(v.toFixed(11));
  return o.length > (v < 0 ? 12 : 11) || o === "0" || o === "-0" ? v.toPrecision(6) : o;
}
function SSF_general_num(v) {
  var V = Math.floor(Math.log(Math.abs(v)) * Math.LOG10E), o;
  if (V >= -4 && V <= -1)
    o = v.toPrecision(10 + V);
  else if (Math.abs(V) <= 9)
    o = SSF_small_exp(v);
  else if (V === 10)
    o = v.toFixed(10).substr(0, 12);
  else
    o = SSF_large_exp(v);
  return SSF_strip_decimal(SSF_normalize_exp(o.toUpperCase()));
}
function SSF_general(v, opts) {
  switch (typeof v) {
    case "string":
      return v;
    case "boolean":
      return v ? "TRUE" : "FALSE";
    case "number":
      return (v | 0) === v ? v.toString(10) : SSF_general_num(v);
    case "undefined":
      return "";
    case "object":
      if (v == null)
        return "";
      if (v instanceof Date)
        return SSF_format(14, datenum_local(v, opts && opts.date1904), opts);
  }
  throw new Error("unsupported value in General format: " + v);
}
function SSF_fix_hijri(date, o) {
  o[0] -= 581;
  var dow = date.getDay();
  if (date < 60)
    dow = (dow + 6) % 7;
  return dow;
}
function SSF_write_date(type, fmt, val, ss0) {
  var o = "", ss = 0, tt = 0, y = val.y, out, outl = 0;
  switch (type) {
    case 98:
      y = val.y + 543;
    case 121:
      switch (fmt.length) {
        case 1:
        case 2:
          out = y % 100;
          outl = 2;
          break;
        default:
          out = y % 1e4;
          outl = 4;
          break;
      }
      break;
    case 109:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.m;
          outl = fmt.length;
          break;
        case 3:
          return months[val.m - 1][1];
        case 5:
          return months[val.m - 1][0];
        default:
          return months[val.m - 1][2];
      }
      break;
    case 100:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.d;
          outl = fmt.length;
          break;
        case 3:
          return days[val.q][0];
        default:
          return days[val.q][1];
      }
      break;
    case 104:
      switch (fmt.length) {
        case 1:
        case 2:
          out = 1 + (val.H + 11) % 12;
          outl = fmt.length;
          break;
        default:
          throw "bad hour format: " + fmt;
      }
      break;
    case 72:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.H;
          outl = fmt.length;
          break;
        default:
          throw "bad hour format: " + fmt;
      }
      break;
    case 77:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.M;
          outl = fmt.length;
          break;
        default:
          throw "bad minute format: " + fmt;
      }
      break;
    case 115:
      if (fmt != "s" && fmt != "ss" && fmt != ".0" && fmt != ".00" && fmt != ".000")
        throw "bad second format: " + fmt;
      if (val.u === 0 && (fmt == "s" || fmt == "ss"))
        return pad0(val.S, fmt.length);
      if (ss0 >= 2)
        tt = ss0 === 3 ? 1e3 : 100;
      else
        tt = ss0 === 1 ? 10 : 1;
      ss = Math.round(tt * (val.S + val.u));
      if (ss >= 60 * tt)
        ss = 0;
      if (fmt === "s")
        return ss === 0 ? "0" : "" + ss / tt;
      o = pad0(ss, 2 + ss0);
      if (fmt === "ss")
        return o.substr(0, 2);
      return "." + o.substr(2, fmt.length - 1);
    case 90:
      switch (fmt) {
        case "[h]":
        case "[hh]":
          out = val.D * 24 + val.H;
          break;
        case "[m]":
        case "[mm]":
          out = (val.D * 24 + val.H) * 60 + val.M;
          break;
        case "[s]":
        case "[ss]":
          out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
          break;
        default:
          throw "bad abstime format: " + fmt;
      }
      outl = fmt.length === 3 ? 1 : 2;
      break;
    case 101:
      out = y;
      outl = 1;
      break;
  }
  var outstr = outl > 0 ? pad0(out, outl) : "";
  return outstr;
}
function commaify(s) {
  var w2 = 3;
  if (s.length <= w2)
    return s;
  var j = s.length % w2, o = s.substr(0, j);
  for (; j != s.length; j += w2)
    o += (o.length > 0 ? "," : "") + s.substr(j, w2);
  return o;
}
var pct1 = /%/g;
function write_num_pct(type, fmt, val) {
  var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
}
function write_num_cm(type, fmt, val) {
  var idx = fmt.length - 1;
  while (fmt.charCodeAt(idx - 1) === 44)
    --idx;
  return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
}
function write_num_exp(fmt, val) {
  var o;
  var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  if (fmt.match(/^#+0.0E\+0$/)) {
    if (val == 0)
      return "0.0E+0";
    else if (val < 0)
      return "-" + write_num_exp(fmt, -val);
    var period = fmt.indexOf(".");
    if (period === -1)
      period = fmt.indexOf("E");
    var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
    if (ee < 0)
      ee += period;
    o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
    if (o.indexOf("e") === -1) {
      var fakee = Math.floor(Math.log(val) * Math.LOG10E);
      if (o.indexOf(".") === -1)
        o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
      else
        o += "E+" + (fakee - ee);
      while (o.substr(0, 2) === "0.") {
        o = o.charAt(0) + o.substr(2, period) + "." + o.substr(2 + period);
        o = o.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
      }
      o = o.replace(/\+-/, "-");
    }
    o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
      return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
    });
  } else
    o = val.toExponential(idx);
  if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/))
    o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
  if (fmt.match(/E\-/) && o.match(/e\+/))
    o = o.replace(/e\+/, "e");
  return o.replace("e", "E");
}
var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
function write_num_f1(r, aval, sign) {
  var den = parseInt(r[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
  var myn = rr - base * den, myd = den;
  return sign + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn, r[1].length) + r[2] + "/" + r[3] + pad0(myd, r[4].length));
}
function write_num_f2(r, aval, sign) {
  return sign + (aval === 0 ? "" : "" + aval) + fill(" ", r[1].length + 2 + r[4].length);
}
var dec1 = /^#*0*\.([0#]+)/;
var closeparen = /\).*[0#]/;
var phone = /\(###\) ###\\?-####/;
function hashq(str) {
  var o = "", cc;
  for (var i = 0; i != str.length; ++i)
    switch (cc = str.charCodeAt(i)) {
      case 35:
        break;
      case 63:
        o += " ";
        break;
      case 48:
        o += "0";
        break;
      default:
        o += String.fromCharCode(cc);
    }
  return o;
}
function rnd(val, d) {
  var dd = Math.pow(10, d);
  return "" + Math.round(val * dd) / dd;
}
function dec(val, d) {
  var _frac = val - Math.floor(val), dd = Math.pow(10, d);
  if (d < ("" + Math.round(_frac * dd)).length)
    return 0;
  return Math.round(_frac * dd);
}
function carry(val, d) {
  if (d < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d))).length) {
    return 1;
  }
  return 0;
}
function flr(val) {
  if (val < 2147483647 && val > -2147483648)
    return "" + (val >= 0 ? val | 0 : val - 1 | 0);
  return "" + Math.floor(val);
}
function write_num_flt(type, fmt, val) {
  if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    if (val >= 0)
      return write_num_flt("n", ffmt, val);
    return "(" + write_num_flt("n", ffmt, -val) + ")";
  }
  if (fmt.charCodeAt(fmt.length - 1) === 44)
    return write_num_cm(type, fmt, val);
  if (fmt.indexOf("%") !== -1)
    return write_num_pct(type, fmt, val);
  if (fmt.indexOf("E") !== -1)
    return write_num_exp(fmt, val);
  if (fmt.charCodeAt(0) === 36)
    return "$" + write_num_flt(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
  var o;
  var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
  if (fmt.match(/^00+$/))
    return sign + pad0r(aval, fmt.length);
  if (fmt.match(/^[#?]+$/)) {
    o = pad0r(val, 0);
    if (o === "0")
      o = "";
    return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
  }
  if (r = fmt.match(frac1))
    return write_num_f1(r, aval, sign);
  if (fmt.match(/^#+0+$/))
    return sign + pad0r(aval, fmt.length - fmt.indexOf("0"));
  if (r = fmt.match(dec1)) {
    o = rnd(val, r[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1])).replace(/\.(\d*)$/, function($$, $1) {
      return "." + $1 + fill("0", hashq(
        /*::(*/
        r[1]
      ).length - $1.length);
    });
    return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
  }
  fmt = fmt.replace(/^#+([0.])/, "$1");
  if (r = fmt.match(/^(0*)\.(#*)$/)) {
    return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
  }
  if (r = fmt.match(/^#{1,3},##0(\.?)$/))
    return sign + commaify(pad0r(aval, 0));
  if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify("" + (Math.floor(val) + carry(val, r[1].length))) + "." + pad0(dec(val, r[1].length), r[1].length);
  }
  if (r = fmt.match(/^#,#*,#0/))
    return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val);
  if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
    o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val));
    ri = 0;
    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
      return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
    }));
  }
  if (fmt.match(phone)) {
    o = write_num_flt(type, "##########", val);
    return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
  }
  var oa = "";
  if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(
      /*::String(*/
      r[4].length,
      7
    );
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
    o = "" + sign;
    oa = write_num(
      "n",
      /*::String(*/
      r[1],
      ff[1]
    );
    if (oa.charAt(oa.length - 1) == " ")
      oa = oa.substr(0, oa.length - 1) + "0";
    o += oa + /*::String(*/
    r[2] + "/" + /*::String(*/
    r[3];
    oa = rpad_(ff[2], ri);
    if (oa.length < r[4].length)
      oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
    o += oa;
    return o;
  }
  if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(Math.max(r[1].length, r[4].length), 7);
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
    return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
  }
  if (r = fmt.match(/^[#0?]+$/)) {
    o = pad0r(val, 0);
    if (fmt.length <= o.length)
      return o;
    return hashq(fmt.substr(0, fmt.length - o.length)) + o;
  }
  if (r = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
    o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
    ri = o.indexOf(".");
    var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
    return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
  }
  if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
    ri = dec(val, r[1].length);
    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
      return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
    }) + "." + pad0(ri, r[1].length);
  }
  switch (fmt) {
    case "###,##0.00":
      return write_num_flt(type, "#,##0.00", val);
    case "###,###":
    case "##,###":
    case "#,###":
      var x = commaify(pad0r(aval, 0));
      return x !== "0" ? sign + x : "";
    case "###,###.00":
      return write_num_flt(type, "###,##0.00", val).replace(/^0\./, ".");
    case "#,###.00":
      return write_num_flt(type, "#,##0.00", val).replace(/^0\./, ".");
  }
  throw new Error("unsupported format |" + fmt + "|");
}
function write_num_cm2(type, fmt, val) {
  var idx = fmt.length - 1;
  while (fmt.charCodeAt(idx - 1) === 44)
    --idx;
  return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
}
function write_num_pct2(type, fmt, val) {
  var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
}
function write_num_exp2(fmt, val) {
  var o;
  var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  if (fmt.match(/^#+0.0E\+0$/)) {
    if (val == 0)
      return "0.0E+0";
    else if (val < 0)
      return "-" + write_num_exp2(fmt, -val);
    var period = fmt.indexOf(".");
    if (period === -1)
      period = fmt.indexOf("E");
    var ee = Math.floor(Math.log(val) * Math.LOG10E) % period;
    if (ee < 0)
      ee += period;
    o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
    if (!o.match(/[Ee]/)) {
      var fakee = Math.floor(Math.log(val) * Math.LOG10E);
      if (o.indexOf(".") === -1)
        o = o.charAt(0) + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
      else
        o += "E+" + (fakee - ee);
      o = o.replace(/\+-/, "-");
    }
    o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
      return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E";
    });
  } else
    o = val.toExponential(idx);
  if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/))
    o = o.substr(0, o.length - 1) + "0" + o.charAt(o.length - 1);
  if (fmt.match(/E\-/) && o.match(/e\+/))
    o = o.replace(/e\+/, "e");
  return o.replace("e", "E");
}
function write_num_int(type, fmt, val) {
  if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    if (val >= 0)
      return write_num_int("n", ffmt, val);
    return "(" + write_num_int("n", ffmt, -val) + ")";
  }
  if (fmt.charCodeAt(fmt.length - 1) === 44)
    return write_num_cm2(type, fmt, val);
  if (fmt.indexOf("%") !== -1)
    return write_num_pct2(type, fmt, val);
  if (fmt.indexOf("E") !== -1)
    return write_num_exp2(fmt, val);
  if (fmt.charCodeAt(0) === 36)
    return "$" + write_num_int(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
  var o;
  var r, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
  if (fmt.match(/^00+$/))
    return sign + pad0(aval, fmt.length);
  if (fmt.match(/^[#?]+$/)) {
    o = "" + val;
    if (val === 0)
      o = "";
    return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o;
  }
  if (r = fmt.match(frac1))
    return write_num_f2(r, aval, sign);
  if (fmt.match(/^#+0+$/))
    return sign + pad0(aval, fmt.length - fmt.indexOf("0"));
  if (r = fmt.match(dec1)) {
    o = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r[1])).replace(/\.$/, "." + hashq(r[1]));
    o = o.replace(/\.(\d*)$/, function($$, $1) {
      return "." + $1 + fill("0", hashq(r[1]).length - $1.length);
    });
    return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".");
  }
  fmt = fmt.replace(/^#+([0.])/, "$1");
  if (r = fmt.match(/^(0*)\.(#*)$/)) {
    return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".");
  }
  if (r = fmt.match(/^#{1,3},##0(\.?)$/))
    return sign + commaify("" + aval);
  if (r = fmt.match(/^#,##0\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val) + "." + fill("0", r[1].length);
  }
  if (r = fmt.match(/^#,#*,#0/))
    return write_num_int(type, fmt.replace(/^#,#*,/, ""), val);
  if (r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
    o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val));
    ri = 0;
    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x2) {
      return ri < o.length ? o.charAt(ri++) : x2 === "0" ? "0" : "";
    }));
  }
  if (fmt.match(phone)) {
    o = write_num_int(type, "##########", val);
    return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6);
  }
  var oa = "";
  if (r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(
      /*::String(*/
      r[4].length,
      7
    );
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
    o = "" + sign;
    oa = write_num(
      "n",
      /*::String(*/
      r[1],
      ff[1]
    );
    if (oa.charAt(oa.length - 1) == " ")
      oa = oa.substr(0, oa.length - 1) + "0";
    o += oa + /*::String(*/
    r[2] + "/" + /*::String(*/
    r[3];
    oa = rpad_(ff[2], ri);
    if (oa.length < r[4].length)
      oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
    o += oa;
    return o;
  }
  if (r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(Math.max(r[1].length, r[4].length), 7);
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
    return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length));
  }
  if (r = fmt.match(/^[#0?]+$/)) {
    o = "" + val;
    if (fmt.length <= o.length)
      return o;
    return hashq(fmt.substr(0, fmt.length - o.length)) + o;
  }
  if (r = fmt.match(/^([#0]+)\.([#0]+)$/)) {
    o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
    ri = o.indexOf(".");
    var lres = fmt.indexOf(".") - ri, rres = fmt.length - o.length - lres;
    return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres));
  }
  if (r = fmt.match(/^00,000\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
      return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
    }) + "." + pad0(0, r[1].length);
  }
  switch (fmt) {
    case "###,###":
    case "##,###":
    case "#,###":
      var x = commaify("" + aval);
      return x !== "0" ? sign + x : "";
    default:
      if (fmt.match(/\.[0#?]*$/))
        return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
  }
  throw new Error("unsupported format |" + fmt + "|");
}
function write_num(type, fmt, val) {
  return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
}
function SSF_split_fmt(fmt) {
  var out = [];
  var in_str = false;
  for (var i = 0, j = 0; i < fmt.length; ++i)
    switch (
      /*cc=*/
      fmt.charCodeAt(i)
    ) {
      case 34:
        in_str = !in_str;
        break;
      case 95:
      case 42:
      case 92:
        ++i;
        break;
      case 59:
        out[out.length] = fmt.substr(j, i - j);
        j = i + 1;
    }
  out[out.length] = fmt.substr(j);
  if (in_str === true)
    throw new Error("Format |" + fmt + "| unterminated string ");
  return out;
}
var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function fmt_is_date(fmt) {
  var i = 0, c = "", o = "";
  while (i < fmt.length) {
    switch (c = fmt.charAt(i)) {
      case "G":
        if (SSF_isgeneral(fmt, i))
          i += 6;
        i++;
        break;
      case '"':
        for (
          ;
          /*cc=*/
          fmt.charCodeAt(++i) !== 34 && i < fmt.length;
        ) {
        }
        ++i;
        break;
      case "\\":
        i += 2;
        break;
      case "_":
        i += 2;
        break;
      case "@":
        ++i;
        break;
      case "B":
      case "b":
        if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2")
          return true;
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        return true;
      case "A":
      case "a":
      case "上":
        if (fmt.substr(i, 3).toUpperCase() === "A/P")
          return true;
        if (fmt.substr(i, 5).toUpperCase() === "AM/PM")
          return true;
        if (fmt.substr(i, 5).toUpperCase() === "上午/下午")
          return true;
        ++i;
        break;
      case "[":
        o = c;
        while (fmt.charAt(i++) !== "]" && i < fmt.length)
          o += fmt.charAt(i);
        if (o.match(SSF_abstime))
          return true;
        break;
      case ".":
      case "0":
      case "#":
        while (i < fmt.length && ("0#?.,E+-%".indexOf(c = fmt.charAt(++i)) > -1 || c == "\\" && fmt.charAt(i + 1) == "-" && "0#".indexOf(fmt.charAt(i + 2)) > -1)) {
        }
        break;
      case "?":
        while (fmt.charAt(++i) === c) {
        }
        break;
      case "*":
        ++i;
        if (fmt.charAt(i) == " " || fmt.charAt(i) == "*")
          ++i;
        break;
      case "(":
      case ")":
        ++i;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1) {
        }
        break;
      case " ":
        ++i;
        break;
      default:
        ++i;
        break;
    }
  }
  return false;
}
function eval_fmt(fmt, v, opts, flen) {
  var out = [], o = "", i = 0, c = "", lst = "t", dt, j, cc;
  var hr = "H";
  while (i < fmt.length) {
    switch (c = fmt.charAt(i)) {
      case "G":
        if (!SSF_isgeneral(fmt, i))
          throw new Error("unrecognized character " + c + " in " + fmt);
        out[out.length] = { t: "G", v: "General" };
        i += 7;
        break;
      case '"':
        for (o = ""; (cc = fmt.charCodeAt(++i)) !== 34 && i < fmt.length; )
          o += String.fromCharCode(cc);
        out[out.length] = { t: "t", v: o };
        ++i;
        break;
      case "\\":
        var w2 = fmt.charAt(++i), t = w2 === "(" || w2 === ")" ? w2 : "t";
        out[out.length] = { t, v: w2 };
        ++i;
        break;
      case "_":
        out[out.length] = { t: "t", v: " " };
        i += 2;
        break;
      case "@":
        out[out.length] = { t: "T", v };
        ++i;
        break;
      case "B":
      case "b":
        if (fmt.charAt(i + 1) === "1" || fmt.charAt(i + 1) === "2") {
          if (dt == null) {
            dt = SSF_parse_date_code(v, opts, fmt.charAt(i + 1) === "2");
            if (dt == null)
              return "";
          }
          out[out.length] = { t: "X", v: fmt.substr(i, 2) };
          lst = c;
          i += 2;
          break;
        }
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
        c = c.toLowerCase();
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        if (v < 0)
          return "";
        if (dt == null) {
          dt = SSF_parse_date_code(v, opts);
          if (dt == null)
            return "";
        }
        o = c;
        while (++i < fmt.length && fmt.charAt(i).toLowerCase() === c)
          o += c;
        if (c === "m" && lst.toLowerCase() === "h")
          c = "M";
        if (c === "h")
          c = hr;
        out[out.length] = { t: c, v: o };
        lst = c;
        break;
      case "A":
      case "a":
      case "上":
        var q = { t: c, v: c };
        if (dt == null)
          dt = SSF_parse_date_code(v, opts);
        if (fmt.substr(i, 3).toUpperCase() === "A/P") {
          if (dt != null)
            q.v = dt.H >= 12 ? fmt.charAt(i + 2) : c;
          q.t = "T";
          hr = "h";
          i += 3;
        } else if (fmt.substr(i, 5).toUpperCase() === "AM/PM") {
          if (dt != null)
            q.v = dt.H >= 12 ? "PM" : "AM";
          q.t = "T";
          i += 5;
          hr = "h";
        } else if (fmt.substr(i, 5).toUpperCase() === "上午/下午") {
          if (dt != null)
            q.v = dt.H >= 12 ? "下午" : "上午";
          q.t = "T";
          i += 5;
          hr = "h";
        } else {
          q.t = "t";
          ++i;
        }
        if (dt == null && q.t === "T")
          return "";
        out[out.length] = q;
        lst = c;
        break;
      case "[":
        o = c;
        while (fmt.charAt(i++) !== "]" && i < fmt.length)
          o += fmt.charAt(i);
        if (o.slice(-1) !== "]")
          throw 'unterminated "[" block: |' + o + "|";
        if (o.match(SSF_abstime)) {
          if (dt == null) {
            dt = SSF_parse_date_code(v, opts);
            if (dt == null)
              return "";
          }
          out[out.length] = { t: "Z", v: o.toLowerCase() };
          lst = o.charAt(1);
        } else if (o.indexOf("$") > -1) {
          o = (o.match(/\$([^-\[\]]*)/) || [])[1] || "$";
          if (!fmt_is_date(fmt))
            out[out.length] = { t: "t", v: o };
        }
        break;
      case ".":
        if (dt != null) {
          o = c;
          while (++i < fmt.length && (c = fmt.charAt(i)) === "0")
            o += c;
          out[out.length] = { t: "s", v: o };
          break;
        }
      case "0":
      case "#":
        o = c;
        while (++i < fmt.length && "0#?.,E+-%".indexOf(c = fmt.charAt(i)) > -1)
          o += c;
        out[out.length] = { t: "n", v: o };
        break;
      case "?":
        o = c;
        while (fmt.charAt(++i) === c)
          o += c;
        out[out.length] = { t: c, v: o };
        lst = c;
        break;
      case "*":
        ++i;
        if (fmt.charAt(i) == " " || fmt.charAt(i) == "*")
          ++i;
        break;
      case "(":
      case ")":
        out[out.length] = { t: flen === 1 ? "t" : c, v: c };
        ++i;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        o = c;
        while (i < fmt.length && "0123456789".indexOf(fmt.charAt(++i)) > -1)
          o += fmt.charAt(i);
        out[out.length] = { t: "D", v: o };
        break;
      case " ":
        out[out.length] = { t: c, v: c };
        ++i;
        break;
      case "$":
        out[out.length] = { t: "t", v: "$" };
        ++i;
        break;
      default:
        if (",$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP".indexOf(c) === -1)
          throw new Error("unrecognized character " + c + " in " + fmt);
        out[out.length] = { t: "t", v: c };
        ++i;
        break;
    }
  }
  var bt = 0, ss0 = 0, ssm;
  for (i = out.length - 1, lst = "t"; i >= 0; --i) {
    switch (out[i].t) {
      case "h":
      case "H":
        out[i].t = hr;
        lst = "h";
        if (bt < 1)
          bt = 1;
        break;
      case "s":
        if (ssm = out[i].v.match(/\.0+$/))
          ss0 = Math.max(ss0, ssm[0].length - 1);
        if (bt < 3)
          bt = 3;
      case "d":
      case "y":
      case "M":
      case "e":
        lst = out[i].t;
        break;
      case "m":
        if (lst === "s") {
          out[i].t = "M";
          if (bt < 2)
            bt = 2;
        }
        break;
      case "X":
        break;
      case "Z":
        if (bt < 1 && out[i].v.match(/[Hh]/))
          bt = 1;
        if (bt < 2 && out[i].v.match(/[Mm]/))
          bt = 2;
        if (bt < 3 && out[i].v.match(/[Ss]/))
          bt = 3;
    }
  }
  switch (bt) {
    case 0:
      break;
    case 1:
      if (dt.u >= 0.5) {
        dt.u = 0;
        ++dt.S;
      }
      if (dt.S >= 60) {
        dt.S = 0;
        ++dt.M;
      }
      if (dt.M >= 60) {
        dt.M = 0;
        ++dt.H;
      }
      break;
    case 2:
      if (dt.u >= 0.5) {
        dt.u = 0;
        ++dt.S;
      }
      if (dt.S >= 60) {
        dt.S = 0;
        ++dt.M;
      }
      break;
  }
  var nstr = "", jj;
  for (i = 0; i < out.length; ++i) {
    switch (out[i].t) {
      case "t":
      case "T":
      case " ":
      case "D":
        break;
      case "X":
        out[i].v = "";
        out[i].t = ";";
        break;
      case "d":
      case "m":
      case "y":
      case "h":
      case "H":
      case "M":
      case "s":
      case "e":
      case "b":
      case "Z":
        out[i].v = SSF_write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
        out[i].t = "t";
        break;
      case "n":
      case "?":
        jj = i + 1;
        while (out[jj] != null && ((c = out[jj].t) === "?" || c === "D" || (c === " " || c === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i].t === "(" && (c === " " || c === "n" || c === ")") || c === "t" && (out[jj].v === "/" || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t == "?"))) {
          out[i].v += out[jj].v;
          out[jj] = { v: "", t: ";" };
          ++jj;
        }
        nstr += out[i].v;
        i = jj - 1;
        break;
      case "G":
        out[i].t = "t";
        out[i].v = SSF_general(v, opts);
        break;
    }
  }
  var vv = "", myv, ostr;
  if (nstr.length > 0) {
    if (nstr.charCodeAt(0) == 40) {
      myv = v < 0 && nstr.charCodeAt(0) === 45 ? -v : v;
      ostr = write_num("n", nstr, myv);
    } else {
      myv = v < 0 && flen > 1 ? -v : v;
      ostr = write_num("n", nstr, myv);
      if (myv < 0 && out[0] && out[0].t == "t") {
        ostr = ostr.substr(1);
        out[0].v = "-" + out[0].v;
      }
    }
    jj = ostr.length - 1;
    var decpt = out.length;
    for (i = 0; i < out.length; ++i)
      if (out[i] != null && out[i].t != "t" && out[i].v.indexOf(".") > -1) {
        decpt = i;
        break;
      }
    var lasti = out.length;
    if (decpt === out.length && ostr.indexOf("E") === -1) {
      for (i = out.length - 1; i >= 0; --i) {
        if (out[i] == null || "n?".indexOf(out[i].t) === -1)
          continue;
        if (jj >= out[i].v.length - 1) {
          jj -= out[i].v.length;
          out[i].v = ostr.substr(jj + 1, out[i].v.length);
        } else if (jj < 0)
          out[i].v = "";
        else {
          out[i].v = ostr.substr(0, jj + 1);
          jj = -1;
        }
        out[i].t = "t";
        lasti = i;
      }
      if (jj >= 0 && lasti < out.length)
        out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
    } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
      jj = ostr.indexOf(".") - 1;
      for (i = decpt; i >= 0; --i) {
        if (out[i] == null || "n?".indexOf(out[i].t) === -1)
          continue;
        j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") - 1 : out[i].v.length - 1;
        vv = out[i].v.substr(j + 1);
        for (; j >= 0; --j) {
          if (jj >= 0 && (out[i].v.charAt(j) === "0" || out[i].v.charAt(j) === "#"))
            vv = ostr.charAt(jj--) + vv;
        }
        out[i].v = vv;
        out[i].t = "t";
        lasti = i;
      }
      if (jj >= 0 && lasti < out.length)
        out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
      jj = ostr.indexOf(".") + 1;
      for (i = decpt; i < out.length; ++i) {
        if (out[i] == null || "n?(".indexOf(out[i].t) === -1 && i !== decpt)
          continue;
        j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") + 1 : 0;
        vv = out[i].v.substr(0, j);
        for (; j < out[i].v.length; ++j) {
          if (jj < ostr.length)
            vv += ostr.charAt(jj++);
        }
        out[i].v = vv;
        out[i].t = "t";
        lasti = i;
      }
    }
  }
  for (i = 0; i < out.length; ++i)
    if (out[i] != null && "n?".indexOf(out[i].t) > -1) {
      myv = flen > 1 && v < 0 && i > 0 && out[i - 1].v === "-" ? -v : v;
      out[i].v = write_num(out[i].t, out[i].v, myv);
      out[i].t = "t";
    }
  var retval = "";
  for (i = 0; i !== out.length; ++i)
    if (out[i] != null)
      retval += out[i].v;
  return retval;
}
var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function chkcond(v, rr) {
  if (rr == null)
    return false;
  var thresh = parseFloat(rr[2]);
  switch (rr[1]) {
    case "=":
      if (v == thresh)
        return true;
      break;
    case ">":
      if (v > thresh)
        return true;
      break;
    case "<":
      if (v < thresh)
        return true;
      break;
    case "<>":
      if (v != thresh)
        return true;
      break;
    case ">=":
      if (v >= thresh)
        return true;
      break;
    case "<=":
      if (v <= thresh)
        return true;
      break;
  }
  return false;
}
function choose_fmt(f, v) {
  var fmt = SSF_split_fmt(f);
  var l = fmt.length, lat = fmt[l - 1].indexOf("@");
  if (l < 4 && lat > -1)
    --l;
  if (fmt.length > 4)
    throw new Error("cannot find right format for |" + fmt.join("|") + "|");
  if (typeof v !== "number")
    return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
  switch (fmt.length) {
    case 1:
      fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
      break;
    case 2:
      fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
      break;
    case 3:
      fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
      break;
  }
  var ff = v > 0 ? fmt[0] : v < 0 ? fmt[1] : fmt[2];
  if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1)
    return [l, ff];
  if (fmt[0].match(/\[[=<>]/) != null || fmt[1].match(/\[[=<>]/) != null) {
    var m1 = fmt[0].match(cfregex2);
    var m2 = fmt[1].match(cfregex2);
    return chkcond(v, m1) ? [l, fmt[0]] : chkcond(v, m2) ? [l, fmt[1]] : [l, fmt[m1 != null && m2 != null ? 2 : 1]];
  }
  return [l, ff];
}
function SSF_format(fmt, v, o) {
  if (o == null)
    o = {};
  var sfmt = "";
  switch (typeof fmt) {
    case "string":
      if (fmt == "m/d/yy" && o.dateNF)
        sfmt = o.dateNF;
      else
        sfmt = fmt;
      break;
    case "number":
      if (fmt == 14 && o.dateNF)
        sfmt = o.dateNF;
      else
        sfmt = (o.table != null ? o.table : table_fmt)[fmt];
      if (sfmt == null)
        sfmt = o.table && o.table[SSF_default_map[fmt]] || table_fmt[SSF_default_map[fmt]];
      if (sfmt == null)
        sfmt = SSF_default_str[fmt] || "General";
      break;
  }
  if (SSF_isgeneral(sfmt, 0))
    return SSF_general(v, o);
  if (v instanceof Date)
    v = datenum_local(v, o.date1904);
  var f = choose_fmt(sfmt, v);
  if (SSF_isgeneral(f[1]))
    return SSF_general(v, o);
  if (v === true)
    v = "TRUE";
  else if (v === false)
    v = "FALSE";
  else if (v === "" || v == null)
    return "";
  return eval_fmt(f[1], v, o, f[0]);
}
function SSF_load(fmt, idx) {
  if (typeof idx != "number") {
    idx = +idx || -1;
    for (var i = 0; i < 392; ++i) {
      if (table_fmt[i] == void 0) {
        if (idx < 0)
          idx = i;
        continue;
      }
      if (table_fmt[i] == fmt) {
        idx = i;
        break;
      }
    }
    if (idx < 0)
      idx = 391;
  }
  table_fmt[idx] = fmt;
  return idx;
}
function SSF_load_table(tbl) {
  for (var i = 0; i != 392; ++i)
    if (tbl[i] !== void 0)
      SSF_load(tbl[i], i);
}
function make_ssf() {
  table_fmt = SSF_init_table();
}
var SSFImplicit = {
  "5": '"$"#,##0_);\\("$"#,##0\\)',
  "6": '"$"#,##0_);[Red]\\("$"#,##0\\)',
  "7": '"$"#,##0.00_);\\("$"#,##0.00\\)',
  "8": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  "23": "General",
  "24": "General",
  "25": "General",
  "26": "General",
  "27": "m/d/yy",
  "28": "m/d/yy",
  "29": "m/d/yy",
  "30": "m/d/yy",
  "31": "m/d/yy",
  "32": "h:mm:ss",
  "33": "h:mm:ss",
  "34": "h:mm:ss",
  "35": "h:mm:ss",
  "36": "m/d/yy",
  "41": '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
  "42": '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
  "43": '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
  "44": '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
  "50": "m/d/yy",
  "51": "m/d/yy",
  "52": "m/d/yy",
  "53": "m/d/yy",
  "54": "m/d/yy",
  "55": "m/d/yy",
  "56": "m/d/yy",
  "57": "m/d/yy",
  "58": "m/d/yy",
  "59": "0",
  "60": "0.00",
  "61": "#,##0",
  "62": "#,##0.00",
  "63": '"$"#,##0_);\\("$"#,##0\\)',
  "64": '"$"#,##0_);[Red]\\("$"#,##0\\)',
  "65": '"$"#,##0.00_);\\("$"#,##0.00\\)',
  "66": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  "67": "0%",
  "68": "0.00%",
  "69": "# ?/?",
  "70": "# ??/??",
  "71": "m/d/yy",
  "72": "m/d/yy",
  "73": "d-mmm-yy",
  "74": "d-mmm",
  "75": "mmm-yy",
  "76": "h:mm",
  "77": "h:mm:ss",
  "78": "m/d/yy h:mm",
  "79": "mm:ss",
  "80": "[h]:mm:ss",
  "81": "mmss.0"
};
var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function dateNF_regex(dateNF) {
  var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;
  fmt = fmt.replace(dateNFregex, "(\\d+)");
  return new RegExp("^" + fmt + "$");
}
function dateNF_fix(str, dateNF, match2) {
  var Y = -1, m = -1, d = -1, H = -1, M = -1, S = -1;
  (dateNF.match(dateNFregex) || []).forEach(function(n, i) {
    var v = parseInt(match2[i + 1], 10);
    switch (n.toLowerCase().charAt(0)) {
      case "y":
        Y = v;
        break;
      case "d":
        d = v;
        break;
      case "h":
        H = v;
        break;
      case "s":
        S = v;
        break;
      case "m":
        if (H >= 0)
          M = v;
        else
          m = v;
        break;
    }
  });
  if (S >= 0 && M == -1 && m >= 0) {
    M = m;
    m = -1;
  }
  var datestr = ("" + (Y >= 0 ? Y : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (m >= 1 ? m : 1)).slice(-2) + "-" + ("00" + (d >= 1 ? d : 1)).slice(-2);
  if (datestr.length == 7)
    datestr = "0" + datestr;
  if (datestr.length == 8)
    datestr = "20" + datestr;
  var timestr = ("00" + (H >= 0 ? H : 0)).slice(-2) + ":" + ("00" + (M >= 0 ? M : 0)).slice(-2) + ":" + ("00" + (S >= 0 ? S : 0)).slice(-2);
  if (H == -1 && M == -1 && S == -1)
    return datestr;
  if (Y == -1 && m == -1 && d == -1)
    return timestr;
  return datestr + "T" + timestr;
}
var bad_formats = {
  "d.m": "d\\.m"
  // Issue #2571 Google Sheets writes invalid format 'd.m', correct format is 'd"."m' or 'd\\.m'
};
function SSF__load(fmt, idx) {
  return SSF_load(bad_formats[fmt] || fmt, idx);
}
var CRC32 = /* @__PURE__ */ function() {
  var CRC322 = {};
  CRC322.version = "1.2.0";
  function signed_crc_table() {
    var c = 0, table = new Array(256);
    for (var n = 0; n != 256; ++n) {
      c = n;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
      table[n] = c;
    }
    return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
  }
  var T0 = signed_crc_table();
  function slice_by_16_tables(T) {
    var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
    for (n = 0; n != 256; ++n)
      table[n] = T[n];
    for (n = 0; n != 256; ++n) {
      v = T[n];
      for (c = 256 + n; c < 4096; c += 256)
        v = table[c] = v >>> 8 ^ T[v & 255];
    }
    var out = [];
    for (n = 1; n != 16; ++n)
      out[n - 1] = typeof Int32Array !== "undefined" && typeof table.subarray == "function" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
    return out;
  }
  var TT = slice_by_16_tables(T0);
  var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
  var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
  var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
  function crc32_bstr(bstr, seed) {
    var C = seed ^ -1;
    for (var i = 0, L = bstr.length; i < L; )
      C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
    return ~C;
  }
  function crc32_buf(B, seed) {
    var C = seed ^ -1, L = B.length - 15, i = 0;
    for (; i < L; )
      C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
    L += 15;
    while (i < L)
      C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
    return ~C;
  }
  function crc32_str(str, seed) {
    var C = seed ^ -1;
    for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
      c = str.charCodeAt(i++);
      if (c < 128) {
        C = C >>> 8 ^ T0[(C ^ c) & 255];
      } else if (c < 2048) {
        C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
        C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
      } else if (c >= 55296 && c < 57344) {
        c = (c & 1023) + 64;
        d = str.charCodeAt(i++) & 1023;
        C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
        C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
        C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
        C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
      } else {
        C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
        C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
        C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
      }
    }
    return ~C;
  }
  CRC322.table = T0;
  CRC322.bstr = crc32_bstr;
  CRC322.buf = crc32_buf;
  CRC322.str = crc32_str;
  return CRC322;
}();
var CFB = /* @__PURE__ */ function _CFB() {
  var exports2 = (
    /*::(*/
    {}
  );
  exports2.version = "1.2.2";
  function namecmp(l, r) {
    var L = l.split("/"), R = r.split("/");
    for (var i2 = 0, c = 0, Z = Math.min(L.length, R.length); i2 < Z; ++i2) {
      if (c = L[i2].length - R[i2].length)
        return c;
      if (L[i2] != R[i2])
        return L[i2] < R[i2] ? -1 : 1;
    }
    return L.length - R.length;
  }
  function dirname(p) {
    if (p.charAt(p.length - 1) == "/")
      return p.slice(0, -1).indexOf("/") === -1 ? p : dirname(p.slice(0, -1));
    var c = p.lastIndexOf("/");
    return c === -1 ? p : p.slice(0, c + 1);
  }
  function filename(p) {
    if (p.charAt(p.length - 1) == "/")
      return filename(p.slice(0, -1));
    var c = p.lastIndexOf("/");
    return c === -1 ? p : p.slice(c + 1);
  }
  function write_dos_date(buf, date) {
    if (typeof date === "string")
      date = new Date(date);
    var hms = date.getHours();
    hms = hms << 6 | date.getMinutes();
    hms = hms << 5 | date.getSeconds() >>> 1;
    buf.write_shift(2, hms);
    var ymd = date.getFullYear() - 1980;
    ymd = ymd << 4 | date.getMonth() + 1;
    ymd = ymd << 5 | date.getDate();
    buf.write_shift(2, ymd);
  }
  function parse_dos_date(buf) {
    var hms = buf.read_shift(2) & 65535;
    var ymd = buf.read_shift(2) & 65535;
    var val = /* @__PURE__ */ new Date();
    var d = ymd & 31;
    ymd >>>= 5;
    var m = ymd & 15;
    ymd >>>= 4;
    val.setMilliseconds(0);
    val.setFullYear(ymd + 1980);
    val.setMonth(m - 1);
    val.setDate(d);
    var S = hms & 31;
    hms >>>= 5;
    var M = hms & 63;
    hms >>>= 6;
    val.setHours(hms);
    val.setMinutes(M);
    val.setSeconds(S << 1);
    return val;
  }
  function parse_extra_field(blob2) {
    prep_blob(blob2, 0);
    var o = (
      /*::(*/
      {}
    );
    var flags = 0;
    while (blob2.l <= blob2.length - 4) {
      var type = blob2.read_shift(2);
      var sz = blob2.read_shift(2), tgt = blob2.l + sz;
      var p = {};
      switch (type) {
        case 21589:
          {
            flags = blob2.read_shift(1);
            if (flags & 1)
              p.mtime = blob2.read_shift(4);
            if (sz > 5) {
              if (flags & 2)
                p.atime = blob2.read_shift(4);
              if (flags & 4)
                p.ctime = blob2.read_shift(4);
            }
            if (p.mtime)
              p.mt = new Date(p.mtime * 1e3);
          }
          break;
        case 1:
          {
            var sz1 = blob2.read_shift(4), sz2 = blob2.read_shift(4);
            p.usz = sz2 * Math.pow(2, 32) + sz1;
            sz1 = blob2.read_shift(4);
            sz2 = blob2.read_shift(4);
            p.csz = sz2 * Math.pow(2, 32) + sz1;
          }
          break;
      }
      blob2.l = tgt;
      o[type] = p;
    }
    return o;
  }
  var fs;
  function get_fs() {
    return fs || (fs = _fs);
  }
  function parse2(file, options2) {
    if (file[0] == 80 && file[1] == 75)
      return parse_zip2(file, options2);
    if ((file[0] | 32) == 109 && (file[1] | 32) == 105)
      return parse_mad(file, options2);
    if (file.length < 512)
      throw new Error("CFB file size " + file.length + " < 512");
    var mver = 3;
    var ssz = 512;
    var nmfs = 0;
    var difat_sec_cnt = 0;
    var dir_start = 0;
    var minifat_start = 0;
    var difat_start = 0;
    var fat_addrs = [];
    var blob2 = (
      /*::(*/
      file.slice(0, 512)
    );
    prep_blob(blob2, 0);
    var mv = check_get_mver(blob2);
    mver = mv[0];
    switch (mver) {
      case 3:
        ssz = 512;
        break;
      case 4:
        ssz = 4096;
        break;
      case 0:
        if (mv[1] == 0)
          return parse_zip2(file, options2);
      default:
        throw new Error("Major Version: Expected 3 or 4 saw " + mver);
    }
    if (ssz !== 512) {
      blob2 = /*::(*/
      file.slice(0, ssz);
      prep_blob(
        blob2,
        28
        /* blob.l */
      );
    }
    var header = file.slice(0, ssz);
    check_shifts(blob2, mver);
    var dir_cnt = blob2.read_shift(4, "i");
    if (mver === 3 && dir_cnt !== 0)
      throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
    blob2.l += 4;
    dir_start = blob2.read_shift(4, "i");
    blob2.l += 4;
    blob2.chk("00100000", "Mini Stream Cutoff Size: ");
    minifat_start = blob2.read_shift(4, "i");
    nmfs = blob2.read_shift(4, "i");
    difat_start = blob2.read_shift(4, "i");
    difat_sec_cnt = blob2.read_shift(4, "i");
    for (var q2 = -1, j = 0; j < 109; ++j) {
      q2 = blob2.read_shift(4, "i");
      if (q2 < 0)
        break;
      fat_addrs[j] = q2;
    }
    var sectors = sectorify(file, ssz);
    sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
    var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
    if (dir_start < sector_list.length)
      sector_list[dir_start].name = "!Directory";
    if (nmfs > 0 && minifat_start !== ENDOFCHAIN)
      sector_list[minifat_start].name = "!MiniFAT";
    sector_list[fat_addrs[0]].name = "!FAT";
    sector_list.fat_addrs = fat_addrs;
    sector_list.ssz = ssz;
    var files = {}, Paths = [], FileIndex = [], FullPaths = [];
    read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
    build_full_paths(FileIndex, FullPaths, Paths);
    Paths.shift();
    var o = {
      FileIndex,
      FullPaths
    };
    if (options2 && options2.raw)
      o.raw = { header, sectors };
    return o;
  }
  function check_get_mver(blob2) {
    if (blob2[blob2.l] == 80 && blob2[blob2.l + 1] == 75)
      return [0, 0];
    blob2.chk(HEADER_SIGNATURE, "Header Signature: ");
    blob2.l += 16;
    var mver = blob2.read_shift(2, "u");
    return [blob2.read_shift(2, "u"), mver];
  }
  function check_shifts(blob2, mver) {
    var shift = 9;
    blob2.l += 2;
    switch (shift = blob2.read_shift(2)) {
      case 9:
        if (mver != 3)
          throw new Error("Sector Shift: Expected 9 saw " + shift);
        break;
      case 12:
        if (mver != 4)
          throw new Error("Sector Shift: Expected 12 saw " + shift);
        break;
      default:
        throw new Error("Sector Shift: Expected 9 or 12 saw " + shift);
    }
    blob2.chk("0600", "Mini Sector Shift: ");
    blob2.chk("000000000000", "Reserved: ");
  }
  function sectorify(file, ssz) {
    var nsectors = Math.ceil(file.length / ssz) - 1;
    var sectors = [];
    for (var i2 = 1; i2 < nsectors; ++i2)
      sectors[i2 - 1] = file.slice(i2 * ssz, (i2 + 1) * ssz);
    sectors[nsectors - 1] = file.slice(nsectors * ssz);
    return sectors;
  }
  function build_full_paths(FI, FP, Paths) {
    var i2 = 0, L = 0, R = 0, C = 0, j = 0, pl = Paths.length;
    var dad = [], q2 = [];
    for (; i2 < pl; ++i2) {
      dad[i2] = q2[i2] = i2;
      FP[i2] = Paths[i2];
    }
    for (; j < q2.length; ++j) {
      i2 = q2[j];
      L = FI[i2].L;
      R = FI[i2].R;
      C = FI[i2].C;
      if (dad[i2] === i2) {
        if (L !== -1 && dad[L] !== L)
          dad[i2] = dad[L];
        if (R !== -1 && dad[R] !== R)
          dad[i2] = dad[R];
      }
      if (C !== -1)
        dad[C] = i2;
      if (L !== -1 && i2 != dad[i2]) {
        dad[L] = dad[i2];
        if (q2.lastIndexOf(L) < j)
          q2.push(L);
      }
      if (R !== -1 && i2 != dad[i2]) {
        dad[R] = dad[i2];
        if (q2.lastIndexOf(R) < j)
          q2.push(R);
      }
    }
    for (i2 = 1; i2 < pl; ++i2)
      if (dad[i2] === i2) {
        if (R !== -1 && dad[R] !== R)
          dad[i2] = dad[R];
        else if (L !== -1 && dad[L] !== L)
          dad[i2] = dad[L];
      }
    for (i2 = 1; i2 < pl; ++i2) {
      if (FI[i2].type === 0)
        continue;
      j = i2;
      if (j != dad[j])
        do {
          j = dad[j];
          FP[i2] = FP[j] + "/" + FP[i2];
        } while (j !== 0 && -1 !== dad[j] && j != dad[j]);
      dad[i2] = -1;
    }
    FP[0] += "/";
    for (i2 = 1; i2 < pl; ++i2) {
      if (FI[i2].type !== 2)
        FP[i2] += "/";
    }
  }
  function get_mfat_entry(entry, payload, mini) {
    var start = entry.start, size = entry.size;
    var o = [];
    var idx = start;
    while (mini && size > 0 && idx >= 0) {
      o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
      size -= MSSZ;
      idx = __readInt32LE(mini, idx * 4);
    }
    if (o.length === 0)
      return new_buf(0);
    return bconcat(o).slice(0, entry.size);
  }
  function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
    var q2 = ENDOFCHAIN;
    if (idx === ENDOFCHAIN) {
      if (cnt !== 0)
        throw new Error("DIFAT chain shorter than expected");
    } else if (idx !== -1) {
      var sector = sectors[idx], m = (ssz >>> 2) - 1;
      if (!sector)
        return;
      for (var i2 = 0; i2 < m; ++i2) {
        if ((q2 = __readInt32LE(sector, i2 * 4)) === ENDOFCHAIN)
          break;
        fat_addrs.push(q2);
      }
      if (cnt >= 1)
        sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
    }
  }
  function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
    var buf = [], buf_chain = [];
    if (!chkd)
      chkd = [];
    var modulus = ssz - 1, j = 0, jj = 0;
    for (j = start; j >= 0; ) {
      chkd[j] = true;
      buf[buf.length] = j;
      buf_chain.push(sectors[j]);
      var addr = fat_addrs[Math.floor(j * 4 / ssz)];
      jj = j * 4 & modulus;
      if (ssz < 4 + jj)
        throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
      if (!sectors[addr])
        break;
      j = __readInt32LE(sectors[addr], jj);
    }
    return { nodes: buf, data: __toBuffer([buf_chain]) };
  }
  function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
    var sl = sectors.length, sector_list = [];
    var chkd = [], buf = [], buf_chain = [];
    var modulus = ssz - 1, i2 = 0, j = 0, k = 0, jj = 0;
    for (i2 = 0; i2 < sl; ++i2) {
      buf = [];
      k = i2 + dir_start;
      if (k >= sl)
        k -= sl;
      if (chkd[k])
        continue;
      buf_chain = [];
      var seen = [];
      for (j = k; j >= 0; ) {
        seen[j] = true;
        chkd[j] = true;
        buf[buf.length] = j;
        buf_chain.push(sectors[j]);
        var addr = fat_addrs[Math.floor(j * 4 / ssz)];
        jj = j * 4 & modulus;
        if (ssz < 4 + jj)
          throw new Error("FAT boundary crossed: " + j + " 4 " + ssz);
        if (!sectors[addr])
          break;
        j = __readInt32LE(sectors[addr], jj);
        if (seen[j])
          break;
      }
      sector_list[k] = { nodes: buf, data: __toBuffer([buf_chain]) };
    }
    return sector_list;
  }
  function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
    var minifat_store = 0, pl = Paths.length ? 2 : 0;
    var sector = sector_list[dir_start].data;
    var i2 = 0, namelen = 0, name;
    for (; i2 < sector.length; i2 += 128) {
      var blob2 = (
        /*::(*/
        sector.slice(i2, i2 + 128)
      );
      prep_blob(blob2, 64);
      namelen = blob2.read_shift(2);
      name = __utf16le(blob2, 0, namelen - pl);
      Paths.push(name);
      var o = {
        name,
        type: blob2.read_shift(1),
        color: blob2.read_shift(1),
        L: blob2.read_shift(4, "i"),
        R: blob2.read_shift(4, "i"),
        C: blob2.read_shift(4, "i"),
        clsid: blob2.read_shift(16),
        state: blob2.read_shift(4, "i"),
        start: 0,
        size: 0
      };
      var ctime = blob2.read_shift(2) + blob2.read_shift(2) + blob2.read_shift(2) + blob2.read_shift(2);
      if (ctime !== 0)
        o.ct = read_date(blob2, blob2.l - 8);
      var mtime = blob2.read_shift(2) + blob2.read_shift(2) + blob2.read_shift(2) + blob2.read_shift(2);
      if (mtime !== 0)
        o.mt = read_date(blob2, blob2.l - 8);
      o.start = blob2.read_shift(4, "i");
      o.size = blob2.read_shift(4, "i");
      if (o.size < 0 && o.start < 0) {
        o.size = o.type = 0;
        o.start = ENDOFCHAIN;
        o.name = "";
      }
      if (o.type === 5) {
        minifat_store = o.start;
        if (nmfs > 0 && minifat_store !== ENDOFCHAIN)
          sector_list[minifat_store].name = "!StreamData";
      } else if (o.size >= 4096) {
        o.storage = "fat";
        if (sector_list[o.start] === void 0)
          sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
        sector_list[o.start].name = o.name;
        o.content = sector_list[o.start].data.slice(0, o.size);
      } else {
        o.storage = "minifat";
        if (o.size < 0)
          o.size = 0;
        else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {
          o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
        }
      }
      if (o.content)
        prep_blob(o.content, 0);
      files[name] = o;
      FileIndex.push(o);
    }
  }
  function read_date(blob2, offset) {
    return new Date((__readUInt32LE(blob2, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob2, offset) / 1e7 - 11644473600) * 1e3);
  }
  function read_file(filename2, options2) {
    get_fs();
    return parse2(fs.readFileSync(filename2), options2);
  }
  function read(blob2, options2) {
    var type = options2 && options2.type;
    if (!type) {
      if (has_buf && Buffer.isBuffer(blob2))
        type = "buffer";
    }
    switch (type || "base64") {
      case "file":
        return read_file(blob2, options2);
      case "base64":
        return parse2(s2a(Base64_decode(blob2)), options2);
      case "binary":
        return parse2(s2a(blob2), options2);
    }
    return parse2(
      /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
      blob2,
      options2
    );
  }
  function init_cfb(cfb, opts) {
    var o = opts || {}, root2 = o.root || "Root Entry";
    if (!cfb.FullPaths)
      cfb.FullPaths = [];
    if (!cfb.FileIndex)
      cfb.FileIndex = [];
    if (cfb.FullPaths.length !== cfb.FileIndex.length)
      throw new Error("inconsistent CFB structure");
    if (cfb.FullPaths.length === 0) {
      cfb.FullPaths[0] = root2 + "/";
      cfb.FileIndex[0] = { name: root2, type: 5 };
    }
    if (o.CLSID)
      cfb.FileIndex[0].clsid = o.CLSID;
    seed_cfb(cfb);
  }
  function seed_cfb(cfb) {
    var nm = "Sh33tJ5";
    if (CFB.find(cfb, "/" + nm))
      return;
    var p = new_buf(4);
    p[0] = 55;
    p[1] = p[3] = 50;
    p[2] = 54;
    cfb.FileIndex.push({ name: nm, type: 2, content: p, size: 4, L: 69, R: 69, C: 69 });
    cfb.FullPaths.push(cfb.FullPaths[0] + nm);
    rebuild_cfb(cfb);
  }
  function rebuild_cfb(cfb, f) {
    init_cfb(cfb);
    var gc = false, s = false;
    for (var i2 = cfb.FullPaths.length - 1; i2 >= 0; --i2) {
      var _file = cfb.FileIndex[i2];
      switch (_file.type) {
        case 0:
          if (s)
            gc = true;
          else {
            cfb.FileIndex.pop();
            cfb.FullPaths.pop();
          }
          break;
        case 1:
        case 2:
        case 5:
          s = true;
          if (isNaN(_file.R * _file.L * _file.C))
            gc = true;
          if (_file.R > -1 && _file.L > -1 && _file.R == _file.L)
            gc = true;
          break;
        default:
          gc = true;
          break;
      }
    }
    if (!gc && !f)
      return;
    var now2 = new Date(1987, 1, 19), j = 0;
    var fullPaths = Object.create ? /* @__PURE__ */ Object.create(null) : {};
    var data = [];
    for (i2 = 0; i2 < cfb.FullPaths.length; ++i2) {
      fullPaths[cfb.FullPaths[i2]] = true;
      if (cfb.FileIndex[i2].type === 0)
        continue;
      data.push([cfb.FullPaths[i2], cfb.FileIndex[i2]]);
    }
    for (i2 = 0; i2 < data.length; ++i2) {
      var dad = dirname(data[i2][0]);
      s = fullPaths[dad];
      while (!s) {
        while (dirname(dad) && !fullPaths[dirname(dad)])
          dad = dirname(dad);
        data.push([dad, {
          name: filename(dad).replace("/", ""),
          type: 1,
          clsid: HEADER_CLSID,
          ct: now2,
          mt: now2,
          content: null
        }]);
        fullPaths[dad] = true;
        dad = dirname(data[i2][0]);
        s = fullPaths[dad];
      }
    }
    data.sort(function(x, y) {
      return namecmp(x[0], y[0]);
    });
    cfb.FullPaths = [];
    cfb.FileIndex = [];
    for (i2 = 0; i2 < data.length; ++i2) {
      cfb.FullPaths[i2] = data[i2][0];
      cfb.FileIndex[i2] = data[i2][1];
    }
    for (i2 = 0; i2 < data.length; ++i2) {
      var elt = cfb.FileIndex[i2];
      var nm = cfb.FullPaths[i2];
      elt.name = filename(nm).replace("/", "");
      elt.L = elt.R = elt.C = -(elt.color = 1);
      elt.size = elt.content ? elt.content.length : 0;
      elt.start = 0;
      elt.clsid = elt.clsid || HEADER_CLSID;
      if (i2 === 0) {
        elt.C = data.length > 1 ? 1 : -1;
        elt.size = 0;
        elt.type = 5;
      } else if (nm.slice(-1) == "/") {
        for (j = i2 + 1; j < data.length; ++j)
          if (dirname(cfb.FullPaths[j]) == nm)
            break;
        elt.C = j >= data.length ? -1 : j;
        for (j = i2 + 1; j < data.length; ++j)
          if (dirname(cfb.FullPaths[j]) == dirname(nm))
            break;
        elt.R = j >= data.length ? -1 : j;
        elt.type = 1;
      } else {
        if (dirname(cfb.FullPaths[i2 + 1] || "") == dirname(nm))
          elt.R = i2 + 1;
        elt.type = 2;
      }
    }
  }
  function _write(cfb, options2) {
    var _opts = options2 || {};
    if (_opts.fileType == "mad")
      return write_mad(cfb, _opts);
    rebuild_cfb(cfb);
    switch (_opts.fileType) {
      case "zip":
        return write_zip2(cfb, _opts);
    }
    var L = function(cfb2) {
      var mini_size = 0, fat_size = 0;
      for (var i3 = 0; i3 < cfb2.FileIndex.length; ++i3) {
        var file2 = cfb2.FileIndex[i3];
        if (!file2.content)
          continue;
        var flen2 = file2.content.length;
        if (flen2 > 0) {
          if (flen2 < 4096)
            mini_size += flen2 + 63 >> 6;
          else
            fat_size += flen2 + 511 >> 9;
        }
      }
      var dir_cnt = cfb2.FullPaths.length + 3 >> 2;
      var mini_cnt = mini_size + 7 >> 3;
      var mfat_cnt = mini_size + 127 >> 7;
      var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
      var fat_cnt = fat_base + 127 >> 7;
      var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
      while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt)
        difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
      var L2 = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
      cfb2.FileIndex[0].size = mini_size << 6;
      L2[7] = (cfb2.FileIndex[0].start = L2[0] + L2[1] + L2[2] + L2[3] + L2[4] + L2[5]) + (L2[6] + 7 >> 3);
      return L2;
    }(cfb);
    var o = new_buf(L[7] << 9);
    var i2 = 0, T = 0;
    {
      for (i2 = 0; i2 < 8; ++i2)
        o.write_shift(1, HEADER_SIG[i2]);
      for (i2 = 0; i2 < 8; ++i2)
        o.write_shift(2, 0);
      o.write_shift(2, 62);
      o.write_shift(2, 3);
      o.write_shift(2, 65534);
      o.write_shift(2, 9);
      o.write_shift(2, 6);
      for (i2 = 0; i2 < 3; ++i2)
        o.write_shift(2, 0);
      o.write_shift(4, 0);
      o.write_shift(4, L[2]);
      o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);
      o.write_shift(4, 0);
      o.write_shift(4, 1 << 12);
      o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);
      o.write_shift(4, L[3]);
      o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);
      o.write_shift(4, L[1]);
      for (i2 = 0; i2 < 109; ++i2)
        o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
    }
    if (L[1]) {
      for (T = 0; T < L[1]; ++T) {
        for (; i2 < 236 + T * 127; ++i2)
          o.write_shift(-4, i2 < L[2] ? L[1] + i2 : -1);
        o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);
      }
    }
    var chainit = function(w2) {
      for (T += w2; i2 < T - 1; ++i2)
        o.write_shift(-4, i2 + 1);
      if (w2) {
        ++i2;
        o.write_shift(-4, ENDOFCHAIN);
      }
    };
    T = i2 = 0;
    for (T += L[1]; i2 < T; ++i2)
      o.write_shift(-4, consts.DIFSECT);
    for (T += L[2]; i2 < T; ++i2)
      o.write_shift(-4, consts.FATSECT);
    chainit(L[3]);
    chainit(L[4]);
    var j = 0, flen = 0;
    var file = cfb.FileIndex[0];
    for (; j < cfb.FileIndex.length; ++j) {
      file = cfb.FileIndex[j];
      if (!file.content)
        continue;
      flen = file.content.length;
      if (flen < 4096)
        continue;
      file.start = T;
      chainit(flen + 511 >> 9);
    }
    chainit(L[6] + 7 >> 3);
    while (o.l & 511)
      o.write_shift(-4, consts.ENDOFCHAIN);
    T = i2 = 0;
    for (j = 0; j < cfb.FileIndex.length; ++j) {
      file = cfb.FileIndex[j];
      if (!file.content)
        continue;
      flen = file.content.length;
      if (!flen || flen >= 4096)
        continue;
      file.start = T;
      chainit(flen + 63 >> 6);
    }
    while (o.l & 511)
      o.write_shift(-4, consts.ENDOFCHAIN);
    for (i2 = 0; i2 < L[4] << 2; ++i2) {
      var nm = cfb.FullPaths[i2];
      if (!nm || nm.length === 0) {
        for (j = 0; j < 17; ++j)
          o.write_shift(4, 0);
        for (j = 0; j < 3; ++j)
          o.write_shift(4, -1);
        for (j = 0; j < 12; ++j)
          o.write_shift(4, 0);
        continue;
      }
      file = cfb.FileIndex[i2];
      if (i2 === 0)
        file.start = file.size ? file.start - 1 : ENDOFCHAIN;
      var _nm = i2 === 0 && _opts.root || file.name;
      if (_nm.length > 32) {
        console.error("Name " + _nm + " will be truncated to " + _nm.slice(0, 32));
        _nm = _nm.slice(0, 32);
      }
      flen = 2 * (_nm.length + 1);
      o.write_shift(64, _nm, "utf16le");
      o.write_shift(2, flen);
      o.write_shift(1, file.type);
      o.write_shift(1, file.color);
      o.write_shift(-4, file.L);
      o.write_shift(-4, file.R);
      o.write_shift(-4, file.C);
      if (!file.clsid)
        for (j = 0; j < 4; ++j)
          o.write_shift(4, 0);
      else
        o.write_shift(16, file.clsid, "hex");
      o.write_shift(4, file.state || 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(4, file.start);
      o.write_shift(4, file.size);
      o.write_shift(4, 0);
    }
    for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
      file = cfb.FileIndex[i2];
      if (file.size >= 4096) {
        o.l = file.start + 1 << 9;
        if (has_buf && Buffer.isBuffer(file.content)) {
          file.content.copy(o, o.l, 0, file.size);
          o.l += file.size + 511 & -512;
        } else {
          for (j = 0; j < file.size; ++j)
            o.write_shift(1, file.content[j]);
          for (; j & 511; ++j)
            o.write_shift(1, 0);
        }
      }
    }
    for (i2 = 1; i2 < cfb.FileIndex.length; ++i2) {
      file = cfb.FileIndex[i2];
      if (file.size > 0 && file.size < 4096) {
        if (has_buf && Buffer.isBuffer(file.content)) {
          file.content.copy(o, o.l, 0, file.size);
          o.l += file.size + 63 & -64;
        } else {
          for (j = 0; j < file.size; ++j)
            o.write_shift(1, file.content[j]);
          for (; j & 63; ++j)
            o.write_shift(1, 0);
        }
      }
    }
    if (has_buf) {
      o.l = o.length;
    } else {
      while (o.l < o.length)
        o.write_shift(1, 0);
    }
    return o;
  }
  function find(cfb, path) {
    var UCFullPaths = cfb.FullPaths.map(function(x) {
      return x.toUpperCase();
    });
    var UCPaths = UCFullPaths.map(function(x) {
      var y = x.split("/");
      return y[y.length - (x.slice(-1) == "/" ? 2 : 1)];
    });
    var k = false;
    if (path.charCodeAt(0) === 47) {
      k = true;
      path = UCFullPaths[0].slice(0, -1) + path;
    } else
      k = path.indexOf("/") !== -1;
    var UCPath = path.toUpperCase();
    var w2 = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
    if (w2 !== -1)
      return cfb.FileIndex[w2];
    var m = !UCPath.match(chr1);
    UCPath = UCPath.replace(chr0, "");
    if (m)
      UCPath = UCPath.replace(chr1, "!");
    for (w2 = 0; w2 < UCFullPaths.length; ++w2) {
      if ((m ? UCFullPaths[w2].replace(chr1, "!") : UCFullPaths[w2]).replace(chr0, "") == UCPath)
        return cfb.FileIndex[w2];
      if ((m ? UCPaths[w2].replace(chr1, "!") : UCPaths[w2]).replace(chr0, "") == UCPath)
        return cfb.FileIndex[w2];
    }
    return null;
  }
  var MSSZ = 64;
  var ENDOFCHAIN = -2;
  var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
  var HEADER_SIG = [208, 207, 17, 224, 161, 177, 26, 225];
  var HEADER_CLSID = "00000000000000000000000000000000";
  var consts = {
    /* 2.1 Compund File Sector Numbers and Types */
    MAXREGSECT: -6,
    DIFSECT: -4,
    FATSECT: -3,
    ENDOFCHAIN,
    FREESECT: -1,
    /* 2.2 Compound File Header */
    HEADER_SIGNATURE,
    HEADER_MINOR_VERSION: "3e00",
    MAXREGSID: -6,
    NOSTREAM: -1,
    HEADER_CLSID,
    /* 2.6.1 Compound File Directory Entry */
    EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
  };
  function write_file(cfb, filename2, options2) {
    get_fs();
    var o = _write(cfb, options2);
    fs.writeFileSync(filename2, o);
  }
  function a2s2(o) {
    var out = new Array(o.length);
    for (var i2 = 0; i2 < o.length; ++i2)
      out[i2] = String.fromCharCode(o[i2]);
    return out.join("");
  }
  function write(cfb, options2) {
    var o = _write(cfb, options2);
    switch (options2 && options2.type || "buffer") {
      case "file":
        get_fs();
        fs.writeFileSync(options2.filename, o);
        return o;
      case "binary":
        return typeof o == "string" ? o : a2s2(o);
      case "base64":
        return Base64_encode(typeof o == "string" ? o : a2s2(o));
      case "buffer":
        if (has_buf)
          return Buffer.isBuffer(o) ? o : Buffer_from(o);
      case "array":
        return typeof o == "string" ? s2a(o) : o;
    }
    return o;
  }
  var _zlib;
  function use_zlib(zlib) {
    try {
      var InflateRaw = zlib.InflateRaw;
      var InflRaw = new InflateRaw();
      InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
      if (InflRaw.bytesRead)
        _zlib = zlib;
      else
        throw new Error("zlib does not expose bytesRead");
    } catch (e) {
      console.error("cannot use native zlib: " + (e.message || e));
    }
  }
  function _inflateRawSync(payload, usz) {
    if (!_zlib)
      return _inflate(payload, usz);
    var InflateRaw = _zlib.InflateRaw;
    var InflRaw = new InflateRaw();
    var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
    payload.l += InflRaw.bytesRead;
    return out;
  }
  function _deflateRawSync(payload) {
    return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
  }
  var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];
  var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  function bit_swap_8(n) {
    var t = (n << 1 | n << 11) & 139536 | (n << 5 | n << 15) & 558144;
    return (t >> 16 | t >> 8 | t) & 255;
  }
  var use_typed_arrays = typeof Uint8Array !== "undefined";
  var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
  for (var q = 0; q < 1 << 8; ++q)
    bitswap8[q] = bit_swap_8(q);
  function bit_swap_n(n, b) {
    var rev = bitswap8[n & 255];
    if (b <= 8)
      return rev >>> 8 - b;
    rev = rev << 8 | bitswap8[n >> 8 & 255];
    if (b <= 16)
      return rev >>> 16 - b;
    rev = rev << 8 | bitswap8[n >> 16 & 255];
    return rev >>> 24 - b;
  }
  function read_bits_2(buf, bl) {
    var w2 = bl & 7, h = bl >>> 3;
    return (buf[h] | (w2 <= 6 ? 0 : buf[h + 1] << 8)) >>> w2 & 3;
  }
  function read_bits_3(buf, bl) {
    var w2 = bl & 7, h = bl >>> 3;
    return (buf[h] | (w2 <= 5 ? 0 : buf[h + 1] << 8)) >>> w2 & 7;
  }
  function read_bits_4(buf, bl) {
    var w2 = bl & 7, h = bl >>> 3;
    return (buf[h] | (w2 <= 4 ? 0 : buf[h + 1] << 8)) >>> w2 & 15;
  }
  function read_bits_5(buf, bl) {
    var w2 = bl & 7, h = bl >>> 3;
    return (buf[h] | (w2 <= 3 ? 0 : buf[h + 1] << 8)) >>> w2 & 31;
  }
  function read_bits_7(buf, bl) {
    var w2 = bl & 7, h = bl >>> 3;
    return (buf[h] | (w2 <= 1 ? 0 : buf[h + 1] << 8)) >>> w2 & 127;
  }
  function read_bits_n(buf, bl, n) {
    var w2 = bl & 7, h = bl >>> 3, f = (1 << n) - 1;
    var v = buf[h] >>> w2;
    if (n < 8 - w2)
      return v & f;
    v |= buf[h + 1] << 8 - w2;
    if (n < 16 - w2)
      return v & f;
    v |= buf[h + 2] << 16 - w2;
    if (n < 24 - w2)
      return v & f;
    v |= buf[h + 3] << 24 - w2;
    return v & f;
  }
  function write_bits_3(buf, bl, v) {
    var w2 = bl & 7, h = bl >>> 3;
    if (w2 <= 5)
      buf[h] |= (v & 7) << w2;
    else {
      buf[h] |= v << w2 & 255;
      buf[h + 1] = (v & 7) >> 8 - w2;
    }
    return bl + 3;
  }
  function write_bits_1(buf, bl, v) {
    var w2 = bl & 7, h = bl >>> 3;
    v = (v & 1) << w2;
    buf[h] |= v;
    return bl + 1;
  }
  function write_bits_8(buf, bl, v) {
    var w2 = bl & 7, h = bl >>> 3;
    v <<= w2;
    buf[h] |= v & 255;
    v >>>= 8;
    buf[h + 1] = v;
    return bl + 8;
  }
  function write_bits_16(buf, bl, v) {
    var w2 = bl & 7, h = bl >>> 3;
    v <<= w2;
    buf[h] |= v & 255;
    v >>>= 8;
    buf[h + 1] = v & 255;
    buf[h + 2] = v >>> 8;
    return bl + 16;
  }
  function realloc(b, sz) {
    var L = b.length, M = 2 * L > sz ? 2 * L : sz + 5, i2 = 0;
    if (L >= sz)
      return b;
    if (has_buf) {
      var o = new_unsafe_buf(M);
      if (b.copy)
        b.copy(o);
      else
        for (; i2 < b.length; ++i2)
          o[i2] = b[i2];
      return o;
    } else if (use_typed_arrays) {
      var a = new Uint8Array(M);
      if (a.set)
        a.set(b);
      else
        for (; i2 < L; ++i2)
          a[i2] = b[i2];
      return a;
    }
    b.length = M;
    return b;
  }
  function zero_fill_array(n) {
    var o = new Array(n);
    for (var i2 = 0; i2 < n; ++i2)
      o[i2] = 0;
    return o;
  }
  function build_tree(clens, cmap, MAX) {
    var maxlen = 1, w2 = 0, i2 = 0, j = 0, ccode = 0, L = clens.length;
    var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
    for (i2 = 0; i2 < 32; ++i2)
      bl_count[i2] = 0;
    for (i2 = L; i2 < MAX; ++i2)
      clens[i2] = 0;
    L = clens.length;
    var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L);
    for (i2 = 0; i2 < L; ++i2) {
      bl_count[w2 = clens[i2]]++;
      if (maxlen < w2)
        maxlen = w2;
      ctree[i2] = 0;
    }
    bl_count[0] = 0;
    for (i2 = 1; i2 <= maxlen; ++i2)
      bl_count[i2 + 16] = ccode = ccode + bl_count[i2 - 1] << 1;
    for (i2 = 0; i2 < L; ++i2) {
      ccode = clens[i2];
      if (ccode != 0)
        ctree[i2] = bl_count[ccode + 16]++;
    }
    var cleni = 0;
    for (i2 = 0; i2 < L; ++i2) {
      cleni = clens[i2];
      if (cleni != 0) {
        ccode = bit_swap_n(ctree[i2], maxlen) >> maxlen - cleni;
        for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j)
          cmap[ccode | j << cleni] = cleni & 15 | i2 << 4;
      }
    }
    return maxlen;
  }
  var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
  var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
  if (!use_typed_arrays) {
    for (var i = 0; i < 512; ++i)
      fix_lmap[i] = 0;
    for (i = 0; i < 32; ++i)
      fix_dmap[i] = 0;
  }
  (function() {
    var dlens = [];
    var i2 = 0;
    for (; i2 < 32; i2++)
      dlens.push(5);
    build_tree(dlens, fix_dmap, 32);
    var clens = [];
    i2 = 0;
    for (; i2 <= 143; i2++)
      clens.push(8);
    for (; i2 <= 255; i2++)
      clens.push(9);
    for (; i2 <= 279; i2++)
      clens.push(7);
    for (; i2 <= 287; i2++)
      clens.push(8);
    build_tree(clens, fix_lmap, 288);
  })();
  var _deflateRaw = /* @__PURE__ */ function _deflateRawIIFE() {
    var DST_LN_RE = use_typed_arrays ? new Uint8Array(32768) : [];
    var j = 0, k = 0;
    for (; j < DST_LN.length - 1; ++j) {
      for (; k < DST_LN[j + 1]; ++k)
        DST_LN_RE[k] = j;
    }
    for (; k < 32768; ++k)
      DST_LN_RE[k] = 29;
    var LEN_LN_RE = use_typed_arrays ? new Uint8Array(259) : [];
    for (j = 0, k = 0; j < LEN_LN.length - 1; ++j) {
      for (; k < LEN_LN[j + 1]; ++k)
        LEN_LN_RE[k] = j;
    }
    function write_stored(data, out) {
      var boff = 0;
      while (boff < data.length) {
        var L = Math.min(65535, data.length - boff);
        var h = boff + L == data.length;
        out.write_shift(1, +h);
        out.write_shift(2, L);
        out.write_shift(2, ~L & 65535);
        while (L-- > 0)
          out[out.l++] = data[boff++];
      }
      return out.l;
    }
    function write_huff_fixed(data, out) {
      var bl = 0;
      var boff = 0;
      var addrs = use_typed_arrays ? new Uint16Array(32768) : [];
      while (boff < data.length) {
        var L = (
          /* data.length - boff; */
          Math.min(65535, data.length - boff)
        );
        if (L < 10) {
          bl = write_bits_3(out, bl, +!!(boff + L == data.length));
          if (bl & 7)
            bl += 8 - (bl & 7);
          out.l = bl / 8 | 0;
          out.write_shift(2, L);
          out.write_shift(2, ~L & 65535);
          while (L-- > 0)
            out[out.l++] = data[boff++];
          bl = out.l * 8;
          continue;
        }
        bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2);
        var hash2 = 0;
        while (L-- > 0) {
          var d = data[boff];
          hash2 = (hash2 << 5 ^ d) & 32767;
          var match2 = -1, mlen = 0;
          if (match2 = addrs[hash2]) {
            match2 |= boff & ~32767;
            if (match2 > boff)
              match2 -= 32768;
            if (match2 < boff)
              while (data[match2 + mlen] == data[boff + mlen] && mlen < 250)
                ++mlen;
          }
          if (mlen > 2) {
            d = LEN_LN_RE[mlen];
            if (d <= 22)
              bl = write_bits_8(out, bl, bitswap8[d + 1] >> 1) - 1;
            else {
              write_bits_8(out, bl, 3);
              bl += 5;
              write_bits_8(out, bl, bitswap8[d - 23] >> 5);
              bl += 3;
            }
            var len_eb = d < 8 ? 0 : d - 4 >> 2;
            if (len_eb > 0) {
              write_bits_16(out, bl, mlen - LEN_LN[d]);
              bl += len_eb;
            }
            d = DST_LN_RE[boff - match2];
            bl = write_bits_8(out, bl, bitswap8[d] >> 3);
            bl -= 3;
            var dst_eb = d < 4 ? 0 : d - 2 >> 1;
            if (dst_eb > 0) {
              write_bits_16(out, bl, boff - match2 - DST_LN[d]);
              bl += dst_eb;
            }
            for (var q2 = 0; q2 < mlen; ++q2) {
              addrs[hash2] = boff & 32767;
              hash2 = (hash2 << 5 ^ data[boff]) & 32767;
              ++boff;
            }
            L -= mlen - 1;
          } else {
            if (d <= 143)
              d = d + 48;
            else
              bl = write_bits_1(out, bl, 1);
            bl = write_bits_8(out, bl, bitswap8[d]);
            addrs[hash2] = boff & 32767;
            ++boff;
          }
        }
        bl = write_bits_8(out, bl, 0) - 1;
      }
      out.l = (bl + 7) / 8 | 0;
      return out.l;
    }
    return function _deflateRaw2(data, out) {
      if (data.length < 8)
        return write_stored(data, out);
      return write_huff_fixed(data, out);
    };
  }();
  function _deflate(data) {
    var buf = new_buf(50 + Math.floor(data.length * 1.1));
    var off = _deflateRaw(data, buf);
    return buf.slice(0, off);
  }
  var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
  var dyn_len_1 = 1, dyn_len_2 = 1;
  function dyn(data, boff) {
    var _HLIT = read_bits_5(data, boff) + 257;
    boff += 5;
    var _HDIST = read_bits_5(data, boff) + 1;
    boff += 5;
    var _HCLEN = read_bits_4(data, boff) + 4;
    boff += 4;
    var w2 = 0;
    var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
    var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var maxlen = 1;
    var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
    var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
    var L = clens.length;
    for (var i2 = 0; i2 < _HCLEN; ++i2) {
      clens[CLEN_ORDER[i2]] = w2 = read_bits_3(data, boff);
      if (maxlen < w2)
        maxlen = w2;
      bl_count[w2]++;
      boff += 3;
    }
    var ccode = 0;
    bl_count[0] = 0;
    for (i2 = 1; i2 <= maxlen; ++i2)
      next_code[i2] = ccode = ccode + bl_count[i2 - 1] << 1;
    for (i2 = 0; i2 < L; ++i2)
      if ((ccode = clens[i2]) != 0)
        ctree[i2] = next_code[ccode]++;
    var cleni = 0;
    for (i2 = 0; i2 < L; ++i2) {
      cleni = clens[i2];
      if (cleni != 0) {
        ccode = bitswap8[ctree[i2]] >> 8 - cleni;
        for (var j = (1 << 7 - cleni) - 1; j >= 0; --j)
          dyn_cmap[ccode | j << cleni] = cleni & 7 | i2 << 3;
      }
    }
    var hcodes = [];
    maxlen = 1;
    for (; hcodes.length < _HLIT + _HDIST; ) {
      ccode = dyn_cmap[read_bits_7(data, boff)];
      boff += ccode & 7;
      switch (ccode >>>= 3) {
        case 16:
          w2 = 3 + read_bits_2(data, boff);
          boff += 2;
          ccode = hcodes[hcodes.length - 1];
          while (w2-- > 0)
            hcodes.push(ccode);
          break;
        case 17:
          w2 = 3 + read_bits_3(data, boff);
          boff += 3;
          while (w2-- > 0)
            hcodes.push(0);
          break;
        case 18:
          w2 = 11 + read_bits_7(data, boff);
          boff += 7;
          while (w2-- > 0)
            hcodes.push(0);
          break;
        default:
          hcodes.push(ccode);
          if (maxlen < ccode)
            maxlen = ccode;
          break;
      }
    }
    var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);
    for (i2 = _HLIT; i2 < 286; ++i2)
      h1[i2] = 0;
    for (i2 = _HDIST; i2 < 30; ++i2)
      h2[i2] = 0;
    dyn_len_1 = build_tree(h1, dyn_lmap, 286);
    dyn_len_2 = build_tree(h2, dyn_dmap, 30);
    return boff;
  }
  function inflate(data, usz) {
    if (data[0] == 3 && !(data[1] & 3)) {
      return [new_raw_buf(usz), 2];
    }
    var boff = 0;
    var header = 0;
    var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
    var woff = 0;
    var OL = outbuf.length >>> 0;
    var max_len_1 = 0, max_len_2 = 0;
    while ((header & 1) == 0) {
      header = read_bits_3(data, boff);
      boff += 3;
      if (header >>> 1 == 0) {
        if (boff & 7)
          boff += 8 - (boff & 7);
        var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
        boff += 32;
        if (sz > 0) {
          if (!usz && OL < woff + sz) {
            outbuf = realloc(outbuf, woff + sz);
            OL = outbuf.length;
          }
          while (sz-- > 0) {
            outbuf[woff++] = data[boff >>> 3];
            boff += 8;
          }
        }
        continue;
      } else if (header >> 1 == 1) {
        max_len_1 = 9;
        max_len_2 = 5;
      } else {
        boff = dyn(data, boff);
        max_len_1 = dyn_len_1;
        max_len_2 = dyn_len_2;
      }
      for (; ; ) {
        if (!usz && OL < woff + 32767) {
          outbuf = realloc(outbuf, woff + 32767);
          OL = outbuf.length;
        }
        var bits = read_bits_n(data, boff, max_len_1);
        var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
        boff += code & 15;
        code >>>= 4;
        if ((code >>> 8 & 255) === 0)
          outbuf[woff++] = code;
        else if (code == 256)
          break;
        else {
          code -= 257;
          var len_eb = code < 8 ? 0 : code - 4 >> 2;
          if (len_eb > 5)
            len_eb = 0;
          var tgt = woff + LEN_LN[code];
          if (len_eb > 0) {
            tgt += read_bits_n(data, boff, len_eb);
            boff += len_eb;
          }
          bits = read_bits_n(data, boff, max_len_2);
          code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
          boff += code & 15;
          code >>>= 4;
          var dst_eb = code < 4 ? 0 : code - 2 >> 1;
          var dst = DST_LN[code];
          if (dst_eb > 0) {
            dst += read_bits_n(data, boff, dst_eb);
            boff += dst_eb;
          }
          if (!usz && OL < tgt) {
            outbuf = realloc(outbuf, tgt + 100);
            OL = outbuf.length;
          }
          while (woff < tgt) {
            outbuf[woff] = outbuf[woff - dst];
            ++woff;
          }
        }
      }
    }
    if (usz)
      return [outbuf, boff + 7 >>> 3];
    return [outbuf.slice(0, woff), boff + 7 >>> 3];
  }
  function _inflate(payload, usz) {
    var data = payload.slice(payload.l || 0);
    var out = inflate(data, usz);
    payload.l += out[1];
    return out[0];
  }
  function warn_or_throw(wrn, msg) {
    if (wrn) {
      if (typeof console !== "undefined")
        console.error(msg);
    } else
      throw new Error(msg);
  }
  function parse_zip2(file, options2) {
    var blob2 = (
      /*::(*/
      file
    );
    prep_blob(blob2, 0);
    var FileIndex = [], FullPaths = [];
    var o = {
      FileIndex,
      FullPaths
    };
    init_cfb(o, { root: options2.root });
    var i2 = blob2.length - 4;
    while ((blob2[i2] != 80 || blob2[i2 + 1] != 75 || blob2[i2 + 2] != 5 || blob2[i2 + 3] != 6) && i2 >= 0)
      --i2;
    blob2.l = i2 + 4;
    blob2.l += 4;
    var fcnt = blob2.read_shift(2);
    blob2.l += 6;
    var start_cd = blob2.read_shift(4);
    blob2.l = start_cd;
    for (i2 = 0; i2 < fcnt; ++i2) {
      blob2.l += 20;
      var csz = blob2.read_shift(4);
      var usz = blob2.read_shift(4);
      var namelen = blob2.read_shift(2);
      var efsz = blob2.read_shift(2);
      var fcsz = blob2.read_shift(2);
      blob2.l += 8;
      var offset = blob2.read_shift(4);
      var EF = parse_extra_field(
        /*::(*/
        blob2.slice(blob2.l + namelen, blob2.l + namelen + efsz)
        /*:: :any)*/
      );
      blob2.l += namelen + efsz + fcsz;
      var L = blob2.l;
      blob2.l = offset + 4;
      if (EF && EF[1]) {
        if ((EF[1] || {}).usz)
          usz = EF[1].usz;
        if ((EF[1] || {}).csz)
          csz = EF[1].csz;
      }
      parse_local_file(blob2, csz, usz, o, EF);
      blob2.l = L;
    }
    return o;
  }
  function parse_local_file(blob2, csz, usz, o, EF) {
    blob2.l += 2;
    var flags = blob2.read_shift(2);
    var meth = blob2.read_shift(2);
    var date = parse_dos_date(blob2);
    if (flags & 8257)
      throw new Error("Unsupported ZIP encryption");
    var crc32 = blob2.read_shift(4);
    var _csz = blob2.read_shift(4);
    var _usz = blob2.read_shift(4);
    var namelen = blob2.read_shift(2);
    var efsz = blob2.read_shift(2);
    var name = "";
    for (var i2 = 0; i2 < namelen; ++i2)
      name += String.fromCharCode(blob2[blob2.l++]);
    if (efsz) {
      var ef = parse_extra_field(
        /*::(*/
        blob2.slice(blob2.l, blob2.l + efsz)
        /*:: :any)*/
      );
      if ((ef[21589] || {}).mt)
        date = ef[21589].mt;
      if ((ef[1] || {}).usz)
        _usz = ef[1].usz;
      if ((ef[1] || {}).csz)
        _csz = ef[1].csz;
      if (EF) {
        if ((EF[21589] || {}).mt)
          date = EF[21589].mt;
        if ((EF[1] || {}).usz)
          _usz = ef[1].usz;
        if ((EF[1] || {}).csz)
          _csz = ef[1].csz;
      }
    }
    blob2.l += efsz;
    var data = blob2.slice(blob2.l, blob2.l + _csz);
    switch (meth) {
      case 8:
        data = _inflateRawSync(blob2, _usz);
        break;
      case 0:
        break;
      default:
        throw new Error("Unsupported ZIP Compression method " + meth);
    }
    var wrn = false;
    if (flags & 8) {
      crc32 = blob2.read_shift(4);
      if (crc32 == 134695760) {
        crc32 = blob2.read_shift(4);
        wrn = true;
      }
      _csz = blob2.read_shift(4);
      _usz = blob2.read_shift(4);
    }
    if (_csz != csz)
      warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
    if (_usz != usz)
      warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
    cfb_add(o, name, data, { unsafe: true, mt: date });
  }
  function write_zip2(cfb, options2) {
    var _opts = options2 || {};
    var out = [], cdirs = [];
    var o = new_buf(1);
    var method = _opts.compression ? 8 : 0, flags = 0;
    var i2 = 0, j = 0;
    var start_cd = 0, fcnt = 0;
    var root2 = cfb.FullPaths[0], fp = root2, fi = cfb.FileIndex[0];
    var crcs = [];
    var sz_cd = 0;
    for (i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
      fp = cfb.FullPaths[i2].slice(root2.length);
      fi = cfb.FileIndex[i2];
      if (!fi.size || !fi.content || fp == "Sh33tJ5")
        continue;
      var start = start_cd;
      var namebuf = new_buf(fp.length);
      for (j = 0; j < fp.length; ++j)
        namebuf.write_shift(1, fp.charCodeAt(j) & 127);
      namebuf = namebuf.slice(0, namebuf.l);
      crcs[fcnt] = typeof fi.content == "string" ? CRC32.bstr(fi.content, 0) : CRC32.buf(
        /*::((*/
        fi.content,
        0
      );
      var outbuf = typeof fi.content == "string" ? s2a(fi.content) : fi.content;
      if (method == 8)
        outbuf = _deflateRawSync(outbuf);
      o = new_buf(30);
      o.write_shift(4, 67324752);
      o.write_shift(2, 20);
      o.write_shift(2, flags);
      o.write_shift(2, method);
      if (fi.mt)
        write_dos_date(o, fi.mt);
      else
        o.write_shift(4, 0);
      o.write_shift(-4, crcs[fcnt]);
      o.write_shift(4, outbuf.length);
      o.write_shift(
        4,
        /*::(*/
        fi.content.length
      );
      o.write_shift(2, namebuf.length);
      o.write_shift(2, 0);
      start_cd += o.length;
      out.push(o);
      start_cd += namebuf.length;
      out.push(namebuf);
      start_cd += outbuf.length;
      out.push(outbuf);
      o = new_buf(46);
      o.write_shift(4, 33639248);
      o.write_shift(2, 0);
      o.write_shift(2, 20);
      o.write_shift(2, flags);
      o.write_shift(2, method);
      o.write_shift(4, 0);
      o.write_shift(-4, crcs[fcnt]);
      o.write_shift(4, outbuf.length);
      o.write_shift(
        4,
        /*::(*/
        fi.content.length
      );
      o.write_shift(2, namebuf.length);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(2, 0);
      o.write_shift(4, 0);
      o.write_shift(4, start);
      sz_cd += o.l;
      cdirs.push(o);
      sz_cd += namebuf.length;
      cdirs.push(namebuf);
      ++fcnt;
    }
    o = new_buf(22);
    o.write_shift(4, 101010256);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, fcnt);
    o.write_shift(2, fcnt);
    o.write_shift(4, sz_cd);
    o.write_shift(4, start_cd);
    o.write_shift(2, 0);
    return bconcat([bconcat(out), bconcat(cdirs), o]);
  }
  var ContentTypeMap = {
    "htm": "text/html",
    "xml": "text/xml",
    "gif": "image/gif",
    "jpg": "image/jpeg",
    "png": "image/png",
    "mso": "application/x-mso",
    "thmx": "application/vnd.ms-officetheme",
    "sh33tj5": "application/octet-stream"
  };
  function get_content_type(fi, fp) {
    if (fi.ctype)
      return fi.ctype;
    var ext = fi.name || "", m = ext.match(/\.([^\.]+)$/);
    if (m && ContentTypeMap[m[1]])
      return ContentTypeMap[m[1]];
    if (fp) {
      m = (ext = fp).match(/[\.\\]([^\.\\])+$/);
      if (m && ContentTypeMap[m[1]])
        return ContentTypeMap[m[1]];
    }
    return "application/octet-stream";
  }
  function write_base64_76(bstr) {
    var data = Base64_encode(bstr);
    var o = [];
    for (var i2 = 0; i2 < data.length; i2 += 76)
      o.push(data.slice(i2, i2 + 76));
    return o.join("\r\n") + "\r\n";
  }
  function write_quoted_printable(text) {
    var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c) {
      var w2 = c.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (w2.length == 1 ? "0" + w2 : w2);
    });
    encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
    if (encoded.charAt(0) == "\n")
      encoded = "=0D" + encoded.slice(1);
    encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
    var o = [], split = encoded.split("\r\n");
    for (var si = 0; si < split.length; ++si) {
      var str = split[si];
      if (str.length == 0) {
        o.push("");
        continue;
      }
      for (var i2 = 0; i2 < str.length; ) {
        var end = 76;
        var tmp = str.slice(i2, i2 + end);
        if (tmp.charAt(end - 1) == "=")
          end--;
        else if (tmp.charAt(end - 2) == "=")
          end -= 2;
        else if (tmp.charAt(end - 3) == "=")
          end -= 3;
        tmp = str.slice(i2, i2 + end);
        i2 += end;
        if (i2 < str.length)
          tmp += "=";
        o.push(tmp);
      }
    }
    return o.join("\r\n");
  }
  function parse_quoted_printable(data) {
    var o = [];
    for (var di = 0; di < data.length; ++di) {
      var line2 = data[di];
      while (di <= data.length && line2.charAt(line2.length - 1) == "=")
        line2 = line2.slice(0, line2.length - 1) + data[++di];
      o.push(line2);
    }
    for (var oi = 0; oi < o.length; ++oi)
      o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) {
        return String.fromCharCode(parseInt($$.slice(1), 16));
      });
    return s2a(o.join("\r\n"));
  }
  function parse_mime(cfb, data, root2) {
    var fname = "", cte = "", ctype = "", fdata;
    var di = 0;
    for (; di < 10; ++di) {
      var line2 = data[di];
      if (!line2 || line2.match(/^\s*$/))
        break;
      var m = line2.match(/^(.*?):\s*([^\s].*)$/);
      if (m)
        switch (m[1].toLowerCase()) {
          case "content-location":
            fname = m[2].trim();
            break;
          case "content-type":
            ctype = m[2].trim();
            break;
          case "content-transfer-encoding":
            cte = m[2].trim();
            break;
        }
    }
    ++di;
    switch (cte.toLowerCase()) {
      case "base64":
        fdata = s2a(Base64_decode(data.slice(di).join("")));
        break;
      case "quoted-printable":
        fdata = parse_quoted_printable(data.slice(di));
        break;
      default:
        throw new Error("Unsupported Content-Transfer-Encoding " + cte);
    }
    var file = cfb_add(cfb, fname.slice(root2.length), fdata, { unsafe: true });
    if (ctype)
      file.ctype = ctype;
  }
  function parse_mad(file, options2) {
    if (a2s2(file.slice(0, 13)).toLowerCase() != "mime-version:")
      throw new Error("Unsupported MAD header");
    var root2 = options2 && options2.root || "";
    var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s2(file)).split("\r\n");
    var di = 0, row = "";
    for (di = 0; di < data.length; ++di) {
      row = data[di];
      if (!/^Content-Location:/i.test(row))
        continue;
      row = row.slice(row.indexOf("file"));
      if (!root2)
        root2 = row.slice(0, row.lastIndexOf("/") + 1);
      if (row.slice(0, root2.length) == root2)
        continue;
      while (root2.length > 0) {
        root2 = root2.slice(0, root2.length - 1);
        root2 = root2.slice(0, root2.lastIndexOf("/") + 1);
        if (row.slice(0, root2.length) == root2)
          break;
      }
    }
    var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
    if (!mboundary)
      throw new Error("MAD cannot find boundary");
    var boundary = "--" + (mboundary[1] || "");
    var FileIndex = [], FullPaths = [];
    var o = {
      FileIndex,
      FullPaths
    };
    init_cfb(o);
    var start_di, fcnt = 0;
    for (di = 0; di < data.length; ++di) {
      var line2 = data[di];
      if (line2 !== boundary && line2 !== boundary + "--")
        continue;
      if (fcnt++)
        parse_mime(o, data.slice(start_di, di), root2);
      start_di = di;
    }
    return o;
  }
  function write_mad(cfb, options2) {
    var opts = options2 || {};
    var boundary = opts.boundary || "SheetJS";
    boundary = "------=" + boundary;
    var out = [
      "MIME-Version: 1.0",
      'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',
      "",
      "",
      ""
    ];
    var root2 = cfb.FullPaths[0], fp = root2, fi = cfb.FileIndex[0];
    for (var i2 = 1; i2 < cfb.FullPaths.length; ++i2) {
      fp = cfb.FullPaths[i2].slice(root2.length);
      fi = cfb.FileIndex[i2];
      if (!fi.size || !fi.content || fp == "Sh33tJ5")
        continue;
      fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c) {
        return "_x" + c.charCodeAt(0).toString(16) + "_";
      }).replace(/[\u0080-\uFFFF]/g, function(u) {
        return "_u" + u.charCodeAt(0).toString(16) + "_";
      });
      var ca = fi.content;
      var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s2(ca);
      var dispcnt = 0, L = Math.min(1024, cstr.length), cc = 0;
      for (var csl = 0; csl <= L; ++csl)
        if ((cc = cstr.charCodeAt(csl)) >= 32 && cc < 128)
          ++dispcnt;
      var qp = dispcnt >= L * 4 / 5;
      out.push(boundary);
      out.push("Content-Location: " + (opts.root || "file:///C:/SheetJS/") + fp);
      out.push("Content-Transfer-Encoding: " + (qp ? "quoted-printable" : "base64"));
      out.push("Content-Type: " + get_content_type(fi, fp));
      out.push("");
      out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
    }
    out.push(boundary + "--\r\n");
    return out.join("\r\n");
  }
  function cfb_new(opts) {
    var o = {};
    init_cfb(o, opts);
    return o;
  }
  function cfb_add(cfb, name, content, opts) {
    var unsafe = opts && opts.unsafe;
    if (!unsafe)
      init_cfb(cfb);
    var file = !unsafe && CFB.find(cfb, name);
    if (!file) {
      var fpath = cfb.FullPaths[0];
      if (name.slice(0, fpath.length) == fpath)
        fpath = name;
      else {
        if (fpath.slice(-1) != "/")
          fpath += "/";
        fpath = (fpath + name).replace("//", "/");
      }
      file = { name: filename(name), type: 2 };
      cfb.FileIndex.push(file);
      cfb.FullPaths.push(fpath);
      if (!unsafe)
        CFB.utils.cfb_gc(cfb);
    }
    file.content = content;
    file.size = content ? content.length : 0;
    if (opts) {
      if (opts.CLSID)
        file.clsid = opts.CLSID;
      if (opts.mt)
        file.mt = opts.mt;
      if (opts.ct)
        file.ct = opts.ct;
    }
    return file;
  }
  function cfb_del(cfb, name) {
    init_cfb(cfb);
    var file = CFB.find(cfb, name);
    if (file) {
      for (var j = 0; j < cfb.FileIndex.length; ++j)
        if (cfb.FileIndex[j] == file) {
          cfb.FileIndex.splice(j, 1);
          cfb.FullPaths.splice(j, 1);
          return true;
        }
    }
    return false;
  }
  function cfb_mov(cfb, old_name, new_name) {
    init_cfb(cfb);
    var file = CFB.find(cfb, old_name);
    if (file) {
      for (var j = 0; j < cfb.FileIndex.length; ++j)
        if (cfb.FileIndex[j] == file) {
          cfb.FileIndex[j].name = filename(new_name);
          cfb.FullPaths[j] = new_name;
          return true;
        }
    }
    return false;
  }
  function cfb_gc(cfb) {
    rebuild_cfb(cfb, true);
  }
  exports2.find = find;
  exports2.read = read;
  exports2.parse = parse2;
  exports2.write = write;
  exports2.writeFile = write_file;
  exports2.utils = {
    cfb_new,
    cfb_add,
    cfb_del,
    cfb_mov,
    cfb_gc,
    ReadShift,
    CheckField,
    prep_blob,
    bconcat,
    use_zlib,
    _deflateRaw: _deflate,
    _inflateRaw: _inflate,
    consts
  };
  return exports2;
}();
var _fs;
function blobify(data) {
  if (typeof data === "string")
    return s2ab(data);
  if (Array.isArray(data))
    return a2u(data);
  return data;
}
function write_dl(fname, payload, enc) {
  if (typeof Deno !== "undefined") {
    if (enc && typeof payload == "string")
      switch (enc) {
        case "utf8":
          payload = new TextEncoder(enc).encode(payload);
          break;
        case "binary":
          payload = s2ab(payload);
          break;
        default:
          throw new Error("Unsupported encoding " + enc);
      }
    return Deno.writeFileSync(fname, payload);
  }
  var data = enc == "utf8" ? utf8write(payload) : payload;
  if (typeof IE_SaveFile !== "undefined")
    return IE_SaveFile(data, fname);
  if (typeof Blob !== "undefined") {
    var blob2 = new Blob([blobify(data)], { type: "application/octet-stream" });
    if (typeof navigator !== "undefined" && navigator.msSaveBlob)
      return navigator.msSaveBlob(blob2, fname);
    if (typeof saveAs !== "undefined")
      return saveAs(blob2, fname);
    if (typeof URL !== "undefined" && typeof document !== "undefined" && document.createElement && URL.createObjectURL) {
      var url = URL.createObjectURL(blob2);
      if (typeof chrome === "object" && typeof (chrome.downloads || {}).download == "function") {
        if (URL.revokeObjectURL && typeof setTimeout !== "undefined")
          setTimeout(function() {
            URL.revokeObjectURL(url);
          }, 6e4);
        return chrome.downloads.download({ url, filename: fname, saveAs: true });
      }
      var a = document.createElement("a");
      if (a.download != null) {
        a.download = fname;
        a.href = url;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        if (URL.revokeObjectURL && typeof setTimeout !== "undefined")
          setTimeout(function() {
            URL.revokeObjectURL(url);
          }, 6e4);
        return url;
      }
    }
  }
  if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined")
    try {
      var out = File(fname);
      out.open("w");
      out.encoding = "binary";
      if (Array.isArray(payload))
        payload = a2s(payload);
      out.write(payload);
      out.close();
      return payload;
    } catch (e) {
      if (!e.message || !e.message.match(/onstruct/))
        throw e;
    }
  throw new Error("cannot save file " + fname);
}
function read_binary(path) {
  if (typeof Deno !== "undefined")
    return Deno.readFileSync(path);
  if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined")
    try {
      var infile = File(path);
      infile.open("r");
      infile.encoding = "binary";
      var data = infile.read();
      infile.close();
      return data;
    } catch (e) {
      if (!e.message || !e.message.match(/onstruct/))
        throw e;
    }
  throw new Error("Cannot access file " + path);
}
function keys(o) {
  var ks = Object.keys(o), o2 = [];
  for (var i = 0; i < ks.length; ++i)
    if (Object.prototype.hasOwnProperty.call(o, ks[i]))
      o2.push(ks[i]);
  return o2;
}
function evert_key(obj, key) {
  var o = [], K = keys(obj);
  for (var i = 0; i !== K.length; ++i)
    if (o[obj[K[i]][key]] == null)
      o[obj[K[i]][key]] = K[i];
  return o;
}
function evert(obj) {
  var o = [], K = keys(obj);
  for (var i = 0; i !== K.length; ++i)
    o[obj[K[i]]] = K[i];
  return o;
}
function evert_num(obj) {
  var o = [], K = keys(obj);
  for (var i = 0; i !== K.length; ++i)
    o[obj[K[i]]] = parseInt(K[i], 10);
  return o;
}
function evert_arr(obj) {
  var o = [], K = keys(obj);
  for (var i = 0; i !== K.length; ++i) {
    if (o[obj[K[i]]] == null)
      o[obj[K[i]]] = [];
    o[obj[K[i]]].push(K[i]);
  }
  return o;
}
var basedate = /* @__PURE__ */ new Date(1899, 11, 30, 0, 0, 0);
function datenum(v, date1904) {
  var epoch = /* @__PURE__ */ v.getTime();
  if (date1904)
    epoch -= 1462 * 24 * 60 * 60 * 1e3;
  var dnthresh2 = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ v.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
  return (epoch - dnthresh2) / (24 * 60 * 60 * 1e3);
}
var refdate = /* @__PURE__ */ new Date();
var dnthresh = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ refdate.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
var refoffset = /* @__PURE__ */ refdate.getTimezoneOffset();
function numdate(v) {
  var out = /* @__PURE__ */ new Date();
  out.setTime(v * 24 * 60 * 60 * 1e3 + dnthresh);
  if (out.getTimezoneOffset() !== refoffset) {
    out.setTime(out.getTime() + (out.getTimezoneOffset() - refoffset) * 6e4);
  }
  return out;
}
function parse_isodur(s) {
  var sec = 0, mt = 0, time = false;
  var m = s.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
  if (!m)
    throw new Error("|" + s + "| is not an ISO8601 Duration");
  for (var i = 1; i != m.length; ++i) {
    if (!m[i])
      continue;
    mt = 1;
    if (i > 3)
      time = true;
    switch (m[i].slice(m[i].length - 1)) {
      case "Y":
        throw new Error("Unsupported ISO Duration Field: " + m[i].slice(m[i].length - 1));
      case "D":
        mt *= 24;
      case "H":
        mt *= 60;
      case "M":
        if (!time)
          throw new Error("Unsupported ISO Duration Field: M");
        else
          mt *= 60;
    }
    sec += mt * parseInt(m[i], 10);
  }
  return sec;
}
var good_pd_date_1 = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z");
var good_pd_date = /* @__PURE__ */ isNaN(/* @__PURE__ */ good_pd_date_1.getFullYear()) ? /* @__PURE__ */ new Date("2/19/17") : good_pd_date_1;
var good_pd = /* @__PURE__ */ good_pd_date.getFullYear() == 2017;
function parseDate(str, fixdate) {
  var d = new Date(str);
  if (good_pd) {
    if (fixdate > 0)
      d.setTime(d.getTime() + d.getTimezoneOffset() * 60 * 1e3);
    else if (fixdate < 0)
      d.setTime(d.getTime() - d.getTimezoneOffset() * 60 * 1e3);
    return d;
  }
  if (str instanceof Date)
    return str;
  if (good_pd_date.getFullYear() == 1917 && !isNaN(d.getFullYear())) {
    var s = d.getFullYear();
    if (str.indexOf("" + s) > -1)
      return d;
    d.setFullYear(d.getFullYear() + 100);
    return d;
  }
  var n = str.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"];
  var out = new Date(+n[0], +n[1] - 1, +n[2], +n[3] || 0, +n[4] || 0, +n[5] || 0);
  if (str.indexOf("Z") > -1)
    out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1e3);
  return out;
}
function cc2str(arr, debomit) {
  if (has_buf && Buffer.isBuffer(arr)) {
    if (debomit && buf_utf16le) {
      if (arr[0] == 255 && arr[1] == 254)
        return utf8write(arr.slice(2).toString("utf16le"));
      if (arr[1] == 254 && arr[2] == 255)
        return utf8write(utf16beread(arr.slice(2).toString("binary")));
    }
    return arr.toString("binary");
  }
  if (typeof TextDecoder !== "undefined")
    try {
      if (debomit) {
        if (arr[0] == 255 && arr[1] == 254)
          return utf8write(new TextDecoder("utf-16le").decode(arr.slice(2)));
        if (arr[0] == 254 && arr[1] == 255)
          return utf8write(new TextDecoder("utf-16be").decode(arr.slice(2)));
      }
      var rev = {
        "€": "",
        "‚": "",
        "ƒ": "",
        "„": "",
        "…": "",
        "†": "",
        "‡": "",
        "ˆ": "",
        "‰": "",
        "Š": "",
        "‹": "",
        "Œ": "",
        "Ž": "",
        "‘": "",
        "’": "",
        "“": "",
        "”": "",
        "•": "",
        "–": "",
        "—": "",
        "˜": "",
        "™": "",
        "š": "",
        "›": "",
        "œ": "",
        "ž": "",
        "Ÿ": ""
      };
      if (Array.isArray(arr))
        arr = new Uint8Array(arr);
      return new TextDecoder("latin1").decode(arr).replace(/[€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ]/g, function(c) {
        return rev[c] || c;
      });
    } catch (e) {
    }
  var o = [];
  for (var i = 0; i != arr.length; ++i)
    o.push(String.fromCharCode(arr[i]));
  return o.join("");
}
function dup(o) {
  if (typeof JSON != "undefined" && !Array.isArray(o))
    return JSON.parse(JSON.stringify(o));
  if (typeof o != "object" || o == null)
    return o;
  if (o instanceof Date)
    return new Date(o.getTime());
  var out = {};
  for (var k in o)
    if (Object.prototype.hasOwnProperty.call(o, k))
      out[k] = dup(o[k]);
  return out;
}
function fill(c, l) {
  var o = "";
  while (o.length < l)
    o += c;
  return o;
}
function fuzzynum(s) {
  var v = Number(s);
  if (!isNaN(v))
    return isFinite(v) ? v : NaN;
  if (!/\d/.test(s))
    return v;
  var wt = 1;
  var ss = s.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
    wt *= 100;
    return "";
  });
  if (!isNaN(v = Number(ss)))
    return v / wt;
  ss = ss.replace(/[(](.*)[)]/, function($$, $1) {
    wt = -wt;
    return $1;
  });
  if (!isNaN(v = Number(ss)))
    return v / wt;
  return v;
}
var FDRE1 = /^(0?\d|1[0-2])(?:|:([0-5]?\d)(?:|(\.\d+)(?:|:([0-5]?\d))|:([0-5]?\d)(|\.\d+)))\s+([ap])m?$/;
function fuzzytime1(M) {
  if (!M[2])
    return new Date(1899, 11, 30, +M[1] % 12 + (M[7] == "p" ? 12 : 0), 0, 0, 0);
  if (M[3]) {
    if (M[4])
      return new Date(1899, 11, 30, +M[1] % 12 + (M[7] == "p" ? 12 : 0), +M[2], +M[4], parseFloat(M[3]) * 1e3);
    else
      return new Date(1899, 11, 30, M[7] == "p" ? 12 : 0, +M[1], +M[2], parseFloat(M[3]) * 1e3);
  } else if (M[5])
    return new Date(1899, 11, 30, +M[1] % 12 + (M[7] == "p" ? 12 : 0), +M[2], +M[5], M[6] ? parseFloat(M[6]) * 1e3 : 0);
  else
    return new Date(1899, 11, 30, +M[1] % 12 + (M[7] == "p" ? 12 : 0), +M[2], 0, 0);
}
var lower_months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function fuzzydate(s) {
  var lower = s.toLowerCase();
  var lnos = lower.replace(/\s+/g, " ").trim();
  var M = lnos.match(FDRE1);
  if (M)
    return fuzzytime1(M);
  var o = new Date(s), n = /* @__PURE__ */ new Date(NaN);
  var y = o.getYear();
  o.getMonth();
  var d = o.getDate();
  if (isNaN(d))
    return n;
  if (lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    lower = lower.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, "");
    if (lower.length > 3 && lower_months.indexOf(lower) == -1)
      return n;
  } else if (lower.replace(/[ap]m?/, "").match(/[a-z]/))
    return n;
  if (y < 0 || y > 8099 || s.match(/[^-0-9:,\/\\]/))
    return n;
  return o;
}
var split_regex = /* @__PURE__ */ function() {
  var safe_split_regex = "abacaba".split(/(:?b)/i).length == 5;
  return function split_regex2(str, re, def) {
    if (safe_split_regex || typeof re == "string")
      return str.split(re);
    var p = str.split(re), o = [p[0]];
    for (var i = 1; i < p.length; ++i) {
      o.push(def);
      o.push(p[i]);
    }
    return o;
  };
}();
function getdatastr(data) {
  if (!data)
    return null;
  if (data.content && data.type)
    return cc2str(data.content, true);
  if (data.data)
    return debom(data.data);
  if (data.asNodeBuffer && has_buf)
    return debom(data.asNodeBuffer().toString("binary"));
  if (data.asBinary)
    return debom(data.asBinary());
  if (data._data && data._data.getContent)
    return debom(cc2str(Array.prototype.slice.call(data._data.getContent(), 0)));
  return null;
}
function getdatabin(data) {
  if (!data)
    return null;
  if (data.data)
    return char_codes(data.data);
  if (data.asNodeBuffer && has_buf)
    return data.asNodeBuffer();
  if (data._data && data._data.getContent) {
    var o = data._data.getContent();
    if (typeof o == "string")
      return char_codes(o);
    return Array.prototype.slice.call(o);
  }
  if (data.content && data.type)
    return data.content;
  return null;
}
function getdata(data) {
  return data && data.name.slice(-4) === ".bin" ? getdatabin(data) : getdatastr(data);
}
function safegetzipfile(zip, file) {
  var k = zip.FullPaths || keys(zip.files);
  var f = file.toLowerCase().replace(/[\/]/g, "\\"), g = f.replace(/\\/g, "/");
  for (var i = 0; i < k.length; ++i) {
    var n = k[i].replace(/^Root Entry[\/]/, "").toLowerCase();
    if (f == n || g == n)
      return zip.files ? zip.files[k[i]] : zip.FileIndex[i];
  }
  return null;
}
function getzipfile(zip, file) {
  var o = safegetzipfile(zip, file);
  if (o == null)
    throw new Error("Cannot find file " + file + " in zip");
  return o;
}
function getzipdata(zip, file, safe) {
  if (!safe)
    return getdata(getzipfile(zip, file));
  if (!file)
    return null;
  try {
    return getzipdata(zip, file);
  } catch (e) {
    return null;
  }
}
function getzipstr(zip, file, safe) {
  if (!safe)
    return getdatastr(getzipfile(zip, file));
  if (!file)
    return null;
  try {
    return getzipstr(zip, file);
  } catch (e) {
    return null;
  }
}
function getzipbin(zip, file, safe) {
  if (!safe)
    return getdatabin(getzipfile(zip, file));
  if (!file)
    return null;
  try {
    return getzipbin(zip, file);
  } catch (e) {
    return null;
  }
}
function zipentries(zip) {
  var k = zip.FullPaths || keys(zip.files), o = [];
  for (var i = 0; i < k.length; ++i)
    if (k[i].slice(-1) != "/")
      o.push(k[i].replace(/^Root Entry[\/]/, ""));
  return o.sort();
}
function zip_add_file(zip, path, content) {
  if (zip.FullPaths) {
    if (typeof content == "string") {
      var res;
      if (has_buf)
        res = Buffer_from(content);
      else
        res = utf8decode(content);
      return CFB.utils.cfb_add(zip, path, res);
    }
    CFB.utils.cfb_add(zip, path, content);
  } else
    zip.file(path, content);
}
function zip_new() {
  return CFB.utils.cfb_new();
}
function zip_read(d, o) {
  switch (o.type) {
    case "base64":
      return CFB.read(d, { type: "base64" });
    case "binary":
      return CFB.read(d, { type: "binary" });
    case "buffer":
    case "array":
      return CFB.read(d, { type: "buffer" });
  }
  throw new Error("Unrecognized type " + o.type);
}
function resolve_path(path, base) {
  if (path.charAt(0) == "/")
    return path.slice(1);
  var result = base.split("/");
  if (base.slice(-1) != "/")
    result.pop();
  var target = path.split("/");
  while (target.length !== 0) {
    var step = target.shift();
    if (step === "..")
      result.pop();
    else if (step !== ".")
      result.push(step);
  }
  return result.join("/");
}
var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
var attregexg = /([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g;
var tagregex1 = /<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'">\s=]+))*\s*[\/\?]?>/mg, tagregex2 = /<[^>]*>/g;
var tagregex = /* @__PURE__ */ XML_HEADER.match(tagregex1) ? tagregex1 : tagregex2;
var nsregex = /<\w*:/, nsregex2 = /<(\/?)\w+:/;
function parsexmltag(tag, skip_root, skip_LC) {
  var z = {};
  var eq = 0, c = 0;
  for (; eq !== tag.length; ++eq)
    if ((c = tag.charCodeAt(eq)) === 32 || c === 10 || c === 13)
      break;
  if (!skip_root)
    z[0] = tag.slice(0, eq);
  if (eq === tag.length)
    return z;
  var m = tag.match(attregexg), j = 0, v = "", i = 0, q = "", cc = "", quot = 1;
  if (m)
    for (i = 0; i != m.length; ++i) {
      cc = m[i];
      for (c = 0; c != cc.length; ++c)
        if (cc.charCodeAt(c) === 61)
          break;
      q = cc.slice(0, c).trim();
      while (cc.charCodeAt(c + 1) == 32)
        ++c;
      quot = (eq = cc.charCodeAt(c + 1)) == 34 || eq == 39 ? 1 : 0;
      v = cc.slice(c + 1 + quot, cc.length - quot);
      for (j = 0; j != q.length; ++j)
        if (q.charCodeAt(j) === 58)
          break;
      if (j === q.length) {
        if (q.indexOf("_") > 0)
          q = q.slice(0, q.indexOf("_"));
        z[q] = v;
        if (!skip_LC)
          z[q.toLowerCase()] = v;
      } else {
        var k = (j === 5 && q.slice(0, 5) === "xmlns" ? "xmlns" : "") + q.slice(j + 1);
        if (z[k] && q.slice(j - 3, j) == "ext")
          continue;
        z[k] = v;
        if (!skip_LC)
          z[k.toLowerCase()] = v;
      }
    }
  return z;
}
function strip_ns(x) {
  return x.replace(nsregex2, "<$1");
}
var encodings = {
  "&quot;": '"',
  "&apos;": "'",
  "&gt;": ">",
  "&lt;": "<",
  "&amp;": "&"
};
var rencoding = /* @__PURE__ */ evert(encodings);
var unescapexml = /* @__PURE__ */ function() {
  var encregex = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, coderegex = /_x([\da-fA-F]{4})_/ig;
  function raw_unescapexml(text) {
    var s = text + "", i = s.indexOf("<![CDATA[");
    if (i == -1)
      return s.replace(encregex, function($$, $1) {
        return encodings[$$] || String.fromCharCode(parseInt($1, $$.indexOf("x") > -1 ? 16 : 10)) || $$;
      }).replace(coderegex, function(m, c) {
        return String.fromCharCode(parseInt(c, 16));
      });
    var j = s.indexOf("]]>");
    return raw_unescapexml(s.slice(0, i)) + s.slice(i + 9, j) + raw_unescapexml(s.slice(j + 3));
  }
  return function unescapexml2(text, xlsx) {
    var out = raw_unescapexml(text);
    return xlsx ? out.replace(/\r\n/g, "\n") : out;
  };
}();
var decregex = /[&<>'"]/g, charegex = /[\u0000-\u0008\u000b-\u001f\uFFFE-\uFFFF]/g;
function escapexml(text) {
  var s = text + "";
  return s.replace(decregex, function(y) {
    return rencoding[y];
  }).replace(charegex, function(s2) {
    return "_x" + ("000" + s2.charCodeAt(0).toString(16)).slice(-4) + "_";
  });
}
function escapexmltag(text) {
  return escapexml(text).replace(/ /g, "_x0020_");
}
var htmlcharegex = /[\u0000-\u001f]/g;
function escapehtml(text) {
  var s = text + "";
  return s.replace(decregex, function(y) {
    return rencoding[y];
  }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(s2) {
    return "&#x" + ("000" + s2.charCodeAt(0).toString(16)).slice(-4) + ";";
  });
}
function escapexlml(text) {
  var s = text + "";
  return s.replace(decregex, function(y) {
    return rencoding[y];
  }).replace(htmlcharegex, function(s2) {
    return "&#x" + s2.charCodeAt(0).toString(16).toUpperCase() + ";";
  });
}
var xlml_fixstr = /* @__PURE__ */ function() {
  var entregex = /&#(\d+);/g;
  function entrepl($$, $1) {
    return String.fromCharCode(parseInt($1, 10));
  }
  return function xlml_fixstr2(str) {
    return str.replace(entregex, entrepl);
  };
}();
function xlml_unfixstr(str) {
  return str.replace(/(\r\n|[\r\n])/g, "&#10;");
}
function parsexmlbool(value) {
  switch (value) {
    case 1:
    case true:
    case "1":
    case "true":
      return true;
    case 0:
    case false:
    case "0":
    case "false":
      return false;
  }
  return false;
}
function utf8reada(orig) {
  var out = "", i = 0, c = 0, d = 0, e = 0, f = 0, w2 = 0;
  while (i < orig.length) {
    c = orig.charCodeAt(i++);
    if (c < 128) {
      out += String.fromCharCode(c);
      continue;
    }
    d = orig.charCodeAt(i++);
    if (c > 191 && c < 224) {
      f = (c & 31) << 6;
      f |= d & 63;
      out += String.fromCharCode(f);
      continue;
    }
    e = orig.charCodeAt(i++);
    if (c < 240) {
      out += String.fromCharCode((c & 15) << 12 | (d & 63) << 6 | e & 63);
      continue;
    }
    f = orig.charCodeAt(i++);
    w2 = ((c & 7) << 18 | (d & 63) << 12 | (e & 63) << 6 | f & 63) - 65536;
    out += String.fromCharCode(55296 + (w2 >>> 10 & 1023));
    out += String.fromCharCode(56320 + (w2 & 1023));
  }
  return out;
}
function utf8readb(data) {
  var out = new_raw_buf(2 * data.length), w2, i, j = 1, k = 0, ww = 0, c;
  for (i = 0; i < data.length; i += j) {
    j = 1;
    if ((c = data.charCodeAt(i)) < 128)
      w2 = c;
    else if (c < 224) {
      w2 = (c & 31) * 64 + (data.charCodeAt(i + 1) & 63);
      j = 2;
    } else if (c < 240) {
      w2 = (c & 15) * 4096 + (data.charCodeAt(i + 1) & 63) * 64 + (data.charCodeAt(i + 2) & 63);
      j = 3;
    } else {
      j = 4;
      w2 = (c & 7) * 262144 + (data.charCodeAt(i + 1) & 63) * 4096 + (data.charCodeAt(i + 2) & 63) * 64 + (data.charCodeAt(i + 3) & 63);
      w2 -= 65536;
      ww = 55296 + (w2 >>> 10 & 1023);
      w2 = 56320 + (w2 & 1023);
    }
    if (ww !== 0) {
      out[k++] = ww & 255;
      out[k++] = ww >>> 8;
      ww = 0;
    }
    out[k++] = w2 % 256;
    out[k++] = w2 >>> 8;
  }
  return out.slice(0, k).toString("ucs2");
}
function utf8readc(data) {
  return Buffer_from(data, "binary").toString("utf8");
}
var utf8corpus = "foo bar bazâð£";
var utf8read = has_buf && (/* @__PURE__ */ utf8readc(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readc || /* @__PURE__ */ utf8readb(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readb) || utf8reada;
var utf8write = has_buf ? function(data) {
  return Buffer_from(data, "utf8").toString("binary");
} : function(orig) {
  var out = [], i = 0, c = 0, d = 0;
  while (i < orig.length) {
    c = orig.charCodeAt(i++);
    switch (true) {
      case c < 128:
        out.push(String.fromCharCode(c));
        break;
      case c < 2048:
        out.push(String.fromCharCode(192 + (c >> 6)));
        out.push(String.fromCharCode(128 + (c & 63)));
        break;
      case (c >= 55296 && c < 57344):
        c -= 55296;
        d = orig.charCodeAt(i++) - 56320 + (c << 10);
        out.push(String.fromCharCode(240 + (d >> 18 & 7)));
        out.push(String.fromCharCode(144 + (d >> 12 & 63)));
        out.push(String.fromCharCode(128 + (d >> 6 & 63)));
        out.push(String.fromCharCode(128 + (d & 63)));
        break;
      default:
        out.push(String.fromCharCode(224 + (c >> 12)));
        out.push(String.fromCharCode(128 + (c >> 6 & 63)));
        out.push(String.fromCharCode(128 + (c & 63)));
    }
  }
  return out.join("");
};
var matchtag = /* @__PURE__ */ function() {
  var mtcache = {};
  return function matchtag2(f, g) {
    var t = f + "|" + (g || "");
    if (mtcache[t])
      return mtcache[t];
    return mtcache[t] = new RegExp("<(?:\\w+:)?" + f + '(?: xml:space="preserve")?(?:[^>]*)>([\\s\\S]*?)</(?:\\w+:)?' + f + ">", g || "");
  };
}();
var htmldecode = /* @__PURE__ */ function() {
  var entities = [
    ["nbsp", " "],
    ["middot", "·"],
    ["quot", '"'],
    ["apos", "'"],
    ["gt", ">"],
    ["lt", "<"],
    ["amp", "&"]
  ].map(function(x) {
    return [new RegExp("&" + x[0] + ";", "ig"), x[1]];
  });
  return function htmldecode2(str) {
    var o = str.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, "\n").replace(/<[^>]*>/g, "");
    for (var i = 0; i < entities.length; ++i)
      o = o.replace(entities[i][0], entities[i][1]);
    return o;
  };
}();
var vtregex = /* @__PURE__ */ function() {
  var vt_cache = {};
  return function vt_regex(bt) {
    if (vt_cache[bt] !== void 0)
      return vt_cache[bt];
    return vt_cache[bt] = new RegExp("<(?:vt:)?" + bt + ">([\\s\\S]*?)</(?:vt:)?" + bt + ">", "g");
  };
}();
var vtvregex = /<\/?(?:vt:)?variant>/g, vtmregex = /<(?:vt:)([^>]*)>([\s\S]*)</;
function parseVector(data, opts) {
  var h = parsexmltag(data);
  var matches = data.match(vtregex(h.baseType)) || [];
  var res = [];
  if (matches.length != h.size) {
    if (opts.WTF)
      throw new Error("unexpected vector length " + matches.length + " != " + h.size);
    return res;
  }
  matches.forEach(function(x) {
    var v = x.replace(vtvregex, "").match(vtmregex);
    if (v)
      res.push({ v: utf8read(v[2]), t: v[1] });
  });
  return res;
}
var wtregex = /(^\s|\s$|\n)/;
function writetag(f, g) {
  return "<" + f + (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f + ">";
}
function wxt_helper(h) {
  return keys(h).map(function(k) {
    return " " + k + '="' + h[k] + '"';
  }).join("");
}
function writextag(f, g, h) {
  return "<" + f + (h != null ? wxt_helper(h) : "") + (g != null ? (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f : "/") + ">";
}
function write_w3cdtf(d, t) {
  try {
    return d.toISOString().replace(/\.\d*/, "");
  } catch (e) {
    if (t)
      throw e;
  }
  return "";
}
function write_vt(s, xlsx) {
  switch (typeof s) {
    case "string":
      var o = writextag("vt:lpwstr", escapexml(s));
      if (xlsx)
        o = o.replace(/&quot;/g, "_x0022_");
      return o;
    case "number":
      return writextag((s | 0) == s ? "vt:i4" : "vt:r8", escapexml(String(s)));
    case "boolean":
      return writextag("vt:bool", s ? "true" : "false");
  }
  if (s instanceof Date)
    return writextag("vt:filetime", write_w3cdtf(s));
  throw new Error("Unable to serialize " + s);
}
function xlml_normalize(d) {
  if (has_buf && /*::typeof Buffer !== "undefined" && d != null && d instanceof Buffer &&*/
  Buffer.isBuffer(d))
    return d.toString("utf8");
  if (typeof d === "string")
    return d;
  if (typeof Uint8Array !== "undefined" && d instanceof Uint8Array)
    return utf8read(a2s(ab2a(d)));
  throw new Error("Bad input format: expected Buffer or string");
}
var xlmlregex = /<(\/?)([^\s?><!\/:]*:|)([^\s?<>:\/]+)(?:[\s?:\/](?:[^>=]|="[^"]*?")*)?>/mg;
var XMLNS = {
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
  CT: "http://schemas.openxmlformats.org/package/2006/content-types",
  RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
  TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
  "dc": "http://purl.org/dc/elements/1.1/",
  "dcterms": "http://purl.org/dc/terms/",
  "dcmitype": "http://purl.org/dc/dcmitype/",
  "mx": "http://schemas.microsoft.com/office/mac/excel/2008/main",
  "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  "sjs": "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
  "vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
  "xsi": "http://www.w3.org/2001/XMLSchema-instance",
  "xsd": "http://www.w3.org/2001/XMLSchema"
};
var XMLNS_main = [
  "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "http://purl.oclc.org/ooxml/spreadsheetml/main",
  "http://schemas.microsoft.com/office/excel/2006/main",
  "http://schemas.microsoft.com/office/excel/2006/2"
];
var XLMLNS = {
  "o": "urn:schemas-microsoft-com:office:office",
  "x": "urn:schemas-microsoft-com:office:excel",
  "ss": "urn:schemas-microsoft-com:office:spreadsheet",
  "dt": "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
  "mv": "http://macVmlSchemaUri",
  "v": "urn:schemas-microsoft-com:vml",
  "html": "http://www.w3.org/TR/REC-html40"
};
function read_double_le(b, idx) {
  var s = 1 - 2 * (b[idx + 7] >>> 7);
  var e = ((b[idx + 7] & 127) << 4) + (b[idx + 6] >>> 4 & 15);
  var m = b[idx + 6] & 15;
  for (var i = 5; i >= 0; --i)
    m = m * 256 + b[idx + i];
  if (e == 2047)
    return m == 0 ? s * Infinity : NaN;
  if (e == 0)
    e = -1022;
  else {
    e -= 1023;
    m += Math.pow(2, 52);
  }
  return s * Math.pow(2, e - 52) * m;
}
function write_double_le(b, v, idx) {
  var bs = (v < 0 || 1 / v == -Infinity ? 1 : 0) << 7, e = 0, m = 0;
  var av = bs ? -v : v;
  if (!isFinite(av)) {
    e = 2047;
    m = isNaN(v) ? 26985 : 0;
  } else if (av == 0)
    e = m = 0;
  else {
    e = Math.floor(Math.log(av) / Math.LN2);
    m = av * Math.pow(2, 52 - e);
    if (e <= -1023 && (!isFinite(m) || m < Math.pow(2, 52))) {
      e = -1022;
    } else {
      m -= Math.pow(2, 52);
      e += 1023;
    }
  }
  for (var i = 0; i <= 5; ++i, m /= 256)
    b[idx + i] = m & 255;
  b[idx + 6] = (e & 15) << 4 | m & 15;
  b[idx + 7] = e >> 4 | bs;
}
var ___toBuffer = function(bufs) {
  var x = [], w2 = 10240;
  for (var i = 0; i < bufs[0].length; ++i)
    if (bufs[0][i])
      for (var j = 0, L = bufs[0][i].length; j < L; j += w2)
        x.push.apply(x, bufs[0][i].slice(j, j + w2));
  return x;
};
var __toBuffer = has_buf ? function(bufs) {
  return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0].map(function(x) {
    return Buffer.isBuffer(x) ? x : Buffer_from(x);
  })) : ___toBuffer(bufs);
} : ___toBuffer;
var ___utf16le = function(b, s, e) {
  var ss = [];
  for (var i = s; i < e; i += 2)
    ss.push(String.fromCharCode(__readUInt16LE(b, i)));
  return ss.join("").replace(chr0, "");
};
var __utf16le = has_buf ? function(b, s, e) {
  if (!Buffer.isBuffer(b) || !buf_utf16le)
    return ___utf16le(b, s, e);
  return b.toString("utf16le", s, e).replace(chr0, "");
} : ___utf16le;
var ___hexlify = function(b, s, l) {
  var ss = [];
  for (var i = s; i < s + l; ++i)
    ss.push(("0" + b[i].toString(16)).slice(-2));
  return ss.join("");
};
var __hexlify = has_buf ? function(b, s, l) {
  return Buffer.isBuffer(b) ? b.toString("hex", s, s + l) : ___hexlify(b, s, l);
} : ___hexlify;
var ___utf8 = function(b, s, e) {
  var ss = [];
  for (var i = s; i < e; i++)
    ss.push(String.fromCharCode(__readUInt8(b, i)));
  return ss.join("");
};
var __utf8 = has_buf ? function utf8_b(b, s, e) {
  return Buffer.isBuffer(b) ? b.toString("utf8", s, e) : ___utf8(b, s, e);
} : ___utf8;
var ___lpstr = function(b, i) {
  var len = __readUInt32LE(b, i);
  return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
};
var __lpstr = ___lpstr;
var ___cpstr = function(b, i) {
  var len = __readUInt32LE(b, i);
  return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
};
var __cpstr = ___cpstr;
var ___lpwstr = function(b, i) {
  var len = 2 * __readUInt32LE(b, i);
  return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : "";
};
var __lpwstr = ___lpwstr;
var ___lpp4 = function lpp4_(b, i) {
  var len = __readUInt32LE(b, i);
  return len > 0 ? __utf16le(b, i + 4, i + 4 + len) : "";
};
var __lpp4 = ___lpp4;
var ___8lpp4 = function(b, i) {
  var len = __readUInt32LE(b, i);
  return len > 0 ? __utf8(b, i + 4, i + 4 + len) : "";
};
var __8lpp4 = ___8lpp4;
var ___double = function(b, idx) {
  return read_double_le(b, idx);
};
var __double = ___double;
var is_buf = function is_buf_a(a) {
  return Array.isArray(a) || typeof Uint8Array !== "undefined" && a instanceof Uint8Array;
};
if (has_buf) {
  __lpstr = function lpstr_b(b, i) {
    if (!Buffer.isBuffer(b))
      return ___lpstr(b, i);
    var len = b.readUInt32LE(i);
    return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
  };
  __cpstr = function cpstr_b(b, i) {
    if (!Buffer.isBuffer(b))
      return ___cpstr(b, i);
    var len = b.readUInt32LE(i);
    return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : "";
  };
  __lpwstr = function lpwstr_b(b, i) {
    if (!Buffer.isBuffer(b) || !buf_utf16le)
      return ___lpwstr(b, i);
    var len = 2 * b.readUInt32LE(i);
    return b.toString("utf16le", i + 4, i + 4 + len - 1);
  };
  __lpp4 = function lpp4_b(b, i) {
    if (!Buffer.isBuffer(b) || !buf_utf16le)
      return ___lpp4(b, i);
    var len = b.readUInt32LE(i);
    return b.toString("utf16le", i + 4, i + 4 + len);
  };
  __8lpp4 = function lpp4_8b(b, i) {
    if (!Buffer.isBuffer(b))
      return ___8lpp4(b, i);
    var len = b.readUInt32LE(i);
    return b.toString("utf8", i + 4, i + 4 + len);
  };
  __double = function double_(b, i) {
    if (Buffer.isBuffer(b))
      return b.readDoubleLE(i);
    return ___double(b, i);
  };
  is_buf = function is_buf_b(a) {
    return Buffer.isBuffer(a) || Array.isArray(a) || typeof Uint8Array !== "undefined" && a instanceof Uint8Array;
  };
}
var __readUInt8 = function(b, idx) {
  return b[idx];
};
var __readUInt16LE = function(b, idx) {
  return b[idx + 1] * (1 << 8) + b[idx];
};
var __readInt16LE = function(b, idx) {
  var u = b[idx + 1] * (1 << 8) + b[idx];
  return u < 32768 ? u : (65535 - u + 1) * -1;
};
var __readUInt32LE = function(b, idx) {
  return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];
};
var __readInt32LE = function(b, idx) {
  return b[idx + 3] << 24 | b[idx + 2] << 16 | b[idx + 1] << 8 | b[idx];
};
var __readInt32BE = function(b, idx) {
  return b[idx] << 24 | b[idx + 1] << 16 | b[idx + 2] << 8 | b[idx + 3];
};
function ReadShift(size, t) {
  var o = "", oI, oR, oo = [], w2, vv, i, loc;
  switch (t) {
    case "dbcs":
      loc = this.l;
      if (has_buf && Buffer.isBuffer(this) && buf_utf16le)
        o = this.slice(this.l, this.l + 2 * size).toString("utf16le");
      else
        for (i = 0; i < size; ++i) {
          o += String.fromCharCode(__readUInt16LE(this, loc));
          loc += 2;
        }
      size *= 2;
      break;
    case "utf8":
      o = __utf8(this, this.l, this.l + size);
      break;
    case "utf16le":
      size *= 2;
      o = __utf16le(this, this.l, this.l + size);
      break;
    case "wstr":
      return ReadShift.call(this, size, "dbcs");
    case "lpstr-ansi":
      o = __lpstr(this, this.l);
      size = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpstr-cp":
      o = __cpstr(this, this.l);
      size = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpwstr":
      o = __lpwstr(this, this.l);
      size = 4 + 2 * __readUInt32LE(this, this.l);
      break;
    case "lpp4":
      size = 4 + __readUInt32LE(this, this.l);
      o = __lpp4(this, this.l);
      if (size & 2)
        size += 2;
      break;
    case "8lpp4":
      size = 4 + __readUInt32LE(this, this.l);
      o = __8lpp4(this, this.l);
      if (size & 3)
        size += 4 - (size & 3);
      break;
    case "cstr":
      size = 0;
      o = "";
      while ((w2 = __readUInt8(this, this.l + size++)) !== 0)
        oo.push(_getchar(w2));
      o = oo.join("");
      break;
    case "_wstr":
      size = 0;
      o = "";
      while ((w2 = __readUInt16LE(this, this.l + size)) !== 0) {
        oo.push(_getchar(w2));
        size += 2;
      }
      size += 2;
      o = oo.join("");
      break;
    case "dbcs-cont":
      o = "";
      loc = this.l;
      for (i = 0; i < size; ++i) {
        if (this.lens && this.lens.indexOf(loc) !== -1) {
          w2 = __readUInt8(this, loc);
          this.l = loc + 1;
          vv = ReadShift.call(this, size - i, w2 ? "dbcs-cont" : "sbcs-cont");
          return oo.join("") + vv;
        }
        oo.push(_getchar(__readUInt16LE(this, loc)));
        loc += 2;
      }
      o = oo.join("");
      size *= 2;
      break;
    case "cpstr":
    case "sbcs-cont":
      o = "";
      loc = this.l;
      for (i = 0; i != size; ++i) {
        if (this.lens && this.lens.indexOf(loc) !== -1) {
          w2 = __readUInt8(this, loc);
          this.l = loc + 1;
          vv = ReadShift.call(this, size - i, w2 ? "dbcs-cont" : "sbcs-cont");
          return oo.join("") + vv;
        }
        oo.push(_getchar(__readUInt8(this, loc)));
        loc += 1;
      }
      o = oo.join("");
      break;
    default:
      switch (size) {
        case 1:
          oI = __readUInt8(this, this.l);
          this.l++;
          return oI;
        case 2:
          oI = (t === "i" ? __readInt16LE : __readUInt16LE)(this, this.l);
          this.l += 2;
          return oI;
        case 4:
        case -4:
          if (t === "i" || (this[this.l + 3] & 128) === 0) {
            oI = (size > 0 ? __readInt32LE : __readInt32BE)(this, this.l);
            this.l += 4;
            return oI;
          } else {
            oR = __readUInt32LE(this, this.l);
            this.l += 4;
          }
          return oR;
        case 8:
        case -8:
          if (t === "f") {
            if (size == 8)
              oR = __double(this, this.l);
            else
              oR = __double([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0);
            this.l += 8;
            return oR;
          } else
            size = 8;
        case 16:
          o = __hexlify(this, this.l, size);
          break;
      }
  }
  this.l += size;
  return o;
}
var __writeUInt32LE = function(b, val, idx) {
  b[idx] = val & 255;
  b[idx + 1] = val >>> 8 & 255;
  b[idx + 2] = val >>> 16 & 255;
  b[idx + 3] = val >>> 24 & 255;
};
var __writeInt32LE = function(b, val, idx) {
  b[idx] = val & 255;
  b[idx + 1] = val >> 8 & 255;
  b[idx + 2] = val >> 16 & 255;
  b[idx + 3] = val >> 24 & 255;
};
var __writeUInt16LE = function(b, val, idx) {
  b[idx] = val & 255;
  b[idx + 1] = val >>> 8 & 255;
};
function WriteShift(t, val, f) {
  var size = 0, i = 0;
  if (f === "dbcs") {
    for (i = 0; i != val.length; ++i)
      __writeUInt16LE(this, val.charCodeAt(i), this.l + 2 * i);
    size = 2 * val.length;
  } else if (f === "sbcs" || f == "cpstr") {
    {
      val = val.replace(/[^\x00-\x7F]/g, "_");
      for (i = 0; i != val.length; ++i)
        this[this.l + i] = val.charCodeAt(i) & 255;
      size = val.length;
    }
  } else if (f === "hex") {
    for (; i < t; ++i) {
      this[this.l++] = parseInt(val.slice(2 * i, 2 * i + 2), 16) || 0;
    }
    return this;
  } else if (f === "utf16le") {
    var end = Math.min(this.l + t, this.length);
    for (i = 0; i < Math.min(val.length, t); ++i) {
      var cc = val.charCodeAt(i);
      this[this.l++] = cc & 255;
      this[this.l++] = cc >> 8;
    }
    while (this.l < end)
      this[this.l++] = 0;
    return this;
  } else
    switch (t) {
      case 1:
        size = 1;
        this[this.l] = val & 255;
        break;
      case 2:
        size = 2;
        this[this.l] = val & 255;
        val >>>= 8;
        this[this.l + 1] = val & 255;
        break;
      case 3:
        size = 3;
        this[this.l] = val & 255;
        val >>>= 8;
        this[this.l + 1] = val & 255;
        val >>>= 8;
        this[this.l + 2] = val & 255;
        break;
      case 4:
        size = 4;
        __writeUInt32LE(this, val, this.l);
        break;
      case 8:
        size = 8;
        if (f === "f") {
          write_double_le(this, val, this.l);
          break;
        }
      case 16:
        break;
      case -4:
        size = 4;
        __writeInt32LE(this, val, this.l);
        break;
    }
  this.l += size;
  return this;
}
function CheckField(hexstr, fld) {
  var m = __hexlify(this, this.l, hexstr.length >> 1);
  if (m !== hexstr)
    throw new Error(fld + "Expected " + hexstr + " saw " + m);
  this.l += hexstr.length >> 1;
}
function prep_blob(blob2, pos) {
  blob2.l = pos;
  blob2.read_shift = /*::(*/
  ReadShift;
  blob2.chk = CheckField;
  blob2.write_shift = WriteShift;
}
function parsenoop(blob2, length2) {
  blob2.l += length2;
}
function new_buf(sz) {
  var o = new_raw_buf(sz);
  prep_blob(o, 0);
  return o;
}
function recordhopper(data, cb, opts) {
  if (!data)
    return;
  var tmpbyte, cntbyte, length2;
  prep_blob(data, data.l || 0);
  var L = data.length, RT = 0, tgt = 0;
  while (data.l < L) {
    RT = data.read_shift(1);
    if (RT & 128)
      RT = (RT & 127) + ((data.read_shift(1) & 127) << 7);
    var R = XLSBRecordEnum[RT] || XLSBRecordEnum[65535];
    tmpbyte = data.read_shift(1);
    length2 = tmpbyte & 127;
    for (cntbyte = 1; cntbyte < 4 && tmpbyte & 128; ++cntbyte)
      length2 += ((tmpbyte = data.read_shift(1)) & 127) << 7 * cntbyte;
    tgt = data.l + length2;
    var d = R.f && R.f(data, length2, opts);
    data.l = tgt;
    if (cb(d, R, RT))
      return;
  }
}
function buf_array() {
  var bufs = [], blksz = has_buf ? 256 : 2048;
  var newblk = function ba_newblk(sz) {
    var o = new_buf(sz);
    prep_blob(o, 0);
    return o;
  };
  var curbuf = newblk(blksz);
  var endbuf = function ba_endbuf() {
    if (!curbuf)
      return;
    if (curbuf.l) {
      if (curbuf.length > curbuf.l) {
        curbuf = curbuf.slice(0, curbuf.l);
        curbuf.l = curbuf.length;
      }
      if (curbuf.length > 0)
        bufs.push(curbuf);
    }
    curbuf = null;
  };
  var next2 = function ba_next(sz) {
    if (curbuf && sz < curbuf.length - curbuf.l)
      return curbuf;
    endbuf();
    return curbuf = newblk(Math.max(sz + 1, blksz));
  };
  var end = function ba_end() {
    endbuf();
    return bconcat(bufs);
  };
  var push = function ba_push(buf) {
    endbuf();
    curbuf = buf;
    if (curbuf.l == null)
      curbuf.l = curbuf.length;
    next2(blksz);
  };
  return { next: next2, push, end, _bufs: bufs };
}
function write_record(ba, type, payload, length2) {
  var t = +type, l;
  if (isNaN(t))
    return;
  if (!length2)
    length2 = XLSBRecordEnum[t].p || (payload || []).length || 0;
  l = 1 + (t >= 128 ? 1 : 0) + 1;
  if (length2 >= 128)
    ++l;
  if (length2 >= 16384)
    ++l;
  if (length2 >= 2097152)
    ++l;
  var o = ba.next(l);
  if (t <= 127)
    o.write_shift(1, t);
  else {
    o.write_shift(1, (t & 127) + 128);
    o.write_shift(1, t >> 7);
  }
  for (var i = 0; i != 4; ++i) {
    if (length2 >= 128) {
      o.write_shift(1, (length2 & 127) + 128);
      length2 >>= 7;
    } else {
      o.write_shift(1, length2);
      break;
    }
  }
  if (
    /*:: length != null &&*/
    length2 > 0 && is_buf(payload)
  )
    ba.push(payload);
}
function shift_cell_xls(cell, tgt, opts) {
  var out = dup(cell);
  if (tgt.s) {
    if (out.cRel)
      out.c += tgt.s.c;
    if (out.rRel)
      out.r += tgt.s.r;
  } else {
    if (out.cRel)
      out.c += tgt.c;
    if (out.rRel)
      out.r += tgt.r;
  }
  if (!opts || opts.biff < 12) {
    while (out.c >= 256)
      out.c -= 256;
    while (out.r >= 65536)
      out.r -= 65536;
  }
  return out;
}
function shift_range_xls(cell, range, opts) {
  var out = dup(cell);
  out.s = shift_cell_xls(out.s, range.s, opts);
  out.e = shift_cell_xls(out.e, range.s, opts);
  return out;
}
function encode_cell_xls(c, biff) {
  if (c.cRel && c.c < 0) {
    c = dup(c);
    while (c.c < 0)
      c.c += biff > 8 ? 16384 : 256;
  }
  if (c.rRel && c.r < 0) {
    c = dup(c);
    while (c.r < 0)
      c.r += biff > 8 ? 1048576 : biff > 5 ? 65536 : 16384;
  }
  var s = encode_cell(c);
  if (!c.cRel && c.cRel != null)
    s = fix_col(s);
  if (!c.rRel && c.rRel != null)
    s = fix_row(s);
  return s;
}
function encode_range_xls(r, opts) {
  if (r.s.r == 0 && !r.s.rRel) {
    if (r.e.r == (opts.biff >= 12 ? 1048575 : opts.biff >= 8 ? 65536 : 16384) && !r.e.rRel) {
      return (r.s.cRel ? "" : "$") + encode_col(r.s.c) + ":" + (r.e.cRel ? "" : "$") + encode_col(r.e.c);
    }
  }
  if (r.s.c == 0 && !r.s.cRel) {
    if (r.e.c == (opts.biff >= 12 ? 16383 : 255) && !r.e.cRel) {
      return (r.s.rRel ? "" : "$") + encode_row(r.s.r) + ":" + (r.e.rRel ? "" : "$") + encode_row(r.e.r);
    }
  }
  return encode_cell_xls(r.s, opts.biff) + ":" + encode_cell_xls(r.e, opts.biff);
}
function decode_row(rowstr) {
  return parseInt(unfix_row(rowstr), 10) - 1;
}
function encode_row(row) {
  return "" + (row + 1);
}
function fix_row(cstr) {
  return cstr.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
}
function unfix_row(cstr) {
  return cstr.replace(/\$(\d+)$/, "$1");
}
function decode_col(colstr) {
  var c = unfix_col(colstr), d = 0, i = 0;
  for (; i !== c.length; ++i)
    d = 26 * d + c.charCodeAt(i) - 64;
  return d - 1;
}
function encode_col(col) {
  if (col < 0)
    throw new Error("invalid column " + col);
  var s = "";
  for (++col; col; col = Math.floor((col - 1) / 26))
    s = String.fromCharCode((col - 1) % 26 + 65) + s;
  return s;
}
function fix_col(cstr) {
  return cstr.replace(/^([A-Z])/, "$$$1");
}
function unfix_col(cstr) {
  return cstr.replace(/^\$([A-Z])/, "$1");
}
function split_cell(cstr) {
  return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
}
function decode_cell(cstr) {
  var R = 0, C = 0;
  for (var i = 0; i < cstr.length; ++i) {
    var cc = cstr.charCodeAt(i);
    if (cc >= 48 && cc <= 57)
      R = 10 * R + (cc - 48);
    else if (cc >= 65 && cc <= 90)
      C = 26 * C + (cc - 64);
  }
  return { c: C - 1, r: R - 1 };
}
function encode_cell(cell) {
  var col = cell.c + 1;
  var s = "";
  for (; col; col = (col - 1) / 26 | 0)
    s = String.fromCharCode((col - 1) % 26 + 65) + s;
  return s + (cell.r + 1);
}
function decode_range(range) {
  var idx = range.indexOf(":");
  if (idx == -1)
    return { s: decode_cell(range), e: decode_cell(range) };
  return { s: decode_cell(range.slice(0, idx)), e: decode_cell(range.slice(idx + 1)) };
}
function encode_range(cs, ce) {
  if (typeof ce === "undefined" || typeof ce === "number") {
    return encode_range(cs.s, cs.e);
  }
  if (typeof cs !== "string")
    cs = encode_cell(cs);
  if (typeof ce !== "string")
    ce = encode_cell(ce);
  return cs == ce ? cs : cs + ":" + ce;
}
function fix_range(a1) {
  var s = decode_range(a1);
  return "$" + encode_col(s.s.c) + "$" + encode_row(s.s.r) + ":$" + encode_col(s.e.c) + "$" + encode_row(s.e.r);
}
function formula_quote_sheet_name(sname, opts) {
  if (!sname && !(opts && opts.biff <= 5 && opts.biff >= 2))
    throw new Error("empty sheet name");
  if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname))
    return "'" + sname.replace(/'/g, "''") + "'";
  return sname;
}
function safe_decode_range(range) {
  var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
  var idx = 0, i = 0, cc = 0;
  var len = range.length;
  for (idx = 0; i < len; ++i) {
    if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26)
      break;
    idx = 26 * idx + cc;
  }
  o.s.c = --idx;
  for (idx = 0; i < len; ++i) {
    if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9)
      break;
    idx = 10 * idx + cc;
  }
  o.s.r = --idx;
  if (i === len || cc != 10) {
    o.e.c = o.s.c;
    o.e.r = o.s.r;
    return o;
  }
  ++i;
  for (idx = 0; i != len; ++i) {
    if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26)
      break;
    idx = 26 * idx + cc;
  }
  o.e.c = --idx;
  for (idx = 0; i != len; ++i) {
    if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9)
      break;
    idx = 10 * idx + cc;
  }
  o.e.r = --idx;
  return o;
}
function safe_format_cell(cell, v) {
  var q = cell.t == "d" && v instanceof Date;
  if (cell.z != null)
    try {
      return cell.w = SSF_format(cell.z, q ? datenum(v) : v);
    } catch (e) {
    }
  try {
    return cell.w = SSF_format((cell.XF || {}).numFmtId || (q ? 14 : 0), q ? datenum(v) : v);
  } catch (e) {
    return "" + v;
  }
}
function format_cell(cell, v, o) {
  if (cell == null || cell.t == null || cell.t == "z")
    return "";
  if (cell.w !== void 0)
    return cell.w;
  if (cell.t == "d" && !cell.z && o && o.dateNF)
    cell.z = o.dateNF;
  if (cell.t == "e")
    return BErr[cell.v] || cell.v;
  if (v == void 0)
    return safe_format_cell(cell, cell.v);
  return safe_format_cell(cell, v);
}
function sheet_to_workbook(sheet, opts) {
  var n = opts && opts.sheet ? opts.sheet : "Sheet1";
  var sheets = {};
  sheets[n] = sheet;
  return { SheetNames: [n], Sheets: sheets };
}
function sheet_add_aoa(_ws, data, opts) {
  var o = opts || {};
  var dense = _ws ? _ws["!data"] != null : o.dense;
  var ws = _ws || {};
  if (dense && !ws["!data"])
    ws["!data"] = [];
  var _R = 0, _C = 0;
  if (ws && o.origin != null) {
    if (typeof o.origin == "number")
      _R = o.origin;
    else {
      var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
      _R = _origin.r;
      _C = _origin.c;
    }
    if (!ws["!ref"])
      ws["!ref"] = "A1:A1";
  }
  var range = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
  if (ws["!ref"]) {
    var _range = safe_decode_range(ws["!ref"]);
    range.s.c = _range.s.c;
    range.s.r = _range.s.r;
    range.e.c = Math.max(range.e.c, _range.e.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    if (_R == -1)
      range.e.r = _R = _range.e.r + 1;
  }
  var row = [];
  for (var R = 0; R != data.length; ++R) {
    if (!data[R])
      continue;
    if (!Array.isArray(data[R]))
      throw new Error("aoa_to_sheet expects an array of arrays");
    var __R = _R + R, __Rstr = "" + (__R + 1);
    if (dense) {
      if (!ws["!data"][__R])
        ws["!data"][__R] = [];
      row = ws["!data"][__R];
    }
    for (var C = 0; C != data[R].length; ++C) {
      if (typeof data[R][C] === "undefined")
        continue;
      var cell = { v: data[R][C] };
      var __C = _C + C;
      if (range.s.r > __R)
        range.s.r = __R;
      if (range.s.c > __C)
        range.s.c = __C;
      if (range.e.r < __R)
        range.e.r = __R;
      if (range.e.c < __C)
        range.e.c = __C;
      if (data[R][C] && typeof data[R][C] === "object" && !Array.isArray(data[R][C]) && !(data[R][C] instanceof Date))
        cell = data[R][C];
      else {
        if (Array.isArray(cell.v)) {
          cell.f = data[R][C][1];
          cell.v = cell.v[0];
        }
        if (cell.v === null) {
          if (cell.f)
            cell.t = "n";
          else if (o.nullError) {
            cell.t = "e";
            cell.v = 0;
          } else if (!o.sheetStubs)
            continue;
          else
            cell.t = "z";
        } else if (typeof cell.v === "number")
          cell.t = "n";
        else if (typeof cell.v === "boolean")
          cell.t = "b";
        else if (cell.v instanceof Date) {
          cell.z = o.dateNF || table_fmt[14];
          if (o.cellDates) {
            cell.t = "d";
            cell.w = SSF_format(cell.z, datenum(cell.v, o.date1904));
          } else {
            cell.t = "n";
            cell.v = datenum(cell.v, o.date1904);
            cell.w = SSF_format(cell.z, cell.v);
          }
        } else
          cell.t = "s";
      }
      if (dense) {
        if (row[__C] && row[__C].z)
          cell.z = row[__C].z;
        row[__C] = cell;
      } else {
        var cell_ref = encode_col(__C) + __Rstr;
        if (ws[cell_ref] && ws[cell_ref].z)
          cell.z = ws[cell_ref].z;
        ws[cell_ref] = cell;
      }
    }
  }
  if (range.s.c < 1e7)
    ws["!ref"] = encode_range(range);
  return ws;
}
function aoa_to_sheet(data, opts) {
  return sheet_add_aoa(null, data, opts);
}
function parse_Int32LE(data) {
  return data.read_shift(4, "i");
}
function write_UInt32LE(x, o) {
  if (!o)
    o = new_buf(4);
  o.write_shift(4, x);
  return o;
}
function parse_XLWideString(data) {
  var cchCharacters = data.read_shift(4);
  return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "dbcs");
}
function write_XLWideString(data, o) {
  var _null = false;
  if (o == null) {
    _null = true;
    o = new_buf(4 + 2 * data.length);
  }
  o.write_shift(4, data.length);
  if (data.length > 0)
    o.write_shift(0, data, "dbcs");
  return _null ? o.slice(0, o.l) : o;
}
function parse_StrRun(data) {
  return { ich: data.read_shift(2), ifnt: data.read_shift(2) };
}
function write_StrRun(run, o) {
  if (!o)
    o = new_buf(4);
  o.write_shift(2, run.ich || 0);
  o.write_shift(2, run.ifnt || 0);
  return o;
}
function parse_RichStr(data, length2) {
  var start = data.l;
  var flags = data.read_shift(1);
  var str = parse_XLWideString(data);
  var rgsStrRun = [];
  var z = { t: str, h: str };
  if ((flags & 1) !== 0) {
    var dwSizeStrRun = data.read_shift(4);
    for (var i = 0; i != dwSizeStrRun; ++i)
      rgsStrRun.push(parse_StrRun(data));
    z.r = rgsStrRun;
  } else
    z.r = [{ ich: 0, ifnt: 0 }];
  data.l = start + length2;
  return z;
}
function write_RichStr(str, o) {
  var _null = false;
  if (o == null) {
    _null = true;
    o = new_buf(15 + 4 * str.t.length);
  }
  o.write_shift(1, 0);
  write_XLWideString(str.t, o);
  return _null ? o.slice(0, o.l) : o;
}
var parse_BrtCommentText = parse_RichStr;
function write_BrtCommentText(str, o) {
  var _null = false;
  if (o == null) {
    _null = true;
    o = new_buf(23 + 4 * str.t.length);
  }
  o.write_shift(1, 1);
  write_XLWideString(str.t, o);
  o.write_shift(4, 1);
  write_StrRun({ ich: 0, ifnt: 0 }, o);
  return _null ? o.slice(0, o.l) : o;
}
function parse_XLSBCell(data) {
  var col = data.read_shift(4);
  var iStyleRef = data.read_shift(2);
  iStyleRef += data.read_shift(1) << 16;
  data.l++;
  return { c: col, iStyleRef };
}
function write_XLSBCell(cell, o) {
  if (o == null)
    o = new_buf(8);
  o.write_shift(-4, cell.c);
  o.write_shift(3, cell.iStyleRef || cell.s);
  o.write_shift(1, 0);
  return o;
}
function parse_XLSBShortCell(data) {
  var iStyleRef = data.read_shift(2);
  iStyleRef += data.read_shift(1) << 16;
  data.l++;
  return { c: -1, iStyleRef };
}
function write_XLSBShortCell(cell, o) {
  if (o == null)
    o = new_buf(4);
  o.write_shift(3, cell.iStyleRef || cell.s);
  o.write_shift(1, 0);
  return o;
}
var parse_XLSBCodeName = parse_XLWideString;
var write_XLSBCodeName = write_XLWideString;
function parse_XLNullableWideString(data) {
  var cchCharacters = data.read_shift(4);
  return cchCharacters === 0 || cchCharacters === 4294967295 ? "" : data.read_shift(cchCharacters, "dbcs");
}
function write_XLNullableWideString(data, o) {
  var _null = false;
  if (o == null) {
    _null = true;
    o = new_buf(127);
  }
  o.write_shift(4, data.length > 0 ? data.length : 4294967295);
  if (data.length > 0)
    o.write_shift(0, data, "dbcs");
  return _null ? o.slice(0, o.l) : o;
}
var parse_XLNameWideString = parse_XLWideString;
var parse_RelID = parse_XLNullableWideString;
var write_RelID = write_XLNullableWideString;
function parse_RkNumber(data) {
  var b = data.slice(data.l, data.l + 4);
  var fX100 = b[0] & 1, fInt = b[0] & 2;
  data.l += 4;
  var RK = fInt === 0 ? __double([0, 0, 0, 0, b[0] & 252, b[1], b[2], b[3]], 0) : __readInt32LE(b, 0) >> 2;
  return fX100 ? RK / 100 : RK;
}
function write_RkNumber(data, o) {
  if (o == null)
    o = new_buf(4);
  var fX100 = 0, fInt = 0, d100 = data * 100;
  if (data == (data | 0) && data >= -(1 << 29) && data < 1 << 29) {
    fInt = 1;
  } else if (d100 == (d100 | 0) && d100 >= -(1 << 29) && d100 < 1 << 29) {
    fInt = 1;
    fX100 = 1;
  }
  if (fInt)
    o.write_shift(-4, ((fX100 ? d100 : data) << 2) + (fX100 + 2));
  else
    throw new Error("unsupported RkNumber " + data);
}
function parse_RfX(data) {
  var cell = { s: {}, e: {} };
  cell.s.r = data.read_shift(4);
  cell.e.r = data.read_shift(4);
  cell.s.c = data.read_shift(4);
  cell.e.c = data.read_shift(4);
  return cell;
}
function write_RfX(r, o) {
  if (!o)
    o = new_buf(16);
  o.write_shift(4, r.s.r);
  o.write_shift(4, r.e.r);
  o.write_shift(4, r.s.c);
  o.write_shift(4, r.e.c);
  return o;
}
var parse_UncheckedRfX = parse_RfX;
var write_UncheckedRfX = write_RfX;
function parse_Xnum(data) {
  if (data.length - data.l < 8)
    throw "XLS Xnum Buffer underflow";
  return data.read_shift(8, "f");
}
function write_Xnum(data, o) {
  return (o || new_buf(8)).write_shift(8, data, "f");
}
function parse_BrtColor(data) {
  var out = {};
  var d = data.read_shift(1);
  var xColorType = d >>> 1;
  var index2 = data.read_shift(1);
  var nTS = data.read_shift(2, "i");
  var bR = data.read_shift(1);
  var bG = data.read_shift(1);
  var bB = data.read_shift(1);
  data.l++;
  switch (xColorType) {
    case 0:
      out.auto = 1;
      break;
    case 1:
      out.index = index2;
      var icv = XLSIcv[index2];
      if (icv)
        out.rgb = rgb2Hex(icv);
      break;
    case 2:
      out.rgb = rgb2Hex([bR, bG, bB]);
      break;
    case 3:
      out.theme = index2;
      break;
  }
  if (nTS != 0)
    out.tint = nTS > 0 ? nTS / 32767 : nTS / 32768;
  return out;
}
function write_BrtColor(color, o) {
  if (!o)
    o = new_buf(8);
  if (!color || color.auto) {
    o.write_shift(4, 0);
    o.write_shift(4, 0);
    return o;
  }
  if (color.index != null) {
    o.write_shift(1, 2);
    o.write_shift(1, color.index);
  } else if (color.theme != null) {
    o.write_shift(1, 6);
    o.write_shift(1, color.theme);
  } else {
    o.write_shift(1, 5);
    o.write_shift(1, 0);
  }
  var nTS = color.tint || 0;
  if (nTS > 0)
    nTS *= 32767;
  else if (nTS < 0)
    nTS *= 32768;
  o.write_shift(2, nTS);
  if (!color.rgb || color.theme != null) {
    o.write_shift(2, 0);
    o.write_shift(1, 0);
    o.write_shift(1, 0);
  } else {
    var rgb = color.rgb || "FFFFFF";
    if (typeof rgb == "number")
      rgb = ("000000" + rgb.toString(16)).slice(-6);
    o.write_shift(1, parseInt(rgb.slice(0, 2), 16));
    o.write_shift(1, parseInt(rgb.slice(2, 4), 16));
    o.write_shift(1, parseInt(rgb.slice(4, 6), 16));
    o.write_shift(1, 255);
  }
  return o;
}
function parse_FontFlags(data) {
  var d = data.read_shift(1);
  data.l++;
  var out = {
    fBold: d & 1,
    fItalic: d & 2,
    fUnderline: d & 4,
    fStrikeout: d & 8,
    fOutline: d & 16,
    fShadow: d & 32,
    fCondense: d & 64,
    fExtend: d & 128
  };
  return out;
}
function write_FontFlags(font, o) {
  if (!o)
    o = new_buf(2);
  var grbit = (font.italic ? 2 : 0) | (font.strike ? 8 : 0) | (font.outline ? 16 : 0) | (font.shadow ? 32 : 0) | (font.condense ? 64 : 0) | (font.extend ? 128 : 0);
  o.write_shift(1, grbit);
  o.write_shift(1, 0);
  return o;
}
function parse_ClipboardFormatOrString(o, w2) {
  var ClipFmt = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" };
  var m = o.read_shift(4);
  switch (m) {
    case 0:
      return "";
    case 4294967295:
    case 4294967294:
      return ClipFmt[o.read_shift(4)] || "";
  }
  if (m > 400)
    throw new Error("Unsupported Clipboard: " + m.toString(16));
  o.l -= 4;
  return o.read_shift(0, w2 == 1 ? "lpstr" : "lpwstr");
}
function parse_ClipboardFormatOrAnsiString(o) {
  return parse_ClipboardFormatOrString(o, 1);
}
function parse_ClipboardFormatOrUnicodeString(o) {
  return parse_ClipboardFormatOrString(o, 2);
}
var VT_I2 = 2;
var VT_I4 = 3;
var VT_BOOL = 11;
var VT_VARIANT = 12;
var VT_UI4 = 19;
var VT_FILETIME = 64;
var VT_BLOB = 65;
var VT_CF = 71;
var VT_VECTOR_VARIANT = 4108;
var VT_VECTOR_LPSTR = 4126;
var VT_STRING = 80;
var VT_USTR = 81;
var VT_CUSTOM = [VT_STRING, VT_USTR];
var DocSummaryPIDDSI = {
  /*::[*/
  1: { n: "CodePage", t: VT_I2 },
  /*::[*/
  2: { n: "Category", t: VT_STRING },
  /*::[*/
  3: { n: "PresentationFormat", t: VT_STRING },
  /*::[*/
  4: { n: "ByteCount", t: VT_I4 },
  /*::[*/
  5: { n: "LineCount", t: VT_I4 },
  /*::[*/
  6: { n: "ParagraphCount", t: VT_I4 },
  /*::[*/
  7: { n: "SlideCount", t: VT_I4 },
  /*::[*/
  8: { n: "NoteCount", t: VT_I4 },
  /*::[*/
  9: { n: "HiddenCount", t: VT_I4 },
  /*::[*/
  10: { n: "MultimediaClipCount", t: VT_I4 },
  /*::[*/
  11: { n: "ScaleCrop", t: VT_BOOL },
  /*::[*/
  12: {
    n: "HeadingPairs",
    t: VT_VECTOR_VARIANT
    /* VT_VECTOR | VT_VARIANT */
  },
  /*::[*/
  13: {
    n: "TitlesOfParts",
    t: VT_VECTOR_LPSTR
    /* VT_VECTOR | VT_LPSTR */
  },
  /*::[*/
  14: { n: "Manager", t: VT_STRING },
  /*::[*/
  15: { n: "Company", t: VT_STRING },
  /*::[*/
  16: { n: "LinksUpToDate", t: VT_BOOL },
  /*::[*/
  17: { n: "CharacterCount", t: VT_I4 },
  /*::[*/
  19: { n: "SharedDoc", t: VT_BOOL },
  /*::[*/
  22: { n: "HyperlinksChanged", t: VT_BOOL },
  /*::[*/
  23: { n: "AppVersion", t: VT_I4, p: "version" },
  /*::[*/
  24: { n: "DigSig", t: VT_BLOB },
  /*::[*/
  26: { n: "ContentType", t: VT_STRING },
  /*::[*/
  27: { n: "ContentStatus", t: VT_STRING },
  /*::[*/
  28: { n: "Language", t: VT_STRING },
  /*::[*/
  29: { n: "Version", t: VT_STRING },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: VT_UI4 },
  /*::[*/
  2147483651: { n: "Behavior", t: VT_UI4 },
  /*::[*/
  1919054434: {}
};
var SummaryPIDSI = {
  /*::[*/
  1: { n: "CodePage", t: VT_I2 },
  /*::[*/
  2: { n: "Title", t: VT_STRING },
  /*::[*/
  3: { n: "Subject", t: VT_STRING },
  /*::[*/
  4: { n: "Author", t: VT_STRING },
  /*::[*/
  5: { n: "Keywords", t: VT_STRING },
  /*::[*/
  6: { n: "Comments", t: VT_STRING },
  /*::[*/
  7: { n: "Template", t: VT_STRING },
  /*::[*/
  8: { n: "LastAuthor", t: VT_STRING },
  /*::[*/
  9: { n: "RevNumber", t: VT_STRING },
  /*::[*/
  10: { n: "EditTime", t: VT_FILETIME },
  /*::[*/
  11: { n: "LastPrinted", t: VT_FILETIME },
  /*::[*/
  12: { n: "CreatedDate", t: VT_FILETIME },
  /*::[*/
  13: { n: "ModifiedDate", t: VT_FILETIME },
  /*::[*/
  14: { n: "PageCount", t: VT_I4 },
  /*::[*/
  15: { n: "WordCount", t: VT_I4 },
  /*::[*/
  16: { n: "CharCount", t: VT_I4 },
  /*::[*/
  17: { n: "Thumbnail", t: VT_CF },
  /*::[*/
  18: { n: "Application", t: VT_STRING },
  /*::[*/
  19: { n: "DocSecurity", t: VT_I4 },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: VT_UI4 },
  /*::[*/
  2147483651: { n: "Behavior", t: VT_UI4 },
  /*::[*/
  1919054434: {}
};
var CountryEnum = {
  /*::[*/
  1: "US",
  // United States
  /*::[*/
  2: "CA",
  // Canada
  /*::[*/
  3: "",
  // Latin America (except Brazil)
  /*::[*/
  7: "RU",
  // Russia
  /*::[*/
  20: "EG",
  // Egypt
  /*::[*/
  30: "GR",
  // Greece
  /*::[*/
  31: "NL",
  // Netherlands
  /*::[*/
  32: "BE",
  // Belgium
  /*::[*/
  33: "FR",
  // France
  /*::[*/
  34: "ES",
  // Spain
  /*::[*/
  36: "HU",
  // Hungary
  /*::[*/
  39: "IT",
  // Italy
  /*::[*/
  41: "CH",
  // Switzerland
  /*::[*/
  43: "AT",
  // Austria
  /*::[*/
  44: "GB",
  // United Kingdom
  /*::[*/
  45: "DK",
  // Denmark
  /*::[*/
  46: "SE",
  // Sweden
  /*::[*/
  47: "NO",
  // Norway
  /*::[*/
  48: "PL",
  // Poland
  /*::[*/
  49: "DE",
  // Germany
  /*::[*/
  52: "MX",
  // Mexico
  /*::[*/
  55: "BR",
  // Brazil
  /*::[*/
  61: "AU",
  // Australia
  /*::[*/
  64: "NZ",
  // New Zealand
  /*::[*/
  66: "TH",
  // Thailand
  /*::[*/
  81: "JP",
  // Japan
  /*::[*/
  82: "KR",
  // Korea
  /*::[*/
  84: "VN",
  // Viet Nam
  /*::[*/
  86: "CN",
  // China
  /*::[*/
  90: "TR",
  // Turkey
  /*::[*/
  105: "JS",
  // Ramastan
  /*::[*/
  213: "DZ",
  // Algeria
  /*::[*/
  216: "MA",
  // Morocco
  /*::[*/
  218: "LY",
  // Libya
  /*::[*/
  351: "PT",
  // Portugal
  /*::[*/
  354: "IS",
  // Iceland
  /*::[*/
  358: "FI",
  // Finland
  /*::[*/
  420: "CZ",
  // Czech Republic
  /*::[*/
  886: "TW",
  // Taiwan
  /*::[*/
  961: "LB",
  // Lebanon
  /*::[*/
  962: "JO",
  // Jordan
  /*::[*/
  963: "SY",
  // Syria
  /*::[*/
  964: "IQ",
  // Iraq
  /*::[*/
  965: "KW",
  // Kuwait
  /*::[*/
  966: "SA",
  // Saudi Arabia
  /*::[*/
  971: "AE",
  // United Arab Emirates
  /*::[*/
  972: "IL",
  // Israel
  /*::[*/
  974: "QA",
  // Qatar
  /*::[*/
  981: "IR",
  // Iran
  /*::[*/
  65535: "US"
  // United States
};
var XLSFillPattern = [
  null,
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
function rgbify(arr) {
  return arr.map(function(x) {
    return [x >> 16 & 255, x >> 8 & 255, x & 255];
  });
}
var _XLSIcv = /* @__PURE__ */ rgbify([
  /* Color Constants */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  /* Overridable Defaults */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  8388608,
  32768,
  128,
  8421376,
  8388736,
  32896,
  12632256,
  8421504,
  10066431,
  10040166,
  16777164,
  13434879,
  6684774,
  16744576,
  26316,
  13421823,
  128,
  16711935,
  16776960,
  65535,
  8388736,
  8388608,
  32896,
  255,
  52479,
  13434879,
  13434828,
  16777113,
  10079487,
  16751052,
  13408767,
  16764057,
  3368703,
  3394764,
  10079232,
  16763904,
  16750848,
  16737792,
  6710937,
  9868950,
  13158,
  3381606,
  13056,
  3355392,
  10040064,
  10040166,
  3355545,
  3355443,
  /* Other entries to appease BIFF8/12 */
  0,
  /* 0x40 icvForeground ?? */
  16777215,
  /* 0x41 icvBackground ?? */
  0,
  /* 0x42 icvFrame ?? */
  0,
  /* 0x43 icv3D ?? */
  0,
  /* 0x44 icv3DText ?? */
  0,
  /* 0x45 icv3DHilite ?? */
  0,
  /* 0x46 icv3DShadow ?? */
  0,
  /* 0x47 icvHilite ?? */
  0,
  /* 0x48 icvCtlText ?? */
  0,
  /* 0x49 icvCtlScrl ?? */
  0,
  /* 0x4A icvCtlInv ?? */
  0,
  /* 0x4B icvCtlBody ?? */
  0,
  /* 0x4C icvCtlFrame ?? */
  0,
  /* 0x4D icvCtlFore ?? */
  0,
  /* 0x4E icvCtlBack ?? */
  0,
  /* 0x4F icvCtlNeutral */
  0,
  /* 0x50 icvInfoBk ?? */
  0
  /* 0x51 icvInfoText ?? */
]);
var XLSIcv = /* @__PURE__ */ dup(_XLSIcv);
var BErr = {
  /*::[*/
  0: "#NULL!",
  /*::[*/
  7: "#DIV/0!",
  /*::[*/
  15: "#VALUE!",
  /*::[*/
  23: "#REF!",
  /*::[*/
  29: "#NAME?",
  /*::[*/
  36: "#NUM!",
  /*::[*/
  42: "#N/A",
  /*::[*/
  43: "#GETTING_DATA",
  /*::[*/
  255: "#WTF?"
};
var RBErr = {
  "#NULL!": 0,
  "#DIV/0!": 7,
  "#VALUE!": 15,
  "#REF!": 23,
  "#NAME?": 29,
  "#NUM!": 36,
  "#N/A": 42,
  "#GETTING_DATA": 43,
  "#WTF?": 255
};
var XLSLblBuiltIn = [
  "_xlnm.Consolidate_Area",
  "_xlnm.Auto_Open",
  "_xlnm.Auto_Close",
  "_xlnm.Extract",
  "_xlnm.Database",
  "_xlnm.Criteria",
  "_xlnm.Print_Area",
  "_xlnm.Print_Titles",
  "_xlnm.Recorder",
  "_xlnm.Data_Form",
  "_xlnm.Auto_Activate",
  "_xlnm.Auto_Deactivate",
  "_xlnm.Sheet_Title",
  "_xlnm._FilterDatabase"
];
var ct2type = {
  /* Workbook */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
  /* Worksheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  "application/vnd.ms-excel.worksheet": "sheets",
  "application/vnd.ms-excel.binIndexWs": "TODO",
  /* Binary Index */
  /* Chartsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  "application/vnd.ms-excel.chartsheet": "charts",
  /* Macrosheet */
  "application/vnd.ms-excel.macrosheet+xml": "macros",
  "application/vnd.ms-excel.macrosheet": "macros",
  "application/vnd.ms-excel.intlmacrosheet": "TODO",
  "application/vnd.ms-excel.binIndexMs": "TODO",
  /* Binary Index */
  /* Dialogsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  "application/vnd.ms-excel.dialogsheet": "dialogs",
  /* Shared Strings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  "application/vnd.ms-excel.sharedStrings": "strs",
  /* Styles */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  "application/vnd.ms-excel.styles": "styles",
  /* File Properties */
  "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
  /* Custom Data Properties */
  "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
  /* Comments */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  "application/vnd.ms-excel.comments": "comments",
  "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  "application/vnd.ms-excel.person+xml": "people",
  /* Metadata (Stock/Geography and Dynamic Array) */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  "application/vnd.ms-excel.sheetMetadata": "metadata",
  /* PivotTable */
  "application/vnd.ms-excel.pivotTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
  /* Chart Objects */
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
  /* Chart Colors */
  "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
  /* Chart Style */
  "application/vnd.ms-office.chartstyle+xml": "TODO",
  /* Chart Advanced */
  "application/vnd.ms-office.chartex+xml": "TODO",
  /* Calculation Chain */
  "application/vnd.ms-excel.calcChain": "calcchains",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
  /* Printer Settings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
  /* ActiveX */
  "application/vnd.ms-office.activeX": "TODO",
  "application/vnd.ms-office.activeX+xml": "TODO",
  /* Custom Toolbars */
  "application/vnd.ms-excel.attachedToolbars": "TODO",
  /* External Data Connections */
  "application/vnd.ms-excel.connections": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
  /* External Links */
  "application/vnd.ms-excel.externalLink": "links",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
  /* PivotCache */
  "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  "application/vnd.ms-excel.pivotCacheRecords": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
  /* Query Table */
  "application/vnd.ms-excel.queryTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
  /* Shared Workbook */
  "application/vnd.ms-excel.userNames": "TODO",
  "application/vnd.ms-excel.revisionHeaders": "TODO",
  "application/vnd.ms-excel.revisionLog": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
  /* Single Cell Table */
  "application/vnd.ms-excel.tableSingleCells": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
  /* Slicer */
  "application/vnd.ms-excel.slicer": "TODO",
  "application/vnd.ms-excel.slicerCache": "TODO",
  "application/vnd.ms-excel.slicer+xml": "TODO",
  "application/vnd.ms-excel.slicerCache+xml": "TODO",
  /* Sort Map */
  "application/vnd.ms-excel.wsSortMap": "TODO",
  /* Table */
  "application/vnd.ms-excel.table": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
  /* Themes */
  "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
  /* Theme Override */
  "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
  /* Timeline */
  "application/vnd.ms-excel.Timeline+xml": "TODO",
  /* verify */
  "application/vnd.ms-excel.TimelineCache+xml": "TODO",
  /* verify */
  /* VBA */
  "application/vnd.ms-office.vbaProject": "vba",
  "application/vnd.ms-office.vbaProjectSignature": "TODO",
  /* Volatile Dependencies */
  "application/vnd.ms-office.volatileDependencies": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
  /* Control Properties */
  "application/vnd.ms-excel.controlproperties+xml": "TODO",
  /* Data Model */
  "application/vnd.openxmlformats-officedocument.model+data": "TODO",
  /* Survey */
  "application/vnd.ms-excel.Survey+xml": "TODO",
  /* Drawing */
  "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
  /* VML */
  "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
  "application/vnd.openxmlformats-package.relationships+xml": "rels",
  "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
  /* Image */
  "image/png": "TODO",
  "sheet": "js"
};
var CT_LIST = {
  workbooks: {
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
    xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
    xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
    xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
  },
  strs: {
    /* Shared Strings */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
    xlsb: "application/vnd.ms-excel.sharedStrings"
  },
  comments: {
    /* Comments */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
    xlsb: "application/vnd.ms-excel.comments"
  },
  sheets: {
    /* Worksheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
    xlsb: "application/vnd.ms-excel.worksheet"
  },
  charts: {
    /* Chartsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
    xlsb: "application/vnd.ms-excel.chartsheet"
  },
  dialogs: {
    /* Dialogsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
    xlsb: "application/vnd.ms-excel.dialogsheet"
  },
  macros: {
    /* Macrosheet (Excel 4.0 Macros) */
    xlsx: "application/vnd.ms-excel.macrosheet+xml",
    xlsb: "application/vnd.ms-excel.macrosheet"
  },
  metadata: {
    /* Metadata (Stock/Geography and Dynamic Array) */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
    xlsb: "application/vnd.ms-excel.sheetMetadata"
  },
  styles: {
    /* Styles */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
    xlsb: "application/vnd.ms-excel.styles"
  }
};
function new_ct() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ""
  };
}
function parse_ct(data) {
  var ct = new_ct();
  if (!data || !data.match)
    return ct;
  var ctext = {};
  (data.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (y[0].replace(nsregex, "<")) {
      case "<?xml":
        break;
      case "<Types":
        ct.xmlns = y["xmlns" + (y[0].match(/<(\w+):/) || ["", ""])[1]];
        break;
      case "<Default":
        ctext[y.Extension.toLowerCase()] = y.ContentType;
        break;
      case "<Override":
        if (ct[ct2type[y.ContentType]] !== void 0)
          ct[ct2type[y.ContentType]].push(y.PartName);
        break;
    }
  });
  if (ct.xmlns !== XMLNS.CT)
    throw new Error("Unknown Namespace: " + ct.xmlns);
  ct.calcchain = ct.calcchains.length > 0 ? ct.calcchains[0] : "";
  ct.sst = ct.strs.length > 0 ? ct.strs[0] : "";
  ct.style = ct.styles.length > 0 ? ct.styles[0] : "";
  ct.defaults = ctext;
  delete ct.calcchains;
  return ct;
}
function write_ct(ct, opts, raw) {
  var type2ct = evert_arr(ct2type);
  var o = [], v;
  if (!raw) {
    o[o.length] = XML_HEADER;
    o[o.length] = writextag("Types", null, {
      "xmlns": XMLNS.CT,
      "xmlns:xsd": XMLNS.xsd,
      "xmlns:xsi": XMLNS.xsi
    });
    o = o.concat([
      ["xml", "application/xml"],
      ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"],
      ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"],
      ["data", "application/vnd.openxmlformats-officedocument.model+data"],
      /* from test files */
      ["bmp", "image/bmp"],
      ["png", "image/png"],
      ["gif", "image/gif"],
      ["emf", "image/x-emf"],
      ["wmf", "image/x-wmf"],
      ["jpg", "image/jpeg"],
      ["jpeg", "image/jpeg"],
      ["tif", "image/tiff"],
      ["tiff", "image/tiff"],
      ["pdf", "application/pdf"],
      ["rels", "application/vnd.openxmlformats-package.relationships+xml"]
    ].map(function(x) {
      return writextag("Default", null, { "Extension": x[0], "ContentType": x[1] });
    }));
  }
  var f1 = function(w2) {
    if (ct[w2] && ct[w2].length > 0) {
      v = ct[w2][0];
      o[o.length] = writextag("Override", null, {
        "PartName": (v[0] == "/" ? "" : "/") + v,
        "ContentType": CT_LIST[w2][opts.bookType] || CT_LIST[w2]["xlsx"]
      });
    }
  };
  var f2 = function(w2) {
    (ct[w2] || []).forEach(function(v2) {
      o[o.length] = writextag("Override", null, {
        "PartName": (v2[0] == "/" ? "" : "/") + v2,
        "ContentType": CT_LIST[w2][opts.bookType] || CT_LIST[w2]["xlsx"]
      });
    });
  };
  var f3 = function(t) {
    (ct[t] || []).forEach(function(v2) {
      o[o.length] = writextag("Override", null, {
        "PartName": (v2[0] == "/" ? "" : "/") + v2,
        "ContentType": type2ct[t][0]
      });
    });
  };
  f1("workbooks");
  f2("sheets");
  f2("charts");
  f3("themes");
  ["strs", "styles"].forEach(f1);
  ["coreprops", "extprops", "custprops"].forEach(f3);
  f3("vba");
  f3("comments");
  f3("threadedcomments");
  f3("drawings");
  f2("metadata");
  f3("people");
  if (!raw && o.length > 2) {
    o[o.length] = "</Types>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
var RELS = {
  WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
  CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
  CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
  CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
  SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
  CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
  WS: [
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
  ],
  DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
  MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
  IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  CONN: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/connections",
  VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function get_rels_path(file) {
  var n = file.lastIndexOf("/");
  return file.slice(0, n + 1) + "_rels/" + file.slice(n + 1) + ".rels";
}
function parse_rels(data, currentFilePath) {
  var rels = { "!id": {} };
  if (!data)
    return rels;
  if (currentFilePath.charAt(0) !== "/") {
    currentFilePath = "/" + currentFilePath;
  }
  var hash2 = {};
  (data.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    if (y[0] === "<Relationship") {
      var rel = {};
      rel.Type = y.Type;
      rel.Target = unescapexml(y.Target);
      rel.Id = y.Id;
      if (y.TargetMode)
        rel.TargetMode = y.TargetMode;
      var canonictarget = y.TargetMode === "External" ? y.Target : resolve_path(y.Target, currentFilePath);
      rels[canonictarget] = rel;
      hash2[y.Id] = rel;
    }
  });
  rels["!id"] = hash2;
  return rels;
}
function write_rels(rels) {
  var o = [XML_HEADER, writextag("Relationships", null, {
    //'xmlns:ns0': XMLNS.RELS,
    "xmlns": XMLNS.RELS
  })];
  keys(rels["!id"]).forEach(function(rid) {
    o[o.length] = writextag("Relationship", null, rels["!id"][rid]);
  });
  if (o.length > 2) {
    o[o.length] = "</Relationships>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
function add_rels(rels, rId, f, type, relobj, targetmode) {
  if (!relobj)
    relobj = {};
  if (!rels["!id"])
    rels["!id"] = {};
  if (!rels["!idx"])
    rels["!idx"] = 1;
  if (rId < 0)
    for (rId = rels["!idx"]; rels["!id"]["rId" + rId]; ++rId) {
    }
  rels["!idx"] = rId + 1;
  relobj.Id = "rId" + rId;
  relobj.Type = type;
  relobj.Target = f;
  if (targetmode)
    relobj.TargetMode = targetmode;
  else if ([RELS.HLINK, RELS.XPATH, RELS.XMISS].indexOf(relobj.Type) > -1)
    relobj.TargetMode = "External";
  if (rels["!id"][relobj.Id])
    throw new Error("Cannot rewrite rId " + rId);
  rels["!id"][relobj.Id] = relobj;
  rels[("/" + relobj.Target).replace("//", "/")] = relobj;
  return rId;
}
var CT_ODS = "application/vnd.oasis.opendocument.spreadsheet";
function parse_manifest(d, opts) {
  var str = xlml_normalize(d);
  var Rn;
  var FEtag;
  while (Rn = xlmlregex.exec(str))
    switch (Rn[3]) {
      case "manifest":
        break;
      case "file-entry":
        FEtag = parsexmltag(Rn[0], false);
        if (FEtag.path == "/" && FEtag.type !== CT_ODS)
          throw new Error("This OpenDocument is not a spreadsheet");
        break;
      case "encryption-data":
      case "algorithm":
      case "start-key-generation":
      case "key-derivation":
        throw new Error("Unsupported ODS Encryption");
      default:
        if (opts && opts.WTF)
          throw Rn;
    }
}
function write_manifest(manifest) {
  var o = [XML_HEADER];
  o.push('<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">\n');
  o.push('  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>\n');
  for (var i = 0; i < manifest.length; ++i)
    o.push('  <manifest:file-entry manifest:full-path="' + manifest[i][0] + '" manifest:media-type="' + manifest[i][1] + '"/>\n');
  o.push("</manifest:manifest>");
  return o.join("");
}
function write_rdf_type(file, res, tag) {
  return [
    '  <rdf:Description rdf:about="' + file + '">\n',
    '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (tag || "odf") + "#" + res + '"/>\n',
    "  </rdf:Description>\n"
  ].join("");
}
function write_rdf_has(base, file) {
  return [
    '  <rdf:Description rdf:about="' + base + '">\n',
    '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + file + '"/>\n',
    "  </rdf:Description>\n"
  ].join("");
}
function write_rdf(rdf) {
  var o = [XML_HEADER];
  o.push('<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n');
  for (var i = 0; i != rdf.length; ++i) {
    o.push(write_rdf_type(rdf[i][0], rdf[i][1]));
    o.push(write_rdf_has("", rdf[i][0]));
  }
  o.push(write_rdf_type("", "Document", "pkg"));
  o.push("</rdf:RDF>");
  return o.join("");
}
function write_meta_ods(wb, opts) {
  return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + XLSX.version + "</meta:generator></office:meta></office:document-meta>";
}
var CORE_PROPS = [
  ["cp:category", "Category"],
  ["cp:contentStatus", "ContentStatus"],
  ["cp:keywords", "Keywords"],
  ["cp:lastModifiedBy", "LastAuthor"],
  ["cp:lastPrinted", "LastPrinted"],
  ["cp:revision", "RevNumber"],
  ["cp:version", "Version"],
  ["dc:creator", "Author"],
  ["dc:description", "Comments"],
  ["dc:identifier", "Identifier"],
  ["dc:language", "Language"],
  ["dc:subject", "Subject"],
  ["dc:title", "Title"],
  ["dcterms:created", "CreatedDate", "date"],
  ["dcterms:modified", "ModifiedDate", "date"]
];
var CORE_PROPS_REGEX = /* @__PURE__ */ function() {
  var r = new Array(CORE_PROPS.length);
  for (var i = 0; i < CORE_PROPS.length; ++i) {
    var f = CORE_PROPS[i];
    var g = "(?:" + f[0].slice(0, f[0].indexOf(":")) + ":)" + f[0].slice(f[0].indexOf(":") + 1);
    r[i] = new RegExp("<" + g + "[^>]*>([\\s\\S]*?)</" + g + ">");
  }
  return r;
}();
function parse_core_props(data) {
  var p = {};
  data = utf8read(data);
  for (var i = 0; i < CORE_PROPS.length; ++i) {
    var f = CORE_PROPS[i], cur = data.match(CORE_PROPS_REGEX[i]);
    if (cur != null && cur.length > 0)
      p[f[1]] = unescapexml(cur[1]);
    if (f[2] === "date" && p[f[1]])
      p[f[1]] = parseDate(p[f[1]]);
  }
  return p;
}
function cp_doit(f, g, h, o, p) {
  if (p[f] != null || g == null || g === "")
    return;
  p[f] = g;
  g = escapexml(g);
  o[o.length] = h ? writextag(f, g, h) : writetag(f, g);
}
function write_core_props(cp, _opts) {
  var opts = _opts || {};
  var o = [XML_HEADER, writextag("cp:coreProperties", null, {
    //'xmlns': XMLNS.CORE_PROPS,
    "xmlns:cp": XMLNS.CORE_PROPS,
    "xmlns:dc": XMLNS.dc,
    "xmlns:dcterms": XMLNS.dcterms,
    "xmlns:dcmitype": XMLNS.dcmitype,
    "xmlns:xsi": XMLNS.xsi
  })], p = {};
  if (!cp && !opts.Props)
    return o.join("");
  if (cp) {
    if (cp.CreatedDate != null)
      cp_doit("dcterms:created", typeof cp.CreatedDate === "string" ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o, p);
    if (cp.ModifiedDate != null)
      cp_doit("dcterms:modified", typeof cp.ModifiedDate === "string" ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o, p);
  }
  for (var i = 0; i != CORE_PROPS.length; ++i) {
    var f = CORE_PROPS[i];
    var v = opts.Props && opts.Props[f[1]] != null ? opts.Props[f[1]] : cp ? cp[f[1]] : null;
    if (v === true)
      v = "1";
    else if (v === false)
      v = "0";
    else if (typeof v == "number")
      v = String(v);
    if (v != null)
      cp_doit(f[0], v, null, o, p);
  }
  if (o.length > 2) {
    o[o.length] = "</cp:coreProperties>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
var EXT_PROPS = [
  ["Application", "Application", "string"],
  ["AppVersion", "AppVersion", "string"],
  ["Company", "Company", "string"],
  ["DocSecurity", "DocSecurity", "string"],
  ["Manager", "Manager", "string"],
  ["HyperlinksChanged", "HyperlinksChanged", "bool"],
  ["SharedDoc", "SharedDoc", "bool"],
  ["LinksUpToDate", "LinksUpToDate", "bool"],
  ["ScaleCrop", "ScaleCrop", "bool"],
  ["HeadingPairs", "HeadingPairs", "raw"],
  ["TitlesOfParts", "TitlesOfParts", "raw"]
];
var PseudoPropsPairs = [
  "Worksheets",
  "SheetNames",
  "NamedRanges",
  "DefinedNames",
  "Chartsheets",
  "ChartNames"
];
function load_props_pairs(HP, TOP, props, opts) {
  var v = [];
  if (typeof HP == "string")
    v = parseVector(HP, opts);
  else
    for (var j = 0; j < HP.length; ++j)
      v = v.concat(HP[j].map(function(hp) {
        return { v: hp };
      }));
  var parts = typeof TOP == "string" ? parseVector(TOP, opts).map(function(x) {
    return x.v;
  }) : TOP;
  var idx = 0, len = 0;
  if (parts.length > 0)
    for (var i = 0; i !== v.length; i += 2) {
      len = +v[i + 1].v;
      switch (v[i].v) {
        case "Worksheets":
        case "工作表":
        case "Листы":
        case "أوراق العمل":
        case "ワークシート":
        case "גליונות עבודה":
        case "Arbeitsblätter":
        case "Çalışma Sayfaları":
        case "Feuilles de calcul":
        case "Fogli di lavoro":
        case "Folhas de cálculo":
        case "Planilhas":
        case "Regneark":
        case "Hojas de cálculo":
        case "Werkbladen":
          props.Worksheets = len;
          props.SheetNames = parts.slice(idx, idx + len);
          break;
        case "Named Ranges":
        case "Rangos con nombre":
        case "名前付き一覧":
        case "Benannte Bereiche":
        case "Navngivne områder":
          props.NamedRanges = len;
          props.DefinedNames = parts.slice(idx, idx + len);
          break;
        case "Charts":
        case "Diagramme":
          props.Chartsheets = len;
          props.ChartNames = parts.slice(idx, idx + len);
          break;
      }
      idx += len;
    }
}
function parse_ext_props(data, p, opts) {
  var q = {};
  if (!p)
    p = {};
  data = utf8read(data);
  EXT_PROPS.forEach(function(f) {
    var xml = (data.match(matchtag(f[0])) || [])[1];
    switch (f[2]) {
      case "string":
        if (xml)
          p[f[1]] = unescapexml(xml);
        break;
      case "bool":
        p[f[1]] = xml === "true";
        break;
      case "raw":
        var cur = data.match(new RegExp("<" + f[0] + "[^>]*>([\\s\\S]*?)</" + f[0] + ">"));
        if (cur && cur.length > 0)
          q[f[1]] = cur[1];
        break;
    }
  });
  if (q.HeadingPairs && q.TitlesOfParts)
    load_props_pairs(q.HeadingPairs, q.TitlesOfParts, p, opts);
  return p;
}
function write_ext_props(cp) {
  var o = [], W = writextag;
  if (!cp)
    cp = {};
  cp.Application = "SheetJS";
  o[o.length] = XML_HEADER;
  o[o.length] = writextag("Properties", null, {
    "xmlns": XMLNS.EXT_PROPS,
    "xmlns:vt": XMLNS.vt
  });
  EXT_PROPS.forEach(function(f) {
    if (cp[f[1]] === void 0)
      return;
    var v;
    switch (f[2]) {
      case "string":
        v = escapexml(String(cp[f[1]]));
        break;
      case "bool":
        v = cp[f[1]] ? "true" : "false";
        break;
    }
    if (v !== void 0)
      o[o.length] = W(f[0], v);
  });
  o[o.length] = W("HeadingPairs", W("vt:vector", W("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + W("vt:variant", W("vt:i4", String(cp.Worksheets))), { size: 2, baseType: "variant" }));
  o[o.length] = W("TitlesOfParts", W("vt:vector", cp.SheetNames.map(function(s) {
    return "<vt:lpstr>" + escapexml(s) + "</vt:lpstr>";
  }).join(""), { size: cp.Worksheets, baseType: "lpstr" }));
  if (o.length > 2) {
    o[o.length] = "</Properties>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
var custregex = /<[^>]+>[^<]*/g;
function parse_cust_props(data, opts) {
  var p = {}, name = "";
  var m = data.match(custregex);
  if (m)
    for (var i = 0; i != m.length; ++i) {
      var x = m[i], y = parsexmltag(x);
      switch (strip_ns(y[0])) {
        case "<?xml":
          break;
        case "<Properties":
          break;
        case "<property":
          name = unescapexml(y.name);
          break;
        case "</property>":
          name = null;
          break;
        default:
          if (x.indexOf("<vt:") === 0) {
            var toks = x.split(">");
            var type = toks[0].slice(4), text = toks[1];
            switch (type) {
              case "lpstr":
              case "bstr":
              case "lpwstr":
                p[name] = unescapexml(text);
                break;
              case "bool":
                p[name] = parsexmlbool(text);
                break;
              case "i1":
              case "i2":
              case "i4":
              case "i8":
              case "int":
              case "uint":
                p[name] = parseInt(text, 10);
                break;
              case "r4":
              case "r8":
              case "decimal":
                p[name] = parseFloat(text);
                break;
              case "filetime":
              case "date":
                p[name] = parseDate(text);
                break;
              case "cy":
              case "error":
                p[name] = unescapexml(text);
                break;
              default:
                if (type.slice(-1) == "/")
                  break;
                if (opts.WTF && typeof console !== "undefined")
                  console.warn("Unexpected", x, type, toks);
            }
          } else if (x.slice(0, 2) === "</")
            ;
          else if (opts.WTF)
            throw new Error(x);
      }
    }
  return p;
}
function write_cust_props(cp) {
  var o = [XML_HEADER, writextag("Properties", null, {
    "xmlns": XMLNS.CUST_PROPS,
    "xmlns:vt": XMLNS.vt
  })];
  if (!cp)
    return o.join("");
  var pid = 1;
  keys(cp).forEach(function custprop(k) {
    ++pid;
    o[o.length] = writextag("property", write_vt(cp[k], true), {
      "fmtid": "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
      "pid": pid,
      "name": escapexml(k)
    });
  });
  if (o.length > 2) {
    o[o.length] = "</Properties>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
var XLMLDocPropsMap = {
  Title: "Title",
  Subject: "Subject",
  Author: "Author",
  Keywords: "Keywords",
  Comments: "Description",
  LastAuthor: "LastAuthor",
  RevNumber: "Revision",
  Application: "AppName",
  /* TotalTime: 'TotalTime', */
  LastPrinted: "LastPrinted",
  CreatedDate: "Created",
  ModifiedDate: "LastSaved",
  /* Pages */
  /* Words */
  /* Characters */
  Category: "Category",
  /* PresentationFormat */
  Manager: "Manager",
  Company: "Company",
  /* Guid */
  /* HyperlinkBase */
  /* Bytes */
  /* Lines */
  /* Paragraphs */
  /* CharactersWithSpaces */
  AppVersion: "Version",
  ContentStatus: "ContentStatus",
  /* NOTE: missing from schema */
  Identifier: "Identifier",
  /* NOTE: missing from schema */
  Language: "Language"
  /* NOTE: missing from schema */
};
var evert_XLMLDPM;
function xlml_set_prop(Props, tag, val) {
  if (!evert_XLMLDPM)
    evert_XLMLDPM = evert(XLMLDocPropsMap);
  tag = evert_XLMLDPM[tag] || tag;
  Props[tag] = val;
}
function xlml_write_docprops(Props, opts) {
  var o = [];
  keys(XLMLDocPropsMap).map(function(m) {
    for (var i = 0; i < CORE_PROPS.length; ++i)
      if (CORE_PROPS[i][1] == m)
        return CORE_PROPS[i];
    for (i = 0; i < EXT_PROPS.length; ++i)
      if (EXT_PROPS[i][1] == m)
        return EXT_PROPS[i];
    throw m;
  }).forEach(function(p) {
    if (Props[p[1]] == null)
      return;
    var m = opts && opts.Props && opts.Props[p[1]] != null ? opts.Props[p[1]] : Props[p[1]];
    switch (p[2]) {
      case "date":
        m = new Date(m).toISOString().replace(/\.\d*Z/, "Z");
        break;
    }
    if (typeof m == "number")
      m = String(m);
    else if (m === true || m === false) {
      m = m ? "1" : "0";
    } else if (m instanceof Date)
      m = new Date(m).toISOString().replace(/\.\d*Z/, "");
    o.push(writetag(XLMLDocPropsMap[p[1]] || p[1], m));
  });
  return writextag("DocumentProperties", o.join(""), { xmlns: XLMLNS.o });
}
function xlml_write_custprops(Props, Custprops) {
  var BLACKLIST = ["Worksheets", "SheetNames"];
  var T = "CustomDocumentProperties";
  var o = [];
  if (Props)
    keys(Props).forEach(function(k) {
      if (!Object.prototype.hasOwnProperty.call(Props, k))
        return;
      for (var i = 0; i < CORE_PROPS.length; ++i)
        if (k == CORE_PROPS[i][1])
          return;
      for (i = 0; i < EXT_PROPS.length; ++i)
        if (k == EXT_PROPS[i][1])
          return;
      for (i = 0; i < BLACKLIST.length; ++i)
        if (k == BLACKLIST[i])
          return;
      var m = Props[k];
      var t = "string";
      if (typeof m == "number") {
        t = "float";
        m = String(m);
      } else if (m === true || m === false) {
        t = "boolean";
        m = m ? "1" : "0";
      } else
        m = String(m);
      o.push(writextag(escapexmltag(k), m, { "dt:dt": t }));
    });
  if (Custprops)
    keys(Custprops).forEach(function(k) {
      if (!Object.prototype.hasOwnProperty.call(Custprops, k))
        return;
      if (Props && Object.prototype.hasOwnProperty.call(Props, k))
        return;
      var m = Custprops[k];
      var t = "string";
      if (typeof m == "number") {
        t = "float";
        m = String(m);
      } else if (m === true || m === false) {
        t = "boolean";
        m = m ? "1" : "0";
      } else if (m instanceof Date) {
        t = "dateTime.tz";
        m = m.toISOString();
      } else
        m = String(m);
      o.push(writextag(escapexmltag(k), m, { "dt:dt": t }));
    });
  return "<" + T + ' xmlns="' + XLMLNS.o + '">' + o.join("") + "</" + T + ">";
}
function parse_FILETIME(blob2) {
  var dwLowDateTime = blob2.read_shift(4), dwHighDateTime = blob2.read_shift(4);
  return new Date((dwHighDateTime / 1e7 * Math.pow(2, 32) + dwLowDateTime / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "");
}
function write_FILETIME(time) {
  var date = typeof time == "string" ? new Date(Date.parse(time)) : time;
  var t = date.getTime() / 1e3 + 11644473600;
  var l = t % Math.pow(2, 32), h = (t - l) / Math.pow(2, 32);
  l *= 1e7;
  h *= 1e7;
  var w2 = l / Math.pow(2, 32) | 0;
  if (w2 > 0) {
    l = l % Math.pow(2, 32);
    h += w2;
  }
  var o = new_buf(8);
  o.write_shift(4, l);
  o.write_shift(4, h);
  return o;
}
function parse_lpstr(blob2, type, pad) {
  var start = blob2.l;
  var str = blob2.read_shift(0, "lpstr-cp");
  if (pad)
    while (blob2.l - start & 3)
      ++blob2.l;
  return str;
}
function parse_lpwstr(blob2, type, pad) {
  var str = blob2.read_shift(0, "lpwstr");
  if (pad)
    blob2.l += 4 - (str.length + 1 & 3) & 3;
  return str;
}
function parse_VtStringBase(blob2, stringType, pad) {
  if (stringType === 31)
    return parse_lpwstr(blob2);
  return parse_lpstr(blob2, stringType, pad);
}
function parse_VtString(blob2, t, pad) {
  return parse_VtStringBase(blob2, t, pad === false ? 0 : 4);
}
function parse_VtUnalignedString(blob2, t) {
  if (!t)
    throw new Error("VtUnalignedString must have positive length");
  return parse_VtStringBase(blob2, t, 0);
}
function parse_VtVecLpwstrValue(blob2) {
  var length2 = blob2.read_shift(4);
  var ret = [];
  for (var i = 0; i != length2; ++i) {
    var start = blob2.l;
    ret[i] = blob2.read_shift(0, "lpwstr").replace(chr0, "");
    if (blob2.l - start & 2)
      blob2.l += 2;
  }
  return ret;
}
function parse_VtVecUnalignedLpstrValue(blob2) {
  var length2 = blob2.read_shift(4);
  var ret = [];
  for (var i = 0; i != length2; ++i)
    ret[i] = blob2.read_shift(0, "lpstr-cp").replace(chr0, "");
  return ret;
}
function parse_VtHeadingPair(blob2) {
  var start = blob2.l;
  var headingString = parse_TypedPropertyValue(blob2, VT_USTR);
  if (blob2[blob2.l] == 0 && blob2[blob2.l + 1] == 0 && blob2.l - start & 2)
    blob2.l += 2;
  var headerParts = parse_TypedPropertyValue(blob2, VT_I4);
  return [headingString, headerParts];
}
function parse_VtVecHeadingPairValue(blob2) {
  var cElements = blob2.read_shift(4);
  var out = [];
  for (var i = 0; i < cElements / 2; ++i)
    out.push(parse_VtHeadingPair(blob2));
  return out;
}
function parse_dictionary(blob2, CodePage) {
  var cnt = blob2.read_shift(4);
  var dict = {};
  for (var j = 0; j != cnt; ++j) {
    var pid = blob2.read_shift(4);
    var len = blob2.read_shift(4);
    dict[pid] = blob2.read_shift(len, CodePage === 1200 ? "utf16le" : "utf8").replace(chr0, "").replace(chr1, "!");
    if (CodePage === 1200 && len % 2)
      blob2.l += 2;
  }
  if (blob2.l & 3)
    blob2.l = blob2.l >> 2 + 1 << 2;
  return dict;
}
function parse_BLOB(blob2) {
  var size = blob2.read_shift(4);
  var bytes = blob2.slice(blob2.l, blob2.l + size);
  blob2.l += size;
  if ((size & 3) > 0)
    blob2.l += 4 - (size & 3) & 3;
  return bytes;
}
function parse_ClipboardData(blob2) {
  var o = {};
  o.Size = blob2.read_shift(4);
  blob2.l += o.Size + 3 - (o.Size - 1) % 4;
  return o;
}
function parse_TypedPropertyValue(blob2, type, _opts) {
  var t = blob2.read_shift(2), ret, opts = _opts || {};
  blob2.l += 2;
  if (type !== VT_VARIANT) {
    if (t !== type && VT_CUSTOM.indexOf(type) === -1 && !((type & 65534) == 4126 && (t & 65534) == 4126))
      throw new Error("Expected type " + type + " saw " + t);
  }
  switch (type === VT_VARIANT ? t : type) {
    case 2:
      ret = blob2.read_shift(2, "i");
      if (!opts.raw)
        blob2.l += 2;
      return ret;
    case 3:
      ret = blob2.read_shift(4, "i");
      return ret;
    case 11:
      return blob2.read_shift(4) !== 0;
    case 19:
      ret = blob2.read_shift(4);
      return ret;
    case 30:
      return parse_lpstr(blob2, t, 4).replace(chr0, "");
    case 31:
      return parse_lpwstr(blob2);
    case 64:
      return parse_FILETIME(blob2);
    case 65:
      return parse_BLOB(blob2);
    case 71:
      return parse_ClipboardData(blob2);
    case 80:
      return parse_VtString(blob2, t, !opts.raw).replace(chr0, "");
    case 81:
      return parse_VtUnalignedString(
        blob2,
        t
        /*, 4*/
      ).replace(chr0, "");
    case 4108:
      return parse_VtVecHeadingPairValue(blob2);
    case 4126:
    case 4127:
      return t == 4127 ? parse_VtVecLpwstrValue(blob2) : parse_VtVecUnalignedLpstrValue(blob2);
    default:
      throw new Error("TypedPropertyValue unrecognized type " + type + " " + t);
  }
}
function write_TypedPropertyValue(type, value) {
  var o = new_buf(4), p = new_buf(4);
  o.write_shift(4, type == 80 ? 31 : type);
  switch (type) {
    case 3:
      p.write_shift(-4, value);
      break;
    case 5:
      p = new_buf(8);
      p.write_shift(8, value, "f");
      break;
    case 11:
      p.write_shift(4, value ? 1 : 0);
      break;
    case 64:
      p = write_FILETIME(value);
      break;
    case 31:
    case 80:
      p = new_buf(4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
      p.write_shift(4, value.length + 1);
      p.write_shift(0, value, "dbcs");
      while (p.l != p.length)
        p.write_shift(1, 0);
      break;
    default:
      throw new Error("TypedPropertyValue unrecognized type " + type + " " + value);
  }
  return bconcat([o, p]);
}
function parse_PropertySet(blob2, PIDSI) {
  var start_addr = blob2.l;
  var size = blob2.read_shift(4);
  var NumProps = blob2.read_shift(4);
  var Props = [], i = 0;
  var CodePage = 0;
  var Dictionary = -1, DictObj = {};
  for (i = 0; i != NumProps; ++i) {
    var PropID = blob2.read_shift(4);
    var Offset = blob2.read_shift(4);
    Props[i] = [PropID, Offset + start_addr];
  }
  Props.sort(function(x, y) {
    return x[1] - y[1];
  });
  var PropH = {};
  for (i = 0; i != NumProps; ++i) {
    if (blob2.l !== Props[i][1]) {
      var fail = true;
      if (i > 0 && PIDSI)
        switch (PIDSI[Props[i - 1][0]].t) {
          case 2:
            if (blob2.l + 2 === Props[i][1]) {
              blob2.l += 2;
              fail = false;
            }
            break;
          case 80:
            if (blob2.l <= Props[i][1]) {
              blob2.l = Props[i][1];
              fail = false;
            }
            break;
          case 4108:
            if (blob2.l <= Props[i][1]) {
              blob2.l = Props[i][1];
              fail = false;
            }
            break;
        }
      if ((!PIDSI || i == 0) && blob2.l <= Props[i][1]) {
        fail = false;
        blob2.l = Props[i][1];
      }
      if (fail)
        throw new Error("Read Error: Expected address " + Props[i][1] + " at " + blob2.l + " :" + i);
    }
    if (PIDSI) {
      if (Props[i][0] == 0 && Props.length > i + 1 && Props[i][1] == Props[i + 1][1])
        continue;
      var piddsi = PIDSI[Props[i][0]];
      PropH[piddsi.n] = parse_TypedPropertyValue(blob2, piddsi.t, { raw: true });
      if (piddsi.p === "version")
        PropH[piddsi.n] = String(PropH[piddsi.n] >> 16) + "." + ("0000" + String(PropH[piddsi.n] & 65535)).slice(-4);
      if (piddsi.n == "CodePage")
        switch (PropH[piddsi.n]) {
          case 0:
            PropH[piddsi.n] = 1252;
          case 874:
          case 932:
          case 936:
          case 949:
          case 950:
          case 1250:
          case 1251:
          case 1253:
          case 1254:
          case 1255:
          case 1256:
          case 1257:
          case 1258:
          case 1e4:
          case 1200:
          case 1201:
          case 1252:
          case 65e3:
          case -536:
          case 65001:
          case -535:
            set_cp(CodePage = PropH[piddsi.n] >>> 0 & 65535);
            break;
          default:
            throw new Error("Unsupported CodePage: " + PropH[piddsi.n]);
        }
    } else {
      if (Props[i][0] === 1) {
        CodePage = PropH.CodePage = parse_TypedPropertyValue(blob2, VT_I2);
        set_cp(CodePage);
        if (Dictionary !== -1) {
          var oldpos = blob2.l;
          blob2.l = Props[Dictionary][1];
          DictObj = parse_dictionary(blob2, CodePage);
          blob2.l = oldpos;
        }
      } else if (Props[i][0] === 0) {
        if (CodePage === 0) {
          Dictionary = i;
          blob2.l = Props[i + 1][1];
          continue;
        }
        DictObj = parse_dictionary(blob2, CodePage);
      } else {
        var name = DictObj[Props[i][0]];
        var val;
        switch (blob2[blob2.l]) {
          case 65:
            blob2.l += 4;
            val = parse_BLOB(blob2);
            break;
          case 30:
            blob2.l += 4;
            val = parse_VtString(blob2, blob2[blob2.l - 4]).replace(/\u0000+$/, "");
            break;
          case 31:
            blob2.l += 4;
            val = parse_VtString(blob2, blob2[blob2.l - 4]).replace(/\u0000+$/, "");
            break;
          case 3:
            blob2.l += 4;
            val = blob2.read_shift(4, "i");
            break;
          case 19:
            blob2.l += 4;
            val = blob2.read_shift(4);
            break;
          case 5:
            blob2.l += 4;
            val = blob2.read_shift(8, "f");
            break;
          case 11:
            blob2.l += 4;
            val = parsebool(blob2, 4);
            break;
          case 64:
            blob2.l += 4;
            val = parseDate(parse_FILETIME(blob2));
            break;
          default:
            throw new Error("unparsed value: " + blob2[blob2.l]);
        }
        PropH[name] = val;
      }
    }
  }
  blob2.l = start_addr + size;
  return PropH;
}
var XLSPSSkip = ["CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID"];
function guess_property_type(val) {
  switch (typeof val) {
    case "boolean":
      return 11;
    case "number":
      return (val | 0) == val ? 3 : 5;
    case "string":
      return 31;
    case "object":
      if (val instanceof Date)
        return 64;
      break;
  }
  return -1;
}
function write_PropertySet(entries, RE, PIDSI) {
  var hdr = new_buf(8), piao = [], prop = [];
  var sz = 8, i = 0;
  var pr = new_buf(8), pio = new_buf(8);
  pr.write_shift(4, 2);
  pr.write_shift(4, 1200);
  pio.write_shift(4, 1);
  prop.push(pr);
  piao.push(pio);
  sz += 8 + pr.length;
  if (!RE) {
    pio = new_buf(8);
    pio.write_shift(4, 0);
    piao.unshift(pio);
    var bufs = [new_buf(4)];
    bufs[0].write_shift(4, entries.length);
    for (i = 0; i < entries.length; ++i) {
      var value = entries[i][0];
      pr = new_buf(4 + 4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
      pr.write_shift(4, i + 2);
      pr.write_shift(4, value.length + 1);
      pr.write_shift(0, value, "dbcs");
      while (pr.l != pr.length)
        pr.write_shift(1, 0);
      bufs.push(pr);
    }
    pr = bconcat(bufs);
    prop.unshift(pr);
    sz += 8 + pr.length;
  }
  for (i = 0; i < entries.length; ++i) {
    if (RE && !RE[entries[i][0]])
      continue;
    if (XLSPSSkip.indexOf(entries[i][0]) > -1 || PseudoPropsPairs.indexOf(entries[i][0]) > -1)
      continue;
    if (entries[i][1] == null)
      continue;
    var val = entries[i][1], idx = 0;
    if (RE) {
      idx = +RE[entries[i][0]];
      var pinfo = PIDSI[idx];
      if (pinfo.p == "version" && typeof val == "string") {
        var arr = val.split(".");
        val = (+arr[0] << 16) + (+arr[1] || 0);
      }
      pr = write_TypedPropertyValue(pinfo.t, val);
    } else {
      var T = guess_property_type(val);
      if (T == -1) {
        T = 31;
        val = String(val);
      }
      pr = write_TypedPropertyValue(T, val);
    }
    prop.push(pr);
    pio = new_buf(8);
    pio.write_shift(4, !RE ? 2 + i : idx);
    piao.push(pio);
    sz += 8 + pr.length;
  }
  var w2 = 8 * (prop.length + 1);
  for (i = 0; i < prop.length; ++i) {
    piao[i].write_shift(4, w2);
    w2 += prop[i].length;
  }
  hdr.write_shift(4, sz);
  hdr.write_shift(4, prop.length);
  return bconcat([hdr].concat(piao).concat(prop));
}
function parse_PropertySetStream(file, PIDSI, clsid) {
  var blob2 = file.content;
  if (!blob2)
    return {};
  prep_blob(blob2, 0);
  var NumSets, FMTID0, FMTID1, Offset0, Offset1 = 0;
  blob2.chk("feff", "Byte Order: ");
  blob2.read_shift(2);
  var SystemIdentifier = blob2.read_shift(4);
  var CLSID = blob2.read_shift(16);
  if (CLSID !== CFB.utils.consts.HEADER_CLSID && CLSID !== clsid)
    throw new Error("Bad PropertySet CLSID " + CLSID);
  NumSets = blob2.read_shift(4);
  if (NumSets !== 1 && NumSets !== 2)
    throw new Error("Unrecognized #Sets: " + NumSets);
  FMTID0 = blob2.read_shift(16);
  Offset0 = blob2.read_shift(4);
  if (NumSets === 1 && Offset0 !== blob2.l)
    throw new Error("Length mismatch: " + Offset0 + " !== " + blob2.l);
  else if (NumSets === 2) {
    FMTID1 = blob2.read_shift(16);
    Offset1 = blob2.read_shift(4);
  }
  var PSet0 = parse_PropertySet(blob2, PIDSI);
  var rval = { SystemIdentifier };
  for (var y in PSet0)
    rval[y] = PSet0[y];
  rval.FMTID = FMTID0;
  if (NumSets === 1)
    return rval;
  if (Offset1 - blob2.l == 2)
    blob2.l += 2;
  if (blob2.l !== Offset1)
    throw new Error("Length mismatch 2: " + blob2.l + " !== " + Offset1);
  var PSet1;
  try {
    PSet1 = parse_PropertySet(blob2, null);
  } catch (e) {
  }
  for (y in PSet1)
    rval[y] = PSet1[y];
  rval.FMTID = [FMTID0, FMTID1];
  return rval;
}
function write_PropertySetStream(entries, clsid, RE, PIDSI, entries2, clsid2) {
  var hdr = new_buf(entries2 ? 68 : 48);
  var bufs = [hdr];
  hdr.write_shift(2, 65534);
  hdr.write_shift(2, 0);
  hdr.write_shift(4, 842412599);
  hdr.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex");
  hdr.write_shift(4, entries2 ? 2 : 1);
  hdr.write_shift(16, clsid, "hex");
  hdr.write_shift(4, entries2 ? 68 : 48);
  var ps0 = write_PropertySet(entries, RE, PIDSI);
  bufs.push(ps0);
  if (entries2) {
    var ps1 = write_PropertySet(entries2, null, null);
    hdr.write_shift(16, clsid2, "hex");
    hdr.write_shift(4, 68 + ps0.length);
    bufs.push(ps1);
  }
  return bconcat(bufs);
}
function parsenoop2(blob2, length2) {
  blob2.read_shift(length2);
  return null;
}
function writezeroes(n, o) {
  if (!o)
    o = new_buf(n);
  for (var j = 0; j < n; ++j)
    o.write_shift(1, 0);
  return o;
}
function parslurp(blob2, length2, cb) {
  var arr = [], target = blob2.l + length2;
  while (blob2.l < target)
    arr.push(cb(blob2, target - blob2.l));
  if (target !== blob2.l)
    throw new Error("Slurp error");
  return arr;
}
function parsebool(blob2, length2) {
  return blob2.read_shift(length2) === 1;
}
function writebool(v, o) {
  if (!o)
    o = new_buf(2);
  o.write_shift(2, +!!v);
  return o;
}
function parseuint16(blob2) {
  return blob2.read_shift(2, "u");
}
function writeuint16(v, o) {
  if (!o)
    o = new_buf(2);
  o.write_shift(2, v);
  return o;
}
function parseuint16a(blob2, length2) {
  return parslurp(blob2, length2, parseuint16);
}
function parse_Bes(blob2) {
  var v = blob2.read_shift(1), t = blob2.read_shift(1);
  return t === 1 ? v : v === 1;
}
function write_Bes(v, t, o) {
  if (!o)
    o = new_buf(2);
  o.write_shift(1, t == "e" ? +v : +!!v);
  o.write_shift(1, t == "e" ? 1 : 0);
  return o;
}
function parse_ShortXLUnicodeString(blob2, length2, opts) {
  var cch = blob2.read_shift(opts && opts.biff >= 12 ? 2 : 1);
  var encoding = "sbcs-cont";
  var cp = current_codepage;
  if (opts && opts.biff >= 8)
    current_codepage = 1200;
  if (!opts || opts.biff == 8) {
    var fHighByte = blob2.read_shift(1);
    if (fHighByte) {
      encoding = "dbcs-cont";
    }
  } else if (opts.biff == 12) {
    encoding = "wstr";
  }
  if (opts.biff >= 2 && opts.biff <= 5)
    encoding = "cpstr";
  var o = cch ? blob2.read_shift(cch, encoding) : "";
  current_codepage = cp;
  return o;
}
function parse_XLUnicodeRichExtendedString(blob2) {
  var cp = current_codepage;
  current_codepage = 1200;
  var cch = blob2.read_shift(2), flags = blob2.read_shift(1);
  var fExtSt = flags & 4, fRichSt = flags & 8;
  var width = 1 + (flags & 1);
  var cRun = 0, cbExtRst;
  var z = {};
  if (fRichSt)
    cRun = blob2.read_shift(2);
  if (fExtSt)
    cbExtRst = blob2.read_shift(4);
  var encoding = width == 2 ? "dbcs-cont" : "sbcs-cont";
  var msg = cch === 0 ? "" : blob2.read_shift(cch, encoding);
  if (fRichSt)
    blob2.l += 4 * cRun;
  if (fExtSt)
    blob2.l += cbExtRst;
  z.t = msg;
  if (!fRichSt) {
    z.raw = "<t>" + z.t + "</t>";
    z.r = z.t;
  }
  current_codepage = cp;
  return z;
}
function write_XLUnicodeRichExtendedString(xlstr) {
  var str = xlstr.t || "";
  var hdr = new_buf(3 + 0);
  hdr.write_shift(2, str.length);
  hdr.write_shift(1, 0 | 1);
  var otext = new_buf(2 * str.length);
  otext.write_shift(2 * str.length, str, "utf16le");
  var out = [hdr, otext];
  return bconcat(out);
}
function parse_XLUnicodeStringNoCch(blob2, cch, opts) {
  var retval;
  if (opts) {
    if (opts.biff >= 2 && opts.biff <= 5)
      return blob2.read_shift(cch, "cpstr");
    if (opts.biff >= 12)
      return blob2.read_shift(cch, "dbcs-cont");
  }
  var fHighByte = blob2.read_shift(1);
  if (fHighByte === 0) {
    retval = blob2.read_shift(cch, "sbcs-cont");
  } else {
    retval = blob2.read_shift(cch, "dbcs-cont");
  }
  return retval;
}
function parse_XLUnicodeString(blob2, length2, opts) {
  var cch = blob2.read_shift(opts && opts.biff == 2 ? 1 : 2);
  if (cch === 0) {
    blob2.l++;
    return "";
  }
  return parse_XLUnicodeStringNoCch(blob2, cch, opts);
}
function parse_XLUnicodeString2(blob2, length2, opts) {
  if (opts.biff > 5)
    return parse_XLUnicodeString(blob2, length2, opts);
  var cch = blob2.read_shift(1);
  if (cch === 0) {
    blob2.l++;
    return "";
  }
  return blob2.read_shift(cch, opts.biff <= 4 || !blob2.lens ? "cpstr" : "sbcs-cont");
}
function write_XLUnicodeString(str, opts, o) {
  if (!o)
    o = new_buf(3 + 2 * str.length);
  o.write_shift(2, str.length);
  o.write_shift(1, 1);
  o.write_shift(31, str, "utf16le");
  return o;
}
function parse_ControlInfo(blob2) {
  var flags = blob2.read_shift(1);
  blob2.l++;
  var accel = blob2.read_shift(2);
  blob2.l += 2;
  return [flags, accel];
}
function parse_URLMoniker(blob2) {
  var len = blob2.read_shift(4), start = blob2.l;
  var extra = false;
  if (len > 24) {
    blob2.l += len - 24;
    if (blob2.read_shift(16) === "795881f43b1d7f48af2c825dc4852763")
      extra = true;
    blob2.l = start;
  }
  var url = blob2.read_shift((extra ? len - 24 : len) >> 1, "utf16le").replace(chr0, "");
  if (extra)
    blob2.l += 24;
  return url;
}
function parse_FileMoniker(blob2) {
  var cAnti = blob2.read_shift(2);
  var preamble = "";
  while (cAnti-- > 0)
    preamble += "../";
  var ansiPath = blob2.read_shift(0, "lpstr-ansi");
  blob2.l += 2;
  if (blob2.read_shift(2) != 57005)
    throw new Error("Bad FileMoniker");
  var sz = blob2.read_shift(4);
  if (sz === 0)
    return preamble + ansiPath.replace(/\\/g, "/");
  var bytes = blob2.read_shift(4);
  if (blob2.read_shift(2) != 3)
    throw new Error("Bad FileMoniker");
  var unicodePath = blob2.read_shift(bytes >> 1, "utf16le").replace(chr0, "");
  return preamble + unicodePath;
}
function parse_HyperlinkMoniker(blob2, length2) {
  var clsid = blob2.read_shift(16);
  switch (clsid) {
    case "e0c9ea79f9bace118c8200aa004ba90b":
      return parse_URLMoniker(blob2);
    case "0303000000000000c000000000000046":
      return parse_FileMoniker(blob2);
    default:
      throw new Error("Unsupported Moniker " + clsid);
  }
}
function parse_HyperlinkString(blob2) {
  var len = blob2.read_shift(4);
  var o = len > 0 ? blob2.read_shift(len, "utf16le").replace(chr0, "") : "";
  return o;
}
function write_HyperlinkString(str, o) {
  if (!o)
    o = new_buf(6 + str.length * 2);
  o.write_shift(4, 1 + str.length);
  for (var i = 0; i < str.length; ++i)
    o.write_shift(2, str.charCodeAt(i));
  o.write_shift(2, 0);
  return o;
}
function parse_Hyperlink(blob2, length2) {
  var end = blob2.l + length2;
  var sVer = blob2.read_shift(4);
  if (sVer !== 2)
    throw new Error("Unrecognized streamVersion: " + sVer);
  var flags = blob2.read_shift(2);
  blob2.l += 2;
  var displayName, targetFrameName, moniker, oleMoniker, Loc = "", guid, fileTime;
  if (flags & 16)
    displayName = parse_HyperlinkString(blob2, end - blob2.l);
  if (flags & 128)
    targetFrameName = parse_HyperlinkString(blob2, end - blob2.l);
  if ((flags & 257) === 257)
    moniker = parse_HyperlinkString(blob2, end - blob2.l);
  if ((flags & 257) === 1)
    oleMoniker = parse_HyperlinkMoniker(blob2, end - blob2.l);
  if (flags & 8)
    Loc = parse_HyperlinkString(blob2, end - blob2.l);
  if (flags & 32)
    guid = blob2.read_shift(16);
  if (flags & 64)
    fileTime = parse_FILETIME(
      blob2
      /*, 8*/
    );
  blob2.l = end;
  var target = targetFrameName || moniker || oleMoniker || "";
  if (target && Loc)
    target += "#" + Loc;
  if (!target)
    target = "#" + Loc;
  if (flags & 2 && target.charAt(0) == "/" && target.charAt(1) != "/")
    target = "file://" + target;
  var out = { Target: target };
  if (guid)
    out.guid = guid;
  if (fileTime)
    out.time = fileTime;
  if (displayName)
    out.Tooltip = displayName;
  return out;
}
function write_Hyperlink(hl) {
  var out = new_buf(512), i = 0;
  var Target = hl.Target;
  if (Target.slice(0, 7) == "file://")
    Target = Target.slice(7);
  var hashidx = Target.indexOf("#");
  var F = hashidx > -1 ? 31 : 23;
  switch (Target.charAt(0)) {
    case "#":
      F = 28;
      break;
    case ".":
      F &= ~2;
      break;
  }
  out.write_shift(4, 2);
  out.write_shift(4, F);
  var data = [8, 6815827, 6619237, 4849780, 83];
  for (i = 0; i < data.length; ++i)
    out.write_shift(4, data[i]);
  if (F == 28) {
    Target = Target.slice(1);
    write_HyperlinkString(Target, out);
  } else if (F & 2) {
    data = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
    for (i = 0; i < data.length; ++i)
      out.write_shift(1, parseInt(data[i], 16));
    var Pretarget = hashidx > -1 ? Target.slice(0, hashidx) : Target;
    out.write_shift(4, 2 * (Pretarget.length + 1));
    for (i = 0; i < Pretarget.length; ++i)
      out.write_shift(2, Pretarget.charCodeAt(i));
    out.write_shift(2, 0);
    if (F & 8)
      write_HyperlinkString(hashidx > -1 ? Target.slice(hashidx + 1) : "", out);
  } else {
    data = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" ");
    for (i = 0; i < data.length; ++i)
      out.write_shift(1, parseInt(data[i], 16));
    var P = 0;
    while (Target.slice(P * 3, P * 3 + 3) == "../" || Target.slice(P * 3, P * 3 + 3) == "..\\")
      ++P;
    out.write_shift(2, P);
    out.write_shift(4, Target.length - 3 * P + 1);
    for (i = 0; i < Target.length - 3 * P; ++i)
      out.write_shift(1, Target.charCodeAt(i + 3 * P) & 255);
    out.write_shift(1, 0);
    out.write_shift(2, 65535);
    out.write_shift(2, 57005);
    for (i = 0; i < 6; ++i)
      out.write_shift(4, 0);
  }
  return out.slice(0, out.l);
}
function parse_LongRGBA(blob2) {
  var r = blob2.read_shift(1), g = blob2.read_shift(1), b = blob2.read_shift(1), a = blob2.read_shift(1);
  return [r, g, b, a];
}
function parse_LongRGB(blob2, length2) {
  var x = parse_LongRGBA(blob2);
  x[3] = 0;
  return x;
}
function parse_XLSCell(blob2) {
  var rw = blob2.read_shift(2);
  var col = blob2.read_shift(2);
  var ixfe = blob2.read_shift(2);
  return { r: rw, c: col, ixfe };
}
function write_XLSCell(R, C, ixfe, o) {
  if (!o)
    o = new_buf(6);
  o.write_shift(2, R);
  o.write_shift(2, C);
  o.write_shift(2, ixfe || 0);
  return o;
}
function parse_frtHeader(blob2) {
  var rt = blob2.read_shift(2);
  var flags = blob2.read_shift(2);
  blob2.l += 8;
  return { type: rt, flags };
}
function parse_OptXLUnicodeString(blob2, length2, opts) {
  return length2 === 0 ? "" : parse_XLUnicodeString2(blob2, length2, opts);
}
function parse_XTI(blob2, length2, opts) {
  var w2 = opts.biff > 8 ? 4 : 2;
  var iSupBook = blob2.read_shift(w2), itabFirst = blob2.read_shift(w2, "i"), itabLast = blob2.read_shift(w2, "i");
  return [iSupBook, itabFirst, itabLast];
}
function parse_RkRec(blob2) {
  var ixfe = blob2.read_shift(2);
  var RK = parse_RkNumber(blob2);
  return [ixfe, RK];
}
function parse_AddinUdf(blob2, length2, opts) {
  blob2.l += 4;
  length2 -= 4;
  var l = blob2.l + length2;
  var udfName = parse_ShortXLUnicodeString(blob2, length2, opts);
  var cb = blob2.read_shift(2);
  l -= blob2.l;
  if (cb !== l)
    throw new Error("Malformed AddinUdf: padding = " + l + " != " + cb);
  blob2.l += cb;
  return udfName;
}
function parse_Ref8U(blob2) {
  var rwFirst = blob2.read_shift(2);
  var rwLast = blob2.read_shift(2);
  var colFirst = blob2.read_shift(2);
  var colLast = blob2.read_shift(2);
  return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
}
function write_Ref8U(r, o) {
  if (!o)
    o = new_buf(8);
  o.write_shift(2, r.s.r);
  o.write_shift(2, r.e.r);
  o.write_shift(2, r.s.c);
  o.write_shift(2, r.e.c);
  return o;
}
function parse_RefU(blob2) {
  var rwFirst = blob2.read_shift(2);
  var rwLast = blob2.read_shift(2);
  var colFirst = blob2.read_shift(1);
  var colLast = blob2.read_shift(1);
  return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
}
var parse_Ref = parse_RefU;
function parse_FtCmo(blob2) {
  blob2.l += 4;
  var ot = blob2.read_shift(2);
  var id = blob2.read_shift(2);
  var flags = blob2.read_shift(2);
  blob2.l += 12;
  return [id, ot, flags];
}
function parse_FtNts(blob2) {
  var out = {};
  blob2.l += 4;
  blob2.l += 16;
  out.fSharedNote = blob2.read_shift(2);
  blob2.l += 4;
  return out;
}
function parse_FtCf(blob2) {
  var out = {};
  blob2.l += 4;
  blob2.cf = blob2.read_shift(2);
  return out;
}
function parse_FtSkip(blob2) {
  blob2.l += 2;
  blob2.l += blob2.read_shift(2);
}
var FtTab = {
  /*::[*/
  0: parse_FtSkip,
  /* FtEnd */
  /*::[*/
  4: parse_FtSkip,
  /* FtMacro */
  /*::[*/
  5: parse_FtSkip,
  /* FtButton */
  /*::[*/
  6: parse_FtSkip,
  /* FtGmo */
  /*::[*/
  7: parse_FtCf,
  /* FtCf */
  /*::[*/
  8: parse_FtSkip,
  /* FtPioGrbit */
  /*::[*/
  9: parse_FtSkip,
  /* FtPictFmla */
  /*::[*/
  10: parse_FtSkip,
  /* FtCbls */
  /*::[*/
  11: parse_FtSkip,
  /* FtRbo */
  /*::[*/
  12: parse_FtSkip,
  /* FtSbs */
  /*::[*/
  13: parse_FtNts,
  /* FtNts */
  /*::[*/
  14: parse_FtSkip,
  /* FtSbsFmla */
  /*::[*/
  15: parse_FtSkip,
  /* FtGboData */
  /*::[*/
  16: parse_FtSkip,
  /* FtEdoData */
  /*::[*/
  17: parse_FtSkip,
  /* FtRboData */
  /*::[*/
  18: parse_FtSkip,
  /* FtCblsData */
  /*::[*/
  19: parse_FtSkip,
  /* FtLbsData */
  /*::[*/
  20: parse_FtSkip,
  /* FtCblsFmla */
  /*::[*/
  21: parse_FtCmo
};
function parse_FtArray(blob2, length2) {
  var tgt = blob2.l + length2;
  var fts = [];
  while (blob2.l < tgt) {
    var ft = blob2.read_shift(2);
    blob2.l -= 2;
    try {
      fts[ft] = FtTab[ft](blob2, tgt - blob2.l);
    } catch (e) {
      blob2.l = tgt;
      return fts;
    }
  }
  if (blob2.l != tgt)
    blob2.l = tgt;
  return fts;
}
function parse_BOF(blob2, length2) {
  var o = { BIFFVer: 0, dt: 0 };
  o.BIFFVer = blob2.read_shift(2);
  length2 -= 2;
  if (length2 >= 2) {
    o.dt = blob2.read_shift(2);
    blob2.l -= 2;
  }
  switch (o.BIFFVer) {
    case 1536:
    case 1280:
    case 1024:
    case 768:
    case 512:
    case 2:
    case 7:
      break;
    default:
      if (length2 > 6)
        throw new Error("Unexpected BIFF Ver " + o.BIFFVer);
  }
  blob2.read_shift(length2);
  return o;
}
function write_BOF(wb, t, o) {
  var h = 1536, w2 = 16;
  switch (o.bookType) {
    case "biff8":
      break;
    case "biff5":
      h = 1280;
      w2 = 8;
      break;
    case "biff4":
      h = 4;
      w2 = 6;
      break;
    case "biff3":
      h = 3;
      w2 = 6;
      break;
    case "biff2":
      h = 2;
      w2 = 4;
      break;
    case "xla":
      break;
    default:
      throw new Error("unsupported BIFF version");
  }
  var out = new_buf(w2);
  out.write_shift(2, h);
  out.write_shift(2, t);
  if (w2 > 4)
    out.write_shift(2, 29282);
  if (w2 > 6)
    out.write_shift(2, 1997);
  if (w2 > 8) {
    out.write_shift(2, 49161);
    out.write_shift(2, 1);
    out.write_shift(2, 1798);
    out.write_shift(2, 0);
  }
  return out;
}
function parse_InterfaceHdr(blob2, length2) {
  if (length2 === 0)
    return 1200;
  if (blob2.read_shift(2) !== 1200)
    ;
  return 1200;
}
function parse_WriteAccess(blob2, length2, opts) {
  if (opts.enc) {
    blob2.l += length2;
    return "";
  }
  var l = blob2.l;
  var UserName = parse_XLUnicodeString2(blob2, 0, opts);
  blob2.read_shift(length2 + l - blob2.l);
  return UserName;
}
function write_WriteAccess(s, opts) {
  var b8 = !opts || opts.biff == 8;
  var o = new_buf(b8 ? 112 : 54);
  o.write_shift(opts.biff == 8 ? 2 : 1, 7);
  if (b8)
    o.write_shift(1, 0);
  o.write_shift(4, 859007059);
  o.write_shift(4, 5458548 | (b8 ? 0 : 536870912));
  while (o.l < o.length)
    o.write_shift(1, b8 ? 0 : 32);
  return o;
}
function parse_WsBool(blob2, length2, opts) {
  var flags = opts && opts.biff == 8 || length2 == 2 ? blob2.read_shift(2) : (blob2.l += length2, 0);
  return { fDialog: flags & 16, fBelow: flags & 64, fRight: flags & 128 };
}
function parse_BoundSheet8(blob2, length2, opts) {
  var pos = blob2.read_shift(4);
  var hidden = blob2.read_shift(1) & 3;
  var dt = blob2.read_shift(1);
  switch (dt) {
    case 0:
      dt = "Worksheet";
      break;
    case 1:
      dt = "Macrosheet";
      break;
    case 2:
      dt = "Chartsheet";
      break;
    case 6:
      dt = "VBAModule";
      break;
  }
  var name = parse_ShortXLUnicodeString(blob2, 0, opts);
  if (name.length === 0)
    name = "Sheet1";
  return { pos, hs: hidden, dt, name };
}
function write_BoundSheet8(data, opts) {
  var w2 = !opts || opts.biff >= 8 ? 2 : 1;
  var o = new_buf(8 + w2 * data.name.length);
  o.write_shift(4, data.pos);
  o.write_shift(1, data.hs || 0);
  o.write_shift(1, data.dt);
  o.write_shift(1, data.name.length);
  if (opts.biff >= 8)
    o.write_shift(1, 1);
  o.write_shift(w2 * data.name.length, data.name, opts.biff < 8 ? "sbcs" : "utf16le");
  var out = o.slice(0, o.l);
  out.l = o.l;
  return out;
}
function parse_SST(blob2, length2) {
  var end = blob2.l + length2;
  var cnt = blob2.read_shift(4);
  var ucnt = blob2.read_shift(4);
  var strs2 = [];
  for (var i = 0; i != ucnt && blob2.l < end; ++i) {
    strs2.push(parse_XLUnicodeRichExtendedString(blob2));
  }
  strs2.Count = cnt;
  strs2.Unique = ucnt;
  return strs2;
}
function write_SST(sst, opts) {
  var header = new_buf(8);
  header.write_shift(4, sst.Count);
  header.write_shift(4, sst.Unique);
  var strs2 = [];
  for (var j = 0; j < sst.length; ++j)
    strs2[j] = write_XLUnicodeRichExtendedString(sst[j]);
  var o = bconcat([header].concat(strs2));
  o.parts = [header.length].concat(strs2.map(function(str) {
    return str.length;
  }));
  return o;
}
function parse_ExtSST(blob2, length2) {
  var extsst = {};
  extsst.dsst = blob2.read_shift(2);
  blob2.l += length2 - 2;
  return extsst;
}
function parse_Row(blob2) {
  var z = {};
  z.r = blob2.read_shift(2);
  z.c = blob2.read_shift(2);
  z.cnt = blob2.read_shift(2) - z.c;
  var miyRw = blob2.read_shift(2);
  blob2.l += 4;
  var flags = blob2.read_shift(1);
  blob2.l += 3;
  if (flags & 7)
    z.level = flags & 7;
  if (flags & 32)
    z.hidden = true;
  if (flags & 64)
    z.hpt = miyRw / 20;
  return z;
}
function parse_ForceFullCalculation(blob2) {
  var header = parse_frtHeader(blob2);
  if (header.type != 2211)
    throw new Error("Invalid Future Record " + header.type);
  var fullcalc = blob2.read_shift(4);
  return fullcalc !== 0;
}
function parse_RecalcId(blob2) {
  blob2.read_shift(2);
  return blob2.read_shift(4);
}
function parse_DefaultRowHeight(blob2, length2, opts) {
  var f = 0;
  if (!(opts && opts.biff == 2)) {
    f = blob2.read_shift(2);
  }
  var miyRw = blob2.read_shift(2);
  if (opts && opts.biff == 2) {
    f = 1 - (miyRw >> 15);
    miyRw &= 32767;
  }
  var fl = { Unsynced: f & 1, DyZero: (f & 2) >> 1, ExAsc: (f & 4) >> 2, ExDsc: (f & 8) >> 3 };
  return [fl, miyRw];
}
function parse_Window1(blob2) {
  var xWn = blob2.read_shift(2), yWn = blob2.read_shift(2), dxWn = blob2.read_shift(2), dyWn = blob2.read_shift(2);
  var flags = blob2.read_shift(2), iTabCur = blob2.read_shift(2), iTabFirst = blob2.read_shift(2);
  var ctabSel = blob2.read_shift(2), wTabRatio = blob2.read_shift(2);
  return {
    Pos: [xWn, yWn],
    Dim: [dxWn, dyWn],
    Flags: flags,
    CurTab: iTabCur,
    FirstTab: iTabFirst,
    Selected: ctabSel,
    TabRatio: wTabRatio
  };
}
function write_Window1() {
  var o = new_buf(18);
  o.write_shift(2, 0);
  o.write_shift(2, 0);
  o.write_shift(2, 29280);
  o.write_shift(2, 17600);
  o.write_shift(2, 56);
  o.write_shift(2, 0);
  o.write_shift(2, 0);
  o.write_shift(2, 1);
  o.write_shift(2, 500);
  return o;
}
function parse_Window2(blob2, length2, opts) {
  if (opts && opts.biff >= 2 && opts.biff < 5)
    return {};
  var f = blob2.read_shift(2);
  return { RTL: f & 64 };
}
function write_Window2(view) {
  var o = new_buf(18), f = 1718;
  if (view && view.RTL)
    f |= 64;
  o.write_shift(2, f);
  o.write_shift(4, 0);
  o.write_shift(4, 64);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  return o;
}
function parse_Pane() {
}
function parse_Font(blob2, length2, opts) {
  var o = {
    dyHeight: blob2.read_shift(2),
    fl: blob2.read_shift(2)
  };
  switch (opts && opts.biff || 8) {
    case 2:
      break;
    case 3:
    case 4:
      blob2.l += 2;
      break;
    default:
      blob2.l += 10;
      break;
  }
  o.name = parse_ShortXLUnicodeString(blob2, 0, opts);
  return o;
}
function write_Font(data, opts) {
  var name = data.name || "Arial";
  var b5 = opts && opts.biff == 5, w2 = b5 ? 15 + name.length : 16 + 2 * name.length;
  var o = new_buf(w2);
  o.write_shift(2, (data.sz || 12) * 20);
  o.write_shift(4, 0);
  o.write_shift(2, 400);
  o.write_shift(4, 0);
  o.write_shift(2, 0);
  o.write_shift(1, name.length);
  if (!b5)
    o.write_shift(1, 1);
  o.write_shift((b5 ? 1 : 2) * name.length, name, b5 ? "sbcs" : "utf16le");
  return o;
}
function parse_LabelSst(blob2) {
  var cell = parse_XLSCell(blob2);
  cell.isst = blob2.read_shift(4);
  return cell;
}
function write_LabelSst(R, C, v, os) {
  var o = new_buf(10);
  write_XLSCell(R, C, os, o);
  o.write_shift(4, v);
  return o;
}
function parse_Label(blob2, length2, opts) {
  if (opts.biffguess && opts.biff == 2)
    opts.biff = 5;
  var target = blob2.l + length2;
  var cell = parse_XLSCell(blob2);
  if (opts.biff == 2)
    blob2.l++;
  var str = parse_XLUnicodeString(blob2, target - blob2.l, opts);
  cell.val = str;
  return cell;
}
function write_Label(R, C, v, os, opts) {
  var b8 = !opts || opts.biff == 8;
  var o = new_buf(6 + 2 + +b8 + (1 + b8) * v.length);
  write_XLSCell(R, C, os, o);
  o.write_shift(2, v.length);
  if (b8)
    o.write_shift(1, 1);
  o.write_shift((1 + b8) * v.length, v, b8 ? "utf16le" : "sbcs");
  return o;
}
function parse_Format(blob2, length2, opts) {
  var numFmtId = blob2.read_shift(2);
  var fmtstr = parse_XLUnicodeString2(blob2, 0, opts);
  return [numFmtId, fmtstr];
}
function write_Format(i, f, opts, o) {
  var b5 = opts && opts.biff == 5;
  if (!o)
    o = new_buf(b5 ? 3 + f.length : 5 + 2 * f.length);
  o.write_shift(2, i);
  o.write_shift(b5 ? 1 : 2, f.length);
  if (!b5)
    o.write_shift(1, 1);
  o.write_shift((b5 ? 1 : 2) * f.length, f, b5 ? "sbcs" : "utf16le");
  var out = o.length > o.l ? o.slice(0, o.l) : o;
  if (out.l == null)
    out.l = out.length;
  return out;
}
var parse_BIFF2Format = parse_XLUnicodeString2;
function parse_Dimensions(blob2, length2, opts) {
  var end = blob2.l + length2;
  var w2 = opts.biff == 8 || !opts.biff ? 4 : 2;
  var r = blob2.read_shift(w2), R = blob2.read_shift(w2);
  var c = blob2.read_shift(2), C = blob2.read_shift(2);
  blob2.l = end;
  return { s: { r, c }, e: { r: R, c: C } };
}
function write_Dimensions(range, opts) {
  var w2 = opts.biff == 8 || !opts.biff ? 4 : 2;
  var o = new_buf(2 * w2 + 6);
  o.write_shift(w2, range.s.r);
  o.write_shift(w2, range.e.r + 1);
  o.write_shift(2, range.s.c);
  o.write_shift(2, range.e.c + 1);
  o.write_shift(2, 0);
  return o;
}
function parse_RK(blob2) {
  var rw = blob2.read_shift(2), col = blob2.read_shift(2);
  var rkrec = parse_RkRec(blob2);
  return { r: rw, c: col, ixfe: rkrec[0], rknum: rkrec[1] };
}
function parse_MulRk(blob2, length2) {
  var target = blob2.l + length2 - 2;
  var rw = blob2.read_shift(2), col = blob2.read_shift(2);
  var rkrecs = [];
  while (blob2.l < target)
    rkrecs.push(parse_RkRec(blob2));
  if (blob2.l !== target)
    throw new Error("MulRK read error");
  var lastcol = blob2.read_shift(2);
  if (rkrecs.length != lastcol - col + 1)
    throw new Error("MulRK length mismatch");
  return { r: rw, c: col, C: lastcol, rkrec: rkrecs };
}
function parse_MulBlank(blob2, length2) {
  var target = blob2.l + length2 - 2;
  var rw = blob2.read_shift(2), col = blob2.read_shift(2);
  var ixfes = [];
  while (blob2.l < target)
    ixfes.push(blob2.read_shift(2));
  if (blob2.l !== target)
    throw new Error("MulBlank read error");
  var lastcol = blob2.read_shift(2);
  if (ixfes.length != lastcol - col + 1)
    throw new Error("MulBlank length mismatch");
  return { r: rw, c: col, C: lastcol, ixfe: ixfes };
}
function parse_CellStyleXF(blob2, length2, style, opts) {
  var o = {};
  var a = blob2.read_shift(4), b = blob2.read_shift(4);
  var c = blob2.read_shift(4), d = blob2.read_shift(2);
  o.patternType = XLSFillPattern[c >> 26];
  if (!opts.cellStyles)
    return o;
  o.alc = a & 7;
  o.fWrap = a >> 3 & 1;
  o.alcV = a >> 4 & 7;
  o.fJustLast = a >> 7 & 1;
  o.trot = a >> 8 & 255;
  o.cIndent = a >> 16 & 15;
  o.fShrinkToFit = a >> 20 & 1;
  o.iReadOrder = a >> 22 & 2;
  o.fAtrNum = a >> 26 & 1;
  o.fAtrFnt = a >> 27 & 1;
  o.fAtrAlc = a >> 28 & 1;
  o.fAtrBdr = a >> 29 & 1;
  o.fAtrPat = a >> 30 & 1;
  o.fAtrProt = a >> 31 & 1;
  o.dgLeft = b & 15;
  o.dgRight = b >> 4 & 15;
  o.dgTop = b >> 8 & 15;
  o.dgBottom = b >> 12 & 15;
  o.icvLeft = b >> 16 & 127;
  o.icvRight = b >> 23 & 127;
  o.grbitDiag = b >> 30 & 3;
  o.icvTop = c & 127;
  o.icvBottom = c >> 7 & 127;
  o.icvDiag = c >> 14 & 127;
  o.dgDiag = c >> 21 & 15;
  o.icvFore = d & 127;
  o.icvBack = d >> 7 & 127;
  o.fsxButton = d >> 14 & 1;
  return o;
}
function parse_XF(blob2, length2, opts) {
  var o = {};
  o.ifnt = blob2.read_shift(2);
  o.numFmtId = blob2.read_shift(2);
  o.flags = blob2.read_shift(2);
  o.fStyle = o.flags >> 2 & 1;
  length2 -= 6;
  o.data = parse_CellStyleXF(blob2, length2, o.fStyle, opts);
  return o;
}
function write_XF(data, ixfeP, opts, o) {
  var b5 = opts && opts.biff == 5;
  if (!o)
    o = new_buf(b5 ? 16 : 20);
  o.write_shift(2, 0);
  if (data.style) {
    o.write_shift(2, data.numFmtId || 0);
    o.write_shift(2, 65524);
  } else {
    o.write_shift(2, data.numFmtId || 0);
    o.write_shift(2, ixfeP << 4);
  }
  var f = 0;
  if (data.numFmtId > 0 && b5)
    f |= 1024;
  o.write_shift(4, f);
  o.write_shift(4, 0);
  if (!b5)
    o.write_shift(4, 0);
  o.write_shift(2, 0);
  return o;
}
function parse_Guts(blob2) {
  blob2.l += 4;
  var out = [blob2.read_shift(2), blob2.read_shift(2)];
  if (out[0] !== 0)
    out[0]--;
  if (out[1] !== 0)
    out[1]--;
  if (out[0] > 7 || out[1] > 7)
    throw new Error("Bad Gutters: " + out.join("|"));
  return out;
}
function write_Guts(guts) {
  var o = new_buf(8);
  o.write_shift(4, 0);
  o.write_shift(2, guts[0] ? guts[0] + 1 : 0);
  o.write_shift(2, guts[1] ? guts[1] + 1 : 0);
  return o;
}
function parse_BoolErr(blob2, length2, opts) {
  var cell = parse_XLSCell(blob2);
  if (opts.biff == 2 || length2 == 9)
    ++blob2.l;
  var val = parse_Bes(blob2);
  cell.val = val;
  cell.t = val === true || val === false ? "b" : "e";
  return cell;
}
function write_BoolErr(R, C, v, os, opts, t) {
  var o = new_buf(8);
  write_XLSCell(R, C, os, o);
  write_Bes(v, t, o);
  return o;
}
function parse_Number(blob2, length2, opts) {
  if (opts.biffguess && opts.biff == 2)
    opts.biff = 5;
  var cell = parse_XLSCell(blob2);
  var xnum = parse_Xnum(blob2);
  cell.val = xnum;
  return cell;
}
function write_Number(R, C, v, os) {
  var o = new_buf(14);
  write_XLSCell(R, C, os, o);
  write_Xnum(v, o);
  return o;
}
var parse_XLHeaderFooter = parse_OptXLUnicodeString;
function parse_SupBook(blob2, length2, opts) {
  var end = blob2.l + length2;
  var ctab = blob2.read_shift(2);
  var cch = blob2.read_shift(2);
  opts.sbcch = cch;
  if (cch == 1025 || cch == 14849)
    return [cch, ctab];
  if (cch < 1 || cch > 255)
    throw new Error("Unexpected SupBook type: " + cch);
  var virtPath = parse_XLUnicodeStringNoCch(blob2, cch);
  var rgst = [];
  while (end > blob2.l)
    rgst.push(parse_XLUnicodeString(blob2));
  return [cch, ctab, virtPath, rgst];
}
function parse_ExternName(blob2, length2, opts) {
  var flags = blob2.read_shift(2);
  var body;
  var o = {
    fBuiltIn: flags & 1,
    fWantAdvise: flags >>> 1 & 1,
    fWantPict: flags >>> 2 & 1,
    fOle: flags >>> 3 & 1,
    fOleLink: flags >>> 4 & 1,
    cf: flags >>> 5 & 1023,
    fIcon: flags >>> 15 & 1
  };
  if (opts.sbcch === 14849)
    body = parse_AddinUdf(blob2, length2 - 2, opts);
  o.body = body || blob2.read_shift(length2 - 2);
  if (typeof body === "string")
    o.Name = body;
  return o;
}
function parse_Lbl(blob2, length2, opts) {
  var target = blob2.l + length2;
  var flags = blob2.read_shift(2);
  var chKey = blob2.read_shift(1);
  var cch = blob2.read_shift(1);
  var cce = blob2.read_shift(opts && opts.biff == 2 ? 1 : 2);
  var itab = 0;
  if (!opts || opts.biff >= 5) {
    if (opts.biff != 5)
      blob2.l += 2;
    itab = blob2.read_shift(2);
    if (opts.biff == 5)
      blob2.l += 2;
    blob2.l += 4;
  }
  var name = parse_XLUnicodeStringNoCch(blob2, cch, opts);
  if (flags & 32)
    name = XLSLblBuiltIn[name.charCodeAt(0)];
  var npflen = target - blob2.l;
  if (opts && opts.biff == 2)
    --npflen;
  var rgce = target == blob2.l || cce === 0 || !(npflen > 0) ? [] : parse_NameParsedFormula(blob2, npflen, opts, cce);
  return {
    chKey,
    Name: name,
    itab,
    rgce
  };
}
function parse_ExternSheet(blob2, length2, opts) {
  if (opts.biff < 8)
    return parse_BIFF5ExternSheet(blob2, length2, opts);
  if (!(opts.biff > 8) && length2 == blob2[blob2.l] + (blob2[blob2.l + 1] == 3 ? 1 : 0) + 1)
    return parse_BIFF5ExternSheet(blob2, length2, opts);
  var o = [], target = blob2.l + length2, len = blob2.read_shift(opts.biff > 8 ? 4 : 2);
  while (len-- !== 0)
    o.push(parse_XTI(blob2, opts.biff > 8 ? 12 : 6, opts));
  if (blob2.l != target)
    throw new Error("Bad ExternSheet: " + blob2.l + " != " + target);
  return o;
}
function parse_BIFF5ExternSheet(blob2, length2, opts) {
  if (blob2[blob2.l + 1] == 3)
    blob2[blob2.l]++;
  var o = parse_ShortXLUnicodeString(blob2, length2, opts);
  return o.charCodeAt(0) == 3 ? o.slice(1) : o;
}
function parse_NameCmt(blob2, length2, opts) {
  if (opts.biff < 8) {
    blob2.l += length2;
    return;
  }
  var cchName = blob2.read_shift(2);
  var cchComment = blob2.read_shift(2);
  var name = parse_XLUnicodeStringNoCch(blob2, cchName, opts);
  var comment2 = parse_XLUnicodeStringNoCch(blob2, cchComment, opts);
  return [name, comment2];
}
function parse_ShrFmla(blob2, length2, opts) {
  var ref = parse_RefU(blob2);
  blob2.l++;
  var cUse = blob2.read_shift(1);
  length2 -= 8;
  return [parse_SharedParsedFormula(blob2, length2, opts), cUse, ref];
}
function parse_Array(blob2, length2, opts) {
  var ref = parse_Ref(blob2);
  switch (opts.biff) {
    case 2:
      blob2.l++;
      length2 -= 7;
      break;
    case 3:
    case 4:
      blob2.l += 2;
      length2 -= 8;
      break;
    default:
      blob2.l += 6;
      length2 -= 12;
  }
  return [ref, parse_ArrayParsedFormula(blob2, length2, opts)];
}
function parse_MTRSettings(blob2) {
  var fMTREnabled = blob2.read_shift(4) !== 0;
  var fUserSetThreadCount = blob2.read_shift(4) !== 0;
  var cUserThreadCount = blob2.read_shift(4);
  return [fMTREnabled, fUserSetThreadCount, cUserThreadCount];
}
function parse_NoteSh(blob2, length2, opts) {
  if (opts.biff < 8)
    return;
  var row = blob2.read_shift(2), col = blob2.read_shift(2);
  var flags = blob2.read_shift(2), idObj = blob2.read_shift(2);
  var stAuthor = parse_XLUnicodeString2(blob2, 0, opts);
  if (opts.biff < 8)
    blob2.read_shift(1);
  return [{ r: row, c: col }, stAuthor, idObj, flags];
}
function parse_Note(blob2, length2, opts) {
  return parse_NoteSh(blob2, length2, opts);
}
function parse_MergeCells(blob2, length2) {
  var merges = [];
  var cmcs = blob2.read_shift(2);
  while (cmcs--)
    merges.push(parse_Ref8U(blob2));
  return merges;
}
function write_MergeCells(merges) {
  var o = new_buf(2 + merges.length * 8);
  o.write_shift(2, merges.length);
  for (var i = 0; i < merges.length; ++i)
    write_Ref8U(merges[i], o);
  return o;
}
function parse_Obj(blob2, length2, opts) {
  if (opts && opts.biff < 8)
    return parse_BIFF5Obj(blob2, length2, opts);
  var cmo = parse_FtCmo(blob2);
  var fts = parse_FtArray(blob2, length2 - 22, cmo[1]);
  return { cmo, ft: fts };
}
var parse_BIFF5OT = {
  8: function(blob2, length2) {
    var tgt = blob2.l + length2;
    blob2.l += 10;
    var cf = blob2.read_shift(2);
    blob2.l += 4;
    blob2.l += 2;
    blob2.l += 2;
    blob2.l += 2;
    blob2.l += 4;
    var cchName = blob2.read_shift(1);
    blob2.l += cchName;
    blob2.l = tgt;
    return { fmt: cf };
  }
};
function parse_BIFF5Obj(blob2, length2, opts) {
  blob2.l += 4;
  var ot = blob2.read_shift(2);
  var id = blob2.read_shift(2);
  var grbit = blob2.read_shift(2);
  blob2.l += 2;
  blob2.l += 2;
  blob2.l += 2;
  blob2.l += 2;
  blob2.l += 2;
  blob2.l += 2;
  blob2.l += 2;
  blob2.l += 2;
  blob2.l += 2;
  blob2.l += 6;
  length2 -= 36;
  var fts = [];
  fts.push((parse_BIFF5OT[ot] || parsenoop)(blob2, length2, opts));
  return { cmo: [id, ot, grbit], ft: fts };
}
function parse_TxO(blob2, length2, opts) {
  var s = blob2.l;
  var texts = "";
  try {
    blob2.l += 4;
    var ot = (opts.lastobj || { cmo: [0, 0] }).cmo[1];
    var controlInfo;
    if ([0, 5, 7, 11, 12, 14].indexOf(ot) == -1)
      blob2.l += 6;
    else
      controlInfo = parse_ControlInfo(blob2, 6, opts);
    var cchText = blob2.read_shift(2);
    blob2.read_shift(2);
    parseuint16(blob2, 2);
    var len = blob2.read_shift(2);
    blob2.l += len;
    for (var i = 1; i < blob2.lens.length - 1; ++i) {
      if (blob2.l - s != blob2.lens[i])
        throw new Error("TxO: bad continue record");
      var hdr = blob2[blob2.l];
      var t = parse_XLUnicodeStringNoCch(blob2, blob2.lens[i + 1] - blob2.lens[i] - 1);
      texts += t;
      if (texts.length >= (hdr ? cchText : 2 * cchText))
        break;
    }
    if (texts.length !== cchText && texts.length !== cchText * 2) {
      throw new Error("cchText: " + cchText + " != " + texts.length);
    }
    blob2.l = s + length2;
    return { t: texts };
  } catch (e) {
    blob2.l = s + length2;
    return { t: texts };
  }
}
function parse_HLink(blob2, length2) {
  var ref = parse_Ref8U(blob2);
  blob2.l += 16;
  var hlink = parse_Hyperlink(blob2, length2 - 24);
  return [ref, hlink];
}
function write_HLink(hl) {
  var O = new_buf(24);
  var ref = decode_cell(hl[0]);
  O.write_shift(2, ref.r);
  O.write_shift(2, ref.r);
  O.write_shift(2, ref.c);
  O.write_shift(2, ref.c);
  var clsid = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
  for (var i = 0; i < 16; ++i)
    O.write_shift(1, parseInt(clsid[i], 16));
  return bconcat([O, write_Hyperlink(hl[1])]);
}
function parse_HLinkTooltip(blob2, length2) {
  blob2.read_shift(2);
  var ref = parse_Ref8U(blob2);
  var wzTooltip = blob2.read_shift((length2 - 10) / 2, "dbcs-cont");
  wzTooltip = wzTooltip.replace(chr0, "");
  return [ref, wzTooltip];
}
function write_HLinkTooltip(hl) {
  var TT = hl[1].Tooltip;
  var O = new_buf(10 + 2 * (TT.length + 1));
  O.write_shift(2, 2048);
  var ref = decode_cell(hl[0]);
  O.write_shift(2, ref.r);
  O.write_shift(2, ref.r);
  O.write_shift(2, ref.c);
  O.write_shift(2, ref.c);
  for (var i = 0; i < TT.length; ++i)
    O.write_shift(2, TT.charCodeAt(i));
  O.write_shift(2, 0);
  return O;
}
function parse_Country(blob2) {
  var o = [0, 0], d;
  d = blob2.read_shift(2);
  o[0] = CountryEnum[d] || d;
  d = blob2.read_shift(2);
  o[1] = CountryEnum[d] || d;
  return o;
}
function write_Country(o) {
  if (!o)
    o = new_buf(4);
  o.write_shift(2, 1);
  o.write_shift(2, 1);
  return o;
}
function parse_ClrtClient(blob2) {
  var ccv = blob2.read_shift(2);
  var o = [];
  while (ccv-- > 0)
    o.push(parse_LongRGB(blob2));
  return o;
}
function parse_Palette(blob2) {
  var ccv = blob2.read_shift(2);
  var o = [];
  while (ccv-- > 0)
    o.push(parse_LongRGB(blob2));
  return o;
}
function parse_XFCRC(blob2) {
  blob2.l += 2;
  var o = { cxfs: 0, crc: 0 };
  o.cxfs = blob2.read_shift(2);
  o.crc = blob2.read_shift(4);
  return o;
}
function parse_ColInfo(blob2, length2, opts) {
  if (!opts.cellStyles)
    return parsenoop(blob2, length2);
  var w2 = opts && opts.biff >= 12 ? 4 : 2;
  var colFirst = blob2.read_shift(w2);
  var colLast = blob2.read_shift(w2);
  var coldx = blob2.read_shift(w2);
  var ixfe = blob2.read_shift(w2);
  var flags = blob2.read_shift(2);
  if (w2 == 2)
    blob2.l += 2;
  var o = { s: colFirst, e: colLast, w: coldx, ixfe, flags };
  if (opts.biff >= 5 || !opts.biff)
    o.level = flags >> 8 & 7;
  return o;
}
function write_ColInfo(col, idx) {
  var o = new_buf(12);
  o.write_shift(2, idx);
  o.write_shift(2, idx);
  o.write_shift(2, col.width * 256);
  o.write_shift(2, 0);
  var f = 0;
  if (col.hidden)
    f |= 1;
  o.write_shift(1, f);
  f = col.level || 0;
  o.write_shift(1, f);
  o.write_shift(2, 0);
  return o;
}
function parse_Setup(blob2, length2) {
  var o = {};
  if (length2 < 32)
    return o;
  blob2.l += 16;
  o.header = parse_Xnum(blob2);
  o.footer = parse_Xnum(blob2);
  blob2.l += 2;
  return o;
}
function parse_ShtProps(blob2, length2, opts) {
  var def = { area: false };
  if (opts.biff != 5) {
    blob2.l += length2;
    return def;
  }
  var d = blob2.read_shift(1);
  blob2.l += 3;
  if (d & 16)
    def.area = true;
  return def;
}
function write_RRTabId(n) {
  var out = new_buf(2 * n);
  for (var i = 0; i < n; ++i)
    out.write_shift(2, i + 1);
  return out;
}
var parse_Blank = parse_XLSCell;
var parse_Scl = parseuint16a;
var parse_String = parse_XLUnicodeString;
function parse_ImData(blob2) {
  var cf = blob2.read_shift(2);
  var env = blob2.read_shift(2);
  var lcb = blob2.read_shift(4);
  var o = { fmt: cf, env, len: lcb, data: blob2.slice(blob2.l, blob2.l + lcb) };
  blob2.l += lcb;
  return o;
}
function parse_BIFF2STR(blob2, length2, opts) {
  if (opts.biffguess && opts.biff == 5)
    opts.biff = 2;
  var cell = parse_XLSCell(blob2);
  ++blob2.l;
  var str = parse_XLUnicodeString2(blob2, length2 - 7, opts);
  cell.t = "str";
  cell.val = str;
  return cell;
}
function parse_BIFF2NUM(blob2) {
  var cell = parse_XLSCell(blob2);
  ++blob2.l;
  var num = parse_Xnum(blob2);
  cell.t = "n";
  cell.val = num;
  return cell;
}
function write_BIFF2NUM(r, c, val) {
  var out = new_buf(15);
  write_BIFF2Cell(out, r, c);
  out.write_shift(8, val, "f");
  return out;
}
function parse_BIFF2INT(blob2) {
  var cell = parse_XLSCell(blob2);
  ++blob2.l;
  var num = blob2.read_shift(2);
  cell.t = "n";
  cell.val = num;
  return cell;
}
function write_BIFF2INT(r, c, val) {
  var out = new_buf(9);
  write_BIFF2Cell(out, r, c);
  out.write_shift(2, val);
  return out;
}
function parse_BIFF2STRING(blob2) {
  var cch = blob2.read_shift(1);
  if (cch === 0) {
    blob2.l++;
    return "";
  }
  return blob2.read_shift(cch, "sbcs-cont");
}
function parse_BIFF2FONTXTRA(blob2, length2) {
  blob2.l += 6;
  blob2.l += 2;
  blob2.l += 1;
  blob2.l += 3;
  blob2.l += 1;
  blob2.l += length2 - 13;
}
function parse_RString(blob2, length2, opts) {
  var end = blob2.l + length2;
  var cell = parse_XLSCell(blob2);
  var cch = blob2.read_shift(2);
  var str = parse_XLUnicodeStringNoCch(blob2, cch, opts);
  blob2.l = end;
  cell.t = "str";
  cell.val = str;
  return cell;
}
var DBF_SUPPORTED_VERSIONS = [2, 3, 48, 49, 131, 139, 140, 245];
var DBF = /* @__PURE__ */ function() {
  var dbf_codepage_map = {
    /* Code Pages Supported by Visual FoxPro */
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /* shapefile DBF extension */
    /*::[*/
    0: 20127,
    /*::[*/
    8: 865,
    /*::[*/
    9: 437,
    /*::[*/
    10: 850,
    /*::[*/
    11: 437,
    /*::[*/
    13: 437,
    /*::[*/
    14: 850,
    /*::[*/
    15: 437,
    /*::[*/
    16: 850,
    /*::[*/
    17: 437,
    /*::[*/
    18: 850,
    /*::[*/
    19: 932,
    /*::[*/
    20: 850,
    /*::[*/
    21: 437,
    /*::[*/
    22: 850,
    /*::[*/
    23: 865,
    /*::[*/
    24: 437,
    /*::[*/
    25: 437,
    /*::[*/
    26: 850,
    /*::[*/
    27: 437,
    /*::[*/
    28: 863,
    /*::[*/
    29: 850,
    /*::[*/
    31: 852,
    /*::[*/
    34: 852,
    /*::[*/
    35: 852,
    /*::[*/
    36: 860,
    /*::[*/
    37: 850,
    /*::[*/
    38: 866,
    /*::[*/
    55: 850,
    /*::[*/
    64: 852,
    /*::[*/
    77: 936,
    /*::[*/
    78: 949,
    /*::[*/
    79: 950,
    /*::[*/
    80: 874,
    /*::[*/
    87: 1252,
    /*::[*/
    88: 1252,
    /*::[*/
    89: 1252,
    /*::[*/
    108: 863,
    /*::[*/
    134: 737,
    /*::[*/
    135: 852,
    /*::[*/
    136: 857,
    /*::[*/
    204: 1257,
    /*::[*/
    255: 16969
  };
  var dbf_reverse_map = evert({
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /*::[*/
    0: 20127
  });
  function dbf_to_aoa(buf, opts) {
    var out = [];
    var d = new_raw_buf(1);
    switch (opts.type) {
      case "base64":
        d = s2a(Base64_decode(buf));
        break;
      case "binary":
        d = s2a(buf);
        break;
      case "buffer":
      case "array":
        d = buf;
        break;
    }
    prep_blob(d, 0);
    var ft = d.read_shift(1);
    var memo = !!(ft & 136);
    var vfp = false, l7 = false;
    switch (ft) {
      case 2:
        break;
      case 3:
        break;
      case 48:
        vfp = true;
        memo = true;
        break;
      case 49:
        vfp = true;
        memo = true;
        break;
      case 131:
        break;
      case 139:
        break;
      case 140:
        l7 = true;
        break;
      case 245:
        break;
      default:
        throw new Error("DBF Unsupported Version: " + ft.toString(16));
    }
    var nrow = 0, fpos = 521;
    if (ft == 2)
      nrow = d.read_shift(2);
    d.l += 3;
    if (ft != 2)
      nrow = d.read_shift(4);
    if (nrow > 1048576)
      nrow = 1e6;
    if (ft != 2)
      fpos = d.read_shift(2);
    var rlen = d.read_shift(2);
    opts.codepage || 1252;
    if (ft != 2) {
      d.l += 16;
      d.read_shift(1);
      if (d[d.l] !== 0)
        dbf_codepage_map[d[d.l]];
      d.l += 1;
      d.l += 2;
    }
    if (l7)
      d.l += 36;
    var fields = [], field = {};
    var hend = Math.min(d.length, ft == 2 ? 521 : fpos - 10 - (vfp ? 264 : 0));
    var ww = l7 ? 32 : 11;
    while (d.l < hend && d[d.l] != 13) {
      field = {};
      field.name = a2s(d.slice(d.l, d.l + ww)).replace(/[\u0000\r\n].*$/g, "");
      d.l += ww;
      field.type = String.fromCharCode(d.read_shift(1));
      if (ft != 2 && !l7)
        field.offset = d.read_shift(4);
      field.len = d.read_shift(1);
      if (ft == 2)
        field.offset = d.read_shift(2);
      field.dec = d.read_shift(1);
      if (field.name.length)
        fields.push(field);
      if (ft != 2)
        d.l += l7 ? 13 : 14;
      switch (field.type) {
        case "B":
          if ((!vfp || field.len != 8) && opts.WTF)
            console.log("Skipping " + field.name + ":" + field.type);
          break;
        case "G":
        case "P":
          if (opts.WTF)
            console.log("Skipping " + field.name + ":" + field.type);
          break;
        case "+":
        case "0":
        case "@":
        case "C":
        case "D":
        case "F":
        case "I":
        case "L":
        case "M":
        case "N":
        case "O":
        case "T":
        case "Y":
          break;
        default:
          throw new Error("Unknown Field Type: " + field.type);
      }
    }
    if (d[d.l] !== 13)
      d.l = fpos - 1;
    if (d.read_shift(1) !== 13)
      throw new Error("DBF Terminator not found " + d.l + " " + d[d.l]);
    d.l = fpos;
    var R = 0, C = 0;
    out[0] = [];
    for (C = 0; C != fields.length; ++C)
      out[0][C] = fields[C].name;
    while (nrow-- > 0) {
      if (d[d.l] === 42) {
        d.l += rlen;
        continue;
      }
      ++d.l;
      out[++R] = [];
      C = 0;
      for (C = 0; C != fields.length; ++C) {
        var dd = d.slice(d.l, d.l + fields[C].len);
        d.l += fields[C].len;
        prep_blob(dd, 0);
        var s = a2s(dd);
        switch (fields[C].type) {
          case "C":
            if (s.trim().length)
              out[R][C] = s.replace(/\s+$/, "");
            break;
          case "D":
            if (s.length === 8)
              out[R][C] = new Date(+s.slice(0, 4), +s.slice(4, 6) - 1, +s.slice(6, 8));
            else
              out[R][C] = s;
            break;
          case "F":
            out[R][C] = parseFloat(s.trim());
            break;
          case "+":
          case "I":
            out[R][C] = l7 ? dd.read_shift(-4, "i") ^ 2147483648 : dd.read_shift(4, "i");
            break;
          case "L":
            switch (s.trim().toUpperCase()) {
              case "Y":
              case "T":
                out[R][C] = true;
                break;
              case "N":
              case "F":
                out[R][C] = false;
                break;
              case "":
              case "?":
                break;
              default:
                throw new Error("DBF Unrecognized L:|" + s + "|");
            }
            break;
          case "M":
            if (!memo)
              throw new Error("DBF Unexpected MEMO for type " + ft.toString(16));
            out[R][C] = "##MEMO##" + (l7 ? parseInt(s.trim(), 10) : dd.read_shift(4));
            break;
          case "N":
            s = s.replace(/\u0000/g, "").trim();
            if (s && s != ".")
              out[R][C] = +s || 0;
            break;
          case "@":
            out[R][C] = new Date(dd.read_shift(-8, "f") - 621356832e5);
            break;
          case "T":
            out[R][C] = new Date((dd.read_shift(4) - 2440588) * 864e5 + dd.read_shift(4));
            break;
          case "Y":
            out[R][C] = dd.read_shift(4, "i") / 1e4 + dd.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
            break;
          case "O":
            out[R][C] = -dd.read_shift(-8, "f");
            break;
          case "B":
            if (vfp && fields[C].len == 8) {
              out[R][C] = dd.read_shift(8, "f");
              break;
            }
          case "G":
          case "P":
            dd.l += fields[C].len;
            break;
          case "0":
            if (fields[C].name === "_NullFlags")
              break;
          default:
            throw new Error("DBF Unsupported data type " + fields[C].type);
        }
      }
    }
    if (ft != 2) {
      if (d.l < d.length && d[d.l++] != 26)
        throw new Error("DBF EOF Marker missing " + (d.l - 1) + " of " + d.length + " " + d[d.l - 1].toString(16));
    }
    if (opts && opts.sheetRows)
      out = out.slice(0, opts.sheetRows);
    opts.DBF = fields;
    return out;
  }
  function dbf_to_sheet(buf, opts) {
    var o = opts || {};
    if (!o.dateNF)
      o.dateNF = "yyyymmdd";
    var ws = aoa_to_sheet(dbf_to_aoa(buf, o), o);
    ws["!cols"] = o.DBF.map(function(field) {
      return {
        wch: field.len,
        DBF: field
      };
    });
    delete o.DBF;
    return ws;
  }
  function dbf_to_workbook(buf, opts) {
    try {
      var o = sheet_to_workbook(dbf_to_sheet(buf, opts), opts);
      o.bookType = "dbf";
      return o;
    } catch (e) {
      if (opts && opts.WTF)
        throw e;
    }
    return { SheetNames: [], Sheets: {} };
  }
  var _RLEN = { "B": 8, "C": 250, "L": 1, "D": 8, "?": 0, "": 0 };
  function sheet_to_dbf(ws, opts) {
    var o = opts || {};
    var old_cp = current_codepage;
    if (+o.codepage >= 0)
      set_cp(+o.codepage);
    if (o.type == "string")
      throw new Error("Cannot write DBF to JS string");
    var ba = buf_array();
    var aoa = sheet_to_json(ws, { header: 1, raw: true, cellDates: true });
    var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];
    var i = 0, j = 0, hcnt = 0, rlen = 1;
    for (i = 0; i < headers.length; ++i) {
      if (((cols[i] || {}).DBF || {}).name) {
        headers[i] = cols[i].DBF.name;
        ++hcnt;
        continue;
      }
      if (headers[i] == null)
        continue;
      ++hcnt;
      if (typeof headers[i] === "number")
        headers[i] = headers[i].toString(10);
      if (typeof headers[i] !== "string")
        throw new Error("DBF Invalid column name " + headers[i] + " |" + typeof headers[i] + "|");
      if (headers.indexOf(headers[i]) !== i) {
        for (j = 0; j < 1024; ++j)
          if (headers.indexOf(headers[i] + "_" + j) == -1) {
            headers[i] += "_" + j;
            break;
          }
      }
    }
    var range = safe_decode_range(ws["!ref"]);
    var coltypes = [];
    var colwidths = [];
    var coldecimals = [];
    for (i = 0; i <= range.e.c - range.s.c; ++i) {
      var guess = "", _guess = "", maxlen = 0;
      var col = [];
      for (j = 0; j < data.length; ++j) {
        if (data[j][i] != null)
          col.push(data[j][i]);
      }
      if (col.length == 0 || headers[i] == null) {
        coltypes[i] = "?";
        continue;
      }
      for (j = 0; j < col.length; ++j) {
        switch (typeof col[j]) {
          case "number":
            _guess = "B";
            break;
          case "string":
            _guess = "C";
            break;
          case "boolean":
            _guess = "L";
            break;
          case "object":
            _guess = col[j] instanceof Date ? "D" : "C";
            break;
          default:
            _guess = "C";
        }
        maxlen = Math.max(maxlen, String(col[j]).length);
        guess = guess && guess != _guess ? "C" : _guess;
      }
      if (maxlen > 250)
        maxlen = 250;
      _guess = ((cols[i] || {}).DBF || {}).type;
      if (_guess == "C") {
        if (cols[i].DBF.len > maxlen)
          maxlen = cols[i].DBF.len;
      }
      if (guess == "B" && _guess == "N") {
        guess = "N";
        coldecimals[i] = cols[i].DBF.dec;
        maxlen = cols[i].DBF.len;
      }
      colwidths[i] = guess == "C" || _guess == "N" ? maxlen : _RLEN[guess] || 0;
      rlen += colwidths[i];
      coltypes[i] = guess;
    }
    var h = ba.next(32);
    h.write_shift(4, 318902576);
    h.write_shift(4, data.length);
    h.write_shift(2, 296 + 32 * hcnt);
    h.write_shift(2, rlen);
    for (i = 0; i < 4; ++i)
      h.write_shift(4, 0);
    var cp = +dbf_reverse_map[
      /*::String(*/
      current_codepage
      /*::)*/
    ] || 3;
    h.write_shift(4, 0 | cp << 8);
    if (dbf_codepage_map[cp] != +o.codepage) {
      if (o.codepage)
        console.error("DBF Unsupported codepage " + current_codepage + ", using 1252");
      current_codepage = 1252;
    }
    for (i = 0, j = 0; i < headers.length; ++i) {
      if (headers[i] == null)
        continue;
      var hf = ba.next(32);
      var _f = (headers[i].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
      hf.write_shift(1, _f, "sbcs");
      hf.write_shift(1, coltypes[i] == "?" ? "C" : coltypes[i], "sbcs");
      hf.write_shift(4, j);
      hf.write_shift(1, colwidths[i] || _RLEN[coltypes[i]] || 0);
      hf.write_shift(1, coldecimals[i] || 0);
      hf.write_shift(1, 2);
      hf.write_shift(4, 0);
      hf.write_shift(1, 0);
      hf.write_shift(4, 0);
      hf.write_shift(4, 0);
      j += colwidths[i] || _RLEN[coltypes[i]] || 0;
    }
    var hb = ba.next(264);
    hb.write_shift(4, 13);
    for (i = 0; i < 65; ++i)
      hb.write_shift(4, 0);
    for (i = 0; i < data.length; ++i) {
      var rout = ba.next(rlen);
      rout.write_shift(1, 0);
      for (j = 0; j < headers.length; ++j) {
        if (headers[j] == null)
          continue;
        switch (coltypes[j]) {
          case "L":
            rout.write_shift(1, data[i][j] == null ? 63 : data[i][j] ? 84 : 70);
            break;
          case "B":
            rout.write_shift(8, data[i][j] || 0, "f");
            break;
          case "N":
            var _n = "0";
            if (typeof data[i][j] == "number")
              _n = data[i][j].toFixed(coldecimals[j] || 0);
            if (_n.length > colwidths[j])
              _n = _n.slice(0, colwidths[j]);
            for (hcnt = 0; hcnt < colwidths[j] - _n.length; ++hcnt)
              rout.write_shift(1, 32);
            rout.write_shift(1, _n, "sbcs");
            break;
          case "D":
            if (!data[i][j])
              rout.write_shift(8, "00000000", "sbcs");
            else {
              rout.write_shift(4, ("0000" + data[i][j].getFullYear()).slice(-4), "sbcs");
              rout.write_shift(2, ("00" + (data[i][j].getMonth() + 1)).slice(-2), "sbcs");
              rout.write_shift(2, ("00" + data[i][j].getDate()).slice(-2), "sbcs");
            }
            break;
          case "C":
            var _l = rout.l;
            var _s = String(data[i][j] != null ? data[i][j] : "").slice(0, colwidths[j]);
            rout.write_shift(1, _s, "cpstr");
            _l += colwidths[j] - rout.l;
            for (hcnt = 0; hcnt < _l; ++hcnt)
              rout.write_shift(1, 32);
            break;
        }
      }
    }
    current_codepage = old_cp;
    ba.next(1).write_shift(1, 26);
    return ba.end();
  }
  return {
    to_workbook: dbf_to_workbook,
    to_sheet: dbf_to_sheet,
    from_sheet: sheet_to_dbf
  };
}();
var SYLK = /* @__PURE__ */ function() {
  var sylk_escapes = {
    AA: "À",
    BA: "Á",
    CA: "Â",
    DA: 195,
    HA: "Ä",
    JA: 197,
    AE: "È",
    BE: "É",
    CE: "Ê",
    HE: "Ë",
    AI: "Ì",
    BI: "Í",
    CI: "Î",
    HI: "Ï",
    AO: "Ò",
    BO: "Ó",
    CO: "Ô",
    DO: 213,
    HO: "Ö",
    AU: "Ù",
    BU: "Ú",
    CU: "Û",
    HU: "Ü",
    Aa: "à",
    Ba: "á",
    Ca: "â",
    Da: 227,
    Ha: "ä",
    Ja: 229,
    Ae: "è",
    Be: "é",
    Ce: "ê",
    He: "ë",
    Ai: "ì",
    Bi: "í",
    Ci: "î",
    Hi: "ï",
    Ao: "ò",
    Bo: "ó",
    Co: "ô",
    Do: 245,
    Ho: "ö",
    Au: "ù",
    Bu: "ú",
    Cu: "û",
    Hu: "ü",
    KC: "Ç",
    Kc: "ç",
    q: "æ",
    z: "œ",
    a: "Æ",
    j: "Œ",
    DN: 209,
    Dn: 241,
    Hy: 255,
    S: 169,
    c: 170,
    R: 174,
    "B ": 180,
    /*::[*/
    0: 176,
    /*::[*/
    1: 177,
    /*::[*/
    2: 178,
    /*::[*/
    3: 179,
    /*::[*/
    5: 181,
    /*::[*/
    6: 182,
    /*::[*/
    7: 183,
    Q: 185,
    k: 186,
    b: 208,
    i: 216,
    l: 222,
    s: 240,
    y: 248,
    "!": 161,
    '"': 162,
    "#": 163,
    "(": 164,
    "%": 165,
    "'": 167,
    "H ": 168,
    "+": 171,
    ";": 187,
    "<": 188,
    "=": 189,
    ">": 190,
    "?": 191,
    "{": 223
  };
  var sylk_char_regex = new RegExp("\x1BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm");
  var sylk_char_fn = function(_, $1) {
    var o = sylk_escapes[$1];
    return typeof o == "number" ? _getansi(o) : o;
  };
  var decode_sylk_char = function($$, $1, $2) {
    var newcc = $1.charCodeAt(0) - 32 << 4 | $2.charCodeAt(0) - 48;
    return newcc == 59 ? $$ : _getansi(newcc);
  };
  sylk_escapes["|"] = 254;
  function sylk_to_aoa(d, opts) {
    switch (opts.type) {
      case "base64":
        return sylk_to_aoa_str(Base64_decode(d), opts);
      case "binary":
        return sylk_to_aoa_str(d, opts);
      case "buffer":
        return sylk_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
      case "array":
        return sylk_to_aoa_str(cc2str(d), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function sylk_to_aoa_str(str, opts) {
    var records = str.split(/[\n\r]+/), R = -1, C = -1, ri = 0, rj = 0, arr = [];
    var formats = [];
    var next_cell_format = null;
    var sht = {}, rowinfo = [], colinfo = [], cw = [];
    var Mval = 0, j;
    var wb = { Workbook: { WBProps: {}, Names: [] } };
    if (+opts.codepage >= 0)
      set_cp(+opts.codepage);
    for (; ri !== records.length; ++ri) {
      Mval = 0;
      var rstr = records[ri].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);
      var record = rstr.replace(/;;/g, "\0").split(";").map(function(x) {
        return x.replace(/\u0000/g, ";");
      });
      var RT = record[0], val;
      if (rstr.length > 0)
        switch (RT) {
          case "ID":
            break;
          case "E":
            break;
          case "B":
            break;
          case "O":
            for (rj = 1; rj < record.length; ++rj)
              switch (record[rj].charAt(0)) {
                case "V":
                  {
                    var d1904 = parseInt(record[rj].slice(1), 10);
                    if (d1904 >= 1 && d1904 <= 4)
                      wb.Workbook.WBProps.date1904 = true;
                  }
                  break;
              }
            break;
          case "W":
            break;
          case "P":
            switch (record[1].charAt(0)) {
              case "P":
                formats.push(rstr.slice(3).replace(/;;/g, ";"));
                break;
            }
            break;
          case "NN":
            {
              var nn = { Sheet: 0 };
              for (rj = 1; rj < record.length; ++rj)
                switch (record[rj].charAt(0)) {
                  case "N":
                    nn.Name = record[rj].slice(1);
                    break;
                  case "E":
                    nn.Ref = (opts && opts.sheet || "Sheet1") + "!" + rc_to_a1(record[rj].slice(1));
                    break;
                }
              wb.Workbook.Names.push(nn);
            }
            break;
          case "C":
            var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1, formula = "", cell_t = "z";
            for (rj = 1; rj < record.length; ++rj)
              switch (record[rj].charAt(0)) {
                case "A":
                  break;
                case "X":
                  C = parseInt(record[rj].slice(1), 10) - 1;
                  C_seen_X = true;
                  break;
                case "Y":
                  R = parseInt(record[rj].slice(1), 10) - 1;
                  if (!C_seen_X)
                    C = 0;
                  for (j = arr.length; j <= R; ++j)
                    arr[j] = [];
                  break;
                case "K":
                  val = record[rj].slice(1);
                  if (val.charAt(0) === '"') {
                    val = val.slice(1, val.length - 1);
                    cell_t = "s";
                  } else if (val === "TRUE" || val === "FALSE") {
                    val = val === "TRUE";
                    cell_t = "b";
                  } else if (!isNaN(fuzzynum(val))) {
                    val = fuzzynum(val);
                    cell_t = "n";
                    if (next_cell_format !== null && fmt_is_date(next_cell_format) && opts.cellDates) {
                      val = numdate(wb.Workbook.WBProps.date1904 ? val + 1462 : val);
                      cell_t = "d";
                    }
                  } else if (!isNaN(fuzzydate(val).getDate())) {
                    val = parseDate(val);
                    cell_t = "d";
                    if (!opts.cellDates) {
                      cell_t = "n";
                      val = datenum(val, wb.Workbook.WBProps.date1904);
                    }
                  }
                  C_seen_K = true;
                  break;
                case "E":
                  C_seen_E = true;
                  formula = rc_to_a1(record[rj].slice(1), { r: R, c: C });
                  break;
                case "S":
                  C_seen_S = true;
                  break;
                case "G":
                  break;
                case "R":
                  _R = parseInt(record[rj].slice(1), 10) - 1;
                  break;
                case "C":
                  _C = parseInt(record[rj].slice(1), 10) - 1;
                  break;
                default:
                  if (opts && opts.WTF)
                    throw new Error("SYLK bad record " + rstr);
              }
            if (C_seen_K) {
              if (!arr[R][C])
                arr[R][C] = { t: cell_t, v: val };
              else {
                arr[R][C].t = cell_t;
                arr[R][C].v = val;
              }
              if (next_cell_format)
                arr[R][C].z = next_cell_format;
              if (opts.cellText !== false && next_cell_format)
                arr[R][C].w = SSF_format(arr[R][C].z, arr[R][C].v, { date1904: wb.Workbook.WBProps.date1904 });
              next_cell_format = null;
            }
            if (C_seen_S) {
              if (C_seen_E)
                throw new Error("SYLK shared formula cannot have own formula");
              var shrbase = _R > -1 && arr[_R][_C];
              if (!shrbase || !shrbase[1])
                throw new Error("SYLK shared formula cannot find base");
              formula = shift_formula_str(shrbase[1], { r: R - _R, c: C - _C });
            }
            if (formula) {
              if (!arr[R][C])
                arr[R][C] = { t: "n", f: formula };
              else
                arr[R][C].f = formula;
            }
            break;
          case "F":
            var F_seen = 0;
            for (rj = 1; rj < record.length; ++rj)
              switch (record[rj].charAt(0)) {
                case "X":
                  C = parseInt(record[rj].slice(1), 10) - 1;
                  ++F_seen;
                  break;
                case "Y":
                  R = parseInt(record[rj].slice(1), 10) - 1;
                  for (j = arr.length; j <= R; ++j)
                    arr[j] = [];
                  break;
                case "M":
                  Mval = parseInt(record[rj].slice(1), 10) / 20;
                  break;
                case "F":
                  break;
                case "G":
                  break;
                case "P":
                  next_cell_format = formats[parseInt(record[rj].slice(1), 10)];
                  break;
                case "S":
                  break;
                case "D":
                  break;
                case "N":
                  break;
                case "W":
                  cw = record[rj].slice(1).split(" ");
                  for (j = parseInt(cw[0], 10); j <= parseInt(cw[1], 10); ++j) {
                    Mval = parseInt(cw[2], 10);
                    colinfo[j - 1] = Mval === 0 ? { hidden: true } : { wch: Mval };
                  }
                  break;
                case "C":
                  C = parseInt(record[rj].slice(1), 10) - 1;
                  if (!colinfo[C])
                    colinfo[C] = {};
                  break;
                case "R":
                  R = parseInt(record[rj].slice(1), 10) - 1;
                  if (!rowinfo[R])
                    rowinfo[R] = {};
                  if (Mval > 0) {
                    rowinfo[R].hpt = Mval;
                    rowinfo[R].hpx = pt2px(Mval);
                  } else if (Mval === 0)
                    rowinfo[R].hidden = true;
                  break;
                default:
                  if (opts && opts.WTF)
                    throw new Error("SYLK bad record " + rstr);
              }
            if (F_seen < 1)
              next_cell_format = null;
            break;
          default:
            if (opts && opts.WTF)
              throw new Error("SYLK bad record " + rstr);
        }
    }
    if (rowinfo.length > 0)
      sht["!rows"] = rowinfo;
    if (colinfo.length > 0)
      sht["!cols"] = colinfo;
    colinfo.forEach(function(col) {
      process_col(col);
    });
    if (opts && opts.sheetRows)
      arr = arr.slice(0, opts.sheetRows);
    return [arr, sht, wb];
  }
  function sylk_to_workbook(d, opts) {
    var aoasht = sylk_to_aoa(d, opts);
    var aoa = aoasht[0], ws = aoasht[1], wb = aoasht[2];
    var _opts = dup(opts);
    _opts.date1904 = (((wb || {}).Workbook || {}).WBProps || {}).date1904;
    var o = aoa_to_sheet(aoa, _opts);
    keys(ws).forEach(function(k) {
      o[k] = ws[k];
    });
    var outwb = sheet_to_workbook(o, opts);
    keys(wb).forEach(function(k) {
      outwb[k] = wb[k];
    });
    outwb.bookType = "sylk";
    return outwb;
  }
  function write_ws_cell_sylk(cell, ws, R, C) {
    var o = "C;Y" + (R + 1) + ";X" + (C + 1) + ";K";
    switch (cell.t) {
      case "n":
        o += cell.v || 0;
        if (cell.f && !cell.F)
          o += ";E" + a1_to_rc(cell.f, { r: R, c: C });
        break;
      case "b":
        o += cell.v ? "TRUE" : "FALSE";
        break;
      case "e":
        o += cell.w || cell.v;
        break;
      case "d":
        o += '"' + (cell.w || cell.v) + '"';
        break;
      case "s":
        o += '"' + (cell.v == null ? "" : String(cell.v)).replace(/"/g, "").replace(/;/g, ";;") + '"';
        break;
    }
    return o;
  }
  function write_ws_cols_sylk(out, cols) {
    cols.forEach(function(col, i) {
      var rec = "F;W" + (i + 1) + " " + (i + 1) + " ";
      if (col.hidden)
        rec += "0";
      else {
        if (typeof col.width == "number" && !col.wpx)
          col.wpx = width2px(col.width);
        if (typeof col.wpx == "number" && !col.wch)
          col.wch = px2char(col.wpx);
        if (typeof col.wch == "number")
          rec += Math.round(col.wch);
      }
      if (rec.charAt(rec.length - 1) != " ")
        out.push(rec);
    });
  }
  function write_ws_rows_sylk(out, rows) {
    rows.forEach(function(row, i) {
      var rec = "F;";
      if (row.hidden)
        rec += "M0;";
      else if (row.hpt)
        rec += "M" + 20 * row.hpt + ";";
      else if (row.hpx)
        rec += "M" + 20 * px2pt(row.hpx) + ";";
      if (rec.length > 2)
        out.push(rec + "R" + (i + 1));
    });
  }
  function sheet_to_sylk(ws, opts, wb) {
    var preamble = ["ID;PSheetJS;N;E"], o = [];
    var r = safe_decode_range(ws["!ref"]), cell;
    var dense = ws["!data"] != null;
    var RS = "\r\n";
    var d1904 = (((wb || {}).Workbook || {}).WBProps || {}).date1904;
    preamble.push("P;PGeneral");
    preamble.push("F;P0;DG0G8;M255");
    if (ws["!cols"])
      write_ws_cols_sylk(preamble, ws["!cols"]);
    if (ws["!rows"])
      write_ws_rows_sylk(preamble, ws["!rows"]);
    preamble.push("B;Y" + (r.e.r - r.s.r + 1) + ";X" + (r.e.c - r.s.c + 1) + ";D" + [r.s.c, r.s.r, r.e.c, r.e.r].join(" "));
    preamble.push("O;L;D;B" + (d1904 ? ";V4" : "") + ";K47;G100 0.001");
    for (var R = r.s.r; R <= r.e.r; ++R) {
      if (dense && !ws["!data"][R])
        continue;
      var p = [];
      for (var C = r.s.c; C <= r.e.c; ++C) {
        cell = dense ? ws["!data"][R][C] : ws[encode_col(C) + encode_row(R)];
        if (!cell || cell.v == null && (!cell.f || cell.F))
          continue;
        p.push(write_ws_cell_sylk(cell, ws, R, C));
      }
      o.push(p.join(RS));
    }
    return preamble.join(RS) + RS + o.join(RS) + RS + "E" + RS;
  }
  return {
    to_workbook: sylk_to_workbook,
    from_sheet: sheet_to_sylk
  };
}();
var DIF = /* @__PURE__ */ function() {
  function dif_to_aoa(d, opts) {
    switch (opts.type) {
      case "base64":
        return dif_to_aoa_str(Base64_decode(d), opts);
      case "binary":
        return dif_to_aoa_str(d, opts);
      case "buffer":
        return dif_to_aoa_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
      case "array":
        return dif_to_aoa_str(cc2str(d), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function dif_to_aoa_str(str, opts) {
    var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
    for (; ri !== records.length; ++ri) {
      if (records[ri].trim() === "BOT") {
        arr[++R] = [];
        C = 0;
        continue;
      }
      if (R < 0)
        continue;
      var metadata = records[ri].trim().split(",");
      var type = metadata[0], value = metadata[1];
      ++ri;
      var data = records[ri] || "";
      while ((data.match(/["]/g) || []).length & 1 && ri < records.length - 1)
        data += "\n" + records[++ri];
      data = data.trim();
      switch (+type) {
        case -1:
          if (data === "BOT") {
            arr[++R] = [];
            C = 0;
            continue;
          } else if (data !== "EOD")
            throw new Error("Unrecognized DIF special command " + data);
          break;
        case 0:
          if (data === "TRUE")
            arr[R][C] = true;
          else if (data === "FALSE")
            arr[R][C] = false;
          else if (!isNaN(fuzzynum(value)))
            arr[R][C] = fuzzynum(value);
          else if (!isNaN(fuzzydate(value).getDate()))
            arr[R][C] = parseDate(value);
          else
            arr[R][C] = value;
          ++C;
          break;
        case 1:
          data = data.slice(1, data.length - 1);
          data = data.replace(/""/g, '"');
          if (data && data.match(/^=".*"$/))
            data = data.slice(2, -1);
          arr[R][C++] = data !== "" ? data : null;
          break;
      }
      if (data === "EOD")
        break;
    }
    if (opts && opts.sheetRows)
      arr = arr.slice(0, opts.sheetRows);
    return arr;
  }
  function dif_to_sheet(str, opts) {
    return aoa_to_sheet(dif_to_aoa(str, opts), opts);
  }
  function dif_to_workbook(str, opts) {
    var o = sheet_to_workbook(dif_to_sheet(str, opts), opts);
    o.bookType = "dif";
    return o;
  }
  function make_value(v, s) {
    return "0," + String(v) + "\r\n" + s;
  }
  function make_value_str(s) {
    return '1,0\r\n"' + s.replace(/"/g, '""') + '"';
  }
  function sheet_to_dif(ws) {
    var r = safe_decode_range(ws["!ref"]);
    var dense = ws["!data"] != null;
    var o = [
      'TABLE\r\n0,1\r\n"sheetjs"\r\n',
      "VECTORS\r\n0," + (r.e.r - r.s.r + 1) + '\r\n""\r\n',
      "TUPLES\r\n0," + (r.e.c - r.s.c + 1) + '\r\n""\r\n',
      'DATA\r\n0,0\r\n""\r\n'
    ];
    for (var R = r.s.r; R <= r.e.r; ++R) {
      var row = dense ? ws["!data"][R] : [];
      var p = "-1,0\r\nBOT\r\n";
      for (var C = r.s.c; C <= r.e.c; ++C) {
        var cell = dense ? row && row[C] : ws[encode_cell({ r: R, c: C })];
        if (cell == null) {
          p += '1,0\r\n""\r\n';
          continue;
        }
        switch (cell.t) {
          case "n":
            {
              if (cell.w != null)
                p += "0," + cell.w + "\r\nV";
              else if (cell.v != null)
                p += make_value(cell.v, "V");
              else if (cell.f != null && !cell.F)
                p += make_value_str("=" + cell.f);
              else
                p += '1,0\r\n""';
            }
            break;
          case "b":
            p += cell.v ? make_value(1, "TRUE") : make_value(0, "FALSE");
            break;
          case "s":
            p += make_value_str(isNaN(+cell.v) ? cell.v : '="' + cell.v + '"');
            break;
          case "d":
            if (!cell.w)
              cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));
            p += make_value(cell.w, "V");
            break;
          default:
            p += '1,0\r\n""';
        }
        p += "\r\n";
      }
      o.push(p);
    }
    return o.join("") + "-1,0\r\nEOD";
  }
  return {
    to_workbook: dif_to_workbook,
    to_sheet: dif_to_sheet,
    from_sheet: sheet_to_dif
  };
}();
var ETH = /* @__PURE__ */ function() {
  function decode(s) {
    return s.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, "\n");
  }
  function encode(s) {
    return s.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
  }
  function eth_to_aoa(str, opts) {
    var records = str.split("\n"), R = -1, C = -1, ri = 0, arr = [];
    for (; ri !== records.length; ++ri) {
      var record = records[ri].trim().split(":");
      if (record[0] !== "cell")
        continue;
      var addr = decode_cell(record[1]);
      if (arr.length <= addr.r) {
        for (R = arr.length; R <= addr.r; ++R)
          if (!arr[R])
            arr[R] = [];
      }
      R = addr.r;
      C = addr.c;
      switch (record[2]) {
        case "t":
          arr[R][C] = decode(record[3]);
          break;
        case "v":
          arr[R][C] = +record[3];
          break;
        case "vtf":
          var _f = record[record.length - 1];
        case "vtc":
          switch (record[3]) {
            case "nl":
              arr[R][C] = +record[4] ? true : false;
              break;
            default:
              arr[R][C] = +record[4];
              break;
          }
          if (record[2] == "vtf")
            arr[R][C] = [arr[R][C], _f];
      }
    }
    if (opts && opts.sheetRows)
      arr = arr.slice(0, opts.sheetRows);
    return arr;
  }
  function eth_to_sheet(d, opts) {
    return aoa_to_sheet(eth_to_aoa(d, opts), opts);
  }
  function eth_to_workbook(d, opts) {
    return sheet_to_workbook(eth_to_sheet(d, opts), opts);
  }
  var header = [
    "socialcalc:version:1.5",
    "MIME-Version: 1.0",
    "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
  ].join("\n");
  var sep = [
    "--SocialCalcSpreadsheetControlSave",
    "Content-type: text/plain; charset=UTF-8"
  ].join("\n") + "\n";
  var meta = [
    "# SocialCalc Spreadsheet Control Save",
    "part:sheet"
  ].join("\n");
  var end = "--SocialCalcSpreadsheetControlSave--";
  function sheet_to_eth_data(ws) {
    if (!ws || !ws["!ref"])
      return "";
    var o = [], oo = [], cell, coord = "";
    var r = decode_range(ws["!ref"]);
    var dense = ws["!data"] != null;
    for (var R = r.s.r; R <= r.e.r; ++R) {
      for (var C = r.s.c; C <= r.e.c; ++C) {
        coord = encode_cell({ r: R, c: C });
        cell = dense ? (ws["!data"][R] || [])[C] : ws[coord];
        if (!cell || cell.v == null || cell.t === "z")
          continue;
        oo = ["cell", coord, "t"];
        switch (cell.t) {
          case "s":
          case "str":
            oo.push(encode(cell.v));
            break;
          case "n":
            if (!cell.f) {
              oo[2] = "v";
              oo[3] = cell.v;
            } else {
              oo[2] = "vtf";
              oo[3] = "n";
              oo[4] = cell.v;
              oo[5] = encode(cell.f);
            }
            break;
          case "b":
            oo[2] = "vt" + (cell.f ? "f" : "c");
            oo[3] = "nl";
            oo[4] = cell.v ? "1" : "0";
            oo[5] = encode(cell.f || (cell.v ? "TRUE" : "FALSE"));
            break;
          case "d":
            var t = datenum(parseDate(cell.v));
            oo[2] = "vtc";
            oo[3] = "nd";
            oo[4] = "" + t;
            oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t);
            break;
          case "e":
            continue;
        }
        o.push(oo.join(":"));
      }
    }
    o.push("sheet:c:" + (r.e.c - r.s.c + 1) + ":r:" + (r.e.r - r.s.r + 1) + ":tvf:1");
    o.push("valueformat:1:text-wiki");
    return o.join("\n");
  }
  function sheet_to_eth(ws) {
    return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");
  }
  return {
    to_workbook: eth_to_workbook,
    to_sheet: eth_to_sheet,
    from_sheet: sheet_to_eth
  };
}();
var PRN = /* @__PURE__ */ function() {
  function set_text_arr(data, arr, R, C, o) {
    if (o.raw)
      arr[R][C] = data;
    else if (data === "")
      ;
    else if (data === "TRUE")
      arr[R][C] = true;
    else if (data === "FALSE")
      arr[R][C] = false;
    else if (!isNaN(fuzzynum(data)))
      arr[R][C] = fuzzynum(data);
    else if (!isNaN(fuzzydate(data).getDate()))
      arr[R][C] = parseDate(data);
    else
      arr[R][C] = data;
  }
  function prn_to_aoa_str(f, opts) {
    var o = opts || {};
    var arr = [];
    if (!f || f.length === 0)
      return arr;
    var lines = f.split(/[\r\n]/);
    var L = lines.length - 1;
    while (L >= 0 && lines[L].length === 0)
      --L;
    var start = 10, idx = 0;
    var R = 0;
    for (; R <= L; ++R) {
      idx = lines[R].indexOf(" ");
      if (idx == -1)
        idx = lines[R].length;
      else
        idx++;
      start = Math.max(start, idx);
    }
    for (R = 0; R <= L; ++R) {
      arr[R] = [];
      var C = 0;
      set_text_arr(lines[R].slice(0, start).trim(), arr, R, C, o);
      for (C = 1; C <= (lines[R].length - start) / 10 + 1; ++C)
        set_text_arr(lines[R].slice(start + (C - 1) * 10, start + C * 10).trim(), arr, R, C, o);
    }
    if (o.sheetRows)
      arr = arr.slice(0, o.sheetRows);
    return arr;
  }
  var guess_seps = {
    /*::[*/
    44: ",",
    /*::[*/
    9: "	",
    /*::[*/
    59: ";",
    /*::[*/
    124: "|"
  };
  var guess_sep_weights = {
    /*::[*/
    44: 3,
    /*::[*/
    9: 2,
    /*::[*/
    59: 1,
    /*::[*/
    124: 0
  };
  function guess_sep(str) {
    var cnt = {}, instr = false, end = 0, cc = 0;
    for (; end < str.length; ++end) {
      if ((cc = str.charCodeAt(end)) == 34)
        instr = !instr;
      else if (!instr && cc in guess_seps)
        cnt[cc] = (cnt[cc] || 0) + 1;
    }
    cc = [];
    for (end in cnt)
      if (Object.prototype.hasOwnProperty.call(cnt, end)) {
        cc.push([cnt[end], end]);
      }
    if (!cc.length) {
      cnt = guess_sep_weights;
      for (end in cnt)
        if (Object.prototype.hasOwnProperty.call(cnt, end)) {
          cc.push([cnt[end], end]);
        }
    }
    cc.sort(function(a, b) {
      return a[0] - b[0] || guess_sep_weights[a[1]] - guess_sep_weights[b[1]];
    });
    return guess_seps[cc.pop()[1]] || 44;
  }
  function dsv_to_sheet_str(str, opts) {
    var o = opts || {};
    var sep = "";
    var ws = {};
    if (o.dense)
      ws["!data"] = [];
    var range = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    if (str.slice(0, 4) == "sep=") {
      if (str.charCodeAt(5) == 13 && str.charCodeAt(6) == 10) {
        sep = str.charAt(4);
        str = str.slice(7);
      } else if (str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10) {
        sep = str.charAt(4);
        str = str.slice(6);
      } else
        sep = guess_sep(str.slice(0, 1024));
    } else if (o && o.FS)
      sep = o.FS;
    else
      sep = guess_sep(str.slice(0, 1024));
    var R = 0, C = 0, v = 0;
    var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc = 0, startcc = str.charCodeAt(0);
    var _re = o.dateNF != null ? dateNF_regex(o.dateNF) : null;
    function finish_cell() {
      var s = str.slice(start, end);
      if (s.slice(-1) == "\r")
        s = s.slice(0, -1);
      var cell = {};
      if (s.charAt(0) == '"' && s.charAt(s.length - 1) == '"')
        s = s.slice(1, -1).replace(/""/g, '"');
      if (s.length === 0)
        cell.t = "z";
      else if (o.raw) {
        cell.t = "s";
        cell.v = s;
      } else if (s.trim().length === 0) {
        cell.t = "s";
        cell.v = s;
      } else if (s.charCodeAt(0) == 61) {
        if (s.charCodeAt(1) == 34 && s.charCodeAt(s.length - 1) == 34) {
          cell.t = "s";
          cell.v = s.slice(2, -1).replace(/""/g, '"');
        } else if (fuzzyfmla(s)) {
          cell.t = "n";
          cell.f = s.slice(1);
        } else {
          cell.t = "s";
          cell.v = s;
        }
      } else if (s == "TRUE") {
        cell.t = "b";
        cell.v = true;
      } else if (s == "FALSE") {
        cell.t = "b";
        cell.v = false;
      } else if (!isNaN(v = fuzzynum(s))) {
        cell.t = "n";
        if (o.cellText !== false)
          cell.w = s;
        cell.v = v;
      } else if (!isNaN((v = fuzzydate(s)).getDate()) || _re && s.match(_re)) {
        cell.z = o.dateNF || table_fmt[14];
        var k = 0;
        if (_re && s.match(_re)) {
          s = dateNF_fix(s, o.dateNF, s.match(_re) || []);
          k = 1;
          v = parseDate(s, k);
        }
        if (o.cellDates) {
          cell.t = "d";
          cell.v = v;
        } else {
          cell.t = "n";
          cell.v = datenum(v);
        }
        if (o.cellText !== false)
          cell.w = SSF_format(cell.z, cell.v instanceof Date ? datenum(cell.v) : cell.v);
        if (!o.cellNF)
          delete cell.z;
      } else {
        cell.t = "s";
        cell.v = s;
      }
      if (cell.t == "z")
        ;
      else if (o.dense) {
        if (!ws["!data"][R])
          ws["!data"][R] = [];
        ws["!data"][R][C] = cell;
      } else
        ws[encode_cell({ c: C, r: R })] = cell;
      start = end + 1;
      startcc = str.charCodeAt(start);
      if (range.e.c < C)
        range.e.c = C;
      if (range.e.r < R)
        range.e.r = R;
      if (cc == sepcc)
        ++C;
      else {
        C = 0;
        ++R;
        if (o.sheetRows && o.sheetRows <= R)
          return true;
      }
    }
    outer:
      for (; end < str.length; ++end)
        switch (cc = str.charCodeAt(end)) {
          case 34:
            if (startcc === 34)
              instr = !instr;
            break;
          case 13:
            if (instr)
              break;
            if (str.charCodeAt(end + 1) == 10)
              ++end;
          case sepcc:
          case 10:
            if (!instr && finish_cell())
              break outer;
            break;
        }
    if (end - start > 0)
      finish_cell();
    ws["!ref"] = encode_range(range);
    return ws;
  }
  function prn_to_sheet_str(str, opts) {
    if (!(opts && opts.PRN))
      return dsv_to_sheet_str(str, opts);
    if (opts.FS)
      return dsv_to_sheet_str(str, opts);
    if (str.slice(0, 4) == "sep=")
      return dsv_to_sheet_str(str, opts);
    if (str.indexOf("	") >= 0 || str.indexOf(",") >= 0 || str.indexOf(";") >= 0)
      return dsv_to_sheet_str(str, opts);
    return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);
  }
  function prn_to_sheet(d, opts) {
    var str = "", bytes = opts.type == "string" ? [0, 0, 0, 0] : firstbyte(d, opts);
    switch (opts.type) {
      case "base64":
        str = Base64_decode(d);
        break;
      case "binary":
        str = d;
        break;
      case "buffer":
        if (opts.codepage == 65001)
          str = d.toString("utf8");
        else if (opts.codepage && typeof $cptable !== "undefined")
          str = $cptable.utils.decode(opts.codepage, d);
        else
          str = has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d);
        break;
      case "array":
        str = cc2str(d);
        break;
      case "string":
        str = d;
        break;
      default:
        throw new Error("Unrecognized type " + opts.type);
    }
    if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191)
      str = utf8read(str.slice(3));
    else if (opts.type != "string" && opts.type != "buffer" && opts.codepage == 65001)
      str = utf8read(str);
    else if (opts.type == "binary" && typeof $cptable !== "undefined" && opts.codepage)
      str = $cptable.utils.decode(opts.codepage, $cptable.utils.encode(28591, str));
    if (str.slice(0, 19) == "socialcalc:version:")
      return ETH.to_sheet(opts.type == "string" ? str : utf8read(str), opts);
    return prn_to_sheet_str(str, opts);
  }
  function prn_to_workbook(d, opts) {
    return sheet_to_workbook(prn_to_sheet(d, opts), opts);
  }
  function sheet_to_prn(ws) {
    var o = [];
    var r = safe_decode_range(ws["!ref"]), cell;
    var dense = ws["!data"] != null;
    for (var R = r.s.r; R <= r.e.r; ++R) {
      var oo = [];
      for (var C = r.s.c; C <= r.e.c; ++C) {
        var coord = encode_cell({ r: R, c: C });
        cell = dense ? (ws["!data"][R] || [])[C] : ws[coord];
        if (!cell || cell.v == null) {
          oo.push("          ");
          continue;
        }
        var w2 = (cell.w || (format_cell(cell), cell.w) || "").slice(0, 10);
        while (w2.length < 10)
          w2 += " ";
        oo.push(w2 + (C === 0 ? " " : ""));
      }
      o.push(oo.join(""));
    }
    return o.join("\n");
  }
  return {
    to_workbook: prn_to_workbook,
    to_sheet: prn_to_sheet,
    from_sheet: sheet_to_prn
  };
}();
function read_wb_ID(d, opts) {
  var o = opts || {}, OLD_WTF = !!o.WTF;
  o.WTF = true;
  try {
    var out = SYLK.to_workbook(d, o);
    o.WTF = OLD_WTF;
    return out;
  } catch (e) {
    o.WTF = OLD_WTF;
    if (!e.message.match(/SYLK bad record ID/) && OLD_WTF)
      throw e;
    return PRN.to_workbook(d, opts);
  }
}
var WK_ = /* @__PURE__ */ function() {
  function lotushopper(data, cb, opts) {
    if (!data)
      return;
    prep_blob(data, data.l || 0);
    var Enum = opts.Enum || WK1Enum;
    while (data.l < data.length) {
      var RT = data.read_shift(2);
      var R = Enum[RT] || Enum[65535];
      var length2 = data.read_shift(2);
      var tgt = data.l + length2;
      var d = R.f && R.f(data, length2, opts);
      data.l = tgt;
      if (cb(d, R, RT))
        return;
    }
  }
  function lotus_to_workbook(d, opts) {
    switch (opts.type) {
      case "base64":
        return lotus_to_workbook_buf(s2a(Base64_decode(d)), opts);
      case "binary":
        return lotus_to_workbook_buf(s2a(d), opts);
      case "buffer":
      case "array":
        return lotus_to_workbook_buf(d, opts);
    }
    throw "Unsupported type " + opts.type;
  }
  function lotus_to_workbook_buf(d, opts) {
    if (!d)
      return d;
    var o = opts || {};
    var s = {}, n = "Sheet1", next_n = "", sidx = 0;
    var sheets = {}, snames = [], realnames = [], sdata = [];
    if (o.dense)
      sdata = s["!data"] = [];
    var refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    var sheetRows = o.sheetRows || 0;
    if (d[4] == 81 && d[5] == 80 && d[6] == 87)
      return qpw_to_workbook_buf(d, opts);
    if (d[2] == 0) {
      if (d[3] == 8 || d[3] == 9) {
        if (d.length >= 16 && d[14] == 5 && d[15] === 108)
          throw new Error("Unsupported Works 3 for Mac file");
      }
    }
    if (d[2] == 2) {
      o.Enum = WK1Enum;
      lotushopper(d, function(val, R, RT) {
        switch (RT) {
          case 0:
            o.vers = val;
            if (val >= 4096)
              o.qpro = true;
            break;
          case 255:
            o.vers = val;
            o.works = true;
            break;
          case 6:
            refguess = val;
            break;
          case 204:
            if (val)
              next_n = val;
            break;
          case 222:
            next_n = val;
            break;
          case 15:
          case 51:
            if ((!o.qpro && !o.works || RT == 51) && val[1].v.charCodeAt(0) < 48)
              val[1].v = val[1].v.slice(1);
            if (o.works || o.works2)
              val[1].v = val[1].v.replace(/\r\n/g, "\n");
          case 13:
          case 14:
          case 16:
            if (RT == 14 && (val[2] & 112) == 112 && (val[2] & 15) > 1 && (val[2] & 15) < 15) {
              val[1].z = o.dateNF || table_fmt[14];
              if (o.cellDates) {
                val[1].t = "d";
                val[1].v = numdate(val[1].v);
              }
            }
            if (o.qpro) {
              if (val[3] > sidx) {
                s["!ref"] = encode_range(refguess);
                sheets[n] = s;
                snames.push(n);
                s = {};
                if (o.dense)
                  sdata = s["!data"] = [];
                refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                sidx = val[3];
                n = next_n || "Sheet" + (sidx + 1);
                next_n = "";
              }
            }
            var tmpcell = o.dense ? (sdata[val[0].r] || [])[val[0].c] : s[encode_cell(val[0])];
            if (tmpcell) {
              tmpcell.t = val[1].t;
              tmpcell.v = val[1].v;
              if (val[1].z != null)
                tmpcell.z = val[1].z;
              if (val[1].f != null)
                tmpcell.f = val[1].f;
              break;
            }
            if (o.dense) {
              if (!sdata[val[0].r])
                sdata[val[0].r] = [];
              sdata[val[0].r][val[0].c] = val[1];
            } else
              s[encode_cell(val[0])] = val[1];
            break;
          case 21509:
            o.works2 = true;
            break;
        }
      }, o);
    } else if (d[2] == 26 || d[2] == 14) {
      o.Enum = WK3Enum;
      if (d[2] == 14) {
        o.qpro = true;
        d.l = 0;
      }
      lotushopper(d, function(val, R, RT) {
        switch (RT) {
          case 204:
            n = val;
            break;
          case 22:
            if (val[1].v.charCodeAt(0) < 48)
              val[1].v = val[1].v.slice(1);
            val[1].v = val[1].v.replace(/\x0F./g, function($$) {
              return String.fromCharCode($$.charCodeAt(1) - 32);
            }).replace(/\r\n/g, "\n");
          case 23:
          case 24:
          case 25:
          case 37:
          case 39:
          case 40:
            if (val[3] > sidx) {
              s["!ref"] = encode_range(refguess);
              sheets[n] = s;
              snames.push(n);
              s = {};
              if (o.dense)
                sdata = s["!data"] = [];
              refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              sidx = val[3];
              n = "Sheet" + (sidx + 1);
            }
            if (sheetRows > 0 && val[0].r >= sheetRows)
              break;
            if (o.dense) {
              if (!sdata[val[0].r])
                sdata[val[0].r] = [];
              sdata[val[0].r][val[0].c] = val[1];
            } else
              s[encode_cell(val[0])] = val[1];
            if (refguess.e.c < val[0].c)
              refguess.e.c = val[0].c;
            if (refguess.e.r < val[0].r)
              refguess.e.r = val[0].r;
            break;
          case 27:
            if (val[14e3])
              realnames[val[14e3][0]] = val[14e3][1];
            break;
          case 1537:
            realnames[val[0]] = val[1];
            if (val[0] == sidx)
              n = val[1];
            break;
        }
      }, o);
    } else
      throw new Error("Unrecognized LOTUS BOF " + d[2]);
    s["!ref"] = encode_range(refguess);
    sheets[next_n || n] = s;
    snames.push(next_n || n);
    if (!realnames.length)
      return { SheetNames: snames, Sheets: sheets };
    var osheets = {}, rnames = [];
    for (var i = 0; i < realnames.length; ++i)
      if (sheets[snames[i]]) {
        rnames.push(realnames[i] || snames[i]);
        osheets[realnames[i]] = sheets[realnames[i]] || sheets[snames[i]];
      } else {
        rnames.push(realnames[i]);
        osheets[realnames[i]] = { "!ref": "A1" };
      }
    return { SheetNames: rnames, Sheets: osheets };
  }
  function sheet_to_wk1(ws, opts) {
    var o = opts || {};
    if (+o.codepage >= 0)
      set_cp(+o.codepage);
    if (o.type == "string")
      throw new Error("Cannot write WK1 to JS string");
    var ba = buf_array();
    var range = safe_decode_range(ws["!ref"]);
    var dense = ws["!data"] != null;
    var cols = [];
    write_biff_rec(ba, 0, write_BOF_WK1(1030));
    write_biff_rec(ba, 6, write_RANGE(range));
    var max_R = Math.min(range.e.r, 8191);
    for (var C = range.s.c; C <= range.e.c; ++C)
      cols[C] = encode_col(C);
    for (var R = range.s.r; R <= max_R; ++R) {
      var rr = encode_row(R);
      for (C = range.s.c; C <= range.e.c; ++C) {
        var cell = dense ? (ws["!data"][R] || [])[C] : ws[cols[C] + rr];
        if (!cell || cell.t == "z")
          continue;
        if (cell.t == "n") {
          if ((cell.v | 0) == cell.v && cell.v >= -32768 && cell.v <= 32767)
            write_biff_rec(ba, 13, write_INTEGER(R, C, cell.v));
          else
            write_biff_rec(ba, 14, write_NUMBER(R, C, cell.v));
        } else {
          var str = format_cell(cell);
          write_biff_rec(ba, 15, write_LABEL(R, C, str.slice(0, 239)));
        }
      }
    }
    write_biff_rec(ba, 1);
    return ba.end();
  }
  function book_to_wk3(wb, opts) {
    var o = opts || {};
    if (+o.codepage >= 0)
      set_cp(+o.codepage);
    if (o.type == "string")
      throw new Error("Cannot write WK3 to JS string");
    var ba = buf_array();
    write_biff_rec(ba, 0, write_BOF_WK3(wb));
    for (var i = 0, cnt = 0; i < wb.SheetNames.length; ++i)
      if ((wb.Sheets[wb.SheetNames[i]] || {})["!ref"])
        write_biff_rec(ba, 27, write_XFORMAT_SHEETNAME(wb.SheetNames[i], cnt++));
    var wsidx = 0;
    for (i = 0; i < wb.SheetNames.length; ++i) {
      var ws = wb.Sheets[wb.SheetNames[i]];
      if (!ws || !ws["!ref"])
        continue;
      var range = safe_decode_range(ws["!ref"]);
      var dense = ws["!data"] != null;
      var cols = [];
      var max_R = Math.min(range.e.r, 8191);
      for (var R = range.s.r; R <= max_R; ++R) {
        var rr = encode_row(R);
        for (var C = range.s.c; C <= range.e.c; ++C) {
          if (R === range.s.r)
            cols[C] = encode_col(C);
          var ref = cols[C] + rr;
          var cell = dense ? (ws["!data"][R] || [])[C] : ws[ref];
          if (!cell || cell.t == "z")
            continue;
          if (cell.t == "n") {
            write_biff_rec(ba, 23, write_NUMBER_17(R, C, wsidx, cell.v));
          } else {
            var str = format_cell(cell);
            write_biff_rec(ba, 22, write_LABEL_16(R, C, wsidx, str.slice(0, 239)));
          }
        }
      }
      ++wsidx;
    }
    write_biff_rec(ba, 1);
    return ba.end();
  }
  function write_BOF_WK1(v) {
    var out = new_buf(2);
    out.write_shift(2, v);
    return out;
  }
  function write_BOF_WK3(wb) {
    var out = new_buf(26);
    out.write_shift(2, 4096);
    out.write_shift(2, 4);
    out.write_shift(4, 0);
    var rows = 0, cols = 0, wscnt = 0;
    for (var i = 0; i < wb.SheetNames.length; ++i) {
      var name = wb.SheetNames[i];
      var ws = wb.Sheets[name];
      if (!ws || !ws["!ref"])
        continue;
      ++wscnt;
      var range = decode_range(ws["!ref"]);
      if (rows < range.e.r)
        rows = range.e.r;
      if (cols < range.e.c)
        cols = range.e.c;
    }
    if (rows > 8191)
      rows = 8191;
    out.write_shift(2, rows);
    out.write_shift(1, wscnt);
    out.write_shift(1, cols);
    out.write_shift(2, 0);
    out.write_shift(2, 0);
    out.write_shift(1, 1);
    out.write_shift(1, 2);
    out.write_shift(4, 0);
    out.write_shift(4, 0);
    return out;
  }
  function parse_RANGE(blob2, length2, opts) {
    var o = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    if (length2 == 8 && opts.qpro) {
      o.s.c = blob2.read_shift(1);
      blob2.l++;
      o.s.r = blob2.read_shift(2);
      o.e.c = blob2.read_shift(1);
      blob2.l++;
      o.e.r = blob2.read_shift(2);
      return o;
    }
    o.s.c = blob2.read_shift(2);
    o.s.r = blob2.read_shift(2);
    if (length2 == 12 && opts.qpro)
      blob2.l += 2;
    o.e.c = blob2.read_shift(2);
    o.e.r = blob2.read_shift(2);
    if (length2 == 12 && opts.qpro)
      blob2.l += 2;
    if (o.s.c == 65535)
      o.s.c = o.e.c = o.s.r = o.e.r = 0;
    return o;
  }
  function write_RANGE(range) {
    var out = new_buf(8);
    out.write_shift(2, range.s.c);
    out.write_shift(2, range.s.r);
    out.write_shift(2, range.e.c);
    out.write_shift(2, range.e.r);
    return out;
  }
  function parse_cell(blob2, length2, opts) {
    var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
    if (opts.qpro && opts.vers != 20768) {
      o[0].c = blob2.read_shift(1);
      o[3] = blob2.read_shift(1);
      o[0].r = blob2.read_shift(2);
      blob2.l += 2;
    } else if (opts.works) {
      o[0].c = blob2.read_shift(2);
      o[0].r = blob2.read_shift(2);
      o[2] = blob2.read_shift(2);
    } else {
      o[2] = blob2.read_shift(1);
      o[0].c = blob2.read_shift(2);
      o[0].r = blob2.read_shift(2);
    }
    return o;
  }
  function parse_LABEL(blob2, length2, opts) {
    var tgt = blob2.l + length2;
    var o = parse_cell(blob2, length2, opts);
    o[1].t = "s";
    if (opts.vers == 20768) {
      blob2.l++;
      var len = blob2.read_shift(1);
      o[1].v = blob2.read_shift(len, "utf8");
      return o;
    }
    if (opts.qpro)
      blob2.l++;
    o[1].v = blob2.read_shift(tgt - blob2.l, "cstr");
    return o;
  }
  function write_LABEL(R, C, s) {
    var o = new_buf(7 + s.length);
    o.write_shift(1, 255);
    o.write_shift(2, C);
    o.write_shift(2, R);
    o.write_shift(1, 39);
    for (var i = 0; i < o.length; ++i) {
      var cc = s.charCodeAt(i);
      o.write_shift(1, cc >= 128 ? 95 : cc);
    }
    o.write_shift(1, 0);
    return o;
  }
  function parse_STRING(blob2, length2, opts) {
    var tgt = blob2.l + length2;
    var o = parse_cell(blob2, length2, opts);
    o[1].t = "s";
    if (opts.vers == 20768) {
      var len = blob2.read_shift(1);
      o[1].v = blob2.read_shift(len, "utf8");
      return o;
    }
    o[1].v = blob2.read_shift(tgt - blob2.l, "cstr");
    return o;
  }
  function parse_INTEGER(blob2, length2, opts) {
    var o = parse_cell(blob2, length2, opts);
    o[1].v = blob2.read_shift(2, "i");
    return o;
  }
  function write_INTEGER(R, C, v) {
    var o = new_buf(7);
    o.write_shift(1, 255);
    o.write_shift(2, C);
    o.write_shift(2, R);
    o.write_shift(2, v, "i");
    return o;
  }
  function parse_NUMBER(blob2, length2, opts) {
    var o = parse_cell(blob2, length2, opts);
    o[1].v = blob2.read_shift(8, "f");
    return o;
  }
  function write_NUMBER(R, C, v) {
    var o = new_buf(13);
    o.write_shift(1, 255);
    o.write_shift(2, C);
    o.write_shift(2, R);
    o.write_shift(8, v, "f");
    return o;
  }
  function parse_FORMULA(blob2, length2, opts) {
    var tgt = blob2.l + length2;
    var o = parse_cell(blob2, length2, opts);
    o[1].v = blob2.read_shift(8, "f");
    if (opts.qpro)
      blob2.l = tgt;
    else {
      var flen = blob2.read_shift(2);
      wk1_fmla_to_csf(blob2.slice(blob2.l, blob2.l + flen), o);
      blob2.l += flen;
    }
    return o;
  }
  function wk1_parse_rc(B, V, col) {
    var rel = V & 32768;
    V &= ~32768;
    V = (rel ? B : 0) + (V >= 8192 ? V - 16384 : V);
    return (rel ? "" : "$") + (col ? encode_col(V) : encode_row(V));
  }
  var FuncTab = {
    31: ["NA", 0],
    // 0x20: ["ERR", 0],
    33: ["ABS", 1],
    34: ["TRUNC", 1],
    35: ["SQRT", 1],
    36: ["LOG", 1],
    37: ["LN", 1],
    38: ["PI", 0],
    39: ["SIN", 1],
    40: ["COS", 1],
    41: ["TAN", 1],
    42: ["ATAN2", 2],
    43: ["ATAN", 1],
    44: ["ASIN", 1],
    45: ["ACOS", 1],
    46: ["EXP", 1],
    47: ["MOD", 2],
    // 0x30
    49: ["ISNA", 1],
    50: ["ISERR", 1],
    51: ["FALSE", 0],
    52: ["TRUE", 0],
    53: ["RAND", 0],
    // 0x36 DATE
    // 0x37 NOW
    // 0x38 PMT
    // 0x39 PV
    // 0x3A FV
    // 0x3B IF
    // 0x3C DAY
    // 0x3D MONTH
    // 0x3E YEAR
    63: ["ROUND", 2],
    // 0x40 TIME
    // 0x41 HOUR
    // 0x42 MINUTE
    // 0x43 SECOND
    68: ["ISNUMBER", 1],
    69: ["ISTEXT", 1],
    70: ["LEN", 1],
    71: ["VALUE", 1],
    // 0x48: ["FIXED", ?? 1],
    73: ["MID", 3],
    74: ["CHAR", 1],
    // 0x4B
    // 0x4C FIND
    // 0x4D DATEVALUE
    // 0x4E TIMEVALUE
    // 0x4F CELL
    80: ["SUM", 69],
    81: ["AVERAGEA", 69],
    82: ["COUNTA", 69],
    83: ["MINA", 69],
    84: ["MAXA", 69],
    // 0x55 VLOOKUP
    // 0x56 NPV
    // 0x57 VAR
    // 0x58 STD
    // 0x59 IRR
    // 0x5A HLOOKUP
    // 0x5B DSUM
    // 0x5C DAVERAGE
    // 0x5D DCOUNTA
    // 0x5E DMIN
    // 0x5F DMAX
    // 0x60 DVARP
    // 0x61 DSTDEVP
    // 0x62 INDEX
    // 0x63 COLS
    // 0x64 ROWS
    // 0x65 REPEAT
    102: ["UPPER", 1],
    103: ["LOWER", 1],
    // 0x68 LEFT
    // 0x69 RIGHT
    // 0x6A REPLACE
    107: ["PROPER", 1],
    // 0x6C CELL
    109: ["TRIM", 1],
    // 0x6E CLEAN
    111: ["T", 1]
    // 0x70 V
  };
  var BinOpTab = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "",
    "+",
    "-",
    "*",
    "/",
    "^",
    "=",
    "<>",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "<=",
    ">=",
    "<",
    ">",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "&",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    // eslint-disable-line no-mixed-spaces-and-tabs
  ];
  function wk1_fmla_to_csf(blob2, o) {
    prep_blob(blob2, 0);
    var out = [], argc = 0, R = "", C = "", argL = "", argR = "";
    while (blob2.l < blob2.length) {
      var cc = blob2[blob2.l++];
      switch (cc) {
        case 0:
          out.push(blob2.read_shift(8, "f"));
          break;
        case 1:
          {
            C = wk1_parse_rc(o[0].c, blob2.read_shift(2), true);
            R = wk1_parse_rc(o[0].r, blob2.read_shift(2), false);
            out.push(C + R);
          }
          break;
        case 2:
          {
            var c = wk1_parse_rc(o[0].c, blob2.read_shift(2), true);
            var r = wk1_parse_rc(o[0].r, blob2.read_shift(2), false);
            C = wk1_parse_rc(o[0].c, blob2.read_shift(2), true);
            R = wk1_parse_rc(o[0].r, blob2.read_shift(2), false);
            out.push(c + r + ":" + C + R);
          }
          break;
        case 3:
          if (blob2.l < blob2.length) {
            console.error("WK1 premature formula end");
            return;
          }
          break;
        case 4:
          out.push("(" + out.pop() + ")");
          break;
        case 5:
          out.push(blob2.read_shift(2));
          break;
        case 6:
          {
            var Z = "";
            while (cc = blob2[blob2.l++])
              Z += String.fromCharCode(cc);
            out.push('"' + Z.replace(/"/g, '""') + '"');
          }
          break;
        case 8:
          out.push("-" + out.pop());
          break;
        case 23:
          out.push("+" + out.pop());
          break;
        case 22:
          out.push("NOT(" + out.pop() + ")");
          break;
        case 20:
        case 21:
          {
            argR = out.pop();
            argL = out.pop();
            out.push(["AND", "OR"][cc - 20] + "(" + argL + "," + argR + ")");
          }
          break;
        default:
          if (cc < 32 && BinOpTab[cc]) {
            argR = out.pop();
            argL = out.pop();
            out.push(argL + BinOpTab[cc] + argR);
          } else if (FuncTab[cc]) {
            argc = FuncTab[cc][1];
            if (argc == 69)
              argc = blob2[blob2.l++];
            if (argc > out.length) {
              console.error("WK1 bad formula parse 0x" + cc.toString(16) + ":|" + out.join("|") + "|");
              return;
            }
            var args = out.slice(-argc);
            out.length -= argc;
            out.push(FuncTab[cc][0] + "(" + args.join(",") + ")");
          } else if (cc <= 7)
            return console.error("WK1 invalid opcode " + cc.toString(16));
          else if (cc <= 24)
            return console.error("WK1 unsupported op " + cc.toString(16));
          else if (cc <= 30)
            return console.error("WK1 invalid opcode " + cc.toString(16));
          else if (cc <= 115)
            return console.error("WK1 unsupported function opcode " + cc.toString(16));
          else
            return console.error("WK1 unrecognized opcode " + cc.toString(16));
      }
    }
    if (out.length == 1)
      o[1].f = "" + out[0];
    else
      console.error("WK1 bad formula parse |" + out.join("|") + "|");
  }
  function parse_cell_3(blob2) {
    var o = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
    o[0].r = blob2.read_shift(2);
    o[3] = blob2[blob2.l++];
    o[0].c = blob2[blob2.l++];
    return o;
  }
  function parse_LABEL_16(blob2, length2) {
    var o = parse_cell_3(blob2);
    o[1].t = "s";
    o[1].v = blob2.read_shift(length2 - 4, "cstr");
    return o;
  }
  function write_LABEL_16(R, C, wsidx, s) {
    var o = new_buf(6 + s.length);
    o.write_shift(2, R);
    o.write_shift(1, wsidx);
    o.write_shift(1, C);
    o.write_shift(1, 39);
    for (var i = 0; i < s.length; ++i) {
      var cc = s.charCodeAt(i);
      o.write_shift(1, cc >= 128 ? 95 : cc);
    }
    o.write_shift(1, 0);
    return o;
  }
  function parse_NUMBER_18(blob2, length2) {
    var o = parse_cell_3(blob2);
    o[1].v = blob2.read_shift(2);
    var v = o[1].v >> 1;
    if (o[1].v & 1) {
      switch (v & 7) {
        case 0:
          v = (v >> 3) * 5e3;
          break;
        case 1:
          v = (v >> 3) * 500;
          break;
        case 2:
          v = (v >> 3) / 20;
          break;
        case 3:
          v = (v >> 3) / 200;
          break;
        case 4:
          v = (v >> 3) / 2e3;
          break;
        case 5:
          v = (v >> 3) / 2e4;
          break;
        case 6:
          v = (v >> 3) / 16;
          break;
        case 7:
          v = (v >> 3) / 64;
          break;
      }
    }
    o[1].v = v;
    return o;
  }
  function parse_NUMBER_17(blob2, length2) {
    var o = parse_cell_3(blob2);
    var v1 = blob2.read_shift(4);
    var v2 = blob2.read_shift(4);
    var e = blob2.read_shift(2);
    if (e == 65535) {
      if (v1 === 0 && v2 === 3221225472) {
        o[1].t = "e";
        o[1].v = 15;
      } else if (v1 === 0 && v2 === 3489660928) {
        o[1].t = "e";
        o[1].v = 42;
      } else
        o[1].v = 0;
      return o;
    }
    var s = e & 32768;
    e = (e & 32767) - 16446;
    o[1].v = (1 - s * 2) * (v2 * Math.pow(2, e + 32) + v1 * Math.pow(2, e));
    return o;
  }
  function write_NUMBER_17(R, C, wsidx, v) {
    var o = new_buf(14);
    o.write_shift(2, R);
    o.write_shift(1, wsidx);
    o.write_shift(1, C);
    if (v == 0) {
      o.write_shift(4, 0);
      o.write_shift(4, 0);
      o.write_shift(2, 65535);
      return o;
    }
    var s = 0, e = 0, v1 = 0, v2 = 0;
    if (v < 0) {
      s = 1;
      v = -v;
    }
    e = Math.log2(v) | 0;
    v /= Math.pow(2, e - 31);
    v2 = v >>> 0;
    if ((v2 & 2147483648) == 0) {
      v /= 2;
      ++e;
      v2 = v >>> 0;
    }
    v -= v2;
    v2 |= 2147483648;
    v2 >>>= 0;
    v *= Math.pow(2, 32);
    v1 = v >>> 0;
    o.write_shift(4, v1);
    o.write_shift(4, v2);
    e += 16383 + (s ? 32768 : 0);
    o.write_shift(2, e);
    return o;
  }
  function parse_FORMULA_19(blob2, length2) {
    var o = parse_NUMBER_17(blob2);
    blob2.l += length2 - 14;
    return o;
  }
  function parse_NUMBER_25(blob2, length2) {
    var o = parse_cell_3(blob2);
    var v1 = blob2.read_shift(4);
    o[1].v = v1 >> 6;
    return o;
  }
  function parse_NUMBER_27(blob2, length2) {
    var o = parse_cell_3(blob2);
    var v1 = blob2.read_shift(8, "f");
    o[1].v = v1;
    return o;
  }
  function parse_FORMULA_28(blob2, length2) {
    var o = parse_NUMBER_27(blob2);
    blob2.l += length2 - 12;
    return o;
  }
  function parse_SHEETNAMECS(blob2, length2) {
    return blob2[blob2.l + length2 - 1] == 0 ? blob2.read_shift(length2, "cstr") : "";
  }
  function parse_SHEETNAMELP(blob2, length2) {
    var len = blob2[blob2.l++];
    if (len > length2 - 1)
      len = length2 - 1;
    var o = "";
    while (o.length < len)
      o += String.fromCharCode(blob2[blob2.l++]);
    return o;
  }
  function parse_SHEETINFOQP(blob2, length2, opts) {
    if (!opts.qpro || length2 < 21)
      return;
    var id = blob2.read_shift(1);
    blob2.l += 17;
    blob2.l += 1;
    blob2.l += 2;
    var nm = blob2.read_shift(length2 - 21, "cstr");
    return [id, nm];
  }
  function parse_XFORMAT(blob2, length2) {
    var o = {}, tgt = blob2.l + length2;
    while (blob2.l < tgt) {
      var dt = blob2.read_shift(2);
      if (dt == 14e3) {
        o[dt] = [0, ""];
        o[dt][0] = blob2.read_shift(2);
        while (blob2[blob2.l]) {
          o[dt][1] += String.fromCharCode(blob2[blob2.l]);
          blob2.l++;
        }
        blob2.l++;
      }
    }
    return o;
  }
  function write_XFORMAT_SHEETNAME(name, wsidx) {
    var out = new_buf(5 + name.length);
    out.write_shift(2, 14e3);
    out.write_shift(2, wsidx);
    for (var i = 0; i < name.length; ++i) {
      var cc = name.charCodeAt(i);
      out[out.l++] = cc > 127 ? 95 : cc;
    }
    out[out.l++] = 0;
    return out;
  }
  var WK1Enum = {
    /*::[*/
    0: { n: "BOF", f: parseuint16 },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "CALCMODE" },
    /*::[*/
    3: { n: "CALCORDER" },
    /*::[*/
    4: { n: "SPLIT" },
    /*::[*/
    5: { n: "SYNC" },
    /*::[*/
    6: { n: "RANGE", f: parse_RANGE },
    /*::[*/
    7: { n: "WINDOW1" },
    /*::[*/
    8: { n: "COLW1" },
    /*::[*/
    9: { n: "WINTWO" },
    /*::[*/
    10: { n: "COLW2" },
    /*::[*/
    11: { n: "NAME" },
    /*::[*/
    12: { n: "BLANK" },
    /*::[*/
    13: { n: "INTEGER", f: parse_INTEGER },
    /*::[*/
    14: { n: "NUMBER", f: parse_NUMBER },
    /*::[*/
    15: { n: "LABEL", f: parse_LABEL },
    /*::[*/
    16: { n: "FORMULA", f: parse_FORMULA },
    /*::[*/
    24: { n: "TABLE" },
    /*::[*/
    25: { n: "ORANGE" },
    /*::[*/
    26: { n: "PRANGE" },
    /*::[*/
    27: { n: "SRANGE" },
    /*::[*/
    28: { n: "FRANGE" },
    /*::[*/
    29: { n: "KRANGE1" },
    /*::[*/
    32: { n: "HRANGE" },
    /*::[*/
    35: { n: "KRANGE2" },
    /*::[*/
    36: { n: "PROTEC" },
    /*::[*/
    37: { n: "FOOTER" },
    /*::[*/
    38: { n: "HEADER" },
    /*::[*/
    39: { n: "SETUP" },
    /*::[*/
    40: { n: "MARGINS" },
    /*::[*/
    41: { n: "LABELFMT" },
    /*::[*/
    42: { n: "TITLES" },
    /*::[*/
    43: { n: "SHEETJS" },
    /*::[*/
    45: { n: "GRAPH" },
    /*::[*/
    46: { n: "NGRAPH" },
    /*::[*/
    47: { n: "CALCCOUNT" },
    /*::[*/
    48: { n: "UNFORMATTED" },
    /*::[*/
    49: { n: "CURSORW12" },
    /*::[*/
    50: { n: "WINDOW" },
    /*::[*/
    51: { n: "STRING", f: parse_STRING },
    /*::[*/
    55: { n: "PASSWORD" },
    /*::[*/
    56: { n: "LOCKED" },
    /*::[*/
    60: { n: "QUERY" },
    /*::[*/
    61: { n: "QUERYNAME" },
    /*::[*/
    62: { n: "PRINT" },
    /*::[*/
    63: { n: "PRINTNAME" },
    /*::[*/
    64: { n: "GRAPH2" },
    /*::[*/
    65: { n: "GRAPHNAME" },
    /*::[*/
    66: { n: "ZOOM" },
    /*::[*/
    67: { n: "SYMSPLIT" },
    /*::[*/
    68: { n: "NSROWS" },
    /*::[*/
    69: { n: "NSCOLS" },
    /*::[*/
    70: { n: "RULER" },
    /*::[*/
    71: { n: "NNAME" },
    /*::[*/
    72: { n: "ACOMM" },
    /*::[*/
    73: { n: "AMACRO" },
    /*::[*/
    74: { n: "PARSE" },
    /*::[*/
    102: { n: "PRANGES??" },
    /*::[*/
    103: { n: "RRANGES??" },
    /*::[*/
    104: { n: "FNAME??" },
    /*::[*/
    105: { n: "MRANGES??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
    /*::[*/
    222: { n: "SHEETNAMELP", f: parse_SHEETNAMELP },
    /*::[*/
    255: { n: "BOF", f: parseuint16 },
    /*::[*/
    65535: { n: "" }
  };
  var WK3Enum = {
    /*::[*/
    0: { n: "BOF" },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "PASSWORD" },
    /*::[*/
    3: { n: "CALCSET" },
    /*::[*/
    4: { n: "WINDOWSET" },
    /*::[*/
    5: { n: "SHEETCELLPTR" },
    /*::[*/
    6: { n: "SHEETLAYOUT" },
    /*::[*/
    7: { n: "COLUMNWIDTH" },
    /*::[*/
    8: { n: "HIDDENCOLUMN" },
    /*::[*/
    9: { n: "USERRANGE" },
    /*::[*/
    10: { n: "SYSTEMRANGE" },
    /*::[*/
    11: { n: "ZEROFORCE" },
    /*::[*/
    12: { n: "SORTKEYDIR" },
    /*::[*/
    13: { n: "FILESEAL" },
    /*::[*/
    14: { n: "DATAFILLNUMS" },
    /*::[*/
    15: { n: "PRINTMAIN" },
    /*::[*/
    16: { n: "PRINTSTRING" },
    /*::[*/
    17: { n: "GRAPHMAIN" },
    /*::[*/
    18: { n: "GRAPHSTRING" },
    /*::[*/
    19: { n: "??" },
    /*::[*/
    20: { n: "ERRCELL" },
    /*::[*/
    21: { n: "NACELL" },
    /*::[*/
    22: { n: "LABEL16", f: parse_LABEL_16 },
    /*::[*/
    23: { n: "NUMBER17", f: parse_NUMBER_17 },
    /*::[*/
    24: { n: "NUMBER18", f: parse_NUMBER_18 },
    /*::[*/
    25: { n: "FORMULA19", f: parse_FORMULA_19 },
    /*::[*/
    26: { n: "FORMULA1A" },
    /*::[*/
    27: { n: "XFORMAT", f: parse_XFORMAT },
    /*::[*/
    28: { n: "DTLABELMISC" },
    /*::[*/
    29: { n: "DTLABELCELL" },
    /*::[*/
    30: { n: "GRAPHWINDOW" },
    /*::[*/
    31: { n: "CPA" },
    /*::[*/
    32: { n: "LPLAUTO" },
    /*::[*/
    33: { n: "QUERY" },
    /*::[*/
    34: { n: "HIDDENSHEET" },
    /*::[*/
    35: { n: "??" },
    /*::[*/
    37: { n: "NUMBER25", f: parse_NUMBER_25 },
    /*::[*/
    38: { n: "??" },
    /*::[*/
    39: { n: "NUMBER27", f: parse_NUMBER_27 },
    /*::[*/
    40: { n: "FORMULA28", f: parse_FORMULA_28 },
    /*::[*/
    142: { n: "??" },
    /*::[*/
    147: { n: "??" },
    /*::[*/
    150: { n: "??" },
    /*::[*/
    151: { n: "??" },
    /*::[*/
    152: { n: "??" },
    /*::[*/
    153: { n: "??" },
    /*::[*/
    154: { n: "??" },
    /*::[*/
    155: { n: "??" },
    /*::[*/
    156: { n: "??" },
    /*::[*/
    163: { n: "??" },
    /*::[*/
    174: { n: "??" },
    /*::[*/
    175: { n: "??" },
    /*::[*/
    176: { n: "??" },
    /*::[*/
    177: { n: "??" },
    /*::[*/
    184: { n: "??" },
    /*::[*/
    185: { n: "??" },
    /*::[*/
    186: { n: "??" },
    /*::[*/
    187: { n: "??" },
    /*::[*/
    188: { n: "??" },
    /*::[*/
    195: { n: "??" },
    /*::[*/
    201: { n: "??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
    /*::[*/
    205: { n: "??" },
    /*::[*/
    206: { n: "??" },
    /*::[*/
    207: { n: "??" },
    /*::[*/
    208: { n: "??" },
    /*::[*/
    256: { n: "??" },
    /*::[*/
    259: { n: "??" },
    /*::[*/
    260: { n: "??" },
    /*::[*/
    261: { n: "??" },
    /*::[*/
    262: { n: "??" },
    /*::[*/
    263: { n: "??" },
    /*::[*/
    265: { n: "??" },
    /*::[*/
    266: { n: "??" },
    /*::[*/
    267: { n: "??" },
    /*::[*/
    268: { n: "??" },
    /*::[*/
    270: { n: "??" },
    /*::[*/
    271: { n: "??" },
    /*::[*/
    384: { n: "??" },
    /*::[*/
    389: { n: "??" },
    /*::[*/
    390: { n: "??" },
    /*::[*/
    393: { n: "??" },
    /*::[*/
    396: { n: "??" },
    /*::[*/
    512: { n: "??" },
    /*::[*/
    514: { n: "??" },
    /*::[*/
    513: { n: "??" },
    /*::[*/
    516: { n: "??" },
    /*::[*/
    517: { n: "??" },
    /*::[*/
    640: { n: "??" },
    /*::[*/
    641: { n: "??" },
    /*::[*/
    642: { n: "??" },
    /*::[*/
    643: { n: "??" },
    /*::[*/
    644: { n: "??" },
    /*::[*/
    645: { n: "??" },
    /*::[*/
    646: { n: "??" },
    /*::[*/
    647: { n: "??" },
    /*::[*/
    648: { n: "??" },
    /*::[*/
    658: { n: "??" },
    /*::[*/
    659: { n: "??" },
    /*::[*/
    660: { n: "??" },
    /*::[*/
    661: { n: "??" },
    /*::[*/
    662: { n: "??" },
    /*::[*/
    665: { n: "??" },
    /*::[*/
    666: { n: "??" },
    /*::[*/
    768: { n: "??" },
    /*::[*/
    772: { n: "??" },
    /*::[*/
    1537: { n: "SHEETINFOQP", f: parse_SHEETINFOQP },
    /*::[*/
    1600: { n: "??" },
    /*::[*/
    1602: { n: "??" },
    /*::[*/
    1793: { n: "??" },
    /*::[*/
    1794: { n: "??" },
    /*::[*/
    1795: { n: "??" },
    /*::[*/
    1796: { n: "??" },
    /*::[*/
    1920: { n: "??" },
    /*::[*/
    2048: { n: "??" },
    /*::[*/
    2049: { n: "??" },
    /*::[*/
    2052: { n: "??" },
    /*::[*/
    2688: { n: "??" },
    /*::[*/
    10998: { n: "??" },
    /*::[*/
    12849: { n: "??" },
    /*::[*/
    28233: { n: "??" },
    /*::[*/
    28484: { n: "??" },
    /*::[*/
    65535: { n: "" }
  };
  function qpw_to_workbook_buf(d, opts) {
    prep_blob(d, 0);
    var o = opts || {};
    var s = {};
    if (o.dense)
      s["!data"] = [];
    var SST = [], sname = "";
    var range = { s: { r: -1, c: -1 }, e: { r: -1, c: -1 } };
    var cnt = 0, type = 0, C = 0, R = 0;
    var wb = { SheetNames: [], Sheets: {} };
    outer:
      while (d.l < d.length) {
        var RT = d.read_shift(2), length2 = d.read_shift(2);
        var p = d.slice(d.l, d.l + length2);
        prep_blob(p, 0);
        switch (RT) {
          case 1:
            if (p.read_shift(4) != 962023505)
              throw "Bad QPW9 BOF!";
            break;
          case 2:
            break outer;
          case 1025:
            break;
          case 1026:
            break;
          case 1031:
            {
              p.l += 12;
              while (p.l < p.length) {
                cnt = p.read_shift(2);
                type = p.read_shift(1);
                SST.push(p.read_shift(cnt, "cstr"));
              }
            }
            break;
          case 1032:
            break;
          case 1537:
            {
              var sidx = p.read_shift(2);
              s = {};
              if (o.dense)
                s["!data"] = [];
              range.s.c = p.read_shift(2);
              range.e.c = p.read_shift(2);
              range.s.r = p.read_shift(4);
              range.e.r = p.read_shift(4);
              p.l += 4;
              if (p.l + 2 < p.length) {
                cnt = p.read_shift(2);
                type = p.read_shift(1);
                sname = cnt == 0 ? "" : p.read_shift(cnt, "cstr");
              }
              if (!sname)
                sname = encode_col(sidx);
            }
            break;
          case 1538:
            {
              if (range.s.c > 255 || range.s.r > 999999)
                break;
              if (range.e.c < range.s.c)
                range.e.c = range.s.c;
              if (range.e.r < range.s.r)
                range.e.r = range.s.r;
              s["!ref"] = encode_range(range);
              book_append_sheet(wb, s, sname);
            }
            break;
          case 2561:
            {
              C = p.read_shift(2);
              if (range.e.c < C)
                range.e.c = C;
              if (range.s.c > C)
                range.s.c = C;
              R = p.read_shift(4);
              if (range.s.r > R)
                range.s.r = R;
              R = p.read_shift(4);
              if (range.e.r < R)
                range.e.r = R;
            }
            break;
          case 3073:
            {
              R = p.read_shift(4), cnt = p.read_shift(4);
              if (range.s.r > R)
                range.s.r = R;
              if (range.e.r < R + cnt - 1)
                range.e.r = R + cnt - 1;
              var CC = encode_col(C);
              while (p.l < p.length) {
                var cell = { t: "z" };
                var flags = p.read_shift(1);
                if (flags & 128)
                  p.l += 2;
                var mul = flags & 64 ? p.read_shift(2) - 1 : 0;
                switch (flags & 31) {
                  case 1:
                    break;
                  case 2:
                    cell = { t: "n", v: p.read_shift(2) };
                    break;
                  case 3:
                    cell = { t: "n", v: p.read_shift(2, "i") };
                    break;
                  case 5:
                    cell = { t: "n", v: p.read_shift(8, "f") };
                    break;
                  case 7:
                    cell = { t: "s", v: SST[type = p.read_shift(4) - 1] };
                    break;
                  case 8:
                    cell = { t: "n", v: p.read_shift(8, "f") };
                    p.l += 2;
                    p.l += 4;
                    break;
                  default:
                    throw "Unrecognized QPW cell type " + (flags & 31);
                }
                var delta = 0;
                if (flags & 32)
                  switch (flags & 31) {
                    case 2:
                      delta = p.read_shift(2);
                      break;
                    case 3:
                      delta = p.read_shift(2, "i");
                      break;
                    case 7:
                      delta = p.read_shift(2);
                      break;
                    default:
                      throw "Unsupported delta for QPW cell type " + (flags & 31);
                  }
                if (!(!o.sheetStubs && cell.t == "z")) {
                  if (s["!data"] != null) {
                    if (!s["!data"][R])
                      s["!data"][R] = [];
                    s["!data"][R][C] = cell;
                  } else
                    s[CC + encode_row(R)] = cell;
                }
                ++R;
                --cnt;
                while (mul-- > 0 && cnt >= 0) {
                  if (flags & 32)
                    switch (flags & 31) {
                      case 2:
                        cell = { t: "n", v: cell.v + delta & 65535 };
                        break;
                      case 3:
                        cell = { t: "n", v: cell.v + delta & 65535 };
                        if (cell.v > 32767)
                          cell.v -= 65536;
                        break;
                      case 7:
                        cell = { t: "s", v: SST[type = type + delta >>> 0] };
                        break;
                      default:
                        throw "Cannot apply delta for QPW cell type " + (flags & 31);
                    }
                  else
                    switch (flags & 31) {
                      case 1:
                        cell = { t: "z" };
                        break;
                      case 2:
                        cell = { t: "n", v: p.read_shift(2) };
                        break;
                      case 7:
                        cell = { t: "s", v: SST[type = p.read_shift(4) - 1] };
                        break;
                      default:
                        throw "Cannot apply repeat for QPW cell type " + (flags & 31);
                    }
                  if (!(!o.sheetStubs && cell.t == "z")) {
                    if (s["!data"] != null) {
                      if (!s["!data"][R])
                        s["!data"][R] = [];
                      s["!data"][R][C] = cell;
                    } else
                      s[CC + encode_row(R)] = cell;
                  }
                  ++R;
                  --cnt;
                }
              }
            }
            break;
        }
        d.l += length2;
      }
    return wb;
  }
  return {
    sheet_to_wk1,
    book_to_wk3,
    to_workbook: lotus_to_workbook
  };
}();
function parse_rpr(rpr) {
  var font = {}, m = rpr.match(tagregex), i = 0;
  var pass = false;
  if (m)
    for (; i != m.length; ++i) {
      var y = parsexmltag(m[i]);
      switch (y[0].replace(/\w*:/g, "")) {
        case "<condense":
          break;
        case "<extend":
          break;
        case "<shadow":
          if (!y.val)
            break;
        case "<shadow>":
        case "<shadow/>":
          font.shadow = 1;
          break;
        case "</shadow>":
          break;
        case "<charset":
          if (y.val == "1")
            break;
          font.cp = CS2CP[parseInt(y.val, 10)];
          break;
        case "<outline":
          if (!y.val)
            break;
        case "<outline>":
        case "<outline/>":
          font.outline = 1;
          break;
        case "</outline>":
          break;
        case "<rFont":
          font.name = y.val;
          break;
        case "<sz":
          font.sz = y.val;
          break;
        case "<strike":
          if (!y.val)
            break;
        case "<strike>":
        case "<strike/>":
          font.strike = 1;
          break;
        case "</strike>":
          break;
        case "<u":
          if (!y.val)
            break;
          switch (y.val) {
            case "double":
              font.uval = "double";
              break;
            case "singleAccounting":
              font.uval = "single-accounting";
              break;
            case "doubleAccounting":
              font.uval = "double-accounting";
              break;
          }
        case "<u>":
        case "<u/>":
          font.u = 1;
          break;
        case "</u>":
          break;
        case "<b":
          if (y.val == "0")
            break;
        case "<b>":
        case "<b/>":
          font.b = 1;
          break;
        case "</b>":
          break;
        case "<i":
          if (y.val == "0")
            break;
        case "<i>":
        case "<i/>":
          font.i = 1;
          break;
        case "</i>":
          break;
        case "<color":
          if (y.rgb)
            font.color = y.rgb.slice(2, 8);
          break;
        case "<color>":
        case "<color/>":
        case "</color>":
          break;
        case "<family":
          font.family = y.val;
          break;
        case "<family>":
        case "<family/>":
        case "</family>":
          break;
        case "<vertAlign":
          font.valign = y.val;
          break;
        case "<vertAlign>":
        case "<vertAlign/>":
        case "</vertAlign>":
          break;
        case "<scheme":
          break;
        case "<scheme>":
        case "<scheme/>":
        case "</scheme>":
          break;
        case "<extLst":
        case "<extLst>":
        case "</extLst>":
          break;
        case "<ext":
          pass = true;
          break;
        case "</ext>":
          pass = false;
          break;
        default:
          if (y[0].charCodeAt(1) !== 47 && !pass)
            throw new Error("Unrecognized rich format " + y[0]);
      }
    }
  return font;
}
var parse_rs = /* @__PURE__ */ function() {
  var tregex = matchtag("t"), rpregex = matchtag("rPr");
  function parse_r(r) {
    var t = r.match(tregex);
    if (!t)
      return { t: "s", v: "" };
    var o = { t: "s", v: unescapexml(t[1]) };
    var rpr = r.match(rpregex);
    if (rpr)
      o.s = parse_rpr(rpr[1]);
    return o;
  }
  var rregex = /<(?:\w+:)?r>/g, rend = /<\/(?:\w+:)?r>/;
  return function parse_rs2(rs) {
    return rs.replace(rregex, "").split(rend).map(parse_r).filter(function(r) {
      return r.v;
    });
  };
}();
var rs_to_html = /* @__PURE__ */ function parse_rs_factory() {
  var nlregex = /(\r\n|\n)/g;
  function parse_rpr2(font, intro, outro) {
    var style = [];
    if (font.u)
      style.push("text-decoration: underline;");
    if (font.uval)
      style.push("text-underline-style:" + font.uval + ";");
    if (font.sz)
      style.push("font-size:" + font.sz + "pt;");
    if (font.outline)
      style.push("text-effect: outline;");
    if (font.shadow)
      style.push("text-shadow: auto;");
    intro.push('<span style="' + style.join("") + '">');
    if (font.b) {
      intro.push("<b>");
      outro.push("</b>");
    }
    if (font.i) {
      intro.push("<i>");
      outro.push("</i>");
    }
    if (font.strike) {
      intro.push("<s>");
      outro.push("</s>");
    }
    var align = font.valign || "";
    if (align == "superscript" || align == "super")
      align = "sup";
    else if (align == "subscript")
      align = "sub";
    if (align != "") {
      intro.push("<" + align + ">");
      outro.push("</" + align + ">");
    }
    outro.push("</span>");
    return font;
  }
  function r_to_html(r) {
    var terms = [[], r.v, []];
    if (!r.v)
      return "";
    if (r.s)
      parse_rpr2(r.s, terms[0], terms[2]);
    return terms[0].join("") + terms[1].replace(nlregex, "<br/>") + terms[2].join("");
  }
  return function parse_rs2(rs) {
    return rs.map(r_to_html).join("");
  };
}();
var sitregex = /<(?:\w+:)?t[^>]*>([^<]*)<\/(?:\w+:)?t>/g, sirregex = /<(?:\w+:)?r\b[^>]*>/;
var sirphregex = /<(?:\w+:)?rPh.*?>([\s\S]*?)<\/(?:\w+:)?rPh>/g;
function parse_si(x, opts) {
  var html = opts ? opts.cellHTML : true;
  var z = {};
  if (!x)
    return { t: "" };
  if (x.match(/^\s*<(?:\w+:)?t[^>]*>/)) {
    z.t = unescapexml(utf8read(x.slice(x.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || ""), true);
    z.r = utf8read(x);
    if (html)
      z.h = escapehtml(z.t);
  } else if (
    /*y = */
    x.match(sirregex)
  ) {
    z.r = utf8read(x);
    z.t = unescapexml(utf8read((x.replace(sirphregex, "").match(sitregex) || []).join("").replace(tagregex, "")), true);
    if (html)
      z.h = rs_to_html(parse_rs(z.r));
  }
  return z;
}
var sstr0 = /<(?:\w+:)?sst([^>]*)>([\s\S]*)<\/(?:\w+:)?sst>/;
var sstr1 = /<(?:\w+:)?(?:si|sstItem)>/g;
var sstr2 = /<\/(?:\w+:)?(?:si|sstItem)>/;
function parse_sst_xml(data, opts) {
  var s = [], ss = "";
  if (!data)
    return s;
  var sst = data.match(sstr0);
  if (sst) {
    ss = sst[2].replace(sstr1, "").split(sstr2);
    for (var i = 0; i != ss.length; ++i) {
      var o = parse_si(ss[i].trim(), opts);
      if (o != null)
        s[s.length] = o;
    }
    sst = parsexmltag(sst[1]);
    s.Count = sst.count;
    s.Unique = sst.uniqueCount;
  }
  return s;
}
var straywsregex = /^\s|\s$|[\t\n\r]/;
function write_sst_xml(sst, opts) {
  if (!opts.bookSST)
    return "";
  var o = [XML_HEADER];
  o[o.length] = writextag("sst", null, {
    xmlns: XMLNS_main[0],
    count: sst.Count,
    uniqueCount: sst.Unique
  });
  for (var i = 0; i != sst.length; ++i) {
    if (sst[i] == null)
      continue;
    var s = sst[i];
    var sitag = "<si>";
    if (s.r)
      sitag += s.r;
    else {
      sitag += "<t";
      if (!s.t)
        s.t = "";
      if (typeof s.t !== "string")
        s.t = String(s.t);
      if (s.t.match(straywsregex))
        sitag += ' xml:space="preserve"';
      sitag += ">" + escapexml(s.t) + "</t>";
    }
    sitag += "</si>";
    o[o.length] = sitag;
  }
  if (o.length > 2) {
    o[o.length] = "</sst>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
function parse_BrtBeginSst(data) {
  return [data.read_shift(4), data.read_shift(4)];
}
function parse_sst_bin(data, opts) {
  var s = [];
  var pass = false;
  recordhopper(data, function hopper_sst(val, R, RT) {
    switch (RT) {
      case 159:
        s.Count = val[0];
        s.Unique = val[1];
        break;
      case 19:
        s.push(val);
        break;
      case 160:
        return true;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      default:
        if (R.T)
          ;
        if (!pass || opts.WTF)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return s;
}
function write_BrtBeginSst(sst, o) {
  if (!o)
    o = new_buf(8);
  o.write_shift(4, sst.Count);
  o.write_shift(4, sst.Unique);
  return o;
}
var write_BrtSSTItem = write_RichStr;
function write_sst_bin(sst) {
  var ba = buf_array();
  write_record(ba, 159, write_BrtBeginSst(sst));
  for (var i = 0; i < sst.length; ++i)
    write_record(ba, 19, write_BrtSSTItem(sst[i]));
  write_record(
    ba,
    160
    /* BrtEndSst */
  );
  return ba.end();
}
function _JS2ANSI(str) {
  var o = [], oo = str.split("");
  for (var i = 0; i < oo.length; ++i)
    o[i] = oo[i].charCodeAt(0);
  return o;
}
function parse_CRYPTOVersion(blob2, length2) {
  var o = {};
  o.Major = blob2.read_shift(2);
  o.Minor = blob2.read_shift(2);
  if (length2 >= 4)
    blob2.l += length2 - 4;
  return o;
}
function parse_DataSpaceVersionInfo(blob2) {
  var o = {};
  o.id = blob2.read_shift(0, "lpp4");
  o.R = parse_CRYPTOVersion(blob2, 4);
  o.U = parse_CRYPTOVersion(blob2, 4);
  o.W = parse_CRYPTOVersion(blob2, 4);
  return o;
}
function parse_DataSpaceMapEntry(blob2) {
  var len = blob2.read_shift(4);
  var end = blob2.l + len - 4;
  var o = {};
  var cnt = blob2.read_shift(4);
  var comps = [];
  while (cnt-- > 0)
    comps.push({ t: blob2.read_shift(4), v: blob2.read_shift(0, "lpp4") });
  o.name = blob2.read_shift(0, "lpp4");
  o.comps = comps;
  if (blob2.l != end)
    throw new Error("Bad DataSpaceMapEntry: " + blob2.l + " != " + end);
  return o;
}
function parse_DataSpaceMap(blob2) {
  var o = [];
  blob2.l += 4;
  var cnt = blob2.read_shift(4);
  while (cnt-- > 0)
    o.push(parse_DataSpaceMapEntry(blob2));
  return o;
}
function parse_DataSpaceDefinition(blob2) {
  var o = [];
  blob2.l += 4;
  var cnt = blob2.read_shift(4);
  while (cnt-- > 0)
    o.push(blob2.read_shift(0, "lpp4"));
  return o;
}
function parse_TransformInfoHeader(blob2) {
  var o = {};
  blob2.read_shift(4);
  blob2.l += 4;
  o.id = blob2.read_shift(0, "lpp4");
  o.name = blob2.read_shift(0, "lpp4");
  o.R = parse_CRYPTOVersion(blob2, 4);
  o.U = parse_CRYPTOVersion(blob2, 4);
  o.W = parse_CRYPTOVersion(blob2, 4);
  return o;
}
function parse_Primary(blob2) {
  var hdr = parse_TransformInfoHeader(blob2);
  hdr.ename = blob2.read_shift(0, "8lpp4");
  hdr.blksz = blob2.read_shift(4);
  hdr.cmode = blob2.read_shift(4);
  if (blob2.read_shift(4) != 4)
    throw new Error("Bad !Primary record");
  return hdr;
}
function parse_EncryptionHeader(blob2, length2) {
  var tgt = blob2.l + length2;
  var o = {};
  o.Flags = blob2.read_shift(4) & 63;
  blob2.l += 4;
  o.AlgID = blob2.read_shift(4);
  var valid = false;
  switch (o.AlgID) {
    case 26126:
    case 26127:
    case 26128:
      valid = o.Flags == 36;
      break;
    case 26625:
      valid = o.Flags == 4;
      break;
    case 0:
      valid = o.Flags == 16 || o.Flags == 4 || o.Flags == 36;
      break;
    default:
      throw "Unrecognized encryption algorithm: " + o.AlgID;
  }
  if (!valid)
    throw new Error("Encryption Flags/AlgID mismatch");
  o.AlgIDHash = blob2.read_shift(4);
  o.KeySize = blob2.read_shift(4);
  o.ProviderType = blob2.read_shift(4);
  blob2.l += 8;
  o.CSPName = blob2.read_shift(tgt - blob2.l >> 1, "utf16le");
  blob2.l = tgt;
  return o;
}
function parse_EncryptionVerifier(blob2, length2) {
  var o = {}, tgt = blob2.l + length2;
  blob2.l += 4;
  o.Salt = blob2.slice(blob2.l, blob2.l + 16);
  blob2.l += 16;
  o.Verifier = blob2.slice(blob2.l, blob2.l + 16);
  blob2.l += 16;
  blob2.read_shift(4);
  o.VerifierHash = blob2.slice(blob2.l, tgt);
  blob2.l = tgt;
  return o;
}
function parse_EncryptionInfo(blob2) {
  var vers = parse_CRYPTOVersion(blob2);
  switch (vers.Minor) {
    case 2:
      return [vers.Minor, parse_EncInfoStd(blob2)];
    case 3:
      return [vers.Minor, parse_EncInfoExt()];
    case 4:
      return [vers.Minor, parse_EncInfoAgl(blob2)];
  }
  throw new Error("ECMA-376 Encrypted file unrecognized Version: " + vers.Minor);
}
function parse_EncInfoStd(blob2) {
  var flags = blob2.read_shift(4);
  if ((flags & 63) != 36)
    throw new Error("EncryptionInfo mismatch");
  var sz = blob2.read_shift(4);
  var hdr = parse_EncryptionHeader(blob2, sz);
  var verifier = parse_EncryptionVerifier(blob2, blob2.length - blob2.l);
  return { t: "Std", h: hdr, v: verifier };
}
function parse_EncInfoExt() {
  throw new Error("File is password-protected: ECMA-376 Extensible");
}
function parse_EncInfoAgl(blob2) {
  var KeyData = ["saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue"];
  blob2.l += 4;
  var xml = blob2.read_shift(blob2.length - blob2.l, "utf8");
  var o = {};
  xml.replace(tagregex, function xml_agile(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<encryption":
      case "</encryption>":
        break;
      case "<keyData":
        KeyData.forEach(function(k) {
          o[k] = y[k];
        });
        break;
      case "<dataIntegrity":
        o.encryptedHmacKey = y.encryptedHmacKey;
        o.encryptedHmacValue = y.encryptedHmacValue;
        break;
      case "<keyEncryptors>":
      case "<keyEncryptors":
        o.encs = [];
        break;
      case "</keyEncryptors>":
        break;
      case "<keyEncryptor":
        o.uri = y.uri;
        break;
      case "</keyEncryptor>":
        break;
      case "<encryptedKey":
        o.encs.push(y);
        break;
      default:
        throw y[0];
    }
  });
  return o;
}
function parse_RC4CryptoHeader(blob2, length2) {
  var o = {};
  var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob2, 4);
  length2 -= 4;
  if (vers.Minor != 2)
    throw new Error("unrecognized minor version code: " + vers.Minor);
  if (vers.Major > 4 || vers.Major < 2)
    throw new Error("unrecognized major version code: " + vers.Major);
  o.Flags = blob2.read_shift(4);
  length2 -= 4;
  var sz = blob2.read_shift(4);
  length2 -= 4;
  o.EncryptionHeader = parse_EncryptionHeader(blob2, sz);
  length2 -= sz;
  o.EncryptionVerifier = parse_EncryptionVerifier(blob2, length2);
  return o;
}
function parse_RC4Header(blob2) {
  var o = {};
  var vers = o.EncryptionVersionInfo = parse_CRYPTOVersion(blob2, 4);
  if (vers.Major != 1 || vers.Minor != 1)
    throw "unrecognized version code " + vers.Major + " : " + vers.Minor;
  o.Salt = blob2.read_shift(16);
  o.EncryptedVerifier = blob2.read_shift(16);
  o.EncryptedVerifierHash = blob2.read_shift(16);
  return o;
}
function crypto_CreatePasswordVerifier_Method1(Password) {
  var Verifier = 0, PasswordArray;
  var PasswordDecoded = _JS2ANSI(Password);
  var len = PasswordDecoded.length + 1, i, PasswordByte;
  var Intermediate1, Intermediate2, Intermediate3;
  PasswordArray = new_raw_buf(len);
  PasswordArray[0] = PasswordDecoded.length;
  for (i = 1; i != len; ++i)
    PasswordArray[i] = PasswordDecoded[i - 1];
  for (i = len - 1; i >= 0; --i) {
    PasswordByte = PasswordArray[i];
    Intermediate1 = (Verifier & 16384) === 0 ? 0 : 1;
    Intermediate2 = Verifier << 1 & 32767;
    Intermediate3 = Intermediate1 | Intermediate2;
    Verifier = Intermediate3 ^ PasswordByte;
  }
  return Verifier ^ 52811;
}
var crypto_CreateXorArray_Method1 = /* @__PURE__ */ function() {
  var PadArray = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0];
  var InitialCode = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163];
  var XorMatrix = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628];
  var Ror = function(Byte) {
    return (Byte / 2 | Byte * 128) & 255;
  };
  var XorRor = function(byte1, byte2) {
    return Ror(byte1 ^ byte2);
  };
  var CreateXorKey_Method1 = function(Password) {
    var XorKey = InitialCode[Password.length - 1];
    var CurrentElement = 104;
    for (var i = Password.length - 1; i >= 0; --i) {
      var Char = Password[i];
      for (var j = 0; j != 7; ++j) {
        if (Char & 64)
          XorKey ^= XorMatrix[CurrentElement];
        Char *= 2;
        --CurrentElement;
      }
    }
    return XorKey;
  };
  return function(password) {
    var Password = _JS2ANSI(password);
    var XorKey = CreateXorKey_Method1(Password);
    var Index = Password.length;
    var ObfuscationArray = new_raw_buf(16);
    for (var i = 0; i != 16; ++i)
      ObfuscationArray[i] = 0;
    var Temp, PasswordLastChar, PadIndex;
    if ((Index & 1) === 1) {
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(PadArray[0], Temp);
      --Index;
      Temp = XorKey & 255;
      PasswordLastChar = Password[Password.length - 1];
      ObfuscationArray[Index] = XorRor(PasswordLastChar, Temp);
    }
    while (Index > 0) {
      --Index;
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
      --Index;
      Temp = XorKey & 255;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
    }
    Index = 15;
    PadIndex = 15 - Password.length;
    while (PadIndex > 0) {
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(PadArray[PadIndex], Temp);
      --Index;
      --PadIndex;
      Temp = XorKey & 255;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
      --Index;
      --PadIndex;
    }
    return ObfuscationArray;
  };
}();
var crypto_DecryptData_Method1 = function(password, Data, XorArrayIndex, XorArray, O) {
  if (!O)
    O = Data;
  if (!XorArray)
    XorArray = crypto_CreateXorArray_Method1(password);
  var Index, Value;
  for (Index = 0; Index != Data.length; ++Index) {
    Value = Data[Index];
    Value ^= XorArray[XorArrayIndex];
    Value = (Value >> 5 | Value << 3) & 255;
    O[Index] = Value;
    ++XorArrayIndex;
  }
  return [O, XorArrayIndex, XorArray];
};
var crypto_MakeXorDecryptor = function(password) {
  var XorArrayIndex = 0, XorArray = crypto_CreateXorArray_Method1(password);
  return function(Data) {
    var O = crypto_DecryptData_Method1("", Data, XorArrayIndex, XorArray);
    XorArrayIndex = O[1];
    return O[0];
  };
};
function parse_XORObfuscation(blob2, length2, opts, out) {
  var o = { key: parseuint16(blob2), verificationBytes: parseuint16(blob2) };
  if (opts.password)
    o.verifier = crypto_CreatePasswordVerifier_Method1(opts.password);
  out.valid = o.verificationBytes === o.verifier;
  if (out.valid)
    out.insitu = crypto_MakeXorDecryptor(opts.password);
  return o;
}
function parse_FilePassHeader(blob2, length2, oo) {
  var o = oo || {};
  o.Info = blob2.read_shift(2);
  blob2.l -= 2;
  if (o.Info === 1)
    o.Data = parse_RC4Header(blob2);
  else
    o.Data = parse_RC4CryptoHeader(blob2, length2);
  return o;
}
function parse_FilePass(blob2, length2, opts) {
  var o = { Type: opts.biff >= 8 ? blob2.read_shift(2) : 0 };
  if (o.Type)
    parse_FilePassHeader(blob2, length2 - 2, o);
  else
    parse_XORObfuscation(blob2, opts.biff >= 8 ? length2 : length2 - 2, opts, o);
  return o;
}
function rtf_to_sheet(d, opts) {
  switch (opts.type) {
    case "base64":
      return rtf_to_sheet_str(Base64_decode(d), opts);
    case "binary":
      return rtf_to_sheet_str(d, opts);
    case "buffer":
      return rtf_to_sheet_str(has_buf && Buffer.isBuffer(d) ? d.toString("binary") : a2s(d), opts);
    case "array":
      return rtf_to_sheet_str(cc2str(d), opts);
  }
  throw new Error("Unrecognized type " + opts.type);
}
function rtf_to_sheet_str(str, opts) {
  var o = opts || {};
  var ws = {};
  var dense = o.dense;
  if (dense)
    ws["!data"] = [];
  var rows = str.match(/\\trowd[\s\S]*?\\row\b/g);
  if (!rows)
    throw new Error("RTF missing table");
  var range = { s: { c: 0, r: 0 }, e: { c: 0, r: rows.length - 1 } };
  var row = [];
  rows.forEach(function(rowtf, R) {
    if (dense)
      row = ws["!data"][R] = [];
    var rtfre = /\\[\w\-]+\b/g;
    var last_index = 0;
    var res;
    var C = -1;
    var payload = [];
    while ((res = rtfre.exec(rowtf)) != null) {
      var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);
      if (data.charCodeAt(0) == 32)
        data = data.slice(1);
      if (data.length)
        payload.push(data);
      switch (res[0]) {
        case "\\cell":
          ++C;
          if (payload.length) {
            var cell = { v: payload.join(""), t: "s" };
            if (cell.v == "TRUE" || cell.v == "FALSE") {
              cell.v = cell.v == "TRUE";
              cell.t = "b";
            } else if (!isNaN(fuzzynum(cell.v))) {
              cell.t = "n";
              if (o.cellText !== false)
                cell.w = cell.v;
              cell.v = fuzzynum(cell.v);
            }
            if (dense)
              row[C] = cell;
            else
              ws[encode_cell({ r: R, c: C })] = cell;
          }
          payload = [];
          break;
        case "\\par":
          payload.push("\n");
          break;
      }
      last_index = rtfre.lastIndex;
    }
    if (C > range.e.c)
      range.e.c = C;
  });
  ws["!ref"] = encode_range(range);
  return ws;
}
function rtf_to_workbook(d, opts) {
  var wb = sheet_to_workbook(rtf_to_sheet(d, opts), opts);
  wb.bookType = "rtf";
  return wb;
}
function sheet_to_rtf(ws, opts) {
  var o = ["{\\rtf1\\ansi"];
  if (!ws["!ref"])
    return o[0] + "}";
  var r = safe_decode_range(ws["!ref"]), cell;
  var dense = ws["!data"] != null, row = [];
  for (var R = r.s.r; R <= r.e.r; ++R) {
    o.push("\\trowd\\trautofit1");
    for (var C = r.s.c; C <= r.e.c; ++C)
      o.push("\\cellx" + (C + 1));
    o.push("\\pard\\intbl");
    if (dense)
      row = ws["!data"][R] || [];
    for (C = r.s.c; C <= r.e.c; ++C) {
      var coord = encode_cell({ r: R, c: C });
      cell = dense ? row[C] : ws[coord];
      if (!cell || cell.v == null && (!cell.f || cell.F)) {
        o.push(" \\cell");
        continue;
      }
      o.push(" " + (cell.w || (format_cell(cell), cell.w) || "").replace(/[\r\n]/g, "\\par "));
      o.push("\\cell");
    }
    o.push("\\pard\\intbl\\row");
  }
  return o.join("") + "}";
}
function hex2RGB(h) {
  var o = h.slice(h[0] === "#" ? 1 : 0).slice(0, 6);
  return [parseInt(o.slice(0, 2), 16), parseInt(o.slice(2, 4), 16), parseInt(o.slice(4, 6), 16)];
}
function rgb2Hex(rgb) {
  for (var i = 0, o = 1; i != 3; ++i)
    o = o * 256 + (rgb[i] > 255 ? 255 : rgb[i] < 0 ? 0 : rgb[i]);
  return o.toString(16).toUpperCase().slice(1);
}
function rgb2HSL(rgb) {
  var R = rgb[0] / 255, G = rgb[1] / 255, B = rgb[2] / 255;
  var M = Math.max(R, G, B), m = Math.min(R, G, B), C = M - m;
  if (C === 0)
    return [0, 0, R];
  var H6 = 0, S = 0, L2 = M + m;
  S = C / (L2 > 1 ? 2 - L2 : L2);
  switch (M) {
    case R:
      H6 = ((G - B) / C + 6) % 6;
      break;
    case G:
      H6 = (B - R) / C + 2;
      break;
    case B:
      H6 = (R - G) / C + 4;
      break;
  }
  return [H6 / 6, S, L2 / 2];
}
function hsl2RGB(hsl) {
  var H = hsl[0], S = hsl[1], L = hsl[2];
  var C = S * 2 * (L < 0.5 ? L : 1 - L), m = L - C / 2;
  var rgb = [m, m, m], h6 = 6 * H;
  var X;
  if (S !== 0)
    switch (h6 | 0) {
      case 0:
      case 6:
        X = C * h6;
        rgb[0] += C;
        rgb[1] += X;
        break;
      case 1:
        X = C * (2 - h6);
        rgb[0] += X;
        rgb[1] += C;
        break;
      case 2:
        X = C * (h6 - 2);
        rgb[1] += C;
        rgb[2] += X;
        break;
      case 3:
        X = C * (4 - h6);
        rgb[1] += X;
        rgb[2] += C;
        break;
      case 4:
        X = C * (h6 - 4);
        rgb[2] += C;
        rgb[0] += X;
        break;
      case 5:
        X = C * (6 - h6);
        rgb[2] += X;
        rgb[0] += C;
        break;
    }
  for (var i = 0; i != 3; ++i)
    rgb[i] = Math.round(rgb[i] * 255);
  return rgb;
}
function rgb_tint(hex, tint) {
  if (tint === 0)
    return hex;
  var hsl = rgb2HSL(hex2RGB(hex));
  if (tint < 0)
    hsl[2] = hsl[2] * (1 + tint);
  else
    hsl[2] = 1 - (1 - hsl[2]) * (1 - tint);
  return rgb2Hex(hsl2RGB(hsl));
}
var DEF_MDW = 6, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;
function width2px(width) {
  return Math.floor((width + Math.round(128 / MDW) / 256) * MDW);
}
function px2char(px) {
  return Math.floor((px - 5) / MDW * 100 + 0.5) / 100;
}
function char2width(chr) {
  return Math.round((chr * MDW + 5) / MDW * 256) / 256;
}
function cycle_width(collw) {
  return char2width(px2char(width2px(collw)));
}
function find_mdw_colw(collw) {
  var delta = Math.abs(collw - cycle_width(collw)), _MDW = MDW;
  if (delta > 5e-3) {
    for (MDW = MIN_MDW; MDW < MAX_MDW; ++MDW)
      if (Math.abs(collw - cycle_width(collw)) <= delta) {
        delta = Math.abs(collw - cycle_width(collw));
        _MDW = MDW;
      }
  }
  MDW = _MDW;
}
function process_col(coll) {
  if (coll.width) {
    coll.wpx = width2px(coll.width);
    coll.wch = px2char(coll.wpx);
    coll.MDW = MDW;
  } else if (coll.wpx) {
    coll.wch = px2char(coll.wpx);
    coll.width = char2width(coll.wch);
    coll.MDW = MDW;
  } else if (typeof coll.wch == "number") {
    coll.width = char2width(coll.wch);
    coll.wpx = width2px(coll.width);
    coll.MDW = MDW;
  }
  if (coll.customWidth)
    delete coll.customWidth;
}
var DEF_PPI = 96, PPI = DEF_PPI;
function px2pt(px) {
  return px * 96 / PPI;
}
function pt2px(pt) {
  return pt * PPI / 96;
}
var XLMLPatternTypeMap = {
  "None": "none",
  "Solid": "solid",
  "Gray50": "mediumGray",
  "Gray75": "darkGray",
  "Gray25": "lightGray",
  "HorzStripe": "darkHorizontal",
  "VertStripe": "darkVertical",
  "ReverseDiagStripe": "darkDown",
  "DiagStripe": "darkUp",
  "DiagCross": "darkGrid",
  "ThickDiagCross": "darkTrellis",
  "ThinHorzStripe": "lightHorizontal",
  "ThinVertStripe": "lightVertical",
  "ThinReverseDiagStripe": "lightDown",
  "ThinHorzCross": "lightGrid"
};
function parse_borders(t, styles2, themes, opts) {
  styles2.Borders = [];
  var border = {};
  var pass = false;
  (t[0].match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<borders":
      case "<borders>":
      case "</borders>":
        break;
      case "<border":
      case "<border>":
      case "<border/>":
        border = /*::(*/
        {};
        if (y.diagonalUp)
          border.diagonalUp = parsexmlbool(y.diagonalUp);
        if (y.diagonalDown)
          border.diagonalDown = parsexmlbool(y.diagonalDown);
        styles2.Borders.push(border);
        break;
      case "</border>":
        break;
      case "<left/>":
        break;
      case "<left":
      case "<left>":
        break;
      case "</left>":
        break;
      case "<right/>":
        break;
      case "<right":
      case "<right>":
        break;
      case "</right>":
        break;
      case "<top/>":
        break;
      case "<top":
      case "<top>":
        break;
      case "</top>":
        break;
      case "<bottom/>":
        break;
      case "<bottom":
      case "<bottom>":
        break;
      case "</bottom>":
        break;
      case "<diagonal":
      case "<diagonal>":
      case "<diagonal/>":
        break;
      case "</diagonal>":
        break;
      case "<horizontal":
      case "<horizontal>":
      case "<horizontal/>":
        break;
      case "</horizontal>":
        break;
      case "<vertical":
      case "<vertical>":
      case "<vertical/>":
        break;
      case "</vertical>":
        break;
      case "<start":
      case "<start>":
      case "<start/>":
        break;
      case "</start>":
        break;
      case "<end":
      case "<end>":
      case "<end/>":
        break;
      case "</end>":
        break;
      case "<color":
      case "<color>":
        break;
      case "<color/>":
      case "</color>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass)
            throw new Error("unrecognized " + y[0] + " in borders");
        }
    }
  });
}
function parse_fills(t, styles2, themes, opts) {
  styles2.Fills = [];
  var fill2 = {};
  var pass = false;
  (t[0].match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<fills":
      case "<fills>":
      case "</fills>":
        break;
      case "<fill>":
      case "<fill":
      case "<fill/>":
        fill2 = {};
        styles2.Fills.push(fill2);
        break;
      case "</fill>":
        break;
      case "<gradientFill>":
        break;
      case "<gradientFill":
      case "</gradientFill>":
        styles2.Fills.push(fill2);
        fill2 = {};
        break;
      case "<patternFill":
      case "<patternFill>":
        if (y.patternType)
          fill2.patternType = y.patternType;
        break;
      case "<patternFill/>":
      case "</patternFill>":
        break;
      case "<bgColor":
        if (!fill2.bgColor)
          fill2.bgColor = {};
        if (y.indexed)
          fill2.bgColor.indexed = parseInt(y.indexed, 10);
        if (y.theme)
          fill2.bgColor.theme = parseInt(y.theme, 10);
        if (y.tint)
          fill2.bgColor.tint = parseFloat(y.tint);
        if (y.rgb)
          fill2.bgColor.rgb = y.rgb.slice(-6);
        break;
      case "<bgColor/>":
      case "</bgColor>":
        break;
      case "<fgColor":
        if (!fill2.fgColor)
          fill2.fgColor = {};
        if (y.theme)
          fill2.fgColor.theme = parseInt(y.theme, 10);
        if (y.tint)
          fill2.fgColor.tint = parseFloat(y.tint);
        if (y.rgb != null)
          fill2.fgColor.rgb = y.rgb.slice(-6);
        break;
      case "<fgColor/>":
      case "</fgColor>":
        break;
      case "<stop":
      case "<stop/>":
        break;
      case "</stop>":
        break;
      case "<color":
      case "<color/>":
        break;
      case "</color>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass)
            throw new Error("unrecognized " + y[0] + " in fills");
        }
    }
  });
}
function parse_fonts(t, styles2, themes, opts) {
  styles2.Fonts = [];
  var font = {};
  var pass = false;
  (t[0].match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<fonts":
      case "<fonts>":
      case "</fonts>":
        break;
      case "<font":
      case "<font>":
        break;
      case "</font>":
      case "<font/>":
        styles2.Fonts.push(font);
        font = {};
        break;
      case "<name":
        if (y.val)
          font.name = utf8read(y.val);
        break;
      case "<name/>":
      case "</name>":
        break;
      case "<b":
        font.bold = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<b/>":
        font.bold = 1;
        break;
      case "<i":
        font.italic = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<i/>":
        font.italic = 1;
        break;
      case "<u":
        switch (y.val) {
          case "none":
            font.underline = 0;
            break;
          case "single":
            font.underline = 1;
            break;
          case "double":
            font.underline = 2;
            break;
          case "singleAccounting":
            font.underline = 33;
            break;
          case "doubleAccounting":
            font.underline = 34;
            break;
        }
        break;
      case "<u/>":
        font.underline = 1;
        break;
      case "<strike":
        font.strike = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<strike/>":
        font.strike = 1;
        break;
      case "<outline":
        font.outline = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<outline/>":
        font.outline = 1;
        break;
      case "<shadow":
        font.shadow = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<shadow/>":
        font.shadow = 1;
        break;
      case "<condense":
        font.condense = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<condense/>":
        font.condense = 1;
        break;
      case "<extend":
        font.extend = y.val ? parsexmlbool(y.val) : 1;
        break;
      case "<extend/>":
        font.extend = 1;
        break;
      case "<sz":
        if (y.val)
          font.sz = +y.val;
        break;
      case "<sz/>":
      case "</sz>":
        break;
      case "<vertAlign":
        if (y.val)
          font.vertAlign = y.val;
        break;
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      case "<family":
        if (y.val)
          font.family = parseInt(y.val, 10);
        break;
      case "<family/>":
      case "</family>":
        break;
      case "<scheme":
        if (y.val)
          font.scheme = y.val;
        break;
      case "<scheme/>":
      case "</scheme>":
        break;
      case "<charset":
        if (y.val == "1")
          break;
        y.codepage = CS2CP[parseInt(y.val, 10)];
        break;
      case "<color":
        if (!font.color)
          font.color = {};
        if (y.auto)
          font.color.auto = parsexmlbool(y.auto);
        if (y.rgb)
          font.color.rgb = y.rgb.slice(-6);
        else if (y.indexed) {
          font.color.index = parseInt(y.indexed, 10);
          var icv = XLSIcv[font.color.index];
          if (font.color.index == 81)
            icv = XLSIcv[1];
          if (!icv)
            icv = XLSIcv[1];
          font.color.rgb = icv[0].toString(16) + icv[1].toString(16) + icv[2].toString(16);
        } else if (y.theme) {
          font.color.theme = parseInt(y.theme, 10);
          if (y.tint)
            font.color.tint = parseFloat(y.tint);
          if (y.theme && themes.themeElements && themes.themeElements.clrScheme) {
            font.color.rgb = rgb_tint(themes.themeElements.clrScheme[font.color.theme].rgb, font.color.tint || 0);
          }
        }
        break;
      case "<color/>":
      case "</color>":
        break;
      case "<AlternateContent":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass)
            throw new Error("unrecognized " + y[0] + " in fonts");
        }
    }
  });
}
function parse_numFmts(t, styles2, opts) {
  styles2.NumberFmt = [];
  var k = keys(table_fmt);
  for (var i = 0; i < k.length; ++i)
    styles2.NumberFmt[k[i]] = table_fmt[k[i]];
  var m = t[0].match(tagregex);
  if (!m)
    return;
  for (i = 0; i < m.length; ++i) {
    var y = parsexmltag(m[i]);
    switch (strip_ns(y[0])) {
      case "<numFmts":
      case "</numFmts>":
      case "<numFmts/>":
      case "<numFmts>":
        break;
      case "<numFmt":
        {
          var f = unescapexml(utf8read(y.formatCode)), j = parseInt(y.numFmtId, 10);
          styles2.NumberFmt[j] = f;
          if (j > 0) {
            if (j > 392) {
              for (j = 392; j > 60; --j)
                if (styles2.NumberFmt[j] == null)
                  break;
              styles2.NumberFmt[j] = f;
            }
            SSF__load(f, j);
          }
        }
        break;
      case "</numFmt>":
        break;
      default:
        if (opts.WTF)
          throw new Error("unrecognized " + y[0] + " in numFmts");
    }
  }
}
function write_numFmts(NF) {
  var o = ["<numFmts>"];
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var i = r[0]; i <= r[1]; ++i)
      if (NF[i] != null)
        o[o.length] = writextag("numFmt", null, { numFmtId: i, formatCode: escapexml(NF[i]) });
  });
  if (o.length === 1)
    return "";
  o[o.length] = "</numFmts>";
  o[0] = writextag("numFmts", null, { count: o.length - 2 }).replace("/>", ">");
  return o.join("");
}
var cellXF_uint = ["numFmtId", "fillId", "fontId", "borderId", "xfId"];
var cellXF_bool = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];
function parse_cellXfs(t, styles2, opts) {
  styles2.CellXf = [];
  var xf;
  var pass = false;
  (t[0].match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x), i = 0;
    switch (strip_ns(y[0])) {
      case "<cellXfs":
      case "<cellXfs>":
      case "<cellXfs/>":
      case "</cellXfs>":
        break;
      case "<xf":
      case "<xf/>":
        xf = y;
        delete xf[0];
        for (i = 0; i < cellXF_uint.length; ++i)
          if (xf[cellXF_uint[i]])
            xf[cellXF_uint[i]] = parseInt(xf[cellXF_uint[i]], 10);
        for (i = 0; i < cellXF_bool.length; ++i)
          if (xf[cellXF_bool[i]])
            xf[cellXF_bool[i]] = parsexmlbool(xf[cellXF_bool[i]]);
        if (styles2.NumberFmt && xf.numFmtId > 392) {
          for (i = 392; i > 60; --i)
            if (styles2.NumberFmt[xf.numFmtId] == styles2.NumberFmt[i]) {
              xf.numFmtId = i;
              break;
            }
        }
        styles2.CellXf.push(xf);
        break;
      case "</xf>":
        break;
      case "<alignment":
      case "<alignment/>":
        var alignment = {};
        if (y.vertical)
          alignment.vertical = y.vertical;
        if (y.horizontal)
          alignment.horizontal = y.horizontal;
        if (y.textRotation != null)
          alignment.textRotation = y.textRotation;
        if (y.indent)
          alignment.indent = y.indent;
        if (y.wrapText)
          alignment.wrapText = parsexmlbool(y.wrapText);
        xf.alignment = alignment;
        break;
      case "</alignment>":
        break;
      case "<protection":
        break;
      case "</protection>":
      case "<protection/>":
        break;
      case "<AlternateContent":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass)
            throw new Error("unrecognized " + y[0] + " in cellXfs");
        }
    }
  });
}
function write_cellXfs(cellXfs) {
  var o = [];
  o[o.length] = writextag("cellXfs", null);
  cellXfs.forEach(function(c) {
    o[o.length] = writextag("xf", null, c);
  });
  o[o.length] = "</cellXfs>";
  if (o.length === 2)
    return "";
  o[0] = writextag("cellXfs", null, { count: o.length - 2 }).replace("/>", ">");
  return o.join("");
}
var parse_sty_xml = /* @__PURE__ */ function make_pstyx() {
  var numFmtRegex = /<(?:\w+:)?numFmts([^>]*)>[\S\s]*?<\/(?:\w+:)?numFmts>/;
  var cellXfRegex = /<(?:\w+:)?cellXfs([^>]*)>[\S\s]*?<\/(?:\w+:)?cellXfs>/;
  var fillsRegex = /<(?:\w+:)?fills([^>]*)>[\S\s]*?<\/(?:\w+:)?fills>/;
  var fontsRegex = /<(?:\w+:)?fonts([^>]*)>[\S\s]*?<\/(?:\w+:)?fonts>/;
  var bordersRegex = /<(?:\w+:)?borders([^>]*)>[\S\s]*?<\/(?:\w+:)?borders>/;
  return function parse_sty_xml2(data, themes, opts) {
    var styles2 = {};
    if (!data)
      return styles2;
    data = data.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
    var t;
    if (t = data.match(numFmtRegex))
      parse_numFmts(t, styles2, opts);
    if (t = data.match(fontsRegex))
      parse_fonts(t, styles2, themes, opts);
    if (t = data.match(fillsRegex))
      parse_fills(t, styles2, themes, opts);
    if (t = data.match(bordersRegex))
      parse_borders(t, styles2, themes, opts);
    if (t = data.match(cellXfRegex))
      parse_cellXfs(t, styles2, opts);
    return styles2;
  };
}();
function write_sty_xml(wb, opts) {
  var o = [XML_HEADER, writextag("styleSheet", null, {
    "xmlns": XMLNS_main[0],
    "xmlns:vt": XMLNS.vt
  })], w2;
  if (wb.SSF && (w2 = write_numFmts(wb.SSF)) != null)
    o[o.length] = w2;
  o[o.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>';
  o[o.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>';
  o[o.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>';
  o[o.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';
  if (w2 = write_cellXfs(opts.cellXfs))
    o[o.length] = w2;
  o[o.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>';
  o[o.length] = '<dxfs count="0"/>';
  o[o.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>';
  if (o.length > 2) {
    o[o.length] = "</styleSheet>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
function parse_BrtFmt(data, length2) {
  var numFmtId = data.read_shift(2);
  var stFmtCode = parse_XLWideString(data);
  return [numFmtId, stFmtCode];
}
function write_BrtFmt(i, f, o) {
  if (!o)
    o = new_buf(6 + 4 * f.length);
  o.write_shift(2, i);
  write_XLWideString(f, o);
  var out = o.length > o.l ? o.slice(0, o.l) : o;
  if (o.l == null)
    o.l = o.length;
  return out;
}
function parse_BrtFont(data, length2, opts) {
  var out = {};
  out.sz = data.read_shift(2) / 20;
  var grbit = parse_FontFlags(data);
  if (grbit.fItalic)
    out.italic = 1;
  if (grbit.fCondense)
    out.condense = 1;
  if (grbit.fExtend)
    out.extend = 1;
  if (grbit.fShadow)
    out.shadow = 1;
  if (grbit.fOutline)
    out.outline = 1;
  if (grbit.fStrikeout)
    out.strike = 1;
  var bls = data.read_shift(2);
  if (bls === 700)
    out.bold = 1;
  switch (data.read_shift(2)) {
    case 1:
      out.vertAlign = "superscript";
      break;
    case 2:
      out.vertAlign = "subscript";
      break;
  }
  var underline = data.read_shift(1);
  if (underline != 0)
    out.underline = underline;
  var family = data.read_shift(1);
  if (family > 0)
    out.family = family;
  var bCharSet = data.read_shift(1);
  if (bCharSet > 0)
    out.charset = bCharSet;
  data.l++;
  out.color = parse_BrtColor(data);
  switch (data.read_shift(1)) {
    case 1:
      out.scheme = "major";
      break;
    case 2:
      out.scheme = "minor";
      break;
  }
  out.name = parse_XLWideString(data);
  return out;
}
function write_BrtFont(font, o) {
  if (!o)
    o = new_buf(25 + 4 * 32);
  o.write_shift(2, font.sz * 20);
  write_FontFlags(font, o);
  o.write_shift(2, font.bold ? 700 : 400);
  var sss = 0;
  if (font.vertAlign == "superscript")
    sss = 1;
  else if (font.vertAlign == "subscript")
    sss = 2;
  o.write_shift(2, sss);
  o.write_shift(1, font.underline || 0);
  o.write_shift(1, font.family || 0);
  o.write_shift(1, font.charset || 0);
  o.write_shift(1, 0);
  write_BrtColor(font.color, o);
  var scheme = 0;
  if (font.scheme == "major")
    scheme = 1;
  if (font.scheme == "minor")
    scheme = 2;
  o.write_shift(1, scheme);
  write_XLWideString(font.name, o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
var XLSBFillPTNames = [
  "none",
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
var rev_XLSBFillPTNames;
var parse_BrtFill = parsenoop;
function write_BrtFill(fill2, o) {
  if (!o)
    o = new_buf(4 * 3 + 8 * 7 + 16 * 1);
  if (!rev_XLSBFillPTNames)
    rev_XLSBFillPTNames = evert(XLSBFillPTNames);
  var fls = rev_XLSBFillPTNames[fill2.patternType];
  if (fls == null)
    fls = 40;
  o.write_shift(4, fls);
  var j = 0;
  if (fls != 40) {
    write_BrtColor({ auto: 1 }, o);
    write_BrtColor({ auto: 1 }, o);
    for (; j < 12; ++j)
      o.write_shift(4, 0);
  } else {
    for (; j < 4; ++j)
      o.write_shift(4, 0);
    for (; j < 12; ++j)
      o.write_shift(4, 0);
  }
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function parse_BrtXF(data, length2) {
  var tgt = data.l + length2;
  var ixfeParent = data.read_shift(2);
  var ifmt = data.read_shift(2);
  data.l = tgt;
  return { ixfe: ixfeParent, numFmtId: ifmt };
}
function write_BrtXF(data, ixfeP, o) {
  if (!o)
    o = new_buf(16);
  o.write_shift(2, ixfeP || 0);
  o.write_shift(2, data.numFmtId || 0);
  o.write_shift(2, 0);
  o.write_shift(2, 0);
  o.write_shift(2, 0);
  o.write_shift(1, 0);
  o.write_shift(1, 0);
  var flow = 0;
  o.write_shift(1, flow);
  o.write_shift(1, 0);
  o.write_shift(1, 0);
  o.write_shift(1, 0);
  return o;
}
function write_Blxf(data, o) {
  if (!o)
    o = new_buf(10);
  o.write_shift(1, 0);
  o.write_shift(1, 0);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  return o;
}
var parse_BrtBorder = parsenoop;
function write_BrtBorder(border, o) {
  if (!o)
    o = new_buf(51);
  o.write_shift(1, 0);
  write_Blxf(null, o);
  write_Blxf(null, o);
  write_Blxf(null, o);
  write_Blxf(null, o);
  write_Blxf(null, o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function write_BrtStyle(style, o) {
  if (!o)
    o = new_buf(12 + 4 * 10);
  o.write_shift(4, style.xfId);
  o.write_shift(2, 1);
  o.write_shift(1, +style.builtinId);
  o.write_shift(1, 0);
  write_XLNullableWideString(style.name || "", o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function write_BrtBeginTableStyles(cnt, defTableStyle, defPivotStyle) {
  var o = new_buf(4 + 256 * 2 * 4);
  o.write_shift(4, cnt);
  write_XLNullableWideString(defTableStyle, o);
  write_XLNullableWideString(defPivotStyle, o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function parse_sty_bin(data, themes, opts) {
  var styles2 = {};
  styles2.NumberFmt = [];
  for (var y in table_fmt)
    styles2.NumberFmt[y] = table_fmt[y];
  styles2.CellXf = [];
  styles2.Fonts = [];
  var state = [];
  var pass = false;
  recordhopper(data, function hopper_sty(val, R, RT) {
    switch (RT) {
      case 44:
        styles2.NumberFmt[val[0]] = val[1];
        SSF__load(val[1], val[0]);
        break;
      case 43:
        styles2.Fonts.push(val);
        if (val.color.theme != null && themes && themes.themeElements && themes.themeElements.clrScheme) {
          val.color.rgb = rgb_tint(themes.themeElements.clrScheme[val.color.theme].rgb, val.color.tint || 0);
        }
        break;
      case 1025:
        break;
      case 45:
        break;
      case 46:
        break;
      case 47:
        if (state[state.length - 1] == 617) {
          styles2.CellXf.push(val);
        }
        break;
      case 48:
      case 507:
      case 572:
      case 475:
        break;
      case 1171:
      case 2102:
      case 1130:
      case 512:
      case 2095:
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        state.push(RT);
        pass = true;
        break;
      case 38:
        state.pop();
        pass = false;
        break;
      default:
        if (R.T > 0)
          state.push(RT);
        else if (R.T < 0)
          state.pop();
        else if (!pass || opts.WTF && state[state.length - 1] != 37)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return styles2;
}
function write_FMTS_bin(ba, NF) {
  if (!NF)
    return;
  var cnt = 0;
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var i = r[0]; i <= r[1]; ++i)
      if (NF[i] != null)
        ++cnt;
  });
  if (cnt == 0)
    return;
  write_record(ba, 615, write_UInt32LE(cnt));
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var i = r[0]; i <= r[1]; ++i)
      if (NF[i] != null)
        write_record(ba, 44, write_BrtFmt(i, NF[i]));
  });
  write_record(
    ba,
    616
    /* BrtEndFmts */
  );
}
function write_FONTS_bin(ba) {
  var cnt = 1;
  write_record(ba, 611, write_UInt32LE(cnt));
  write_record(ba, 43, write_BrtFont({
    sz: 12,
    color: { theme: 1 },
    name: "Calibri",
    family: 2,
    scheme: "minor"
  }));
  write_record(
    ba,
    612
    /* BrtEndFonts */
  );
}
function write_FILLS_bin(ba) {
  var cnt = 2;
  write_record(ba, 603, write_UInt32LE(cnt));
  write_record(ba, 45, write_BrtFill({ patternType: "none" }));
  write_record(ba, 45, write_BrtFill({ patternType: "gray125" }));
  write_record(
    ba,
    604
    /* BrtEndFills */
  );
}
function write_BORDERS_bin(ba) {
  var cnt = 1;
  write_record(ba, 613, write_UInt32LE(cnt));
  write_record(ba, 46, write_BrtBorder());
  write_record(
    ba,
    614
    /* BrtEndBorders */
  );
}
function write_CELLSTYLEXFS_bin(ba) {
  var cnt = 1;
  write_record(ba, 626, write_UInt32LE(cnt));
  write_record(ba, 47, write_BrtXF({
    numFmtId: 0,
    fontId: 0,
    fillId: 0,
    borderId: 0
  }, 65535));
  write_record(
    ba,
    627
    /* BrtEndCellStyleXFs */
  );
}
function write_CELLXFS_bin(ba, data) {
  write_record(ba, 617, write_UInt32LE(data.length));
  data.forEach(function(c) {
    write_record(ba, 47, write_BrtXF(c, 0));
  });
  write_record(
    ba,
    618
    /* BrtEndCellXFs */
  );
}
function write_STYLES_bin(ba) {
  var cnt = 1;
  write_record(ba, 619, write_UInt32LE(cnt));
  write_record(ba, 48, write_BrtStyle({
    xfId: 0,
    builtinId: 0,
    name: "Normal"
  }));
  write_record(
    ba,
    620
    /* BrtEndStyles */
  );
}
function write_DXFS_bin(ba) {
  var cnt = 0;
  write_record(ba, 505, write_UInt32LE(cnt));
  write_record(
    ba,
    506
    /* BrtEndDXFs */
  );
}
function write_TABLESTYLES_bin(ba) {
  var cnt = 0;
  write_record(ba, 508, write_BrtBeginTableStyles(cnt, "TableStyleMedium9", "PivotStyleMedium4"));
  write_record(
    ba,
    509
    /* BrtEndTableStyles */
  );
}
function write_sty_bin(wb, opts) {
  var ba = buf_array();
  write_record(
    ba,
    278
    /* BrtBeginStyleSheet */
  );
  write_FMTS_bin(ba, wb.SSF);
  write_FONTS_bin(ba);
  write_FILLS_bin(ba);
  write_BORDERS_bin(ba);
  write_CELLSTYLEXFS_bin(ba);
  write_CELLXFS_bin(ba, opts.cellXfs);
  write_STYLES_bin(ba);
  write_DXFS_bin(ba);
  write_TABLESTYLES_bin(ba);
  write_record(
    ba,
    279
    /* BrtEndStyleSheet */
  );
  return ba.end();
}
var XLSXThemeClrScheme = [
  "</a:lt1>",
  "</a:dk1>",
  "</a:lt2>",
  "</a:dk2>",
  "</a:accent1>",
  "</a:accent2>",
  "</a:accent3>",
  "</a:accent4>",
  "</a:accent5>",
  "</a:accent6>",
  "</a:hlink>",
  "</a:folHlink>"
];
function parse_clrScheme(t, themes, opts) {
  themes.themeElements.clrScheme = [];
  var color = {};
  (t[0].match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (y[0]) {
      case "<a:clrScheme":
      case "</a:clrScheme>":
        break;
      case "<a:srgbClr":
        color.rgb = y.val;
        break;
      case "<a:sysClr":
        color.rgb = y.lastClr;
        break;
      case "<a:dk1>":
      case "</a:dk1>":
      case "<a:lt1>":
      case "</a:lt1>":
      case "<a:dk2>":
      case "</a:dk2>":
      case "<a:lt2>":
      case "</a:lt2>":
      case "<a:accent1>":
      case "</a:accent1>":
      case "<a:accent2>":
      case "</a:accent2>":
      case "<a:accent3>":
      case "</a:accent3>":
      case "<a:accent4>":
      case "</a:accent4>":
      case "<a:accent5>":
      case "</a:accent5>":
      case "<a:accent6>":
      case "</a:accent6>":
      case "<a:hlink>":
      case "</a:hlink>":
      case "<a:folHlink>":
      case "</a:folHlink>":
        if (y[0].charAt(1) === "/") {
          themes.themeElements.clrScheme[XLSXThemeClrScheme.indexOf(y[0])] = color;
          color = {};
        } else {
          color.name = y[0].slice(3, y[0].length - 1);
        }
        break;
      default:
        if (opts && opts.WTF)
          throw new Error("Unrecognized " + y[0] + " in clrScheme");
    }
  });
}
function parse_fontScheme() {
}
function parse_fmtScheme() {
}
var clrsregex = /<a:clrScheme([^>]*)>[\s\S]*<\/a:clrScheme>/;
var fntsregex = /<a:fontScheme([^>]*)>[\s\S]*<\/a:fontScheme>/;
var fmtsregex = /<a:fmtScheme([^>]*)>[\s\S]*<\/a:fmtScheme>/;
function parse_themeElements(data, themes, opts) {
  themes.themeElements = {};
  var t;
  [
    /* clrScheme CT_ColorScheme */
    ["clrScheme", clrsregex, parse_clrScheme],
    /* fontScheme CT_FontScheme */
    ["fontScheme", fntsregex, parse_fontScheme],
    /* fmtScheme CT_StyleMatrix */
    ["fmtScheme", fmtsregex, parse_fmtScheme]
  ].forEach(function(m) {
    if (!(t = data.match(m[1])))
      throw new Error(m[0] + " not found in themeElements");
    m[2](t, themes, opts);
  });
}
var themeltregex = /<a:themeElements([^>]*)>[\s\S]*<\/a:themeElements>/;
function parse_theme_xml(data, opts) {
  if (!data || data.length === 0)
    data = write_theme();
  var t;
  var themes = {};
  if (!(t = data.match(themeltregex)))
    throw new Error("themeElements not found in theme");
  parse_themeElements(t[0], themes, opts);
  themes.raw = data;
  return themes;
}
function write_theme(Themes, opts) {
  if (opts && opts.themeXLSX)
    return opts.themeXLSX;
  if (Themes && typeof Themes.raw == "string")
    return Themes.raw;
  var o = [XML_HEADER];
  o[o.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';
  o[o.length] = "<a:themeElements>";
  o[o.length] = '<a:clrScheme name="Office">';
  o[o.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';
  o[o.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';
  o[o.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';
  o[o.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';
  o[o.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';
  o[o.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';
  o[o.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';
  o[o.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';
  o[o.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';
  o[o.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>';
  o[o.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';
  o[o.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';
  o[o.length] = "</a:clrScheme>";
  o[o.length] = '<a:fontScheme name="Office">';
  o[o.length] = "<a:majorFont>";
  o[o.length] = '<a:latin typeface="Cambria"/>';
  o[o.length] = '<a:ea typeface=""/>';
  o[o.length] = '<a:cs typeface=""/>';
  o[o.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>';
  o[o.length] = '<a:font script="Hang" typeface="맑은 고딕"/>';
  o[o.length] = '<a:font script="Hans" typeface="宋体"/>';
  o[o.length] = '<a:font script="Hant" typeface="新細明體"/>';
  o[o.length] = '<a:font script="Arab" typeface="Times New Roman"/>';
  o[o.length] = '<a:font script="Hebr" typeface="Times New Roman"/>';
  o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
  o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
  o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
  o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
  o[o.length] = '<a:font script="Khmr" typeface="MoolBoran"/>';
  o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
  o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
  o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
  o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
  o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
  o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
  o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
  o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
  o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
  o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
  o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  o[o.length] = '<a:font script="Viet" typeface="Times New Roman"/>';
  o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
  o[o.length] = "</a:majorFont>";
  o[o.length] = "<a:minorFont>";
  o[o.length] = '<a:latin typeface="Calibri"/>';
  o[o.length] = '<a:ea typeface=""/>';
  o[o.length] = '<a:cs typeface=""/>';
  o[o.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>';
  o[o.length] = '<a:font script="Hang" typeface="맑은 고딕"/>';
  o[o.length] = '<a:font script="Hans" typeface="宋体"/>';
  o[o.length] = '<a:font script="Hant" typeface="新細明體"/>';
  o[o.length] = '<a:font script="Arab" typeface="Arial"/>';
  o[o.length] = '<a:font script="Hebr" typeface="Arial"/>';
  o[o.length] = '<a:font script="Thai" typeface="Tahoma"/>';
  o[o.length] = '<a:font script="Ethi" typeface="Nyala"/>';
  o[o.length] = '<a:font script="Beng" typeface="Vrinda"/>';
  o[o.length] = '<a:font script="Gujr" typeface="Shruti"/>';
  o[o.length] = '<a:font script="Khmr" typeface="DaunPenh"/>';
  o[o.length] = '<a:font script="Knda" typeface="Tunga"/>';
  o[o.length] = '<a:font script="Guru" typeface="Raavi"/>';
  o[o.length] = '<a:font script="Cans" typeface="Euphemia"/>';
  o[o.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  o[o.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  o[o.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  o[o.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
  o[o.length] = '<a:font script="Deva" typeface="Mangal"/>';
  o[o.length] = '<a:font script="Telu" typeface="Gautami"/>';
  o[o.length] = '<a:font script="Taml" typeface="Latha"/>';
  o[o.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  o[o.length] = '<a:font script="Orya" typeface="Kalinga"/>';
  o[o.length] = '<a:font script="Mlym" typeface="Kartika"/>';
  o[o.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
  o[o.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  o[o.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  o[o.length] = '<a:font script="Viet" typeface="Arial"/>';
  o[o.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  o[o.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
  o[o.length] = "</a:minorFont>";
  o[o.length] = "</a:fontScheme>";
  o[o.length] = '<a:fmtScheme name="Office">';
  o[o.length] = "<a:fillStyleLst>";
  o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  o[o.length] = '<a:gradFill rotWithShape="1">';
  o[o.length] = "<a:gsLst>";
  o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o[o.length] = "</a:gsLst>";
  o[o.length] = '<a:lin ang="16200000" scaled="1"/>';
  o[o.length] = "</a:gradFill>";
  o[o.length] = '<a:gradFill rotWithShape="1">';
  o[o.length] = "<a:gsLst>";
  o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o[o.length] = "</a:gsLst>";
  o[o.length] = '<a:lin ang="16200000" scaled="0"/>';
  o[o.length] = "</a:gradFill>";
  o[o.length] = "</a:fillStyleLst>";
  o[o.length] = "<a:lnStyleLst>";
  o[o.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o[o.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o[o.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o[o.length] = "</a:lnStyleLst>";
  o[o.length] = "<a:effectStyleLst>";
  o[o.length] = "<a:effectStyle>";
  o[o.length] = "<a:effectLst>";
  o[o.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';
  o[o.length] = "</a:effectLst>";
  o[o.length] = "</a:effectStyle>";
  o[o.length] = "<a:effectStyle>";
  o[o.length] = "<a:effectLst>";
  o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  o[o.length] = "</a:effectLst>";
  o[o.length] = "</a:effectStyle>";
  o[o.length] = "<a:effectStyle>";
  o[o.length] = "<a:effectLst>";
  o[o.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  o[o.length] = "</a:effectLst>";
  o[o.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';
  o[o.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';
  o[o.length] = "</a:effectStyle>";
  o[o.length] = "</a:effectStyleLst>";
  o[o.length] = "<a:bgFillStyleLst>";
  o[o.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  o[o.length] = '<a:gradFill rotWithShape="1">';
  o[o.length] = "<a:gsLst>";
  o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';
  o[o.length] = "</a:gsLst>";
  o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';
  o[o.length] = "</a:gradFill>";
  o[o.length] = '<a:gradFill rotWithShape="1">';
  o[o.length] = "<a:gsLst>";
  o[o.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o[o.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';
  o[o.length] = "</a:gsLst>";
  o[o.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
  o[o.length] = "</a:gradFill>";
  o[o.length] = "</a:bgFillStyleLst>";
  o[o.length] = "</a:fmtScheme>";
  o[o.length] = "</a:themeElements>";
  o[o.length] = "<a:objectDefaults>";
  o[o.length] = "<a:spDef>";
  o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';
  o[o.length] = "</a:spDef>";
  o[o.length] = "<a:lnDef>";
  o[o.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';
  o[o.length] = "</a:lnDef>";
  o[o.length] = "</a:objectDefaults>";
  o[o.length] = "<a:extraClrSchemeLst/>";
  o[o.length] = "</a:theme>";
  return o.join("");
}
function parse_Theme(blob2, length2, opts) {
  var end = blob2.l + length2;
  var dwThemeVersion = blob2.read_shift(4);
  if (dwThemeVersion === 124226)
    return;
  if (!opts.cellStyles) {
    blob2.l = end;
    return;
  }
  var data = blob2.slice(blob2.l);
  blob2.l = end;
  var zip;
  try {
    zip = zip_read(data, { type: "array" });
  } catch (e) {
    return;
  }
  var themeXML = getzipstr(zip, "theme/theme/theme1.xml", true);
  if (!themeXML)
    return;
  return parse_theme_xml(themeXML, opts);
}
function parse_ColorTheme(blob2) {
  return blob2.read_shift(4);
}
function parse_FullColorExt(blob2) {
  var o = {};
  o.xclrType = blob2.read_shift(2);
  o.nTintShade = blob2.read_shift(2);
  switch (o.xclrType) {
    case 0:
      blob2.l += 4;
      break;
    case 1:
      o.xclrValue = parse_IcvXF(blob2, 4);
      break;
    case 2:
      o.xclrValue = parse_LongRGBA(blob2);
      break;
    case 3:
      o.xclrValue = parse_ColorTheme(blob2);
      break;
    case 4:
      blob2.l += 4;
      break;
  }
  blob2.l += 8;
  return o;
}
function parse_IcvXF(blob2, length2) {
  return parsenoop(blob2, length2);
}
function parse_XFExtGradient(blob2, length2) {
  return parsenoop(blob2, length2);
}
function parse_ExtProp(blob2) {
  var extType = blob2.read_shift(2);
  var cb = blob2.read_shift(2) - 4;
  var o = [extType];
  switch (extType) {
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
      o[1] = parse_FullColorExt(blob2);
      break;
    case 6:
      o[1] = parse_XFExtGradient(blob2, cb);
      break;
    case 14:
    case 15:
      o[1] = blob2.read_shift(cb === 1 ? 1 : 2);
      break;
    default:
      throw new Error("Unrecognized ExtProp type: " + extType + " " + cb);
  }
  return o;
}
function parse_XFExt(blob2, length2) {
  var end = blob2.l + length2;
  blob2.l += 2;
  var ixfe = blob2.read_shift(2);
  blob2.l += 2;
  var cexts = blob2.read_shift(2);
  var ext = [];
  while (cexts-- > 0)
    ext.push(parse_ExtProp(blob2, end - blob2.l));
  return { ixfe, ext };
}
function update_xfext(xf, xfext) {
  xfext.forEach(function(xfe) {
    switch (xfe[0]) {
    }
  });
}
function parse_BrtMdtinfo(data, length2) {
  return {
    flags: data.read_shift(4),
    version: data.read_shift(4),
    name: parse_XLWideString(data)
  };
}
function write_BrtMdtinfo(data) {
  var o = new_buf(12 + 2 * data.name.length);
  o.write_shift(4, data.flags);
  o.write_shift(4, data.version);
  write_XLWideString(data.name, o);
  return o.slice(0, o.l);
}
function parse_BrtMdb(data) {
  var out = [];
  var cnt = data.read_shift(4);
  while (cnt-- > 0)
    out.push([data.read_shift(4), data.read_shift(4)]);
  return out;
}
function write_BrtMdb(mdb) {
  var o = new_buf(4 + 8 * mdb.length);
  o.write_shift(4, mdb.length);
  for (var i = 0; i < mdb.length; ++i) {
    o.write_shift(4, mdb[i][0]);
    o.write_shift(4, mdb[i][1]);
  }
  return o;
}
function write_BrtBeginEsfmd(cnt, name) {
  var o = new_buf(8 + 2 * name.length);
  o.write_shift(4, cnt);
  write_XLWideString(name, o);
  return o.slice(0, o.l);
}
function parse_BrtBeginEsmdb(data) {
  data.l += 4;
  return data.read_shift(4) != 0;
}
function write_BrtBeginEsmdb(cnt, cm) {
  var o = new_buf(8);
  o.write_shift(4, cnt);
  o.write_shift(4, cm ? 1 : 0);
  return o;
}
function parse_xlmeta_bin(data, name, _opts) {
  var out = { Types: [], Cell: [], Value: [] };
  var opts = _opts || {};
  var state = [];
  var pass = false;
  var metatype = 2;
  recordhopper(data, function(val, R, RT) {
    switch (RT) {
      case 335:
        out.Types.push({ name: val.name });
        break;
      case 51:
        val.forEach(function(r) {
          if (metatype == 1)
            out.Cell.push({ type: out.Types[r[0] - 1].name, index: r[1] });
          else if (metatype == 0)
            out.Value.push({ type: out.Types[r[0] - 1].name, index: r[1] });
        });
        break;
      case 337:
        metatype = val ? 1 : 0;
        break;
      case 338:
        metatype = 2;
        break;
      case 35:
        state.push(RT);
        pass = true;
        break;
      case 36:
        state.pop();
        pass = false;
        break;
      default:
        if (R.T)
          ;
        else if (!pass || opts.WTF && state[state.length - 1] != 35)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function write_xlmeta_bin() {
  var ba = buf_array();
  write_record(ba, 332);
  write_record(ba, 334, write_UInt32LE(1));
  write_record(ba, 335, write_BrtMdtinfo({
    name: "XLDAPR",
    version: 12e4,
    flags: 3496657072
  }));
  write_record(ba, 336);
  write_record(ba, 339, write_BrtBeginEsfmd(1, "XLDAPR"));
  write_record(ba, 52);
  write_record(ba, 35, write_UInt32LE(514));
  write_record(ba, 4096, write_UInt32LE(0));
  write_record(ba, 4097, writeuint16(1));
  write_record(ba, 36);
  write_record(ba, 53);
  write_record(ba, 340);
  write_record(ba, 337, write_BrtBeginEsmdb(1, true));
  write_record(ba, 51, write_BrtMdb([[1, 0]]));
  write_record(ba, 338);
  write_record(ba, 333);
  return ba.end();
}
function parse_xlmeta_xml(data, name, opts) {
  var out = { Types: [], Cell: [], Value: [] };
  if (!data)
    return out;
  var pass = false;
  var metatype = 2;
  var lastmeta;
  data.replace(tagregex, function(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<metadata":
      case "</metadata>":
        break;
      case "<metadataTypes":
      case "</metadataTypes>":
        break;
      case "<metadataType":
        out.Types.push({ name: y.name });
        break;
      case "</metadataType>":
        break;
      case "<futureMetadata":
        for (var j = 0; j < out.Types.length; ++j)
          if (out.Types[j].name == y.name)
            lastmeta = out.Types[j];
        break;
      case "</futureMetadata>":
        break;
      case "<bk>":
        break;
      case "</bk>":
        break;
      case "<rc":
        if (metatype == 1)
          out.Cell.push({ type: out.Types[y.t - 1].name, index: +y.v });
        else if (metatype == 0)
          out.Value.push({ type: out.Types[y.t - 1].name, index: +y.v });
        break;
      case "</rc>":
        break;
      case "<cellMetadata":
        metatype = 1;
        break;
      case "</cellMetadata>":
        metatype = 2;
        break;
      case "<valueMetadata":
        metatype = 0;
        break;
      case "</valueMetadata>":
        metatype = 2;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      case "<rvb":
        if (!lastmeta)
          break;
        if (!lastmeta.offsets)
          lastmeta.offsets = [];
        lastmeta.offsets.push(+y.i);
        break;
      default:
        if (!pass && (opts == null ? void 0 : opts.WTF))
          throw new Error("unrecognized " + y[0] + " in metadata");
    }
    return x;
  });
  return out;
}
function write_xlmeta_xml() {
  var o = [XML_HEADER];
  o.push('<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">\n  <metadataTypes count="1">\n    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>\n  </metadataTypes>\n  <futureMetadata name="XLDAPR" count="1">\n    <bk>\n      <extLst>\n        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">\n          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>\n        </ext>\n      </extLst>\n    </bk>\n  </futureMetadata>\n  <cellMetadata count="1">\n    <bk>\n      <rc t="1" v="0"/>\n    </bk>\n  </cellMetadata>\n</metadata>');
  return o.join("");
}
function parse_cc_xml(data) {
  var d = [];
  if (!data)
    return d;
  var i = 1;
  (data.match(tagregex) || []).forEach(function(x) {
    var y = parsexmltag(x);
    switch (y[0]) {
      case "<?xml":
        break;
      case "<calcChain":
      case "<calcChain>":
      case "</calcChain>":
        break;
      case "<c":
        delete y[0];
        if (y.i)
          i = y.i;
        else
          y.i = i;
        d.push(y);
        break;
    }
  });
  return d;
}
function parse_BrtCalcChainItem$(data) {
  var out = {};
  out.i = data.read_shift(4);
  var cell = {};
  cell.r = data.read_shift(4);
  cell.c = data.read_shift(4);
  out.r = encode_cell(cell);
  var flags = data.read_shift(1);
  if (flags & 2)
    out.l = "1";
  if (flags & 8)
    out.a = "1";
  return out;
}
function parse_cc_bin(data, name, opts) {
  var out = [];
  recordhopper(data, function hopper_cc(val, R, RT) {
    switch (RT) {
      case 63:
        out.push(val);
        break;
      default:
        if (R.T)
          ;
        else
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function parse_xlink_xml() {
}
function parse_xlink_bin(data, rel, name, _opts) {
  if (!data)
    return data;
  var opts = _opts || {};
  var pass = false;
  recordhopper(data, function xlink_parse(val, R, RT) {
    switch (RT) {
      case 359:
      case 363:
      case 364:
      case 366:
      case 367:
      case 368:
      case 369:
      case 370:
      case 371:
      case 472:
      case 577:
      case 578:
      case 579:
      case 580:
      case 581:
      case 582:
      case 583:
      case 584:
      case 585:
      case 586:
      case 587:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      default:
        if (R.T)
          ;
        else if (!pass || opts.WTF)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
}
function parse_drawing(data, rels) {
  if (!data)
    return "??";
  var id = (data.match(/<c:chart [^>]*r:id="([^"]*)"/) || ["", ""])[1];
  return rels["!id"][id].Target;
}
function write_vml(rId, comments) {
  var csize = [21600, 21600];
  var bbox = ["m0,0l0", csize[1], csize[0], csize[1], csize[0], "0xe"].join(",");
  var o = [
    writextag("xml", null, { "xmlns:v": XLMLNS.v, "xmlns:o": XLMLNS.o, "xmlns:x": XLMLNS.x, "xmlns:mv": XLMLNS.mv }).replace(/\/>/, ">"),
    writextag("o:shapelayout", writextag("o:idmap", null, { "v:ext": "edit", "data": rId }), { "v:ext": "edit" })
  ];
  var _shapeid = 65536 * rId;
  var _comments = comments || [];
  if (_comments.length > 0)
    o.push(writextag("v:shapetype", [
      writextag("v:stroke", null, { joinstyle: "miter" }),
      writextag("v:path", null, { gradientshapeok: "t", "o:connecttype": "rect" })
    ].join(""), { id: "_x0000_t202", coordsize: csize.join(","), "o:spt": 202, path: bbox }));
  _comments.forEach(function(x) {
    ++_shapeid;
    o.push(write_vml_comment(x, _shapeid));
  });
  o.push("</xml>");
  return o.join("");
}
function write_vml_comment(x, _shapeid) {
  var c = decode_cell(x[0]);
  var fillopts = (
    /*::(*/
    { "color2": "#BEFF82", "type": "gradient" }
  );
  if (fillopts.type == "gradient")
    fillopts.angle = "-180";
  var fillparm = fillopts.type == "gradient" ? writextag("o:fill", null, { type: "gradientUnscaled", "v:ext": "view" }) : null;
  var fillxml = writextag("v:fill", fillparm, fillopts);
  var shadata = { on: "t", "obscured": "t" };
  return [
    "<v:shape" + wxt_helper({
      id: "_x0000_s" + _shapeid,
      type: "#_x0000_t202",
      style: "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (x[1].hidden ? ";visibility:hidden" : ""),
      fillcolor: "#ECFAD4",
      strokecolor: "#edeaa1"
    }) + ">",
    fillxml,
    writextag("v:shadow", null, shadata),
    writextag("v:path", null, { "o:connecttype": "none" }),
    '<v:textbox><div style="text-align:left"></div></v:textbox>',
    '<x:ClientData ObjectType="Note">',
    "<x:MoveWithCells/>",
    "<x:SizeWithCells/>",
    /* Part 4 19.4.2.3 Anchor (Anchor) */
    writetag("x:Anchor", [c.c + 1, 0, c.r + 1, 0, c.c + 3, 20, c.r + 5, 20].join(",")),
    writetag("x:AutoFill", "False"),
    writetag("x:Row", String(c.r)),
    writetag("x:Column", String(c.c)),
    x[1].hidden ? "" : "<x:Visible/>",
    "</x:ClientData>",
    "</v:shape>"
  ].join("");
}
function sheet_insert_comments(sheet, comments, threaded, people) {
  var dense = sheet["!data"] != null;
  var cell;
  comments.forEach(function(comment2) {
    var r = decode_cell(comment2.ref);
    if (r.r < 0 || r.c < 0)
      return;
    if (dense) {
      if (!sheet["!data"][r.r])
        sheet["!data"][r.r] = [];
      cell = sheet["!data"][r.r][r.c];
    } else
      cell = sheet[comment2.ref];
    if (!cell) {
      cell = { t: "z" };
      if (dense)
        sheet["!data"][r.r][r.c] = cell;
      else
        sheet[comment2.ref] = cell;
      var range = safe_decode_range(sheet["!ref"] || "BDWGO1000001:A1");
      if (range.s.r > r.r)
        range.s.r = r.r;
      if (range.e.r < r.r)
        range.e.r = r.r;
      if (range.s.c > r.c)
        range.s.c = r.c;
      if (range.e.c < r.c)
        range.e.c = r.c;
      var encoded = encode_range(range);
      sheet["!ref"] = encoded;
    }
    if (!cell.c)
      cell.c = [];
    var o = { a: comment2.author, t: comment2.t, r: comment2.r, T: threaded };
    if (comment2.h)
      o.h = comment2.h;
    for (var i = cell.c.length - 1; i >= 0; --i) {
      if (!threaded && cell.c[i].T)
        return;
      if (threaded && !cell.c[i].T)
        cell.c.splice(i, 1);
    }
    if (threaded && people)
      for (i = 0; i < people.length; ++i) {
        if (o.a == people[i].id) {
          o.a = people[i].name || o.a;
          break;
        }
      }
    cell.c.push(o);
  });
}
function parse_comments_xml(data, opts) {
  if (data.match(/<(?:\w+:)?comments *\/>/))
    return [];
  var authors = [];
  var commentList = [];
  var authtag = data.match(/<(?:\w+:)?authors>([\s\S]*)<\/(?:\w+:)?authors>/);
  if (authtag && authtag[1])
    authtag[1].split(/<\/\w*:?author>/).forEach(function(x) {
      if (x === "" || x.trim() === "")
        return;
      var a = x.match(/<(?:\w+:)?author[^>]*>(.*)/);
      if (a)
        authors.push(a[1]);
    });
  var cmnttag = data.match(/<(?:\w+:)?commentList>([\s\S]*)<\/(?:\w+:)?commentList>/);
  if (cmnttag && cmnttag[1])
    cmnttag[1].split(/<\/\w*:?comment>/).forEach(function(x) {
      if (x === "" || x.trim() === "")
        return;
      var cm = x.match(/<(?:\w+:)?comment[^>]*>/);
      if (!cm)
        return;
      var y = parsexmltag(cm[0]);
      var comment2 = { author: y.authorId && authors[y.authorId] || "sheetjsghost", ref: y.ref, guid: y.guid };
      var cell = decode_cell(y.ref);
      if (opts.sheetRows && opts.sheetRows <= cell.r)
        return;
      var textMatch = x.match(/<(?:\w+:)?text>([\s\S]*)<\/(?:\w+:)?text>/);
      var rt = !!textMatch && !!textMatch[1] && parse_si(textMatch[1]) || { r: "", t: "", h: "" };
      comment2.r = rt.r;
      if (rt.r == "<t></t>")
        rt.t = rt.h = "";
      comment2.t = (rt.t || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      if (opts.cellHTML)
        comment2.h = rt.h;
      commentList.push(comment2);
    });
  return commentList;
}
function write_comments_xml(data) {
  var o = [XML_HEADER, writextag("comments", null, { "xmlns": XMLNS_main[0] })];
  var iauthor = [];
  o.push("<authors>");
  data.forEach(function(x) {
    x[1].forEach(function(w2) {
      var a = escapexml(w2.a);
      if (iauthor.indexOf(a) == -1) {
        iauthor.push(a);
        o.push("<author>" + a + "</author>");
      }
      if (w2.T && w2.ID && iauthor.indexOf("tc=" + w2.ID) == -1) {
        iauthor.push("tc=" + w2.ID);
        o.push("<author>tc=" + w2.ID + "</author>");
      }
    });
  });
  if (iauthor.length == 0) {
    iauthor.push("SheetJ5");
    o.push("<author>SheetJ5</author>");
  }
  o.push("</authors>");
  o.push("<commentList>");
  data.forEach(function(d) {
    var lastauthor = 0, ts = [], tcnt = 0;
    if (d[1][0] && d[1][0].T && d[1][0].ID)
      lastauthor = iauthor.indexOf("tc=" + d[1][0].ID);
    d[1].forEach(function(c) {
      if (c.a)
        lastauthor = iauthor.indexOf(escapexml(c.a));
      if (c.T)
        ++tcnt;
      ts.push(c.t == null ? "" : escapexml(c.t));
    });
    if (tcnt === 0) {
      d[1].forEach(function(c) {
        o.push('<comment ref="' + d[0] + '" authorId="' + iauthor.indexOf(escapexml(c.a)) + '"><text>');
        o.push(writetag("t", c.t == null ? "" : escapexml(c.t)));
        o.push("</text></comment>");
      });
    } else {
      o.push('<comment ref="' + d[0] + '" authorId="' + lastauthor + '"><text>');
      var t = "Comment:\n    " + ts[0] + "\n";
      for (var i = 1; i < ts.length; ++i)
        t += "Reply:\n    " + ts[i] + "\n";
      o.push(writetag("t", escapexml(t)));
      o.push("</text></comment>");
    }
  });
  o.push("</commentList>");
  if (o.length > 2) {
    o[o.length] = "</comments>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
function parse_tcmnt_xml(data, opts) {
  var out = [];
  var pass = false, comment2 = {}, tidx = 0;
  data.replace(tagregex, function xml_tcmnt(x, idx) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<ThreadedComments":
        break;
      case "</ThreadedComments>":
        break;
      case "<threadedComment":
        comment2 = { author: y.personId, guid: y.id, ref: y.ref, T: 1 };
        break;
      case "</threadedComment>":
        if (comment2.t != null)
          out.push(comment2);
        break;
      case "<text>":
      case "<text":
        tidx = idx + x.length;
        break;
      case "</text>":
        comment2.t = data.slice(tidx, idx).replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        break;
      case "<mentions":
      case "<mentions>":
        pass = true;
        break;
      case "</mentions>":
        pass = false;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (!pass && opts.WTF)
          throw new Error("unrecognized " + y[0] + " in threaded comments");
    }
    return x;
  });
  return out;
}
function write_tcmnt_xml(comments, people, opts) {
  var o = [XML_HEADER, writextag("ThreadedComments", null, { "xmlns": XMLNS.TCMNT }).replace(/[\/]>/, ">")];
  comments.forEach(function(carr) {
    var rootid = "";
    (carr[1] || []).forEach(function(c, idx) {
      if (!c.T) {
        delete c.ID;
        return;
      }
      if (c.a && people.indexOf(c.a) == -1)
        people.push(c.a);
      var tcopts = {
        ref: carr[0],
        id: "{54EE7951-7262-4200-6969-" + ("000000000000" + opts.tcid++).slice(-12) + "}"
      };
      if (idx == 0)
        rootid = tcopts.id;
      else
        tcopts.parentId = rootid;
      c.ID = tcopts.id;
      if (c.a)
        tcopts.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + people.indexOf(c.a)).slice(-12) + "}";
      o.push(writextag("threadedComment", writetag("text", c.t || ""), tcopts));
    });
  });
  o.push("</ThreadedComments>");
  return o.join("");
}
function parse_people_xml(data, opts) {
  var out = [];
  var pass = false;
  data.replace(tagregex, function xml_tcmnt(x) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<personList":
        break;
      case "</personList>":
        break;
      case "<person":
        out.push({ name: y.displayname, id: y.id });
        break;
      case "</person>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (!pass && opts.WTF)
          throw new Error("unrecognized " + y[0] + " in threaded comments");
    }
    return x;
  });
  return out;
}
function write_people_xml(people) {
  var o = [XML_HEADER, writextag("personList", null, {
    "xmlns": XMLNS.TCMNT,
    "xmlns:x": XMLNS_main[0]
  }).replace(/[\/]>/, ">")];
  people.forEach(function(person, idx) {
    o.push(writextag("person", null, {
      displayName: person,
      id: "{54EE7950-7262-4200-6969-" + ("000000000000" + idx).slice(-12) + "}",
      userId: person,
      providerId: "None"
    }));
  });
  o.push("</personList>");
  return o.join("");
}
function parse_BrtBeginComment(data) {
  var out = {};
  out.iauthor = data.read_shift(4);
  var rfx = parse_UncheckedRfX(data);
  out.rfx = rfx.s;
  out.ref = encode_cell(rfx.s);
  data.l += 16;
  return out;
}
function write_BrtBeginComment(data, o) {
  if (o == null)
    o = new_buf(36);
  o.write_shift(4, data[1].iauthor);
  write_UncheckedRfX(data[0], o);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  return o;
}
var parse_BrtCommentAuthor = parse_XLWideString;
function write_BrtCommentAuthor(data) {
  return write_XLWideString(data.slice(0, 54));
}
function parse_comments_bin(data, opts) {
  var out = [];
  var authors = [];
  var c = {};
  var pass = false;
  recordhopper(data, function hopper_cmnt(val, R, RT) {
    switch (RT) {
      case 632:
        authors.push(val);
        break;
      case 635:
        c = val;
        break;
      case 637:
        c.t = val.t;
        c.h = val.h;
        c.r = val.r;
        break;
      case 636:
        c.author = authors[c.iauthor];
        delete c.iauthor;
        if (opts.sheetRows && c.rfx && opts.sheetRows <= c.rfx.r)
          break;
        if (!c.t)
          c.t = "";
        delete c.rfx;
        out.push(c);
        break;
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (R.T)
          ;
        else if (!pass || opts.WTF)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function write_comments_bin(data) {
  var ba = buf_array();
  var iauthor = [];
  write_record(
    ba,
    628
    /* BrtBeginComments */
  );
  write_record(
    ba,
    630
    /* BrtBeginCommentAuthors */
  );
  data.forEach(function(comment2) {
    comment2[1].forEach(function(c) {
      if (iauthor.indexOf(c.a) > -1)
        return;
      iauthor.push(c.a.slice(0, 54));
      write_record(ba, 632, write_BrtCommentAuthor(c.a));
    });
  });
  write_record(
    ba,
    631
    /* BrtEndCommentAuthors */
  );
  write_record(
    ba,
    633
    /* BrtBeginCommentList */
  );
  data.forEach(function(comment2) {
    comment2[1].forEach(function(c) {
      c.iauthor = iauthor.indexOf(c.a);
      var range = { s: decode_cell(comment2[0]), e: decode_cell(comment2[0]) };
      write_record(ba, 635, write_BrtBeginComment([range, c]));
      if (c.t && c.t.length > 0)
        write_record(ba, 637, write_BrtCommentText(c));
      write_record(
        ba,
        636
        /* BrtEndComment */
      );
      delete c.iauthor;
    });
  });
  write_record(
    ba,
    634
    /* BrtEndCommentList */
  );
  write_record(
    ba,
    629
    /* BrtEndComments */
  );
  return ba.end();
}
var CT_VBA = "application/vnd.ms-office.vbaProject";
function make_vba_xls(cfb) {
  var newcfb = CFB.utils.cfb_new({ root: "R" });
  cfb.FullPaths.forEach(function(p, i) {
    if (p.slice(-1) === "/" || !p.match(/_VBA_PROJECT_CUR/))
      return;
    var newpath = p.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
    CFB.utils.cfb_add(newcfb, newpath, cfb.FileIndex[i].content);
  });
  return CFB.write(newcfb);
}
function fill_vba_xls(cfb, vba) {
  vba.FullPaths.forEach(function(p, i) {
    if (i == 0)
      return;
    var newpath = p.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
    if (newpath.slice(-1) !== "/")
      CFB.utils.cfb_add(cfb, newpath, vba.FileIndex[i].content);
  });
}
var VBAFMTS = ["xlsb", "xlsm", "xlam", "biff8", "xla"];
function parse_ds_bin() {
  return { "!type": "dialog" };
}
function parse_ds_xml() {
  return { "!type": "dialog" };
}
function parse_ms_bin() {
  return { "!type": "macro" };
}
function parse_ms_xml() {
  return { "!type": "macro" };
}
var rc_to_a1 = /* @__PURE__ */ function() {
  var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;
  var rcbase = { r: 0, c: 0 };
  function rcfunc($$, $1, $2, $3) {
    var cRel = false, rRel = false;
    if ($2.length == 0)
      rRel = true;
    else if ($2.charAt(0) == "[") {
      rRel = true;
      $2 = $2.slice(1, -1);
    }
    if ($3.length == 0)
      cRel = true;
    else if ($3.charAt(0) == "[") {
      cRel = true;
      $3 = $3.slice(1, -1);
    }
    var R = $2.length > 0 ? parseInt($2, 10) | 0 : 0, C = $3.length > 0 ? parseInt($3, 10) | 0 : 0;
    if (cRel)
      C += rcbase.c;
    else
      --C;
    if (rRel)
      R += rcbase.r;
    else
      --R;
    return $1 + (cRel ? "" : "$") + encode_col(C) + (rRel ? "" : "$") + encode_row(R);
  }
  return function rc_to_a12(fstr, base) {
    rcbase = base;
    return fstr.replace(rcregex, rcfunc);
  };
}();
var crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
var a1_to_rc = /* @__PURE__ */ function() {
  return function a1_to_rc2(fstr, base) {
    return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
      var c = decode_col($3) - ($2 ? 0 : base.c);
      var r = decode_row($5) - ($4 ? 0 : base.r);
      var R = $4 == "$" ? r + 1 : r == 0 ? "" : "[" + r + "]";
      var C = $2 == "$" ? c + 1 : c == 0 ? "" : "[" + c + "]";
      return $1 + "R" + R + "C" + C;
    });
  };
}();
function shift_formula_str(f, delta) {
  return f.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
    return $1 + ($2 == "$" ? $2 + $3 : encode_col(decode_col($3) + delta.c)) + ($4 == "$" ? $4 + $5 : encode_row(decode_row($5) + delta.r));
  });
}
function shift_formula_xlsx(f, range, cell) {
  var r = decode_range(range), s = r.s, c = decode_cell(cell);
  var delta = { r: c.r - s.r, c: c.c - s.c };
  return shift_formula_str(f, delta);
}
function fuzzyfmla(f) {
  if (f.length == 1)
    return false;
  return true;
}
function _xlfn(f) {
  return f.replace(/_xlfn\./g, "");
}
function parseread1(blob2) {
  blob2.l += 1;
  return;
}
function parse_ColRelU(blob2, length2) {
  var c = blob2.read_shift(length2 == 1 ? 1 : 2);
  return [c & 16383, c >> 14 & 1, c >> 15 & 1];
}
function parse_RgceArea(blob2, length2, opts) {
  var w2 = 2;
  if (opts) {
    if (opts.biff >= 2 && opts.biff <= 5)
      return parse_RgceArea_BIFF2(blob2);
    else if (opts.biff == 12)
      w2 = 4;
  }
  var r = blob2.read_shift(w2), R = blob2.read_shift(w2);
  var c = parse_ColRelU(blob2, 2);
  var C = parse_ColRelU(blob2, 2);
  return { s: { r, c: c[0], cRel: c[1], rRel: c[2] }, e: { r: R, c: C[0], cRel: C[1], rRel: C[2] } };
}
function parse_RgceArea_BIFF2(blob2) {
  var r = parse_ColRelU(blob2, 2), R = parse_ColRelU(blob2, 2);
  var c = blob2.read_shift(1);
  var C = blob2.read_shift(1);
  return { s: { r: r[0], c, cRel: r[1], rRel: r[2] }, e: { r: R[0], c: C, cRel: R[1], rRel: R[2] } };
}
function parse_RgceAreaRel(blob2, length2, opts) {
  if (opts.biff < 8)
    return parse_RgceArea_BIFF2(blob2);
  var r = blob2.read_shift(opts.biff == 12 ? 4 : 2), R = blob2.read_shift(opts.biff == 12 ? 4 : 2);
  var c = parse_ColRelU(blob2, 2);
  var C = parse_ColRelU(blob2, 2);
  return { s: { r, c: c[0], cRel: c[1], rRel: c[2] }, e: { r: R, c: C[0], cRel: C[1], rRel: C[2] } };
}
function parse_RgceLoc(blob2, length2, opts) {
  if (opts && opts.biff >= 2 && opts.biff <= 5)
    return parse_RgceLoc_BIFF2(blob2);
  var r = blob2.read_shift(opts && opts.biff == 12 ? 4 : 2);
  var c = parse_ColRelU(blob2, 2);
  return { r, c: c[0], cRel: c[1], rRel: c[2] };
}
function parse_RgceLoc_BIFF2(blob2) {
  var r = parse_ColRelU(blob2, 2);
  var c = blob2.read_shift(1);
  return { r: r[0], c, cRel: r[1], rRel: r[2] };
}
function parse_RgceElfLoc(blob2) {
  var r = blob2.read_shift(2);
  var c = blob2.read_shift(2);
  return { r, c: c & 255, fQuoted: !!(c & 16384), cRel: c >> 15, rRel: c >> 15 };
}
function parse_RgceLocRel(blob2, length2, opts) {
  var biff = opts && opts.biff ? opts.biff : 8;
  if (biff >= 2 && biff <= 5)
    return parse_RgceLocRel_BIFF2(blob2);
  var r = blob2.read_shift(biff >= 12 ? 4 : 2);
  var cl = blob2.read_shift(2);
  var cRel = (cl & 16384) >> 14, rRel = (cl & 32768) >> 15;
  cl &= 16383;
  if (rRel == 1)
    while (r > 524287)
      r -= 1048576;
  if (cRel == 1)
    while (cl > 8191)
      cl = cl - 16384;
  return { r, c: cl, cRel, rRel };
}
function parse_RgceLocRel_BIFF2(blob2) {
  var rl = blob2.read_shift(2);
  var c = blob2.read_shift(1);
  var rRel = (rl & 32768) >> 15, cRel = (rl & 16384) >> 14;
  rl &= 16383;
  if (rRel == 1 && rl >= 8192)
    rl = rl - 16384;
  if (cRel == 1 && c >= 128)
    c = c - 256;
  return { r: rl, c, cRel, rRel };
}
function parse_PtgArea(blob2, length2, opts) {
  var type = (blob2[blob2.l++] & 96) >> 5;
  var area = parse_RgceArea(blob2, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);
  return [type, area];
}
function parse_PtgArea3d(blob2, length2, opts) {
  var type = (blob2[blob2.l++] & 96) >> 5;
  var ixti = blob2.read_shift(2, "i");
  var w2 = 8;
  if (opts)
    switch (opts.biff) {
      case 5:
        blob2.l += 12;
        w2 = 6;
        break;
      case 12:
        w2 = 12;
        break;
    }
  var area = parse_RgceArea(blob2, w2, opts);
  return [type, ixti, area];
}
function parse_PtgAreaErr(blob2, length2, opts) {
  var type = (blob2[blob2.l++] & 96) >> 5;
  blob2.l += opts && opts.biff > 8 ? 12 : opts.biff < 8 ? 6 : 8;
  return [type];
}
function parse_PtgAreaErr3d(blob2, length2, opts) {
  var type = (blob2[blob2.l++] & 96) >> 5;
  var ixti = blob2.read_shift(2);
  var w2 = 8;
  if (opts)
    switch (opts.biff) {
      case 5:
        blob2.l += 12;
        w2 = 6;
        break;
      case 12:
        w2 = 12;
        break;
    }
  blob2.l += w2;
  return [type, ixti];
}
function parse_PtgAreaN(blob2, length2, opts) {
  var type = (blob2[blob2.l++] & 96) >> 5;
  var area = parse_RgceAreaRel(blob2, length2 - 1, opts);
  return [type, area];
}
function parse_PtgArray(blob2, length2, opts) {
  var type = (blob2[blob2.l++] & 96) >> 5;
  blob2.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;
  return [type];
}
function parse_PtgAttrBaxcel(blob2) {
  var bitSemi = blob2[blob2.l + 1] & 1;
  var bitBaxcel = 1;
  blob2.l += 4;
  return [bitSemi, bitBaxcel];
}
function parse_PtgAttrChoose(blob2, length2, opts) {
  blob2.l += 2;
  var offset = blob2.read_shift(opts && opts.biff == 2 ? 1 : 2);
  var o = [];
  for (var i = 0; i <= offset; ++i)
    o.push(blob2.read_shift(opts && opts.biff == 2 ? 1 : 2));
  return o;
}
function parse_PtgAttrGoto(blob2, length2, opts) {
  var bitGoto = blob2[blob2.l + 1] & 255 ? 1 : 0;
  blob2.l += 2;
  return [bitGoto, blob2.read_shift(opts && opts.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIf(blob2, length2, opts) {
  var bitIf = blob2[blob2.l + 1] & 255 ? 1 : 0;
  blob2.l += 2;
  return [bitIf, blob2.read_shift(opts && opts.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIfError(blob2) {
  var bitIf = blob2[blob2.l + 1] & 255 ? 1 : 0;
  blob2.l += 2;
  return [bitIf, blob2.read_shift(2)];
}
function parse_PtgAttrSemi(blob2, length2, opts) {
  var bitSemi = blob2[blob2.l + 1] & 255 ? 1 : 0;
  blob2.l += opts && opts.biff == 2 ? 3 : 4;
  return [bitSemi];
}
function parse_PtgAttrSpaceType(blob2) {
  var type = blob2.read_shift(1), cch = blob2.read_shift(1);
  return [type, cch];
}
function parse_PtgAttrSpace(blob2) {
  blob2.read_shift(2);
  return parse_PtgAttrSpaceType(blob2);
}
function parse_PtgAttrSpaceSemi(blob2) {
  blob2.read_shift(2);
  return parse_PtgAttrSpaceType(blob2);
}
function parse_PtgRef(blob2, length2, opts) {
  var type = (blob2[blob2.l] & 96) >> 5;
  blob2.l += 1;
  var loc = parse_RgceLoc(blob2, 0, opts);
  return [type, loc];
}
function parse_PtgRefN(blob2, length2, opts) {
  var type = (blob2[blob2.l] & 96) >> 5;
  blob2.l += 1;
  var loc = parse_RgceLocRel(blob2, 0, opts);
  return [type, loc];
}
function parse_PtgRef3d(blob2, length2, opts) {
  var type = (blob2[blob2.l] & 96) >> 5;
  blob2.l += 1;
  var ixti = blob2.read_shift(2);
  if (opts && opts.biff == 5)
    blob2.l += 12;
  var loc = parse_RgceLoc(blob2, 0, opts);
  return [type, ixti, loc];
}
function parse_PtgFunc(blob2, length2, opts) {
  var type = (blob2[blob2.l] & 96) >> 5;
  blob2.l += 1;
  var iftab = blob2.read_shift(opts && opts.biff <= 3 ? 1 : 2);
  return [FtabArgc[iftab], Ftab[iftab], type];
}
function parse_PtgFuncVar(blob2, length2, opts) {
  var type = blob2[blob2.l++];
  var cparams = blob2.read_shift(1), tab = opts && opts.biff <= 3 ? [type == 88 ? -1 : 0, blob2.read_shift(1)] : parsetab(blob2);
  return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];
}
function parsetab(blob2) {
  return [blob2[blob2.l + 1] >> 7, blob2.read_shift(2) & 32767];
}
function parse_PtgAttrSum(blob2, length2, opts) {
  blob2.l += opts && opts.biff == 2 ? 3 : 4;
  return;
}
function parse_PtgExp(blob2, length2, opts) {
  blob2.l++;
  if (opts && opts.biff == 12)
    return [blob2.read_shift(4, "i"), 0];
  var row = blob2.read_shift(2);
  var col = blob2.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [row, col];
}
function parse_PtgErr(blob2) {
  blob2.l++;
  return BErr[blob2.read_shift(1)];
}
function parse_PtgInt(blob2) {
  blob2.l++;
  return blob2.read_shift(2);
}
function parse_PtgBool(blob2) {
  blob2.l++;
  return blob2.read_shift(1) !== 0;
}
function parse_PtgNum(blob2) {
  blob2.l++;
  return parse_Xnum(blob2);
}
function parse_PtgStr(blob2, length2, opts) {
  blob2.l++;
  return parse_ShortXLUnicodeString(blob2, length2 - 1, opts);
}
function parse_SerAr(blob2, biff) {
  var val = [blob2.read_shift(1)];
  if (biff == 12)
    switch (val[0]) {
      case 2:
        val[0] = 4;
        break;
      case 4:
        val[0] = 16;
        break;
      case 0:
        val[0] = 1;
        break;
      case 1:
        val[0] = 2;
        break;
    }
  switch (val[0]) {
    case 4:
      val[1] = parsebool(blob2, 1) ? "TRUE" : "FALSE";
      if (biff != 12)
        blob2.l += 7;
      break;
    case 37:
    case 16:
      val[1] = BErr[blob2[blob2.l]];
      blob2.l += biff == 12 ? 4 : 8;
      break;
    case 0:
      blob2.l += 8;
      break;
    case 1:
      val[1] = parse_Xnum(blob2);
      break;
    case 2:
      val[1] = parse_XLUnicodeString2(blob2, 0, { biff: biff > 0 && biff < 8 ? 2 : biff });
      break;
    default:
      throw new Error("Bad SerAr: " + val[0]);
  }
  return val;
}
function parse_PtgExtraMem(blob2, cce, opts) {
  var count = blob2.read_shift(opts.biff == 12 ? 4 : 2);
  var out = [];
  for (var i = 0; i != count; ++i)
    out.push((opts.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(blob2));
  return out;
}
function parse_PtgExtraArray(blob2, length2, opts) {
  var rows = 0, cols = 0;
  if (opts.biff == 12) {
    rows = blob2.read_shift(4);
    cols = blob2.read_shift(4);
  } else {
    cols = 1 + blob2.read_shift(1);
    rows = 1 + blob2.read_shift(2);
  }
  if (opts.biff >= 2 && opts.biff < 8) {
    --rows;
    if (--cols == 0)
      cols = 256;
  }
  for (var i = 0, o = []; i != rows && (o[i] = []); ++i)
    for (var j = 0; j != cols; ++j)
      o[i][j] = parse_SerAr(blob2, opts.biff);
  return o;
}
function parse_PtgName(blob2, length2, opts) {
  var type = blob2.read_shift(1) >>> 5 & 3;
  var w2 = !opts || opts.biff >= 8 ? 4 : 2;
  var nameindex = blob2.read_shift(w2);
  switch (opts.biff) {
    case 2:
      blob2.l += 5;
      break;
    case 3:
    case 4:
      blob2.l += 8;
      break;
    case 5:
      blob2.l += 12;
      break;
  }
  return [type, 0, nameindex];
}
function parse_PtgNameX(blob2, length2, opts) {
  if (opts.biff == 5)
    return parse_PtgNameX_BIFF5(blob2);
  var type = blob2.read_shift(1) >>> 5 & 3;
  var ixti = blob2.read_shift(2);
  var nameindex = blob2.read_shift(4);
  return [type, ixti, nameindex];
}
function parse_PtgNameX_BIFF5(blob2) {
  var type = blob2.read_shift(1) >>> 5 & 3;
  var ixti = blob2.read_shift(2, "i");
  blob2.l += 8;
  var nameindex = blob2.read_shift(2);
  blob2.l += 12;
  return [type, ixti, nameindex];
}
function parse_PtgMemArea(blob2, length2, opts) {
  var type = blob2.read_shift(1) >>> 5 & 3;
  blob2.l += opts && opts.biff == 2 ? 3 : 4;
  var cce = blob2.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [type, cce];
}
function parse_PtgMemFunc(blob2, length2, opts) {
  var type = blob2.read_shift(1) >>> 5 & 3;
  var cce = blob2.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [type, cce];
}
function parse_PtgRefErr(blob2, length2, opts) {
  var type = blob2.read_shift(1) >>> 5 & 3;
  blob2.l += 4;
  if (opts.biff < 8)
    blob2.l--;
  if (opts.biff == 12)
    blob2.l += 2;
  return [type];
}
function parse_PtgRefErr3d(blob2, length2, opts) {
  var type = (blob2[blob2.l++] & 96) >> 5;
  var ixti = blob2.read_shift(2);
  var w2 = 4;
  if (opts)
    switch (opts.biff) {
      case 5:
        w2 = 15;
        break;
      case 12:
        w2 = 6;
        break;
    }
  blob2.l += w2;
  return [type, ixti];
}
var parse_PtgMemErr = parsenoop;
var parse_PtgMemNoMem = parsenoop;
var parse_PtgTbl = parsenoop;
function parse_PtgElfLoc(blob2, length2, opts) {
  blob2.l += 2;
  return [parse_RgceElfLoc(blob2)];
}
function parse_PtgElfNoop(blob2) {
  blob2.l += 6;
  return [];
}
var parse_PtgElfCol = parse_PtgElfLoc;
var parse_PtgElfColS = parse_PtgElfNoop;
var parse_PtgElfColSV = parse_PtgElfNoop;
var parse_PtgElfColV = parse_PtgElfLoc;
function parse_PtgElfLel(blob2) {
  blob2.l += 2;
  return [parseuint16(blob2), blob2.read_shift(2) & 1];
}
var parse_PtgElfRadical = parse_PtgElfLoc;
var parse_PtgElfRadicalLel = parse_PtgElfLel;
var parse_PtgElfRadicalS = parse_PtgElfNoop;
var parse_PtgElfRw = parse_PtgElfLoc;
var parse_PtgElfRwV = parse_PtgElfLoc;
var PtgListRT = [
  "Data",
  "All",
  "Headers",
  "??",
  "?Data2",
  "??",
  "?DataHeaders",
  "??",
  "Totals",
  "??",
  "??",
  "??",
  "?DataTotals",
  "??",
  "??",
  "??",
  "?Current"
];
function parse_PtgList(blob2) {
  blob2.l += 2;
  var ixti = blob2.read_shift(2);
  var flags = blob2.read_shift(2);
  var idx = blob2.read_shift(4);
  var c = blob2.read_shift(2);
  var C = blob2.read_shift(2);
  var rt = PtgListRT[flags >> 2 & 31];
  return { ixti, coltype: flags & 3, rt, idx, c, C };
}
function parse_PtgSxName(blob2) {
  blob2.l += 2;
  return [blob2.read_shift(4)];
}
function parse_PtgSheet(blob2, length2, opts) {
  blob2.l += 5;
  blob2.l += 2;
  blob2.l += opts.biff == 2 ? 1 : 4;
  return ["PTGSHEET"];
}
function parse_PtgEndSheet(blob2, length2, opts) {
  blob2.l += opts.biff == 2 ? 4 : 5;
  return ["PTGENDSHEET"];
}
function parse_PtgMemAreaN(blob2) {
  var type = blob2.read_shift(1) >>> 5 & 3;
  var cce = blob2.read_shift(2);
  return [type, cce];
}
function parse_PtgMemNoMemN(blob2) {
  var type = blob2.read_shift(1) >>> 5 & 3;
  var cce = blob2.read_shift(2);
  return [type, cce];
}
function parse_PtgAttrNoop(blob2) {
  blob2.l += 4;
  return [0, 0];
}
var PtgTypes = {
  /*::[*/
  1: { n: "PtgExp", f: parse_PtgExp },
  /*::[*/
  2: { n: "PtgTbl", f: parse_PtgTbl },
  /*::[*/
  3: { n: "PtgAdd", f: parseread1 },
  /*::[*/
  4: { n: "PtgSub", f: parseread1 },
  /*::[*/
  5: { n: "PtgMul", f: parseread1 },
  /*::[*/
  6: { n: "PtgDiv", f: parseread1 },
  /*::[*/
  7: { n: "PtgPower", f: parseread1 },
  /*::[*/
  8: { n: "PtgConcat", f: parseread1 },
  /*::[*/
  9: { n: "PtgLt", f: parseread1 },
  /*::[*/
  10: { n: "PtgLe", f: parseread1 },
  /*::[*/
  11: { n: "PtgEq", f: parseread1 },
  /*::[*/
  12: { n: "PtgGe", f: parseread1 },
  /*::[*/
  13: { n: "PtgGt", f: parseread1 },
  /*::[*/
  14: { n: "PtgNe", f: parseread1 },
  /*::[*/
  15: { n: "PtgIsect", f: parseread1 },
  /*::[*/
  16: { n: "PtgUnion", f: parseread1 },
  /*::[*/
  17: { n: "PtgRange", f: parseread1 },
  /*::[*/
  18: { n: "PtgUplus", f: parseread1 },
  /*::[*/
  19: { n: "PtgUminus", f: parseread1 },
  /*::[*/
  20: { n: "PtgPercent", f: parseread1 },
  /*::[*/
  21: { n: "PtgParen", f: parseread1 },
  /*::[*/
  22: { n: "PtgMissArg", f: parseread1 },
  /*::[*/
  23: { n: "PtgStr", f: parse_PtgStr },
  /*::[*/
  26: { n: "PtgSheet", f: parse_PtgSheet },
  /*::[*/
  27: { n: "PtgEndSheet", f: parse_PtgEndSheet },
  /*::[*/
  28: { n: "PtgErr", f: parse_PtgErr },
  /*::[*/
  29: { n: "PtgBool", f: parse_PtgBool },
  /*::[*/
  30: { n: "PtgInt", f: parse_PtgInt },
  /*::[*/
  31: { n: "PtgNum", f: parse_PtgNum },
  /*::[*/
  32: { n: "PtgArray", f: parse_PtgArray },
  /*::[*/
  33: { n: "PtgFunc", f: parse_PtgFunc },
  /*::[*/
  34: { n: "PtgFuncVar", f: parse_PtgFuncVar },
  /*::[*/
  35: { n: "PtgName", f: parse_PtgName },
  /*::[*/
  36: { n: "PtgRef", f: parse_PtgRef },
  /*::[*/
  37: { n: "PtgArea", f: parse_PtgArea },
  /*::[*/
  38: { n: "PtgMemArea", f: parse_PtgMemArea },
  /*::[*/
  39: { n: "PtgMemErr", f: parse_PtgMemErr },
  /*::[*/
  40: { n: "PtgMemNoMem", f: parse_PtgMemNoMem },
  /*::[*/
  41: { n: "PtgMemFunc", f: parse_PtgMemFunc },
  /*::[*/
  42: { n: "PtgRefErr", f: parse_PtgRefErr },
  /*::[*/
  43: { n: "PtgAreaErr", f: parse_PtgAreaErr },
  /*::[*/
  44: { n: "PtgRefN", f: parse_PtgRefN },
  /*::[*/
  45: { n: "PtgAreaN", f: parse_PtgAreaN },
  /*::[*/
  46: { n: "PtgMemAreaN", f: parse_PtgMemAreaN },
  /*::[*/
  47: { n: "PtgMemNoMemN", f: parse_PtgMemNoMemN },
  /*::[*/
  57: { n: "PtgNameX", f: parse_PtgNameX },
  /*::[*/
  58: { n: "PtgRef3d", f: parse_PtgRef3d },
  /*::[*/
  59: { n: "PtgArea3d", f: parse_PtgArea3d },
  /*::[*/
  60: { n: "PtgRefErr3d", f: parse_PtgRefErr3d },
  /*::[*/
  61: { n: "PtgAreaErr3d", f: parse_PtgAreaErr3d },
  /*::[*/
  255: {}
};
var PtgDupes = {
  /*::[*/
  64: 32,
  /*::[*/
  96: 32,
  /*::[*/
  65: 33,
  /*::[*/
  97: 33,
  /*::[*/
  66: 34,
  /*::[*/
  98: 34,
  /*::[*/
  67: 35,
  /*::[*/
  99: 35,
  /*::[*/
  68: 36,
  /*::[*/
  100: 36,
  /*::[*/
  69: 37,
  /*::[*/
  101: 37,
  /*::[*/
  70: 38,
  /*::[*/
  102: 38,
  /*::[*/
  71: 39,
  /*::[*/
  103: 39,
  /*::[*/
  72: 40,
  /*::[*/
  104: 40,
  /*::[*/
  73: 41,
  /*::[*/
  105: 41,
  /*::[*/
  74: 42,
  /*::[*/
  106: 42,
  /*::[*/
  75: 43,
  /*::[*/
  107: 43,
  /*::[*/
  76: 44,
  /*::[*/
  108: 44,
  /*::[*/
  77: 45,
  /*::[*/
  109: 45,
  /*::[*/
  78: 46,
  /*::[*/
  110: 46,
  /*::[*/
  79: 47,
  /*::[*/
  111: 47,
  /*::[*/
  88: 34,
  /*::[*/
  120: 34,
  /*::[*/
  89: 57,
  /*::[*/
  121: 57,
  /*::[*/
  90: 58,
  /*::[*/
  122: 58,
  /*::[*/
  91: 59,
  /*::[*/
  123: 59,
  /*::[*/
  92: 60,
  /*::[*/
  124: 60,
  /*::[*/
  93: 61,
  /*::[*/
  125: 61
};
var Ptg18 = {
  /*::[*/
  1: { n: "PtgElfLel", f: parse_PtgElfLel },
  /*::[*/
  2: { n: "PtgElfRw", f: parse_PtgElfRw },
  /*::[*/
  3: { n: "PtgElfCol", f: parse_PtgElfCol },
  /*::[*/
  6: { n: "PtgElfRwV", f: parse_PtgElfRwV },
  /*::[*/
  7: { n: "PtgElfColV", f: parse_PtgElfColV },
  /*::[*/
  10: { n: "PtgElfRadical", f: parse_PtgElfRadical },
  /*::[*/
  11: { n: "PtgElfRadicalS", f: parse_PtgElfRadicalS },
  /*::[*/
  13: { n: "PtgElfColS", f: parse_PtgElfColS },
  /*::[*/
  15: { n: "PtgElfColSV", f: parse_PtgElfColSV },
  /*::[*/
  16: { n: "PtgElfRadicalLel", f: parse_PtgElfRadicalLel },
  /*::[*/
  25: { n: "PtgList", f: parse_PtgList },
  /*::[*/
  29: { n: "PtgSxName", f: parse_PtgSxName },
  /*::[*/
  255: {}
};
var Ptg19 = {
  /*::[*/
  0: { n: "PtgAttrNoop", f: parse_PtgAttrNoop },
  /*::[*/
  1: { n: "PtgAttrSemi", f: parse_PtgAttrSemi },
  /*::[*/
  2: { n: "PtgAttrIf", f: parse_PtgAttrIf },
  /*::[*/
  4: { n: "PtgAttrChoose", f: parse_PtgAttrChoose },
  /*::[*/
  8: { n: "PtgAttrGoto", f: parse_PtgAttrGoto },
  /*::[*/
  16: { n: "PtgAttrSum", f: parse_PtgAttrSum },
  /*::[*/
  32: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  /*::[*/
  33: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  /*::[*/
  64: { n: "PtgAttrSpace", f: parse_PtgAttrSpace },
  /*::[*/
  65: { n: "PtgAttrSpaceSemi", f: parse_PtgAttrSpaceSemi },
  /*::[*/
  128: { n: "PtgAttrIfError", f: parse_PtgAttrIfError },
  /*::[*/
  255: {}
};
function parse_RgbExtra(blob2, length2, rgce, opts) {
  if (opts.biff < 8)
    return parsenoop(blob2, length2);
  var target = blob2.l + length2;
  var o = [];
  for (var i = 0; i !== rgce.length; ++i) {
    switch (rgce[i][0]) {
      case "PtgArray":
        rgce[i][1] = parse_PtgExtraArray(blob2, 0, opts);
        o.push(rgce[i][1]);
        break;
      case "PtgMemArea":
        rgce[i][2] = parse_PtgExtraMem(blob2, rgce[i][1], opts);
        o.push(rgce[i][2]);
        break;
      case "PtgExp":
        if (opts && opts.biff == 12) {
          rgce[i][1][1] = blob2.read_shift(4);
          o.push(rgce[i][1]);
        }
        break;
      case "PtgList":
      case "PtgElfRadicalS":
      case "PtgElfColS":
      case "PtgElfColSV":
        throw "Unsupported " + rgce[i][0];
    }
  }
  length2 = target - blob2.l;
  if (length2 !== 0)
    o.push(parsenoop(blob2, length2));
  return o;
}
function parse_Rgce(blob2, length2, opts) {
  var target = blob2.l + length2;
  var R, id, ptgs = [];
  while (target != blob2.l) {
    length2 = target - blob2.l;
    id = blob2[blob2.l];
    R = PtgTypes[id] || PtgTypes[PtgDupes[id]];
    if (id === 24 || id === 25)
      R = (id === 24 ? Ptg18 : Ptg19)[blob2[blob2.l + 1]];
    if (!R || !R.f) {
      parsenoop(blob2, length2);
    } else {
      ptgs.push([R.n, R.f(blob2, length2, opts)]);
    }
  }
  return ptgs;
}
function stringify_array(f) {
  var o = [];
  for (var i = 0; i < f.length; ++i) {
    var x = f[i], r = [];
    for (var j = 0; j < x.length; ++j) {
      var y = x[j];
      if (y)
        switch (y[0]) {
          case 2:
            r.push('"' + y[1].replace(/"/g, '""') + '"');
            break;
          default:
            r.push(y[1]);
        }
      else
        r.push("");
    }
    o.push(r.join(","));
  }
  return o.join(";");
}
var PtgBinOp = {
  PtgAdd: "+",
  PtgConcat: "&",
  PtgDiv: "/",
  PtgEq: "=",
  PtgGe: ">=",
  PtgGt: ">",
  PtgLe: "<=",
  PtgLt: "<",
  PtgMul: "*",
  PtgNe: "<>",
  PtgPower: "^",
  PtgSub: "-"
};
function make_3d_range(start, end) {
  var s = start.lastIndexOf("!"), e = end.lastIndexOf("!");
  if (s == -1 && e == -1)
    return start + ":" + end;
  if (s > 0 && e > 0 && start.slice(0, s).toLowerCase() == end.slice(0, e).toLowerCase())
    return start + ":" + end.slice(e + 1);
  console.error("Cannot hydrate range", start, end);
  return start + ":" + end;
}
function get_ixti_raw(supbooks, ixti, opts) {
  if (!supbooks)
    return "SH33TJSERR0";
  if (opts.biff > 8 && (!supbooks.XTI || !supbooks.XTI[ixti]))
    return supbooks.SheetNames[ixti];
  if (!supbooks.XTI)
    return "SH33TJSERR6";
  var XTI = supbooks.XTI[ixti];
  if (opts.biff < 8) {
    if (ixti > 1e4)
      ixti -= 65536;
    if (ixti < 0)
      ixti = -ixti;
    return ixti == 0 ? "" : supbooks.XTI[ixti - 1];
  }
  if (!XTI)
    return "SH33TJSERR1";
  var o = "";
  if (opts.biff > 8)
    switch (supbooks[XTI[0]][0]) {
      case 357:
        o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];
        return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
      case 358:
        if (opts.SID != null)
          return supbooks.SheetNames[opts.SID];
        return "SH33TJSSAME" + supbooks[XTI[0]][0];
      case 355:
      default:
        return "SH33TJSSRC" + supbooks[XTI[0]][0];
    }
  switch (supbooks[XTI[0]][0][0]) {
    case 1025:
      o = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]] || "SH33TJSERR3";
      return XTI[1] == XTI[2] ? o : o + ":" + supbooks.SheetNames[XTI[2]];
    case 14849:
      return supbooks[XTI[0]].slice(1).map(function(name) {
        return name.Name;
      }).join(";;");
    default:
      if (!supbooks[XTI[0]][0][3])
        return "SH33TJSERR2";
      o = XTI[1] == -1 ? "#REF" : supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4";
      return XTI[1] == XTI[2] ? o : o + ":" + supbooks[XTI[0]][0][3][XTI[2]];
  }
}
function get_ixti(supbooks, ixti, opts) {
  var ixtiraw = get_ixti_raw(supbooks, ixti, opts);
  return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);
}
function stringify_formula(formula, range, cell, supbooks, opts) {
  var biff = opts && opts.biff || 8;
  var _range = (
    /*range != null ? range :*/
    { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }
  );
  var stack = [], e1, e2, c, ixti = 0, nameidx = 0, r, sname = "";
  if (!formula[0] || !formula[0][0])
    return "";
  var last_sp = -1, sp = "";
  for (var ff = 0, fflen = formula[0].length; ff < fflen; ++ff) {
    var f = formula[0][ff];
    switch (f[0]) {
      case "PtgUminus":
        stack.push("-" + stack.pop());
        break;
      case "PtgUplus":
        stack.push("+" + stack.pop());
        break;
      case "PtgPercent":
        stack.push(stack.pop() + "%");
        break;
      case "PtgAdd":
      case "PtgConcat":
      case "PtgDiv":
      case "PtgEq":
      case "PtgGe":
      case "PtgGt":
      case "PtgLe":
      case "PtgLt":
      case "PtgMul":
      case "PtgNe":
      case "PtgPower":
      case "PtgSub":
        e1 = stack.pop();
        e2 = stack.pop();
        if (last_sp >= 0) {
          switch (formula[0][last_sp][1][0]) {
            case 0:
              sp = fill(" ", formula[0][last_sp][1][1]);
              break;
            case 1:
              sp = fill("\r", formula[0][last_sp][1][1]);
              break;
            default:
              sp = "";
              if (opts.WTF)
                throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
          }
          e2 = e2 + sp;
          last_sp = -1;
        }
        stack.push(e2 + PtgBinOp[f[0]] + e1);
        break;
      case "PtgIsect":
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e2 + " " + e1);
        break;
      case "PtgUnion":
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e2 + "," + e1);
        break;
      case "PtgRange":
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(make_3d_range(e2, e1));
        break;
      case "PtgAttrChoose":
        break;
      case "PtgAttrGoto":
        break;
      case "PtgAttrIf":
        break;
      case "PtgAttrIfError":
        break;
      case "PtgRef":
        c = shift_cell_xls(f[1][1], _range, opts);
        stack.push(encode_cell_xls(c, biff));
        break;
      case "PtgRefN":
        c = cell ? shift_cell_xls(f[1][1], cell, opts) : f[1][1];
        stack.push(encode_cell_xls(c, biff));
        break;
      case "PtgRef3d":
        ixti = /*::Number(*/
        f[1][1];
        c = shift_cell_xls(f[1][2], _range, opts);
        sname = get_ixti(supbooks, ixti, opts);
        stack.push(sname + "!" + encode_cell_xls(c, biff));
        break;
      case "PtgFunc":
      case "PtgFuncVar":
        var argc = f[1][0], func = f[1][1];
        if (!argc)
          argc = 0;
        argc &= 127;
        var args = argc == 0 ? [] : stack.slice(-argc);
        stack.length -= argc;
        if (func === "User")
          func = args.shift();
        stack.push(func + "(" + args.join(",") + ")");
        break;
      case "PtgBool":
        stack.push(f[1] ? "TRUE" : "FALSE");
        break;
      case "PtgInt":
        stack.push(
          /*::String(*/
          f[1]
          /*::)*/
        );
        break;
      case "PtgNum":
        stack.push(String(f[1]));
        break;
      case "PtgStr":
        stack.push('"' + f[1].replace(/"/g, '""') + '"');
        break;
      case "PtgErr":
        stack.push(
          /*::String(*/
          f[1]
          /*::)*/
        );
        break;
      case "PtgAreaN":
        r = shift_range_xls(f[1][1], cell ? { s: cell } : _range, opts);
        stack.push(encode_range_xls(r, opts));
        break;
      case "PtgArea":
        r = shift_range_xls(f[1][1], _range, opts);
        stack.push(encode_range_xls(r, opts));
        break;
      case "PtgArea3d":
        ixti = /*::Number(*/
        f[1][1];
        r = f[1][2];
        sname = get_ixti(supbooks, ixti, opts);
        stack.push(sname + "!" + encode_range_xls(r, opts));
        break;
      case "PtgAttrSum":
        stack.push("SUM(" + stack.pop() + ")");
        break;
      case "PtgAttrBaxcel":
      case "PtgAttrSemi":
        break;
      case "PtgName":
        nameidx = f[1][2];
        var lbl = (supbooks.names || [])[nameidx - 1] || (supbooks[0] || [])[nameidx];
        var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);
        if (name && name.slice(0, 6) == "_xlfn." && !opts.xlfn)
          name = name.slice(6);
        stack.push(name);
        break;
      case "PtgNameX":
        var bookidx = f[1][1];
        nameidx = f[1][2];
        var externbook;
        if (opts.biff <= 5) {
          if (bookidx < 0)
            bookidx = -bookidx;
          if (supbooks[bookidx])
            externbook = supbooks[bookidx][nameidx];
        } else {
          var o = "";
          if (((supbooks[bookidx] || [])[0] || [])[0] == 14849)
            ;
          else if (((supbooks[bookidx] || [])[0] || [])[0] == 1025) {
            if (supbooks[bookidx][nameidx] && supbooks[bookidx][nameidx].itab > 0) {
              o = supbooks.SheetNames[supbooks[bookidx][nameidx].itab - 1] + "!";
            }
          } else
            o = supbooks.SheetNames[nameidx - 1] + "!";
          if (supbooks[bookidx] && supbooks[bookidx][nameidx])
            o += supbooks[bookidx][nameidx].Name;
          else if (supbooks[0] && supbooks[0][nameidx])
            o += supbooks[0][nameidx].Name;
          else {
            var ixtidata = (get_ixti_raw(supbooks, bookidx, opts) || "").split(";;");
            if (ixtidata[nameidx - 1])
              o = ixtidata[nameidx - 1];
            else
              o += "SH33TJSERRX";
          }
          stack.push(o);
          break;
        }
        if (!externbook)
          externbook = { Name: "SH33TJSERRY" };
        stack.push(externbook.Name);
        break;
      case "PtgParen":
        var lp = "(", rp = ")";
        if (last_sp >= 0) {
          sp = "";
          switch (formula[0][last_sp][1][0]) {
            case 2:
              lp = fill(" ", formula[0][last_sp][1][1]) + lp;
              break;
            case 3:
              lp = fill("\r", formula[0][last_sp][1][1]) + lp;
              break;
            case 4:
              rp = fill(" ", formula[0][last_sp][1][1]) + rp;
              break;
            case 5:
              rp = fill("\r", formula[0][last_sp][1][1]) + rp;
              break;
            default:
              if (opts.WTF)
                throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
          }
          last_sp = -1;
        }
        stack.push(lp + stack.pop() + rp);
        break;
      case "PtgRefErr":
        stack.push("#REF!");
        break;
      case "PtgRefErr3d":
        stack.push("#REF!");
        break;
      case "PtgExp":
        c = { c: f[1][1], r: f[1][0] };
        var q = { c: cell.c, r: cell.r };
        if (supbooks.sharedf[encode_cell(c)]) {
          var parsedf = supbooks.sharedf[encode_cell(c)];
          stack.push(stringify_formula(parsedf, _range, q, supbooks, opts));
        } else {
          var fnd = false;
          for (e1 = 0; e1 != supbooks.arrayf.length; ++e1) {
            e2 = supbooks.arrayf[e1];
            if (c.c < e2[0].s.c || c.c > e2[0].e.c)
              continue;
            if (c.r < e2[0].s.r || c.r > e2[0].e.r)
              continue;
            stack.push(stringify_formula(e2[1], _range, q, supbooks, opts));
            fnd = true;
            break;
          }
          if (!fnd)
            stack.push(
              /*::String(*/
              f[1]
              /*::)*/
            );
        }
        break;
      case "PtgArray":
        stack.push("{" + stringify_array(
          /*::(*/
          f[1]
          /*:: :any)*/
        ) + "}");
        break;
      case "PtgMemArea":
        break;
      case "PtgAttrSpace":
      case "PtgAttrSpaceSemi":
        last_sp = ff;
        break;
      case "PtgTbl":
        break;
      case "PtgMemErr":
        break;
      case "PtgMissArg":
        stack.push("");
        break;
      case "PtgAreaErr":
        stack.push("#REF!");
        break;
      case "PtgAreaErr3d":
        stack.push("#REF!");
        break;
      case "PtgList":
        stack.push("Table" + f[1].idx + "[#" + f[1].rt + "]");
        break;
      case "PtgMemAreaN":
      case "PtgMemNoMemN":
      case "PtgAttrNoop":
      case "PtgSheet":
      case "PtgEndSheet":
        break;
      case "PtgMemFunc":
        break;
      case "PtgMemNoMem":
        break;
      case "PtgElfCol":
      case "PtgElfColS":
      case "PtgElfColSV":
      case "PtgElfColV":
      case "PtgElfLel":
      case "PtgElfRadical":
      case "PtgElfRadicalLel":
      case "PtgElfRadicalS":
      case "PtgElfRw":
      case "PtgElfRwV":
        throw new Error("Unsupported ELFs");
      case "PtgSxName":
        throw new Error("Unrecognized Formula Token: " + String(f));
      default:
        throw new Error("Unrecognized Formula Token: " + String(f));
    }
    var PtgNonDisp = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
    if (opts.biff != 3) {
      if (last_sp >= 0 && PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {
        f = formula[0][last_sp];
        var _left = true;
        switch (f[1][0]) {
          case 4:
            _left = false;
          case 0:
            sp = fill(" ", f[1][1]);
            break;
          case 5:
            _left = false;
          case 1:
            sp = fill("\r", f[1][1]);
            break;
          default:
            sp = "";
            if (opts.WTF)
              throw new Error("Unexpected PtgAttrSpaceType " + f[1][0]);
        }
        stack.push((_left ? sp : "") + stack.pop() + (_left ? "" : sp));
        last_sp = -1;
      }
    }
  }
  if (stack.length > 1 && opts.WTF)
    throw new Error("bad formula stack");
  if (stack[0] == "TRUE")
    return true;
  if (stack[0] == "FALSE")
    return false;
  return stack[0];
}
function parse_ArrayParsedFormula(blob2, length2, opts) {
  var target = blob2.l + length2, len = opts.biff == 2 ? 1 : 2;
  var rgcb, cce = blob2.read_shift(len);
  if (cce == 65535)
    return [[], parsenoop(blob2, length2 - 2)];
  var rgce = parse_Rgce(blob2, cce, opts);
  if (length2 !== cce + len)
    rgcb = parse_RgbExtra(blob2, length2 - cce - len, rgce, opts);
  blob2.l = target;
  return [rgce, rgcb];
}
function parse_XLSCellParsedFormula(blob2, length2, opts) {
  var target = blob2.l + length2, len = opts.biff == 2 ? 1 : 2;
  var rgcb, cce = blob2.read_shift(len);
  if (cce == 65535)
    return [[], parsenoop(blob2, length2 - 2)];
  var rgce = parse_Rgce(blob2, cce, opts);
  if (length2 !== cce + len)
    rgcb = parse_RgbExtra(blob2, length2 - cce - len, rgce, opts);
  blob2.l = target;
  return [rgce, rgcb];
}
function parse_NameParsedFormula(blob2, length2, opts, cce) {
  var target = blob2.l + length2;
  var rgce = parse_Rgce(blob2, cce, opts);
  var rgcb;
  if (target !== blob2.l)
    rgcb = parse_RgbExtra(blob2, target - blob2.l, rgce, opts);
  return [rgce, rgcb];
}
function parse_SharedParsedFormula(blob2, length2, opts) {
  var target = blob2.l + length2;
  var rgcb, cce = blob2.read_shift(2);
  var rgce = parse_Rgce(blob2, cce, opts);
  if (cce == 65535)
    return [[], parsenoop(blob2, length2 - 2)];
  if (length2 !== cce + 2)
    rgcb = parse_RgbExtra(blob2, target - cce - 2, rgce, opts);
  return [rgce, rgcb];
}
function parse_FormulaValue(blob2) {
  var b;
  if (__readUInt16LE(blob2, blob2.l + 6) !== 65535)
    return [parse_Xnum(blob2), "n"];
  switch (blob2[blob2.l]) {
    case 0:
      blob2.l += 8;
      return ["String", "s"];
    case 1:
      b = blob2[blob2.l + 2] === 1;
      blob2.l += 8;
      return [b, "b"];
    case 2:
      b = blob2[blob2.l + 2];
      blob2.l += 8;
      return [b, "e"];
    case 3:
      blob2.l += 8;
      return ["", "s"];
  }
  return [];
}
function write_FormulaValue(value) {
  if (value == null) {
    var o = new_buf(8);
    o.write_shift(1, 3);
    o.write_shift(1, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 0);
    o.write_shift(2, 65535);
    return o;
  } else if (typeof value == "number")
    return write_Xnum(value);
  return write_Xnum(0);
}
function parse_Formula(blob2, length2, opts) {
  var end = blob2.l + length2;
  var cell = parse_XLSCell(blob2);
  if (opts.biff == 2)
    ++blob2.l;
  var val = parse_FormulaValue(blob2);
  var flags = blob2.read_shift(1);
  if (opts.biff != 2) {
    blob2.read_shift(1);
    if (opts.biff >= 5) {
      blob2.read_shift(4);
    }
  }
  var cbf = parse_XLSCellParsedFormula(blob2, end - blob2.l, opts);
  return { cell, val: val[0], formula: cbf, shared: flags >> 3 & 1, tt: val[1] };
}
function write_Formula(cell, R, C, opts, os) {
  var o1 = write_XLSCell(R, C, os);
  var o2 = write_FormulaValue(cell.v);
  var o3 = new_buf(6);
  var flags = 1 | 32;
  o3.write_shift(2, flags);
  o3.write_shift(4, 0);
  var bf = new_buf(cell.bf.length);
  for (var i = 0; i < cell.bf.length; ++i)
    bf[i] = cell.bf[i];
  var out = bconcat([o1, o2, o3, bf]);
  return out;
}
function parse_XLSBParsedFormula(data, length2, opts) {
  var cce = data.read_shift(4);
  var rgce = parse_Rgce(data, cce, opts);
  var cb = data.read_shift(4);
  var rgcb = cb > 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;
  return [rgce, rgcb];
}
var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
function write_XLSBFormulaNum(val) {
  if ((val | 0) == val && val < Math.pow(2, 16) && val >= 0) {
    var oint = new_buf(11);
    oint.write_shift(4, 3);
    oint.write_shift(1, 30);
    oint.write_shift(2, val);
    oint.write_shift(4, 0);
    return oint;
  }
  var num = new_buf(17);
  num.write_shift(4, 11);
  num.write_shift(1, 31);
  num.write_shift(8, val);
  num.write_shift(4, 0);
  return num;
}
function write_XLSBFormulaErr(val) {
  var oint = new_buf(10);
  oint.write_shift(4, 2);
  oint.write_shift(1, 28);
  oint.write_shift(1, val);
  oint.write_shift(4, 0);
  return oint;
}
function write_XLSBFormulaBool(val) {
  var oint = new_buf(10);
  oint.write_shift(4, 2);
  oint.write_shift(1, 29);
  oint.write_shift(1, val ? 1 : 0);
  oint.write_shift(4, 0);
  return oint;
}
function write_XLSBFormulaStr(val) {
  var preamble = new_buf(7);
  preamble.write_shift(4, 3 + 2 * val.length);
  preamble.write_shift(1, 23);
  preamble.write_shift(2, val.length);
  var body = new_buf(2 * val.length);
  body.write_shift(2 * val.length, val, "utf16le");
  var postamble = new_buf(4);
  postamble.write_shift(4, 0);
  return bconcat([preamble, body, postamble]);
}
function write_XLSBFormulaRef(str) {
  var cell = decode_cell(str);
  var out = new_buf(15);
  out.write_shift(4, 7);
  out.write_shift(1, 4 | 1 << 5);
  out.write_shift(4, cell.r);
  out.write_shift(2, cell.c | (str.charAt(0) == "$" ? 0 : 1) << 14 | (str.match(/\$\d/) ? 0 : 1) << 15);
  out.write_shift(4, 0);
  return out;
}
function write_XLSBFormulaRef3D(str, wb) {
  var lastbang = str.lastIndexOf("!");
  var sname = str.slice(0, lastbang);
  str = str.slice(lastbang + 1);
  var cell = decode_cell(str);
  if (sname.charAt(0) == "'")
    sname = sname.slice(1, -1).replace(/''/g, "'");
  var out = new_buf(17);
  out.write_shift(4, 9);
  out.write_shift(1, 26 | 1 << 5);
  out.write_shift(2, 2 + wb.SheetNames.map(function(n) {
    return n.toLowerCase();
  }).indexOf(sname.toLowerCase()));
  out.write_shift(4, cell.r);
  out.write_shift(2, cell.c | (str.charAt(0) == "$" ? 0 : 1) << 14 | (str.match(/\$\d/) ? 0 : 1) << 15);
  out.write_shift(4, 0);
  return out;
}
function write_XLSBFormulaRefErr3D(str, wb) {
  var lastbang = str.lastIndexOf("!");
  var sname = str.slice(0, lastbang);
  str = str.slice(lastbang + 1);
  if (sname.charAt(0) == "'")
    sname = sname.slice(1, -1).replace(/''/g, "'");
  var out = new_buf(17);
  out.write_shift(4, 9);
  out.write_shift(1, 28 | 1 << 5);
  out.write_shift(2, 2 + wb.SheetNames.map(function(n) {
    return n.toLowerCase();
  }).indexOf(sname.toLowerCase()));
  out.write_shift(4, 0);
  out.write_shift(2, 0);
  out.write_shift(4, 0);
  return out;
}
function write_XLSBFormulaRange(_str) {
  var parts = _str.split(":"), str = parts[0];
  var out = new_buf(23);
  out.write_shift(4, 15);
  str = parts[0];
  var cell = decode_cell(str);
  out.write_shift(1, 4 | 1 << 5);
  out.write_shift(4, cell.r);
  out.write_shift(2, cell.c | (str.charAt(0) == "$" ? 0 : 1) << 14 | (str.match(/\$\d/) ? 0 : 1) << 15);
  out.write_shift(4, 0);
  str = parts[1];
  cell = decode_cell(str);
  out.write_shift(1, 4 | 1 << 5);
  out.write_shift(4, cell.r);
  out.write_shift(2, cell.c | (str.charAt(0) == "$" ? 0 : 1) << 14 | (str.match(/\$\d/) ? 0 : 1) << 15);
  out.write_shift(4, 0);
  out.write_shift(1, 17);
  out.write_shift(4, 0);
  return out;
}
function write_XLSBFormulaRangeWS(_str, wb) {
  var lastbang = _str.lastIndexOf("!");
  var sname = _str.slice(0, lastbang);
  _str = _str.slice(lastbang + 1);
  if (sname.charAt(0) == "'")
    sname = sname.slice(1, -1).replace(/''/g, "'");
  var parts = _str.split(":");
  str = parts[0];
  var out = new_buf(27);
  out.write_shift(4, 19);
  var str = parts[0], cell = decode_cell(str);
  out.write_shift(1, 26 | 1 << 5);
  out.write_shift(2, 2 + wb.SheetNames.map(function(n) {
    return n.toLowerCase();
  }).indexOf(sname.toLowerCase()));
  out.write_shift(4, cell.r);
  out.write_shift(2, cell.c | (str.charAt(0) == "$" ? 0 : 1) << 14 | (str.match(/\$\d/) ? 0 : 1) << 15);
  str = parts[1];
  cell = decode_cell(str);
  out.write_shift(1, 26 | 1 << 5);
  out.write_shift(2, 2 + wb.SheetNames.map(function(n) {
    return n.toLowerCase();
  }).indexOf(sname.toLowerCase()));
  out.write_shift(4, cell.r);
  out.write_shift(2, cell.c | (str.charAt(0) == "$" ? 0 : 1) << 14 | (str.match(/\$\d/) ? 0 : 1) << 15);
  out.write_shift(1, 17);
  out.write_shift(4, 0);
  return out;
}
function write_XLSBFormulaArea3D(_str, wb) {
  var lastbang = _str.lastIndexOf("!");
  var sname = _str.slice(0, lastbang);
  _str = _str.slice(lastbang + 1);
  if (sname.charAt(0) == "'")
    sname = sname.slice(1, -1).replace(/''/g, "'");
  var range = decode_range(_str);
  var out = new_buf(23);
  out.write_shift(4, 15);
  out.write_shift(1, 27 | 1 << 5);
  out.write_shift(2, 2 + wb.SheetNames.map(function(n) {
    return n.toLowerCase();
  }).indexOf(sname.toLowerCase()));
  out.write_shift(4, range.s.r);
  out.write_shift(4, range.e.r);
  out.write_shift(2, range.s.c);
  out.write_shift(2, range.e.c);
  out.write_shift(4, 0);
  return out;
}
function write_XLSBFormula(val, wb) {
  if (typeof val == "number")
    return write_XLSBFormulaNum(val);
  if (typeof val == "boolean")
    return write_XLSBFormulaBool(val);
  if (/^#(DIV\/0!|GETTING_DATA|N\/A|NAME\?|NULL!|NUM!|REF!|VALUE!)$/.test(val))
    return write_XLSBFormulaErr(+RBErr[val]);
  if (val.match(/^\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/))
    return write_XLSBFormulaRef(val);
  if (val.match(/^\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/))
    return write_XLSBFormulaRange(val);
  if (val.match(/^#REF!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/))
    return write_XLSBFormulaArea3D(val, wb);
  if (val.match(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,<.>]*)!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/))
    return write_XLSBFormulaRef3D(val, wb);
  if (val.match(/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,<.>]*)!\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5}):\$?(?:[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D]|[A-Z]{1,2})\$?(?:10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})$/))
    return write_XLSBFormulaRangeWS(val, wb);
  if (/^(?:'[^\\\/?*\[\]:]*'|[^'][^\\\/?*\[\]:'`~!@#$%^()\-=+{}|;,<.>]*)!#REF!$/.test(val))
    return write_XLSBFormulaRefErr3D(val, wb);
  if (/^".*"$/.test(val))
    return write_XLSBFormulaStr(val);
  if (/^[+-]\d+$/.test(val))
    return write_XLSBFormulaNum(parseInt(val, 10));
  throw "Formula |" + val + "| not supported for XLSB";
}
var write_XLSBNameParsedFormula = write_XLSBFormula;
var Cetab = {
  0: "BEEP",
  1: "OPEN",
  2: "OPEN.LINKS",
  3: "CLOSE.ALL",
  4: "SAVE",
  5: "SAVE.AS",
  6: "FILE.DELETE",
  7: "PAGE.SETUP",
  8: "PRINT",
  9: "PRINTER.SETUP",
  10: "QUIT",
  11: "NEW.WINDOW",
  12: "ARRANGE.ALL",
  13: "WINDOW.SIZE",
  14: "WINDOW.MOVE",
  15: "FULL",
  16: "CLOSE",
  17: "RUN",
  22: "SET.PRINT.AREA",
  23: "SET.PRINT.TITLES",
  24: "SET.PAGE.BREAK",
  25: "REMOVE.PAGE.BREAK",
  26: "FONT",
  27: "DISPLAY",
  28: "PROTECT.DOCUMENT",
  29: "PRECISION",
  30: "A1.R1C1",
  31: "CALCULATE.NOW",
  32: "CALCULATION",
  34: "DATA.FIND",
  35: "EXTRACT",
  36: "DATA.DELETE",
  37: "SET.DATABASE",
  38: "SET.CRITERIA",
  39: "SORT",
  40: "DATA.SERIES",
  41: "TABLE",
  42: "FORMAT.NUMBER",
  43: "ALIGNMENT",
  44: "STYLE",
  45: "BORDER",
  46: "CELL.PROTECTION",
  47: "COLUMN.WIDTH",
  48: "UNDO",
  49: "CUT",
  50: "COPY",
  51: "PASTE",
  52: "CLEAR",
  53: "PASTE.SPECIAL",
  54: "EDIT.DELETE",
  55: "INSERT",
  56: "FILL.RIGHT",
  57: "FILL.DOWN",
  61: "DEFINE.NAME",
  62: "CREATE.NAMES",
  63: "FORMULA.GOTO",
  64: "FORMULA.FIND",
  65: "SELECT.LAST.CELL",
  66: "SHOW.ACTIVE.CELL",
  67: "GALLERY.AREA",
  68: "GALLERY.BAR",
  69: "GALLERY.COLUMN",
  70: "GALLERY.LINE",
  71: "GALLERY.PIE",
  72: "GALLERY.SCATTER",
  73: "COMBINATION",
  74: "PREFERRED",
  75: "ADD.OVERLAY",
  76: "GRIDLINES",
  77: "SET.PREFERRED",
  78: "AXES",
  79: "LEGEND",
  80: "ATTACH.TEXT",
  81: "ADD.ARROW",
  82: "SELECT.CHART",
  83: "SELECT.PLOT.AREA",
  84: "PATTERNS",
  85: "MAIN.CHART",
  86: "OVERLAY",
  87: "SCALE",
  88: "FORMAT.LEGEND",
  89: "FORMAT.TEXT",
  90: "EDIT.REPEAT",
  91: "PARSE",
  92: "JUSTIFY",
  93: "HIDE",
  94: "UNHIDE",
  95: "WORKSPACE",
  96: "FORMULA",
  97: "FORMULA.FILL",
  98: "FORMULA.ARRAY",
  99: "DATA.FIND.NEXT",
  100: "DATA.FIND.PREV",
  101: "FORMULA.FIND.NEXT",
  102: "FORMULA.FIND.PREV",
  103: "ACTIVATE",
  104: "ACTIVATE.NEXT",
  105: "ACTIVATE.PREV",
  106: "UNLOCKED.NEXT",
  107: "UNLOCKED.PREV",
  108: "COPY.PICTURE",
  109: "SELECT",
  110: "DELETE.NAME",
  111: "DELETE.FORMAT",
  112: "VLINE",
  113: "HLINE",
  114: "VPAGE",
  115: "HPAGE",
  116: "VSCROLL",
  117: "HSCROLL",
  118: "ALERT",
  119: "NEW",
  120: "CANCEL.COPY",
  121: "SHOW.CLIPBOARD",
  122: "MESSAGE",
  124: "PASTE.LINK",
  125: "APP.ACTIVATE",
  126: "DELETE.ARROW",
  127: "ROW.HEIGHT",
  128: "FORMAT.MOVE",
  129: "FORMAT.SIZE",
  130: "FORMULA.REPLACE",
  131: "SEND.KEYS",
  132: "SELECT.SPECIAL",
  133: "APPLY.NAMES",
  134: "REPLACE.FONT",
  135: "FREEZE.PANES",
  136: "SHOW.INFO",
  137: "SPLIT",
  138: "ON.WINDOW",
  139: "ON.DATA",
  140: "DISABLE.INPUT",
  142: "OUTLINE",
  143: "LIST.NAMES",
  144: "FILE.CLOSE",
  145: "SAVE.WORKBOOK",
  146: "DATA.FORM",
  147: "COPY.CHART",
  148: "ON.TIME",
  149: "WAIT",
  150: "FORMAT.FONT",
  151: "FILL.UP",
  152: "FILL.LEFT",
  153: "DELETE.OVERLAY",
  155: "SHORT.MENUS",
  159: "SET.UPDATE.STATUS",
  161: "COLOR.PALETTE",
  162: "DELETE.STYLE",
  163: "WINDOW.RESTORE",
  164: "WINDOW.MAXIMIZE",
  166: "CHANGE.LINK",
  167: "CALCULATE.DOCUMENT",
  168: "ON.KEY",
  169: "APP.RESTORE",
  170: "APP.MOVE",
  171: "APP.SIZE",
  172: "APP.MINIMIZE",
  173: "APP.MAXIMIZE",
  174: "BRING.TO.FRONT",
  175: "SEND.TO.BACK",
  185: "MAIN.CHART.TYPE",
  186: "OVERLAY.CHART.TYPE",
  187: "SELECT.END",
  188: "OPEN.MAIL",
  189: "SEND.MAIL",
  190: "STANDARD.FONT",
  191: "CONSOLIDATE",
  192: "SORT.SPECIAL",
  193: "GALLERY.3D.AREA",
  194: "GALLERY.3D.COLUMN",
  195: "GALLERY.3D.LINE",
  196: "GALLERY.3D.PIE",
  197: "VIEW.3D",
  198: "GOAL.SEEK",
  199: "WORKGROUP",
  200: "FILL.GROUP",
  201: "UPDATE.LINK",
  202: "PROMOTE",
  203: "DEMOTE",
  204: "SHOW.DETAIL",
  206: "UNGROUP",
  207: "OBJECT.PROPERTIES",
  208: "SAVE.NEW.OBJECT",
  209: "SHARE",
  210: "SHARE.NAME",
  211: "DUPLICATE",
  212: "APPLY.STYLE",
  213: "ASSIGN.TO.OBJECT",
  214: "OBJECT.PROTECTION",
  215: "HIDE.OBJECT",
  216: "SET.EXTRACT",
  217: "CREATE.PUBLISHER",
  218: "SUBSCRIBE.TO",
  219: "ATTRIBUTES",
  220: "SHOW.TOOLBAR",
  222: "PRINT.PREVIEW",
  223: "EDIT.COLOR",
  224: "SHOW.LEVELS",
  225: "FORMAT.MAIN",
  226: "FORMAT.OVERLAY",
  227: "ON.RECALC",
  228: "EDIT.SERIES",
  229: "DEFINE.STYLE",
  240: "LINE.PRINT",
  243: "ENTER.DATA",
  249: "GALLERY.RADAR",
  250: "MERGE.STYLES",
  251: "EDITION.OPTIONS",
  252: "PASTE.PICTURE",
  253: "PASTE.PICTURE.LINK",
  254: "SPELLING",
  256: "ZOOM",
  259: "INSERT.OBJECT",
  260: "WINDOW.MINIMIZE",
  265: "SOUND.NOTE",
  266: "SOUND.PLAY",
  267: "FORMAT.SHAPE",
  268: "EXTEND.POLYGON",
  269: "FORMAT.AUTO",
  272: "GALLERY.3D.BAR",
  273: "GALLERY.3D.SURFACE",
  274: "FILL.AUTO",
  276: "CUSTOMIZE.TOOLBAR",
  277: "ADD.TOOL",
  278: "EDIT.OBJECT",
  279: "ON.DOUBLECLICK",
  280: "ON.ENTRY",
  281: "WORKBOOK.ADD",
  282: "WORKBOOK.MOVE",
  283: "WORKBOOK.COPY",
  284: "WORKBOOK.OPTIONS",
  285: "SAVE.WORKSPACE",
  288: "CHART.WIZARD",
  289: "DELETE.TOOL",
  290: "MOVE.TOOL",
  291: "WORKBOOK.SELECT",
  292: "WORKBOOK.ACTIVATE",
  293: "ASSIGN.TO.TOOL",
  295: "COPY.TOOL",
  296: "RESET.TOOL",
  297: "CONSTRAIN.NUMERIC",
  298: "PASTE.TOOL",
  302: "WORKBOOK.NEW",
  305: "SCENARIO.CELLS",
  306: "SCENARIO.DELETE",
  307: "SCENARIO.ADD",
  308: "SCENARIO.EDIT",
  309: "SCENARIO.SHOW",
  310: "SCENARIO.SHOW.NEXT",
  311: "SCENARIO.SUMMARY",
  312: "PIVOT.TABLE.WIZARD",
  313: "PIVOT.FIELD.PROPERTIES",
  314: "PIVOT.FIELD",
  315: "PIVOT.ITEM",
  316: "PIVOT.ADD.FIELDS",
  318: "OPTIONS.CALCULATION",
  319: "OPTIONS.EDIT",
  320: "OPTIONS.VIEW",
  321: "ADDIN.MANAGER",
  322: "MENU.EDITOR",
  323: "ATTACH.TOOLBARS",
  324: "VBAActivate",
  325: "OPTIONS.CHART",
  328: "VBA.INSERT.FILE",
  330: "VBA.PROCEDURE.DEFINITION",
  336: "ROUTING.SLIP",
  338: "ROUTE.DOCUMENT",
  339: "MAIL.LOGON",
  342: "INSERT.PICTURE",
  343: "EDIT.TOOL",
  344: "GALLERY.DOUGHNUT",
  350: "CHART.TREND",
  352: "PIVOT.ITEM.PROPERTIES",
  354: "WORKBOOK.INSERT",
  355: "OPTIONS.TRANSITION",
  356: "OPTIONS.GENERAL",
  370: "FILTER.ADVANCED",
  373: "MAIL.ADD.MAILER",
  374: "MAIL.DELETE.MAILER",
  375: "MAIL.REPLY",
  376: "MAIL.REPLY.ALL",
  377: "MAIL.FORWARD",
  378: "MAIL.NEXT.LETTER",
  379: "DATA.LABEL",
  380: "INSERT.TITLE",
  381: "FONT.PROPERTIES",
  382: "MACRO.OPTIONS",
  383: "WORKBOOK.HIDE",
  384: "WORKBOOK.UNHIDE",
  385: "WORKBOOK.DELETE",
  386: "WORKBOOK.NAME",
  388: "GALLERY.CUSTOM",
  390: "ADD.CHART.AUTOFORMAT",
  391: "DELETE.CHART.AUTOFORMAT",
  392: "CHART.ADD.DATA",
  393: "AUTO.OUTLINE",
  394: "TAB.ORDER",
  395: "SHOW.DIALOG",
  396: "SELECT.ALL",
  397: "UNGROUP.SHEETS",
  398: "SUBTOTAL.CREATE",
  399: "SUBTOTAL.REMOVE",
  400: "RENAME.OBJECT",
  412: "WORKBOOK.SCROLL",
  413: "WORKBOOK.NEXT",
  414: "WORKBOOK.PREV",
  415: "WORKBOOK.TAB.SPLIT",
  416: "FULL.SCREEN",
  417: "WORKBOOK.PROTECT",
  420: "SCROLLBAR.PROPERTIES",
  421: "PIVOT.SHOW.PAGES",
  422: "TEXT.TO.COLUMNS",
  423: "FORMAT.CHARTTYPE",
  424: "LINK.FORMAT",
  425: "TRACER.DISPLAY",
  430: "TRACER.NAVIGATE",
  431: "TRACER.CLEAR",
  432: "TRACER.ERROR",
  433: "PIVOT.FIELD.GROUP",
  434: "PIVOT.FIELD.UNGROUP",
  435: "CHECKBOX.PROPERTIES",
  436: "LABEL.PROPERTIES",
  437: "LISTBOX.PROPERTIES",
  438: "EDITBOX.PROPERTIES",
  439: "PIVOT.REFRESH",
  440: "LINK.COMBO",
  441: "OPEN.TEXT",
  442: "HIDE.DIALOG",
  443: "SET.DIALOG.FOCUS",
  444: "ENABLE.OBJECT",
  445: "PUSHBUTTON.PROPERTIES",
  446: "SET.DIALOG.DEFAULT",
  447: "FILTER",
  448: "FILTER.SHOW.ALL",
  449: "CLEAR.OUTLINE",
  450: "FUNCTION.WIZARD",
  451: "ADD.LIST.ITEM",
  452: "SET.LIST.ITEM",
  453: "REMOVE.LIST.ITEM",
  454: "SELECT.LIST.ITEM",
  455: "SET.CONTROL.VALUE",
  456: "SAVE.COPY.AS",
  458: "OPTIONS.LISTS.ADD",
  459: "OPTIONS.LISTS.DELETE",
  460: "SERIES.AXES",
  461: "SERIES.X",
  462: "SERIES.Y",
  463: "ERRORBAR.X",
  464: "ERRORBAR.Y",
  465: "FORMAT.CHART",
  466: "SERIES.ORDER",
  467: "MAIL.LOGOFF",
  468: "CLEAR.ROUTING.SLIP",
  469: "APP.ACTIVATE.MICROSOFT",
  470: "MAIL.EDIT.MAILER",
  471: "ON.SHEET",
  472: "STANDARD.WIDTH",
  473: "SCENARIO.MERGE",
  474: "SUMMARY.INFO",
  475: "FIND.FILE",
  476: "ACTIVE.CELL.FONT",
  477: "ENABLE.TIPWIZARD",
  478: "VBA.MAKE.ADDIN",
  480: "INSERTDATATABLE",
  481: "WORKGROUP.OPTIONS",
  482: "MAIL.SEND.MAILER",
  485: "AUTOCORRECT",
  489: "POST.DOCUMENT",
  491: "PICKLIST",
  493: "VIEW.SHOW",
  494: "VIEW.DEFINE",
  495: "VIEW.DELETE",
  509: "SHEET.BACKGROUND",
  510: "INSERT.MAP.OBJECT",
  511: "OPTIONS.MENONO",
  517: "MSOCHECKS",
  518: "NORMAL",
  519: "LAYOUT",
  520: "RM.PRINT.AREA",
  521: "CLEAR.PRINT.AREA",
  522: "ADD.PRINT.AREA",
  523: "MOVE.BRK",
  545: "HIDECURR.NOTE",
  546: "HIDEALL.NOTES",
  547: "DELETE.NOTE",
  548: "TRAVERSE.NOTES",
  549: "ACTIVATE.NOTES",
  620: "PROTECT.REVISIONS",
  621: "UNPROTECT.REVISIONS",
  647: "OPTIONS.ME",
  653: "WEB.PUBLISH",
  667: "NEWWEBQUERY",
  673: "PIVOT.TABLE.CHART",
  753: "OPTIONS.SAVE",
  755: "OPTIONS.SPELL",
  808: "HIDEALL.INKANNOTS"
};
var Ftab = {
  0: "COUNT",
  1: "IF",
  2: "ISNA",
  3: "ISERROR",
  4: "SUM",
  5: "AVERAGE",
  6: "MIN",
  7: "MAX",
  8: "ROW",
  9: "COLUMN",
  10: "NA",
  11: "NPV",
  12: "STDEV",
  13: "DOLLAR",
  14: "FIXED",
  15: "SIN",
  16: "COS",
  17: "TAN",
  18: "ATAN",
  19: "PI",
  20: "SQRT",
  21: "EXP",
  22: "LN",
  23: "LOG10",
  24: "ABS",
  25: "INT",
  26: "SIGN",
  27: "ROUND",
  28: "LOOKUP",
  29: "INDEX",
  30: "REPT",
  31: "MID",
  32: "LEN",
  33: "VALUE",
  34: "TRUE",
  35: "FALSE",
  36: "AND",
  37: "OR",
  38: "NOT",
  39: "MOD",
  40: "DCOUNT",
  41: "DSUM",
  42: "DAVERAGE",
  43: "DMIN",
  44: "DMAX",
  45: "DSTDEV",
  46: "VAR",
  47: "DVAR",
  48: "TEXT",
  49: "LINEST",
  50: "TREND",
  51: "LOGEST",
  52: "GROWTH",
  53: "GOTO",
  54: "HALT",
  55: "RETURN",
  56: "PV",
  57: "FV",
  58: "NPER",
  59: "PMT",
  60: "RATE",
  61: "MIRR",
  62: "IRR",
  63: "RAND",
  64: "MATCH",
  65: "DATE",
  66: "TIME",
  67: "DAY",
  68: "MONTH",
  69: "YEAR",
  70: "WEEKDAY",
  71: "HOUR",
  72: "MINUTE",
  73: "SECOND",
  74: "NOW",
  75: "AREAS",
  76: "ROWS",
  77: "COLUMNS",
  78: "OFFSET",
  79: "ABSREF",
  80: "RELREF",
  81: "ARGUMENT",
  82: "SEARCH",
  83: "TRANSPOSE",
  84: "ERROR",
  85: "STEP",
  86: "TYPE",
  87: "ECHO",
  88: "SET.NAME",
  89: "CALLER",
  90: "DEREF",
  91: "WINDOWS",
  92: "SERIES",
  93: "DOCUMENTS",
  94: "ACTIVE.CELL",
  95: "SELECTION",
  96: "RESULT",
  97: "ATAN2",
  98: "ASIN",
  99: "ACOS",
  100: "CHOOSE",
  101: "HLOOKUP",
  102: "VLOOKUP",
  103: "LINKS",
  104: "INPUT",
  105: "ISREF",
  106: "GET.FORMULA",
  107: "GET.NAME",
  108: "SET.VALUE",
  109: "LOG",
  110: "EXEC",
  111: "CHAR",
  112: "LOWER",
  113: "UPPER",
  114: "PROPER",
  115: "LEFT",
  116: "RIGHT",
  117: "EXACT",
  118: "TRIM",
  119: "REPLACE",
  120: "SUBSTITUTE",
  121: "CODE",
  122: "NAMES",
  123: "DIRECTORY",
  124: "FIND",
  125: "CELL",
  126: "ISERR",
  127: "ISTEXT",
  128: "ISNUMBER",
  129: "ISBLANK",
  130: "T",
  131: "N",
  132: "FOPEN",
  133: "FCLOSE",
  134: "FSIZE",
  135: "FREADLN",
  136: "FREAD",
  137: "FWRITELN",
  138: "FWRITE",
  139: "FPOS",
  140: "DATEVALUE",
  141: "TIMEVALUE",
  142: "SLN",
  143: "SYD",
  144: "DDB",
  145: "GET.DEF",
  146: "REFTEXT",
  147: "TEXTREF",
  148: "INDIRECT",
  149: "REGISTER",
  150: "CALL",
  151: "ADD.BAR",
  152: "ADD.MENU",
  153: "ADD.COMMAND",
  154: "ENABLE.COMMAND",
  155: "CHECK.COMMAND",
  156: "RENAME.COMMAND",
  157: "SHOW.BAR",
  158: "DELETE.MENU",
  159: "DELETE.COMMAND",
  160: "GET.CHART.ITEM",
  161: "DIALOG.BOX",
  162: "CLEAN",
  163: "MDETERM",
  164: "MINVERSE",
  165: "MMULT",
  166: "FILES",
  167: "IPMT",
  168: "PPMT",
  169: "COUNTA",
  170: "CANCEL.KEY",
  171: "FOR",
  172: "WHILE",
  173: "BREAK",
  174: "NEXT",
  175: "INITIATE",
  176: "REQUEST",
  177: "POKE",
  178: "EXECUTE",
  179: "TERMINATE",
  180: "RESTART",
  181: "HELP",
  182: "GET.BAR",
  183: "PRODUCT",
  184: "FACT",
  185: "GET.CELL",
  186: "GET.WORKSPACE",
  187: "GET.WINDOW",
  188: "GET.DOCUMENT",
  189: "DPRODUCT",
  190: "ISNONTEXT",
  191: "GET.NOTE",
  192: "NOTE",
  193: "STDEVP",
  194: "VARP",
  195: "DSTDEVP",
  196: "DVARP",
  197: "TRUNC",
  198: "ISLOGICAL",
  199: "DCOUNTA",
  200: "DELETE.BAR",
  201: "UNREGISTER",
  204: "USDOLLAR",
  205: "FINDB",
  206: "SEARCHB",
  207: "REPLACEB",
  208: "LEFTB",
  209: "RIGHTB",
  210: "MIDB",
  211: "LENB",
  212: "ROUNDUP",
  213: "ROUNDDOWN",
  214: "ASC",
  215: "DBCS",
  216: "RANK",
  219: "ADDRESS",
  220: "DAYS360",
  221: "TODAY",
  222: "VDB",
  223: "ELSE",
  224: "ELSE.IF",
  225: "END.IF",
  226: "FOR.CELL",
  227: "MEDIAN",
  228: "SUMPRODUCT",
  229: "SINH",
  230: "COSH",
  231: "TANH",
  232: "ASINH",
  233: "ACOSH",
  234: "ATANH",
  235: "DGET",
  236: "CREATE.OBJECT",
  237: "VOLATILE",
  238: "LAST.ERROR",
  239: "CUSTOM.UNDO",
  240: "CUSTOM.REPEAT",
  241: "FORMULA.CONVERT",
  242: "GET.LINK.INFO",
  243: "TEXT.BOX",
  244: "INFO",
  245: "GROUP",
  246: "GET.OBJECT",
  247: "DB",
  248: "PAUSE",
  251: "RESUME",
  252: "FREQUENCY",
  253: "ADD.TOOLBAR",
  254: "DELETE.TOOLBAR",
  255: "User",
  256: "RESET.TOOLBAR",
  257: "EVALUATE",
  258: "GET.TOOLBAR",
  259: "GET.TOOL",
  260: "SPELLING.CHECK",
  261: "ERROR.TYPE",
  262: "APP.TITLE",
  263: "WINDOW.TITLE",
  264: "SAVE.TOOLBAR",
  265: "ENABLE.TOOL",
  266: "PRESS.TOOL",
  267: "REGISTER.ID",
  268: "GET.WORKBOOK",
  269: "AVEDEV",
  270: "BETADIST",
  271: "GAMMALN",
  272: "BETAINV",
  273: "BINOMDIST",
  274: "CHIDIST",
  275: "CHIINV",
  276: "COMBIN",
  277: "CONFIDENCE",
  278: "CRITBINOM",
  279: "EVEN",
  280: "EXPONDIST",
  281: "FDIST",
  282: "FINV",
  283: "FISHER",
  284: "FISHERINV",
  285: "FLOOR",
  286: "GAMMADIST",
  287: "GAMMAINV",
  288: "CEILING",
  289: "HYPGEOMDIST",
  290: "LOGNORMDIST",
  291: "LOGINV",
  292: "NEGBINOMDIST",
  293: "NORMDIST",
  294: "NORMSDIST",
  295: "NORMINV",
  296: "NORMSINV",
  297: "STANDARDIZE",
  298: "ODD",
  299: "PERMUT",
  300: "POISSON",
  301: "TDIST",
  302: "WEIBULL",
  303: "SUMXMY2",
  304: "SUMX2MY2",
  305: "SUMX2PY2",
  306: "CHITEST",
  307: "CORREL",
  308: "COVAR",
  309: "FORECAST",
  310: "FTEST",
  311: "INTERCEPT",
  312: "PEARSON",
  313: "RSQ",
  314: "STEYX",
  315: "SLOPE",
  316: "TTEST",
  317: "PROB",
  318: "DEVSQ",
  319: "GEOMEAN",
  320: "HARMEAN",
  321: "SUMSQ",
  322: "KURT",
  323: "SKEW",
  324: "ZTEST",
  325: "LARGE",
  326: "SMALL",
  327: "QUARTILE",
  328: "PERCENTILE",
  329: "PERCENTRANK",
  330: "MODE",
  331: "TRIMMEAN",
  332: "TINV",
  334: "MOVIE.COMMAND",
  335: "GET.MOVIE",
  336: "CONCATENATE",
  337: "POWER",
  338: "PIVOT.ADD.DATA",
  339: "GET.PIVOT.TABLE",
  340: "GET.PIVOT.FIELD",
  341: "GET.PIVOT.ITEM",
  342: "RADIANS",
  343: "DEGREES",
  344: "SUBTOTAL",
  345: "SUMIF",
  346: "COUNTIF",
  347: "COUNTBLANK",
  348: "SCENARIO.GET",
  349: "OPTIONS.LISTS.GET",
  350: "ISPMT",
  351: "DATEDIF",
  352: "DATESTRING",
  353: "NUMBERSTRING",
  354: "ROMAN",
  355: "OPEN.DIALOG",
  356: "SAVE.DIALOG",
  357: "VIEW.GET",
  358: "GETPIVOTDATA",
  359: "HYPERLINK",
  360: "PHONETIC",
  361: "AVERAGEA",
  362: "MAXA",
  363: "MINA",
  364: "STDEVPA",
  365: "VARPA",
  366: "STDEVA",
  367: "VARA",
  368: "BAHTTEXT",
  369: "THAIDAYOFWEEK",
  370: "THAIDIGIT",
  371: "THAIMONTHOFYEAR",
  372: "THAINUMSOUND",
  373: "THAINUMSTRING",
  374: "THAISTRINGLENGTH",
  375: "ISTHAIDIGIT",
  376: "ROUNDBAHTDOWN",
  377: "ROUNDBAHTUP",
  378: "THAIYEAR",
  379: "RTD",
  380: "CUBEVALUE",
  381: "CUBEMEMBER",
  382: "CUBEMEMBERPROPERTY",
  383: "CUBERANKEDMEMBER",
  384: "HEX2BIN",
  385: "HEX2DEC",
  386: "HEX2OCT",
  387: "DEC2BIN",
  388: "DEC2HEX",
  389: "DEC2OCT",
  390: "OCT2BIN",
  391: "OCT2HEX",
  392: "OCT2DEC",
  393: "BIN2DEC",
  394: "BIN2OCT",
  395: "BIN2HEX",
  396: "IMSUB",
  397: "IMDIV",
  398: "IMPOWER",
  399: "IMABS",
  400: "IMSQRT",
  401: "IMLN",
  402: "IMLOG2",
  403: "IMLOG10",
  404: "IMSIN",
  405: "IMCOS",
  406: "IMEXP",
  407: "IMARGUMENT",
  408: "IMCONJUGATE",
  409: "IMAGINARY",
  410: "IMREAL",
  411: "COMPLEX",
  412: "IMSUM",
  413: "IMPRODUCT",
  414: "SERIESSUM",
  415: "FACTDOUBLE",
  416: "SQRTPI",
  417: "QUOTIENT",
  418: "DELTA",
  419: "GESTEP",
  420: "ISEVEN",
  421: "ISODD",
  422: "MROUND",
  423: "ERF",
  424: "ERFC",
  425: "BESSELJ",
  426: "BESSELK",
  427: "BESSELY",
  428: "BESSELI",
  429: "XIRR",
  430: "XNPV",
  431: "PRICEMAT",
  432: "YIELDMAT",
  433: "INTRATE",
  434: "RECEIVED",
  435: "DISC",
  436: "PRICEDISC",
  437: "YIELDDISC",
  438: "TBILLEQ",
  439: "TBILLPRICE",
  440: "TBILLYIELD",
  441: "PRICE",
  442: "YIELD",
  443: "DOLLARDE",
  444: "DOLLARFR",
  445: "NOMINAL",
  446: "EFFECT",
  447: "CUMPRINC",
  448: "CUMIPMT",
  449: "EDATE",
  450: "EOMONTH",
  451: "YEARFRAC",
  452: "COUPDAYBS",
  453: "COUPDAYS",
  454: "COUPDAYSNC",
  455: "COUPNCD",
  456: "COUPNUM",
  457: "COUPPCD",
  458: "DURATION",
  459: "MDURATION",
  460: "ODDLPRICE",
  461: "ODDLYIELD",
  462: "ODDFPRICE",
  463: "ODDFYIELD",
  464: "RANDBETWEEN",
  465: "WEEKNUM",
  466: "AMORDEGRC",
  467: "AMORLINC",
  468: "CONVERT",
  724: "SHEETJS",
  469: "ACCRINT",
  470: "ACCRINTM",
  471: "WORKDAY",
  472: "NETWORKDAYS",
  473: "GCD",
  474: "MULTINOMIAL",
  475: "LCM",
  476: "FVSCHEDULE",
  477: "CUBEKPIMEMBER",
  478: "CUBESET",
  479: "CUBESETCOUNT",
  480: "IFERROR",
  481: "COUNTIFS",
  482: "SUMIFS",
  483: "AVERAGEIF",
  484: "AVERAGEIFS"
};
var FtabArgc = {
  2: 1,
  3: 1,
  10: 0,
  15: 1,
  16: 1,
  17: 1,
  18: 1,
  19: 0,
  20: 1,
  21: 1,
  22: 1,
  23: 1,
  24: 1,
  25: 1,
  26: 1,
  27: 2,
  30: 2,
  31: 3,
  32: 1,
  33: 1,
  34: 0,
  35: 0,
  38: 1,
  39: 2,
  40: 3,
  41: 3,
  42: 3,
  43: 3,
  44: 3,
  45: 3,
  47: 3,
  48: 2,
  53: 1,
  61: 3,
  63: 0,
  65: 3,
  66: 3,
  67: 1,
  68: 1,
  69: 1,
  70: 1,
  71: 1,
  72: 1,
  73: 1,
  74: 0,
  75: 1,
  76: 1,
  77: 1,
  79: 2,
  80: 2,
  83: 1,
  85: 0,
  86: 1,
  89: 0,
  90: 1,
  94: 0,
  95: 0,
  97: 2,
  98: 1,
  99: 1,
  101: 3,
  102: 3,
  105: 1,
  106: 1,
  108: 2,
  111: 1,
  112: 1,
  113: 1,
  114: 1,
  117: 2,
  118: 1,
  119: 4,
  121: 1,
  126: 1,
  127: 1,
  128: 1,
  129: 1,
  130: 1,
  131: 1,
  133: 1,
  134: 1,
  135: 1,
  136: 2,
  137: 2,
  138: 2,
  140: 1,
  141: 1,
  142: 3,
  143: 4,
  144: 4,
  161: 1,
  162: 1,
  163: 1,
  164: 1,
  165: 2,
  172: 1,
  175: 2,
  176: 2,
  177: 3,
  178: 2,
  179: 1,
  184: 1,
  186: 1,
  189: 3,
  190: 1,
  195: 3,
  196: 3,
  197: 1,
  198: 1,
  199: 3,
  201: 1,
  207: 4,
  210: 3,
  211: 1,
  212: 2,
  213: 2,
  214: 1,
  215: 1,
  225: 0,
  229: 1,
  230: 1,
  231: 1,
  232: 1,
  233: 1,
  234: 1,
  235: 3,
  244: 1,
  247: 4,
  252: 2,
  257: 1,
  261: 1,
  271: 1,
  273: 4,
  274: 2,
  275: 2,
  276: 2,
  277: 3,
  278: 3,
  279: 1,
  280: 3,
  281: 3,
  282: 3,
  283: 1,
  284: 1,
  285: 2,
  286: 4,
  287: 3,
  288: 2,
  289: 4,
  290: 3,
  291: 3,
  292: 3,
  293: 4,
  294: 1,
  295: 3,
  296: 1,
  297: 3,
  298: 1,
  299: 2,
  300: 3,
  301: 3,
  302: 4,
  303: 2,
  304: 2,
  305: 2,
  306: 2,
  307: 2,
  308: 2,
  309: 3,
  310: 2,
  311: 2,
  312: 2,
  313: 2,
  314: 2,
  315: 2,
  316: 4,
  325: 2,
  326: 2,
  327: 2,
  328: 2,
  331: 2,
  332: 2,
  337: 2,
  342: 1,
  343: 1,
  346: 2,
  347: 1,
  350: 4,
  351: 3,
  352: 1,
  353: 2,
  360: 1,
  368: 1,
  369: 1,
  370: 1,
  371: 1,
  372: 1,
  373: 1,
  374: 1,
  375: 1,
  376: 1,
  377: 1,
  378: 1,
  382: 3,
  385: 1,
  392: 1,
  393: 1,
  396: 2,
  397: 2,
  398: 2,
  399: 1,
  400: 1,
  401: 1,
  402: 1,
  403: 1,
  404: 1,
  405: 1,
  406: 1,
  407: 1,
  408: 1,
  409: 1,
  410: 1,
  414: 4,
  415: 1,
  416: 1,
  417: 2,
  420: 1,
  421: 1,
  422: 2,
  424: 1,
  425: 2,
  426: 2,
  427: 2,
  428: 2,
  430: 3,
  438: 3,
  439: 3,
  440: 3,
  443: 2,
  444: 2,
  445: 2,
  446: 2,
  447: 6,
  448: 6,
  449: 2,
  450: 2,
  464: 2,
  468: 3,
  476: 2,
  479: 1,
  480: 2,
  65535: 0
};
function ods_to_csf_formula(f) {
  if (f.slice(0, 3) == "of:")
    f = f.slice(3);
  if (f.charCodeAt(0) == 61) {
    f = f.slice(1);
    if (f.charCodeAt(0) == 61)
      f = f.slice(1);
  }
  f = f.replace(/COM\.MICROSOFT\./g, "");
  f = f.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function($$, $1) {
    return $1.replace(/\./g, "");
  });
  f = f.replace(/\$'([^']|'')+'/g, function($$) {
    return $$.slice(1);
  });
  f = f.replace(/\$([^\]\. #$]+)/g, function($$, $1) {
    return $1.match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? $$ : $1;
  });
  f = f.replace(/\[.(#[A-Z]*[?!])\]/g, "$1");
  return f.replace(/[;~]/g, ",").replace(/\|/g, ";");
}
function csf_to_ods_formula(f) {
  var o = "of:=" + f.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":");
  return o.replace(/;/g, "|").replace(/,/g, ";");
}
function ods_to_csf_3D(r) {
  r = r.replace(/\$'([^']|'')+'/g, function($$) {
    return $$.slice(1);
  });
  r = r.replace(/\$([^\]\. #$]+)/g, function($$, $1) {
    return $1.match(/^([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])?(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})?$/) ? $$ : $1;
  });
  var a = r.split(":");
  var s = a[0].split(".")[0];
  return [s, a[0].split(".")[1] + (a.length > 1 ? ":" + (a[1].split(".")[1] || a[1].split(".")[0]) : "")];
}
function csf_to_ods_3D(r) {
  return r.replace(/!/, ".");
}
var strs = {};
var _ssfopts = {};
var browser_has_Map = typeof Map !== "undefined";
function get_sst_id(sst, str, rev) {
  var i = 0, len = sst.length;
  if (rev) {
    if (browser_has_Map ? rev.has(str) : Object.prototype.hasOwnProperty.call(rev, str)) {
      var revarr = browser_has_Map ? rev.get(str) : rev[str];
      for (; i < revarr.length; ++i) {
        if (sst[revarr[i]].t === str) {
          sst.Count++;
          return revarr[i];
        }
      }
    }
  } else
    for (; i < len; ++i) {
      if (sst[i].t === str) {
        sst.Count++;
        return i;
      }
    }
  sst[len] = { t: str };
  sst.Count++;
  sst.Unique++;
  if (rev) {
    if (browser_has_Map) {
      if (!rev.has(str))
        rev.set(str, []);
      rev.get(str).push(len);
    } else {
      if (!Object.prototype.hasOwnProperty.call(rev, str))
        rev[str] = [];
      rev[str].push(len);
    }
  }
  return len;
}
function col_obj_w(C, col) {
  var p = { min: C + 1, max: C + 1 };
  var wch = -1;
  if (col.MDW)
    MDW = col.MDW;
  if (col.width != null)
    p.customWidth = 1;
  else if (col.wpx != null)
    wch = px2char(col.wpx);
  else if (col.wch != null)
    wch = col.wch;
  if (wch > -1) {
    p.width = char2width(wch);
    p.customWidth = 1;
  } else if (col.width != null)
    p.width = col.width;
  if (col.hidden)
    p.hidden = true;
  if (col.level != null) {
    p.outlineLevel = p.level = col.level;
  }
  return p;
}
function default_margins(margins, mode) {
  if (!margins)
    return;
  var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
  if (mode == "xlml")
    defs = [1, 1, 1, 1, 0.5, 0.5];
  if (margins.left == null)
    margins.left = defs[0];
  if (margins.right == null)
    margins.right = defs[1];
  if (margins.top == null)
    margins.top = defs[2];
  if (margins.bottom == null)
    margins.bottom = defs[3];
  if (margins.header == null)
    margins.header = defs[4];
  if (margins.footer == null)
    margins.footer = defs[5];
}
function get_cell_style(styles2, cell, opts) {
  var z = opts.revssf[cell.z != null ? cell.z : "General"];
  var i = 60, len = styles2.length;
  if (z == null && opts.ssf) {
    for (; i < 392; ++i)
      if (opts.ssf[i] == null) {
        SSF__load(cell.z, i);
        opts.ssf[i] = cell.z;
        opts.revssf[cell.z] = z = i;
        break;
      }
  }
  for (i = 0; i != len; ++i)
    if (styles2[i].numFmtId === z)
      return i;
  styles2[len] = {
    numFmtId: z,
    fontId: 0,
    fillId: 0,
    borderId: 0,
    xfId: 0,
    applyNumberFormat: 1
  };
  return len;
}
function safe_format(p, fmtid, fillid, opts, themes, styles2) {
  try {
    if (opts.cellNF)
      p.z = table_fmt[fmtid];
  } catch (e) {
    if (opts.WTF)
      throw e;
  }
  if (p.t === "z" && !opts.cellStyles)
    return;
  if (p.t === "d" && typeof p.v === "string")
    p.v = parseDate(p.v);
  if ((!opts || opts.cellText !== false) && p.t !== "z")
    try {
      if (table_fmt[fmtid] == null)
        SSF__load(SSFImplicit[fmtid] || "General", fmtid);
      if (p.t === "e")
        p.w = p.w || BErr[p.v];
      else if (fmtid === 0) {
        if (p.t === "n") {
          if ((p.v | 0) === p.v)
            p.w = p.v.toString(10);
          else
            p.w = SSF_general_num(p.v);
        } else if (p.t === "d") {
          var dd = datenum(p.v);
          if ((dd | 0) === dd)
            p.w = dd.toString(10);
          else
            p.w = SSF_general_num(dd);
        } else if (p.v === void 0)
          return "";
        else
          p.w = SSF_general(p.v, _ssfopts);
      } else if (p.t === "d")
        p.w = SSF_format(fmtid, datenum(p.v), _ssfopts);
      else
        p.w = SSF_format(fmtid, p.v, _ssfopts);
    } catch (e) {
      if (opts.WTF)
        throw e;
    }
  if (!opts.cellStyles)
    return;
  if (fillid != null)
    try {
      p.s = styles2.Fills[fillid];
      if (p.s.fgColor && p.s.fgColor.theme && !p.s.fgColor.rgb) {
        p.s.fgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.fgColor.theme].rgb, p.s.fgColor.tint || 0);
        if (opts.WTF)
          p.s.fgColor.raw_rgb = themes.themeElements.clrScheme[p.s.fgColor.theme].rgb;
      }
      if (p.s.bgColor && p.s.bgColor.theme) {
        p.s.bgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.bgColor.theme].rgb, p.s.bgColor.tint || 0);
        if (opts.WTF)
          p.s.bgColor.raw_rgb = themes.themeElements.clrScheme[p.s.bgColor.theme].rgb;
      }
    } catch (e) {
      if (opts.WTF && styles2.Fills)
        throw e;
    }
}
function check_ws(ws, sname, i) {
  if (ws && ws["!ref"]) {
    var range = safe_decode_range(ws["!ref"]);
    if (range.e.c < range.s.c || range.e.r < range.s.r)
      throw new Error("Bad range (" + i + "): " + ws["!ref"]);
  }
}
function parse_ws_xml_dim(ws, s) {
  var d = safe_decode_range(s);
  if (d.s.r <= d.e.r && d.s.c <= d.e.c && d.s.r >= 0 && d.s.c >= 0)
    ws["!ref"] = encode_range(d);
}
var mergecregex = /<(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?>/g;
var sheetdataregex = /<(?:\w+:)?sheetData[^>]*>([\s\S]*)<\/(?:\w+:)?sheetData>/;
var hlinkregex = /<(?:\w:)?hyperlink [^>]*>/mg;
var dimregex = /"(\w*:\w*)"/;
var colregex = /<(?:\w:)?col\b[^>]*[\/]?>/g;
var afregex = /<(?:\w:)?autoFilter[^>]*([\/]|>([\s\S]*)<\/(?:\w:)?autoFilter)>/g;
var marginregex = /<(?:\w:)?pageMargins[^>]*\/>/g;
var sheetprregex = /<(?:\w:)?sheetPr\b(?:[^>a-z][^>]*)?\/>/;
var sheetprregex2 = /<(?:\w:)?sheetPr[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetPr)>/;
var svsregex = /<(?:\w:)?sheetViews[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetViews)>/;
function parse_ws_xml(data, opts, idx, rels, wb, themes, styles2) {
  if (!data)
    return data;
  if (!rels)
    rels = { "!id": {} };
  var s = {};
  if (opts.dense)
    s["!data"] = [];
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var data1 = "", data2 = "";
  var mtch = data.match(sheetdataregex);
  if (mtch) {
    data1 = data.slice(0, mtch.index);
    data2 = data.slice(mtch.index + mtch[0].length);
  } else
    data1 = data2 = data;
  var sheetPr = data1.match(sheetprregex);
  if (sheetPr)
    parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);
  else if (sheetPr = data1.match(sheetprregex2))
    parse_ws_xml_sheetpr2(sheetPr[0], sheetPr[1] || "", s, wb, idx);
  var ridx = (data1.match(/<(?:\w*:)?dimension/) || { index: -1 }).index;
  if (ridx > 0) {
    var ref = data1.slice(ridx, ridx + 50).match(dimregex);
    if (ref && !(opts && opts.nodim))
      parse_ws_xml_dim(s, ref[1]);
  }
  var svs = data1.match(svsregex);
  if (svs && svs[1])
    parse_ws_xml_sheetviews(svs[1], wb);
  var columns = [];
  if (opts.cellStyles) {
    var cols = data1.match(colregex);
    if (cols)
      parse_ws_xml_cols(columns, cols);
  }
  if (mtch)
    parse_ws_xml_data(mtch[1], s, opts, refguess, themes, styles2);
  var afilter = data2.match(afregex);
  if (afilter)
    s["!autofilter"] = parse_ws_xml_autofilter(afilter[0]);
  var merges = [];
  var _merge2 = data2.match(mergecregex);
  if (_merge2)
    for (ridx = 0; ridx != _merge2.length; ++ridx)
      merges[ridx] = safe_decode_range(_merge2[ridx].slice(_merge2[ridx].indexOf('"') + 1));
  var hlink = data2.match(hlinkregex);
  if (hlink)
    parse_ws_xml_hlinks(s, hlink, rels);
  var margins = data2.match(marginregex);
  if (margins)
    s["!margins"] = parse_ws_xml_margins(parsexmltag(margins[0]));
  if (opts && opts.nodim)
    refguess.s.c = refguess.s.r = 0;
  if (!s["!ref"] && refguess.e.c >= refguess.s.c && refguess.e.r >= refguess.s.r)
    s["!ref"] = encode_range(refguess);
  if (opts.sheetRows > 0 && s["!ref"]) {
    var tmpref = safe_decode_range(s["!ref"]);
    if (opts.sheetRows <= +tmpref.e.r) {
      tmpref.e.r = opts.sheetRows - 1;
      if (tmpref.e.r > refguess.e.r)
        tmpref.e.r = refguess.e.r;
      if (tmpref.e.r < tmpref.s.r)
        tmpref.s.r = tmpref.e.r;
      if (tmpref.e.c > refguess.e.c)
        tmpref.e.c = refguess.e.c;
      if (tmpref.e.c < tmpref.s.c)
        tmpref.s.c = tmpref.e.c;
      s["!fullref"] = s["!ref"];
      s["!ref"] = encode_range(tmpref);
    }
  }
  if (columns.length > 0)
    s["!cols"] = columns;
  if (merges.length > 0)
    s["!merges"] = merges;
  return s;
}
function write_ws_xml_merges(merges) {
  if (merges.length === 0)
    return "";
  var o = '<mergeCells count="' + merges.length + '">';
  for (var i = 0; i != merges.length; ++i)
    o += '<mergeCell ref="' + encode_range(merges[i]) + '"/>';
  return o + "</mergeCells>";
}
function parse_ws_xml_sheetpr(sheetPr, s, wb, idx) {
  var data = parsexmltag(sheetPr);
  if (!wb.Sheets[idx])
    wb.Sheets[idx] = {};
  if (data.codeName)
    wb.Sheets[idx].CodeName = unescapexml(utf8read(data.codeName));
}
function parse_ws_xml_sheetpr2(sheetPr, body, s, wb, idx) {
  parse_ws_xml_sheetpr(sheetPr.slice(0, sheetPr.indexOf(">")), s, wb, idx);
}
function write_ws_xml_sheetpr(ws, wb, idx, opts, o) {
  var needed = false;
  var props = {}, payload = null;
  if (opts.bookType !== "xlsx" && wb.vbaraw) {
    var cname = wb.SheetNames[idx];
    try {
      if (wb.Workbook)
        cname = wb.Workbook.Sheets[idx].CodeName || cname;
    } catch (e) {
    }
    needed = true;
    props.codeName = utf8write(escapexml(cname));
  }
  if (ws && ws["!outline"]) {
    var outlineprops = { summaryBelow: 1, summaryRight: 1 };
    if (ws["!outline"].above)
      outlineprops.summaryBelow = 0;
    if (ws["!outline"].left)
      outlineprops.summaryRight = 0;
    payload = (payload || "") + writextag("outlinePr", null, outlineprops);
  }
  if (!needed && !payload)
    return;
  o[o.length] = writextag("sheetPr", payload, props);
}
var sheetprot_deffalse = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"];
var sheetprot_deftrue = [
  "formatColumns",
  "formatRows",
  "formatCells",
  "insertColumns",
  "insertRows",
  "insertHyperlinks",
  "deleteColumns",
  "deleteRows",
  "sort",
  "autoFilter",
  "pivotTables"
];
function write_ws_xml_protection(sp) {
  var o = { sheet: 1 };
  sheetprot_deffalse.forEach(function(n) {
    if (sp[n] != null && sp[n])
      o[n] = "1";
  });
  sheetprot_deftrue.forEach(function(n) {
    if (sp[n] != null && !sp[n])
      o[n] = "0";
  });
  if (sp.password)
    o.password = crypto_CreatePasswordVerifier_Method1(sp.password).toString(16).toUpperCase();
  return writextag("sheetProtection", null, o);
}
function parse_ws_xml_hlinks(s, data, rels) {
  var dense = s["!data"] != null;
  for (var i = 0; i != data.length; ++i) {
    var val = parsexmltag(utf8read(data[i]), true);
    if (!val.ref)
      return;
    var rel = ((rels || {})["!id"] || [])[val.id];
    if (rel) {
      val.Target = rel.Target;
      if (val.location)
        val.Target += "#" + unescapexml(val.location);
    } else {
      val.Target = "#" + unescapexml(val.location);
      rel = { Target: val.Target, TargetMode: "Internal" };
    }
    val.Rel = rel;
    if (val.tooltip) {
      val.Tooltip = val.tooltip;
      delete val.tooltip;
    }
    var rng2 = safe_decode_range(val.ref);
    for (var R = rng2.s.r; R <= rng2.e.r; ++R)
      for (var C = rng2.s.c; C <= rng2.e.c; ++C) {
        var addr = encode_col(C) + encode_row(R);
        if (dense) {
          if (!s["!data"][R])
            s["!data"][R] = [];
          if (!s["!data"][R][C])
            s["!data"][R][C] = { t: "z", v: void 0 };
          s["!data"][R][C].l = val;
        } else {
          if (!s[addr])
            s[addr] = { t: "z", v: void 0 };
          s[addr].l = val;
        }
      }
  }
}
function parse_ws_xml_margins(margin) {
  var o = {};
  ["left", "right", "top", "bottom", "header", "footer"].forEach(function(k) {
    if (margin[k])
      o[k] = parseFloat(margin[k]);
  });
  return o;
}
function write_ws_xml_margins(margin) {
  default_margins(margin);
  return writextag("pageMargins", null, margin);
}
function parse_ws_xml_cols(columns, cols) {
  var seencol = false;
  for (var coli = 0; coli != cols.length; ++coli) {
    var coll = parsexmltag(cols[coli], true);
    if (coll.hidden)
      coll.hidden = parsexmlbool(coll.hidden);
    var colm = parseInt(coll.min, 10) - 1, colM = parseInt(coll.max, 10) - 1;
    if (coll.outlineLevel)
      coll.level = +coll.outlineLevel || 0;
    delete coll.min;
    delete coll.max;
    coll.width = +coll.width;
    if (!seencol && coll.width) {
      seencol = true;
      find_mdw_colw(coll.width);
    }
    process_col(coll);
    while (colm <= colM)
      columns[colm++] = dup(coll);
  }
}
function write_ws_xml_cols(ws, cols) {
  var o = ["<cols>"], col;
  for (var i = 0; i != cols.length; ++i) {
    if (!(col = cols[i]))
      continue;
    o[o.length] = writextag("col", null, col_obj_w(i, col));
  }
  o[o.length] = "</cols>";
  return o.join("");
}
function parse_ws_xml_autofilter(data) {
  var o = { ref: (data.match(/ref="([^"]*)"/) || [])[1] };
  return o;
}
function write_ws_xml_autofilter(data, ws, wb, idx) {
  var ref = typeof data.ref == "string" ? data.ref : encode_range(data.ref);
  if (!wb.Workbook)
    wb.Workbook = { Sheets: [] };
  if (!wb.Workbook.Names)
    wb.Workbook.Names = [];
  var names = wb.Workbook.Names;
  var range = decode_range(ref);
  if (range.s.r == range.e.r) {
    range.e.r = decode_range(ws["!ref"]).e.r;
    ref = encode_range(range);
  }
  for (var i = 0; i < names.length; ++i) {
    var name = names[i];
    if (name.Name != "_xlnm._FilterDatabase")
      continue;
    if (name.Sheet != idx)
      continue;
    name.Ref = formula_quote_sheet_name(wb.SheetNames[idx]) + "!" + fix_range(ref);
    break;
  }
  if (i == names.length)
    names.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: "'" + wb.SheetNames[idx] + "'!" + ref });
  return writextag("autoFilter", null, { ref });
}
var sviewregex = /<(?:\w:)?sheetView(?:[^>a-z][^>]*)?\/?>/g;
function parse_ws_xml_sheetviews(data, wb) {
  if (!wb.Views)
    wb.Views = [{}];
  (data.match(sviewregex) || []).forEach(function(r, i) {
    var tag = parsexmltag(r);
    if (!wb.Views[i])
      wb.Views[i] = {};
    if (+tag.zoomScale)
      wb.Views[i].zoom = +tag.zoomScale;
    if (tag.rightToLeft && parsexmlbool(tag.rightToLeft))
      wb.Views[i].RTL = true;
  });
}
function write_ws_xml_sheetviews(ws, opts, idx, wb) {
  var sview = { workbookViewId: "0" };
  if ((((wb || {}).Workbook || {}).Views || [])[0])
    sview.rightToLeft = wb.Workbook.Views[0].RTL ? "1" : "0";
  return writextag("sheetViews", writextag("sheetView", null, sview), {});
}
function write_ws_xml_cell(cell, ref, ws, opts) {
  if (cell.c)
    ws["!comments"].push([ref, cell.c]);
  if ((cell.v === void 0 || cell.t === "z" && !(opts || {}).sheetStubs) && typeof cell.f !== "string" && typeof cell.z == "undefined")
    return "";
  var vv = "";
  var oldt = cell.t, oldv = cell.v;
  if (cell.t !== "z")
    switch (cell.t) {
      case "b":
        vv = cell.v ? "1" : "0";
        break;
      case "n":
        vv = "" + cell.v;
        break;
      case "e":
        vv = BErr[cell.v];
        break;
      case "d":
        if (opts && opts.cellDates)
          vv = parseDate(cell.v, -1).toISOString();
        else {
          cell = dup(cell);
          cell.t = "n";
          vv = "" + (cell.v = datenum(parseDate(cell.v)));
        }
        if (typeof cell.z === "undefined")
          cell.z = table_fmt[14];
        break;
      default:
        vv = cell.v;
        break;
    }
  var v = cell.t == "z" || cell.v == null ? "" : writetag("v", escapexml(vv)), o = { r: ref };
  var os = get_cell_style(opts.cellXfs, cell, opts);
  if (os !== 0)
    o.s = os;
  switch (cell.t) {
    case "n":
      break;
    case "d":
      o.t = "d";
      break;
    case "b":
      o.t = "b";
      break;
    case "e":
      o.t = "e";
      break;
    case "z":
      break;
    default:
      if (cell.v == null) {
        delete cell.t;
        break;
      }
      if (cell.v.length > 32767)
        throw new Error("Text length must not exceed 32767 characters");
      if (opts && opts.bookSST) {
        v = writetag("v", "" + get_sst_id(opts.Strings, cell.v, opts.revStrings));
        o.t = "s";
        break;
      } else
        o.t = "str";
      break;
  }
  if (cell.t != oldt) {
    cell.t = oldt;
    cell.v = oldv;
  }
  if (typeof cell.f == "string" && cell.f) {
    var ff = cell.F && cell.F.slice(0, ref.length) == ref ? { t: "array", ref: cell.F } : null;
    v = writextag("f", escapexml(cell.f), ff) + (cell.v != null ? v : "");
  }
  if (cell.l) {
    cell.l.display = escapexml(vv);
    ws["!links"].push([ref, cell.l]);
  }
  if (cell.D)
    o.cm = 1;
  return writextag("c", v, o);
}
var parse_ws_xml_data = /* @__PURE__ */ function() {
  var cellregex = /<(?:\w+:)?c[ \/>]/, rowregex = /<\/(?:\w+:)?row>/;
  var rregex = /r=["']([^"']*)["']/, isregex = /<(?:\w+:)?is>([\S\s]*?)<\/(?:\w+:)?is>/;
  var refregex = /ref=["']([^"']*)["']/;
  var match_v = matchtag("v"), match_f = matchtag("f");
  return function parse_ws_xml_data2(sdata, s, opts, guess, themes, styles2) {
    var ri = 0, x = "", cells = [], cref = [], idx = 0, i = 0, cc = 0, d = "", p;
    var tag, tagr = 0, tagc = 0;
    var sstr, ftag;
    var fmtid = 0, fillid = 0;
    var do_format = Array.isArray(styles2.CellXf), cf;
    var arrayf = [];
    var sharedf = [];
    var dense = s["!data"] != null;
    var rows = [], rowobj = {}, rowrite = false;
    var sheetStubs = !!opts.sheetStubs;
    for (var marr = sdata.split(rowregex), mt = 0, marrlen = marr.length; mt != marrlen; ++mt) {
      x = marr[mt].trim();
      var xlen = x.length;
      if (xlen === 0)
        continue;
      var rstarti = 0;
      outa:
        for (ri = 0; ri < xlen; ++ri)
          switch (
            /*x.charCodeAt(ri)*/
            x[ri]
          ) {
            case ">":
              if (
                /*x.charCodeAt(ri-1) != 47*/
                x[ri - 1] != "/"
              ) {
                ++ri;
                break outa;
              }
              if (opts && opts.cellStyles) {
                tag = parsexmltag(x.slice(rstarti, ri), true);
                tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
                tagc = -1;
                if (opts.sheetRows && opts.sheetRows < tagr)
                  continue;
                rowobj = {};
                rowrite = false;
                if (tag.ht) {
                  rowrite = true;
                  rowobj.hpt = parseFloat(tag.ht);
                  rowobj.hpx = pt2px(rowobj.hpt);
                }
                if (tag.hidden && parsexmlbool(tag.hidden)) {
                  rowrite = true;
                  rowobj.hidden = true;
                }
                if (tag.outlineLevel != null) {
                  rowrite = true;
                  rowobj.level = +tag.outlineLevel;
                }
                if (rowrite)
                  rows[tagr - 1] = rowobj;
              }
              break;
            case "<":
              rstarti = ri;
              break;
          }
      if (rstarti >= ri)
        break;
      tag = parsexmltag(x.slice(rstarti, ri), true);
      tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
      tagc = -1;
      if (opts.sheetRows && opts.sheetRows < tagr)
        continue;
      if (!opts.nodim) {
        if (guess.s.r > tagr - 1)
          guess.s.r = tagr - 1;
        if (guess.e.r < tagr - 1)
          guess.e.r = tagr - 1;
      }
      if (opts && opts.cellStyles) {
        rowobj = {};
        rowrite = false;
        if (tag.ht) {
          rowrite = true;
          rowobj.hpt = parseFloat(tag.ht);
          rowobj.hpx = pt2px(rowobj.hpt);
        }
        if (tag.hidden && parsexmlbool(tag.hidden)) {
          rowrite = true;
          rowobj.hidden = true;
        }
        if (tag.outlineLevel != null) {
          rowrite = true;
          rowobj.level = +tag.outlineLevel;
        }
        if (rowrite)
          rows[tagr - 1] = rowobj;
      }
      cells = x.slice(ri).split(cellregex);
      for (var rslice = 0; rslice != cells.length; ++rslice)
        if (cells[rslice].trim().charAt(0) != "<")
          break;
      cells = cells.slice(rslice);
      for (ri = 0; ri != cells.length; ++ri) {
        x = cells[ri].trim();
        if (x.length === 0)
          continue;
        cref = x.match(rregex);
        idx = ri;
        i = 0;
        cc = 0;
        x = "<c " + (x.slice(0, 1) == "<" ? ">" : "") + x;
        if (cref != null && cref.length === 2) {
          idx = 0;
          d = cref[1];
          for (i = 0; i != d.length; ++i) {
            if ((cc = d.charCodeAt(i) - 64) < 1 || cc > 26)
              break;
            idx = 26 * idx + cc;
          }
          --idx;
          tagc = idx;
        } else
          ++tagc;
        for (i = 0; i != x.length; ++i)
          if (x.charCodeAt(i) === 62)
            break;
        ++i;
        tag = parsexmltag(x.slice(0, i), true);
        if (!tag.r)
          tag.r = encode_cell({ r: tagr - 1, c: tagc });
        d = x.slice(i);
        p = { t: "" };
        if ((cref = d.match(match_v)) != null && /*::cref != null && */
        cref[1] !== "")
          p.v = unescapexml(cref[1]);
        if (opts.cellFormula) {
          if ((cref = d.match(match_f)) != null && /*::cref != null && */
          cref[1] !== "") {
            p.f = unescapexml(utf8read(cref[1]), true);
            if (!opts.xlfn)
              p.f = _xlfn(p.f);
            if (
              /*::cref != null && cref[0] != null && */
              cref[0].indexOf('t="array"') > -1
            ) {
              p.F = (d.match(refregex) || [])[1];
              if (p.F.indexOf(":") > -1)
                arrayf.push([safe_decode_range(p.F), p.F]);
            } else if (
              /*::cref != null && cref[0] != null && */
              cref[0].indexOf('t="shared"') > -1
            ) {
              ftag = parsexmltag(cref[0]);
              var ___f = unescapexml(utf8read(cref[1]));
              if (!opts.xlfn)
                ___f = _xlfn(___f);
              sharedf[parseInt(ftag.si, 10)] = [ftag, ___f, tag.r];
            }
          } else if (cref = d.match(/<f[^>]*\/>/)) {
            ftag = parsexmltag(cref[0]);
            if (sharedf[ftag.si])
              p.f = shift_formula_xlsx(sharedf[ftag.si][1], sharedf[ftag.si][2], tag.r);
          }
          var _tag = decode_cell(tag.r);
          for (i = 0; i < arrayf.length; ++i)
            if (_tag.r >= arrayf[i][0].s.r && _tag.r <= arrayf[i][0].e.r) {
              if (_tag.c >= arrayf[i][0].s.c && _tag.c <= arrayf[i][0].e.c)
                p.F = arrayf[i][1];
            }
        }
        if (tag.t == null && p.v === void 0) {
          if (p.f || p.F) {
            p.v = 0;
            p.t = "n";
          } else if (!sheetStubs)
            continue;
          else
            p.t = "z";
        } else
          p.t = tag.t || "n";
        if (guess.s.c > tagc)
          guess.s.c = tagc;
        if (guess.e.c < tagc)
          guess.e.c = tagc;
        switch (p.t) {
          case "n":
            if (p.v == "" || p.v == null) {
              if (!sheetStubs)
                continue;
              p.t = "z";
            } else
              p.v = parseFloat(p.v);
            break;
          case "s":
            if (typeof p.v == "undefined") {
              if (!sheetStubs)
                continue;
              p.t = "z";
            } else {
              sstr = strs[parseInt(p.v, 10)];
              p.v = sstr.t;
              p.r = sstr.r;
              if (opts.cellHTML)
                p.h = sstr.h;
            }
            break;
          case "str":
            p.t = "s";
            p.v = p.v != null ? unescapexml(utf8read(p.v), true) : "";
            if (opts.cellHTML)
              p.h = escapehtml(p.v);
            break;
          case "inlineStr":
            cref = d.match(isregex);
            p.t = "s";
            if (cref != null && (sstr = parse_si(cref[1]))) {
              p.v = sstr.t;
              if (opts.cellHTML)
                p.h = sstr.h;
            } else
              p.v = "";
            break;
          case "b":
            p.v = parsexmlbool(p.v);
            break;
          case "d":
            if (opts.cellDates)
              p.v = parseDate(p.v, 1);
            else {
              p.v = datenum(parseDate(p.v, 1));
              p.t = "n";
            }
            break;
          case "e":
            if (!opts || opts.cellText !== false)
              p.w = p.v;
            p.v = RBErr[p.v];
            break;
        }
        fmtid = fillid = 0;
        cf = null;
        if (do_format && tag.s !== void 0) {
          cf = styles2.CellXf[tag.s];
          if (cf != null) {
            if (cf.numFmtId != null)
              fmtid = cf.numFmtId;
            if (opts.cellStyles) {
              if (cf.fillId != null)
                fillid = cf.fillId;
            }
          }
        }
        safe_format(p, fmtid, fillid, opts, themes, styles2);
        if (opts.cellDates && do_format && p.t == "n" && fmt_is_date(table_fmt[fmtid])) {
          p.t = "d";
          p.v = numdate(p.v);
        }
        if (tag.cm && opts.xlmeta) {
          var cm = (opts.xlmeta.Cell || [])[+tag.cm - 1];
          if (cm && cm.type == "XLDAPR")
            p.D = true;
        }
        var _r;
        if (opts.nodim) {
          _r = decode_cell(tag.r);
          if (guess.s.r > _r.r)
            guess.s.r = _r.r;
          if (guess.e.r < _r.r)
            guess.e.r = _r.r;
        }
        if (dense) {
          _r = decode_cell(tag.r);
          if (!s["!data"][_r.r])
            s["!data"][_r.r] = [];
          s["!data"][_r.r][_r.c] = p;
        } else
          s[tag.r] = p;
      }
    }
    if (rows.length > 0)
      s["!rows"] = rows;
  };
}();
function write_ws_xml_data(ws, opts, idx, wb) {
  var o = [], r = [], range = safe_decode_range(ws["!ref"]), cell = "", ref, rr = "", cols = [], R = 0, C = 0, rows = ws["!rows"];
  var dense = ws["!data"] != null;
  var params = { r: rr }, row, height = -1;
  for (C = range.s.c; C <= range.e.c; ++C)
    cols[C] = encode_col(C);
  for (R = range.s.r; R <= range.e.r; ++R) {
    r = [];
    rr = encode_row(R);
    for (C = range.s.c; C <= range.e.c; ++C) {
      ref = cols[C] + rr;
      var _cell = dense ? (ws["!data"][R] || [])[C] : ws[ref];
      if (_cell === void 0)
        continue;
      if ((cell = write_ws_xml_cell(_cell, ref, ws, opts)) != null)
        r.push(cell);
    }
    if (r.length > 0 || rows && rows[R]) {
      params = { r: rr };
      if (rows && rows[R]) {
        row = rows[R];
        if (row.hidden)
          params.hidden = 1;
        height = -1;
        if (row.hpx)
          height = px2pt(row.hpx);
        else if (row.hpt)
          height = row.hpt;
        if (height > -1) {
          params.ht = height;
          params.customHeight = 1;
        }
        if (row.level) {
          params.outlineLevel = row.level;
        }
      }
      o[o.length] = writextag("row", r.join(""), params);
    }
  }
  if (rows)
    for (; R < rows.length; ++R) {
      if (rows && rows[R]) {
        params = { r: R + 1 };
        row = rows[R];
        if (row.hidden)
          params.hidden = 1;
        height = -1;
        if (row.hpx)
          height = px2pt(row.hpx);
        else if (row.hpt)
          height = row.hpt;
        if (height > -1) {
          params.ht = height;
          params.customHeight = 1;
        }
        if (row.level) {
          params.outlineLevel = row.level;
        }
        o[o.length] = writextag("row", "", params);
      }
    }
  return o.join("");
}
function write_ws_xml(idx, opts, wb, rels) {
  var o = [XML_HEADER, writextag("worksheet", null, {
    "xmlns": XMLNS_main[0],
    "xmlns:r": XMLNS.r
  })];
  var s = wb.SheetNames[idx], sidx = 0, rdata = "";
  var ws = wb.Sheets[s];
  if (ws == null)
    ws = {};
  var ref = ws["!ref"] || "A1";
  var range = safe_decode_range(ref);
  if (range.e.c > 16383 || range.e.r > 1048575) {
    if (opts.WTF)
      throw new Error("Range " + ref + " exceeds format limit A1:XFD1048576");
    range.e.c = Math.min(range.e.c, 16383);
    range.e.r = Math.min(range.e.c, 1048575);
    ref = encode_range(range);
  }
  if (!rels)
    rels = {};
  ws["!comments"] = [];
  var _drawing = [];
  write_ws_xml_sheetpr(ws, wb, idx, opts, o);
  o[o.length] = writextag("dimension", null, { "ref": ref });
  o[o.length] = write_ws_xml_sheetviews(ws, opts, idx, wb);
  if (opts.sheetFormat)
    o[o.length] = writextag("sheetFormatPr", null, {
      defaultRowHeight: opts.sheetFormat.defaultRowHeight || "16",
      baseColWidth: opts.sheetFormat.baseColWidth || "10",
      outlineLevelRow: opts.sheetFormat.outlineLevelRow || "7"
    });
  if (ws["!cols"] != null && ws["!cols"].length > 0)
    o[o.length] = write_ws_xml_cols(ws, ws["!cols"]);
  o[sidx = o.length] = "<sheetData/>";
  ws["!links"] = [];
  if (ws["!ref"] != null) {
    rdata = write_ws_xml_data(ws, opts);
    if (rdata.length > 0)
      o[o.length] = rdata;
  }
  if (o.length > sidx + 1) {
    o[o.length] = "</sheetData>";
    o[sidx] = o[sidx].replace("/>", ">");
  }
  if (ws["!protect"])
    o[o.length] = write_ws_xml_protection(ws["!protect"]);
  if (ws["!autofilter"] != null)
    o[o.length] = write_ws_xml_autofilter(ws["!autofilter"], ws, wb, idx);
  if (ws["!merges"] != null && ws["!merges"].length > 0)
    o[o.length] = write_ws_xml_merges(ws["!merges"]);
  var relc = -1, rel, rId = -1;
  if (
    /*::(*/
    ws["!links"].length > 0
  ) {
    o[o.length] = "<hyperlinks>";
    ws["!links"].forEach(function(l) {
      if (!l[1].Target)
        return;
      rel = { "ref": l[0] };
      if (l[1].Target.charAt(0) != "#") {
        rId = add_rels(rels, -1, escapexml(l[1].Target).replace(/#.*$/, ""), RELS.HLINK);
        rel["r:id"] = "rId" + rId;
      }
      if ((relc = l[1].Target.indexOf("#")) > -1)
        rel.location = escapexml(l[1].Target.slice(relc + 1));
      if (l[1].Tooltip)
        rel.tooltip = escapexml(l[1].Tooltip);
      rel.display = l[1].display;
      o[o.length] = writextag("hyperlink", null, rel);
    });
    o[o.length] = "</hyperlinks>";
  }
  delete ws["!links"];
  if (ws["!margins"] != null)
    o[o.length] = write_ws_xml_margins(ws["!margins"]);
  if (!opts || opts.ignoreEC || opts.ignoreEC == void 0)
    o[o.length] = writetag("ignoredErrors", writextag("ignoredError", null, { numberStoredAsText: 1, sqref: ref }));
  if (_drawing.length > 0) {
    rId = add_rels(rels, -1, "../drawings/drawing" + (idx + 1) + ".xml", RELS.DRAW);
    o[o.length] = writextag("drawing", null, { "r:id": "rId" + rId });
    ws["!drawing"] = _drawing;
  }
  if (ws["!comments"].length > 0) {
    rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
    o[o.length] = writextag("legacyDrawing", null, { "r:id": "rId" + rId });
    ws["!legacy"] = rId;
  }
  if (o.length > 1) {
    o[o.length] = "</worksheet>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
function parse_BrtRowHdr(data, length2) {
  var z = {};
  var tgt = data.l + length2;
  z.r = data.read_shift(4);
  data.l += 4;
  var miyRw = data.read_shift(2);
  data.l += 1;
  var flags = data.read_shift(1);
  data.l = tgt;
  if (flags & 7)
    z.level = flags & 7;
  if (flags & 16)
    z.hidden = true;
  if (flags & 32)
    z.hpt = miyRw / 20;
  return z;
}
function write_BrtRowHdr(R, range, ws) {
  var o = new_buf(17 + 8 * 16);
  var row = (ws["!rows"] || [])[R] || {};
  o.write_shift(4, R);
  o.write_shift(4, 0);
  var miyRw = 320;
  if (row.hpx)
    miyRw = px2pt(row.hpx) * 20;
  else if (row.hpt)
    miyRw = row.hpt * 20;
  o.write_shift(2, miyRw);
  o.write_shift(1, 0);
  var flags = 0;
  if (row.level)
    flags |= row.level;
  if (row.hidden)
    flags |= 16;
  if (row.hpx || row.hpt)
    flags |= 32;
  o.write_shift(1, flags);
  o.write_shift(1, 0);
  var ncolspan = 0, lcs = o.l;
  o.l += 4;
  var caddr = { r: R, c: 0 };
  var dense = ws["!data"] != null;
  for (var i = 0; i < 16; ++i) {
    if (range.s.c > i + 1 << 10 || range.e.c < i << 10)
      continue;
    var first = -1, last = -1;
    for (var j = i << 10; j < i + 1 << 10; ++j) {
      caddr.c = j;
      var cell = dense ? (ws["!data"][caddr.r] || [])[caddr.c] : ws[encode_cell(caddr)];
      if (cell) {
        if (first < 0)
          first = j;
        last = j;
      }
    }
    if (first < 0)
      continue;
    ++ncolspan;
    o.write_shift(4, first);
    o.write_shift(4, last);
  }
  var l = o.l;
  o.l = lcs;
  o.write_shift(4, ncolspan);
  o.l = l;
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function write_row_header(ba, ws, range, R) {
  var o = write_BrtRowHdr(R, range, ws);
  if (o.length > 17 || (ws["!rows"] || [])[R])
    write_record(ba, 0, o);
}
var parse_BrtWsDim = parse_UncheckedRfX;
var write_BrtWsDim = write_UncheckedRfX;
function parse_BrtWsFmtInfo() {
}
function parse_BrtWsProp(data, length2) {
  var z = {};
  var f = data[data.l];
  ++data.l;
  z.above = !(f & 64);
  z.left = !(f & 128);
  data.l += 18;
  z.name = parse_XLSBCodeName(data);
  return z;
}
function write_BrtWsProp(str, outl, o) {
  if (o == null)
    o = new_buf(84 + 4 * str.length);
  var f = 192;
  if (outl) {
    if (outl.above)
      f &= ~64;
    if (outl.left)
      f &= ~128;
  }
  o.write_shift(1, f);
  for (var i = 1; i < 3; ++i)
    o.write_shift(1, 0);
  write_BrtColor({ auto: 1 }, o);
  o.write_shift(-4, -1);
  o.write_shift(-4, -1);
  write_XLSBCodeName(str, o);
  return o.slice(0, o.l);
}
function parse_BrtCellBlank(data) {
  var cell = parse_XLSBCell(data);
  return [cell];
}
function write_BrtCellBlank(cell, ncell, o) {
  if (o == null)
    o = new_buf(8);
  return write_XLSBCell(ncell, o);
}
function parse_BrtShortBlank(data) {
  var cell = parse_XLSBShortCell(data);
  return [cell];
}
function write_BrtShortBlank(cell, ncell, o) {
  if (o == null)
    o = new_buf(4);
  return write_XLSBShortCell(ncell, o);
}
function parse_BrtCellBool(data) {
  var cell = parse_XLSBCell(data);
  var fBool = data.read_shift(1);
  return [cell, fBool, "b"];
}
function write_BrtCellBool(cell, ncell, o) {
  if (o == null)
    o = new_buf(9);
  write_XLSBCell(ncell, o);
  o.write_shift(1, cell.v ? 1 : 0);
  return o;
}
function parse_BrtShortBool(data) {
  var cell = parse_XLSBShortCell(data);
  var fBool = data.read_shift(1);
  return [cell, fBool, "b"];
}
function write_BrtShortBool(cell, ncell, o) {
  if (o == null)
    o = new_buf(5);
  write_XLSBShortCell(ncell, o);
  o.write_shift(1, cell.v ? 1 : 0);
  return o;
}
function parse_BrtCellError(data) {
  var cell = parse_XLSBCell(data);
  var bError = data.read_shift(1);
  return [cell, bError, "e"];
}
function write_BrtCellError(cell, ncell, o) {
  if (o == null)
    o = new_buf(9);
  write_XLSBCell(ncell, o);
  o.write_shift(1, cell.v);
  return o;
}
function parse_BrtShortError(data) {
  var cell = parse_XLSBShortCell(data);
  var bError = data.read_shift(1);
  return [cell, bError, "e"];
}
function write_BrtShortError(cell, ncell, o) {
  if (o == null)
    o = new_buf(8);
  write_XLSBShortCell(ncell, o);
  o.write_shift(1, cell.v);
  o.write_shift(2, 0);
  o.write_shift(1, 0);
  return o;
}
function parse_BrtCellIsst(data) {
  var cell = parse_XLSBCell(data);
  var isst = data.read_shift(4);
  return [cell, isst, "s"];
}
function write_BrtCellIsst(cell, ncell, o) {
  if (o == null)
    o = new_buf(12);
  write_XLSBCell(ncell, o);
  o.write_shift(4, ncell.v);
  return o;
}
function parse_BrtShortIsst(data) {
  var cell = parse_XLSBShortCell(data);
  var isst = data.read_shift(4);
  return [cell, isst, "s"];
}
function write_BrtShortIsst(cell, ncell, o) {
  if (o == null)
    o = new_buf(8);
  write_XLSBShortCell(ncell, o);
  o.write_shift(4, ncell.v);
  return o;
}
function parse_BrtCellReal(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_Xnum(data);
  return [cell, value, "n"];
}
function write_BrtCellReal(cell, ncell, o) {
  if (o == null)
    o = new_buf(16);
  write_XLSBCell(ncell, o);
  write_Xnum(cell.v, o);
  return o;
}
function parse_BrtShortReal(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_Xnum(data);
  return [cell, value, "n"];
}
function write_BrtShortReal(cell, ncell, o) {
  if (o == null)
    o = new_buf(12);
  write_XLSBShortCell(ncell, o);
  write_Xnum(cell.v, o);
  return o;
}
function parse_BrtCellRk(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_RkNumber(data);
  return [cell, value, "n"];
}
function write_BrtCellRk(cell, ncell, o) {
  if (o == null)
    o = new_buf(12);
  write_XLSBCell(ncell, o);
  write_RkNumber(cell.v, o);
  return o;
}
function parse_BrtShortRk(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_RkNumber(data);
  return [cell, value, "n"];
}
function write_BrtShortRk(cell, ncell, o) {
  if (o == null)
    o = new_buf(8);
  write_XLSBShortCell(ncell, o);
  write_RkNumber(cell.v, o);
  return o;
}
function parse_BrtCellRString(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_RichStr(data);
  return [cell, value, "is"];
}
function parse_BrtCellSt(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_XLWideString(data);
  return [cell, value, "str"];
}
function write_BrtCellSt(cell, ncell, o) {
  var data = cell.v == null ? "" : String(cell.v);
  if (o == null)
    o = new_buf(12 + 4 * cell.v.length);
  write_XLSBCell(ncell, o);
  write_XLWideString(data, o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function parse_BrtShortSt(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_XLWideString(data);
  return [cell, value, "str"];
}
function write_BrtShortSt(cell, ncell, o) {
  var data = cell.v == null ? "" : String(cell.v);
  if (o == null)
    o = new_buf(8 + 4 * data.length);
  write_XLSBShortCell(ncell, o);
  write_XLWideString(data, o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function parse_BrtFmlaBool(data, length2, opts) {
  var end = data.l + length2;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = data.read_shift(1);
  var o = [cell, value, "b"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else
    data.l = end;
  return o;
}
function parse_BrtFmlaError(data, length2, opts) {
  var end = data.l + length2;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = data.read_shift(1);
  var o = [cell, value, "e"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else
    data.l = end;
  return o;
}
function parse_BrtFmlaNum(data, length2, opts) {
  var end = data.l + length2;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = parse_Xnum(data);
  var o = [cell, value, "n"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else
    data.l = end;
  return o;
}
function parse_BrtFmlaString(data, length2, opts) {
  var end = data.l + length2;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = parse_XLWideString(data);
  var o = [cell, value, "str"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else
    data.l = end;
  return o;
}
var parse_BrtMergeCell = parse_UncheckedRfX;
var write_BrtMergeCell = write_UncheckedRfX;
function write_BrtBeginMergeCells(cnt, o) {
  if (o == null)
    o = new_buf(4);
  o.write_shift(4, cnt);
  return o;
}
function parse_BrtHLink(data, length2) {
  var end = data.l + length2;
  var rfx = parse_UncheckedRfX(data);
  var relId = parse_XLNullableWideString(data);
  var loc = parse_XLWideString(data);
  var tooltip = parse_XLWideString(data);
  var display = parse_XLWideString(data);
  data.l = end;
  var o = { rfx, relId, loc, display };
  if (tooltip)
    o.Tooltip = tooltip;
  return o;
}
function write_BrtHLink(l, rId) {
  var o = new_buf(50 + 4 * (l[1].Target.length + (l[1].Tooltip || "").length));
  write_UncheckedRfX({ s: decode_cell(l[0]), e: decode_cell(l[0]) }, o);
  write_RelID("rId" + rId, o);
  var locidx = l[1].Target.indexOf("#");
  var loc = locidx == -1 ? "" : l[1].Target.slice(locidx + 1);
  write_XLWideString(loc || "", o);
  write_XLWideString(l[1].Tooltip || "", o);
  write_XLWideString("", o);
  return o.slice(0, o.l);
}
function parse_BrtPane() {
}
function parse_BrtArrFmla(data, length2, opts) {
  var end = data.l + length2;
  var rfx = parse_RfX(data);
  var fAlwaysCalc = data.read_shift(1);
  var o = [rfx];
  o[2] = fAlwaysCalc;
  if (opts.cellFormula) {
    var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);
    o[1] = formula;
  } else
    data.l = end;
  return o;
}
function parse_BrtShrFmla(data, length2, opts) {
  var end = data.l + length2;
  var rfx = parse_UncheckedRfX(data);
  var o = [rfx];
  if (opts.cellFormula) {
    var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);
    o[1] = formula;
    data.l = end;
  } else
    data.l = end;
  return o;
}
function write_BrtColInfo(C, col, o) {
  if (o == null)
    o = new_buf(18);
  var p = col_obj_w(C, col);
  o.write_shift(-4, C);
  o.write_shift(-4, C);
  o.write_shift(4, (p.width || 10) * 256);
  o.write_shift(
    4,
    0
    /*ixfe*/
  );
  var flags = 0;
  if (col.hidden)
    flags |= 1;
  if (typeof p.width == "number")
    flags |= 2;
  if (col.level)
    flags |= col.level << 8;
  o.write_shift(2, flags);
  return o;
}
var BrtMarginKeys = ["left", "right", "top", "bottom", "header", "footer"];
function parse_BrtMargins(data) {
  var margins = {};
  BrtMarginKeys.forEach(function(k) {
    margins[k] = parse_Xnum(data);
  });
  return margins;
}
function write_BrtMargins(margins, o) {
  if (o == null)
    o = new_buf(6 * 8);
  default_margins(margins);
  BrtMarginKeys.forEach(function(k) {
    write_Xnum(margins[k], o);
  });
  return o;
}
function parse_BrtBeginWsView(data) {
  var f = data.read_shift(2);
  data.l += 28;
  return { RTL: f & 32 };
}
function write_BrtBeginWsView(ws, Workbook, o) {
  if (o == null)
    o = new_buf(30);
  var f = 924;
  if ((((Workbook || {}).Views || [])[0] || {}).RTL)
    f |= 32;
  o.write_shift(2, f);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  o.write_shift(1, 0);
  o.write_shift(1, 0);
  o.write_shift(2, 0);
  o.write_shift(2, 100);
  o.write_shift(2, 0);
  o.write_shift(2, 0);
  o.write_shift(2, 0);
  o.write_shift(4, 0);
  return o;
}
function write_BrtCellIgnoreEC(ref) {
  var o = new_buf(24);
  o.write_shift(4, 4);
  o.write_shift(4, 1);
  write_UncheckedRfX(ref, o);
  return o;
}
function write_BrtSheetProtection(sp, o) {
  if (o == null)
    o = new_buf(16 * 4 + 2);
  o.write_shift(2, sp.password ? crypto_CreatePasswordVerifier_Method1(sp.password) : 0);
  o.write_shift(4, 1);
  [
    ["objects", false],
    // fObjects
    ["scenarios", false],
    // fScenarios
    ["formatCells", true],
    // fFormatCells
    ["formatColumns", true],
    // fFormatColumns
    ["formatRows", true],
    // fFormatRows
    ["insertColumns", true],
    // fInsertColumns
    ["insertRows", true],
    // fInsertRows
    ["insertHyperlinks", true],
    // fInsertHyperlinks
    ["deleteColumns", true],
    // fDeleteColumns
    ["deleteRows", true],
    // fDeleteRows
    ["selectLockedCells", false],
    // fSelLockedCells
    ["sort", true],
    // fSort
    ["autoFilter", true],
    // fAutoFilter
    ["pivotTables", true],
    // fPivotTables
    ["selectUnlockedCells", false]
    // fSelUnlockedCells
  ].forEach(function(n) {
    if (n[1])
      o.write_shift(4, sp[n[0]] != null && !sp[n[0]] ? 1 : 0);
    else
      o.write_shift(4, sp[n[0]] != null && sp[n[0]] ? 0 : 1);
  });
  return o;
}
function parse_BrtDVal() {
}
function parse_BrtDVal14() {
}
function parse_ws_bin(data, _opts, idx, rels, wb, themes, styles2) {
  if (!data)
    return data;
  var opts = _opts || {};
  if (!rels)
    rels = { "!id": {} };
  var s = {};
  if (opts.dense)
    s["!data"] = [];
  var ref;
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var pass = false, end = false;
  var row, p, cf, R, C, addr, sstr, rr, cell;
  var merges = [];
  opts.biff = 12;
  opts["!row"] = 0;
  var ai = 0, af = false;
  var arrayf = [];
  var sharedf = {};
  var supbooks = opts.supbooks || /*::(*/
  wb.supbooks || [[]];
  supbooks.sharedf = sharedf;
  supbooks.arrayf = arrayf;
  supbooks.SheetNames = wb.SheetNames || wb.Sheets.map(function(x) {
    return x.name;
  });
  if (!opts.supbooks) {
    opts.supbooks = supbooks;
    if (wb.Names)
      for (var i = 0; i < wb.Names.length; ++i)
        supbooks[0][i + 1] = wb.Names[i];
  }
  var colinfo = [], rowinfo = [];
  var seencol = false;
  XLSBRecordEnum[16] = { n: "BrtShortReal", f: parse_BrtShortReal };
  var cm;
  recordhopper(data, function ws_parse(val, RR, RT) {
    if (end)
      return;
    switch (RT) {
      case 148:
        ref = val;
        break;
      case 0:
        row = val;
        if (opts.sheetRows && opts.sheetRows <= row.r)
          end = true;
        rr = encode_row(R = row.r);
        opts["!row"] = row.r;
        if (val.hidden || val.hpt || val.level != null) {
          if (val.hpt)
            val.hpx = pt2px(val.hpt);
          rowinfo[val.r] = val;
        }
        break;
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 62:
        p = { t: val[2] };
        switch (val[2]) {
          case "n":
            p.v = val[1];
            break;
          case "s":
            sstr = strs[val[1]];
            p.v = sstr.t;
            p.r = sstr.r;
            break;
          case "b":
            p.v = val[1] ? true : false;
            break;
          case "e":
            p.v = val[1];
            if (opts.cellText !== false)
              p.w = BErr[p.v];
            break;
          case "str":
            p.t = "s";
            p.v = val[1];
            break;
          case "is":
            p.t = "s";
            p.v = val[1].t;
            break;
        }
        if (cf = styles2.CellXf[val[0].iStyleRef])
          safe_format(p, cf.numFmtId, null, opts, themes, styles2);
        C = val[0].c == -1 ? C + 1 : val[0].c;
        if (opts.dense) {
          if (!s["!data"][R])
            s["!data"][R] = [];
          s["!data"][R][C] = p;
        } else
          s[encode_col(C) + rr] = p;
        if (opts.cellFormula) {
          af = false;
          for (ai = 0; ai < arrayf.length; ++ai) {
            var aii = arrayf[ai];
            if (row.r >= aii[0].s.r && row.r <= aii[0].e.r) {
              if (C >= aii[0].s.c && C <= aii[0].e.c) {
                p.F = encode_range(aii[0]);
                af = true;
              }
            }
          }
          if (!af && val.length > 3)
            p.f = val[3];
        }
        if (refguess.s.r > row.r)
          refguess.s.r = row.r;
        if (refguess.s.c > C)
          refguess.s.c = C;
        if (refguess.e.r < row.r)
          refguess.e.r = row.r;
        if (refguess.e.c < C)
          refguess.e.c = C;
        if (opts.cellDates && cf && p.t == "n" && fmt_is_date(table_fmt[cf.numFmtId])) {
          var _d2 = SSF_parse_date_code(p.v);
          if (_d2) {
            p.t = "d";
            p.v = new Date(_d2.y, _d2.m - 1, _d2.d, _d2.H, _d2.M, _d2.S, _d2.u);
          }
        }
        if (cm) {
          if (cm.type == "XLDAPR")
            p.D = true;
          cm = void 0;
        }
        break;
      case 1:
      case 12:
        if (!opts.sheetStubs || pass)
          break;
        p = { t: "z", v: void 0 };
        C = val[0].c == -1 ? C + 1 : val[0].c;
        if (opts.dense) {
          if (!s["!data"][R])
            s["!data"][R] = [];
          s["!data"][R][C] = p;
        } else
          s[encode_col(C) + rr] = p;
        if (refguess.s.r > row.r)
          refguess.s.r = row.r;
        if (refguess.s.c > C)
          refguess.s.c = C;
        if (refguess.e.r < row.r)
          refguess.e.r = row.r;
        if (refguess.e.c < C)
          refguess.e.c = C;
        if (cm) {
          if (cm.type == "XLDAPR")
            p.D = true;
          cm = void 0;
        }
        break;
      case 176:
        merges.push(val);
        break;
      case 49:
        {
          cm = ((opts.xlmeta || {}).Cell || [])[val - 1];
        }
        break;
      case 494:
        var rel = rels["!id"][val.relId];
        if (rel) {
          val.Target = rel.Target;
          if (val.loc)
            val.Target += "#" + val.loc;
          val.Rel = rel;
        } else if (val.relId == "") {
          val.Target = "#" + val.loc;
        }
        for (R = val.rfx.s.r; R <= val.rfx.e.r; ++R)
          for (C = val.rfx.s.c; C <= val.rfx.e.c; ++C) {
            if (opts.dense) {
              if (!s["!data"][R])
                s["!data"][R] = [];
              if (!s["!data"][R][C])
                s["!data"][R][C] = { t: "z", v: void 0 };
              s["!data"][R][C].l = val;
            } else {
              addr = encode_col(C) + encode_row(R);
              if (!s[addr])
                s[addr] = { t: "z", v: void 0 };
              s[addr].l = val;
            }
          }
        break;
      case 426:
        if (!opts.cellFormula)
          break;
        arrayf.push(val);
        cell = opts.dense ? s["!data"][R][C] : s[encode_col(C) + rr];
        cell.f = stringify_formula(val[1], refguess, { r: row.r, c: C }, supbooks, opts);
        cell.F = encode_range(val[0]);
        break;
      case 427:
        if (!opts.cellFormula)
          break;
        sharedf[encode_cell(val[0].s)] = val[1];
        cell = opts.dense ? s["!data"][R][C] : s[encode_col(C) + rr];
        cell.f = stringify_formula(val[1], refguess, { r: row.r, c: C }, supbooks, opts);
        break;
      case 60:
        if (!opts.cellStyles)
          break;
        while (val.e >= val.s) {
          colinfo[val.e--] = { width: val.w / 256, hidden: !!(val.flags & 1), level: val.level };
          if (!seencol) {
            seencol = true;
            find_mdw_colw(val.w / 256);
          }
          process_col(colinfo[val.e + 1]);
        }
        break;
      case 161:
        s["!autofilter"] = { ref: encode_range(val) };
        break;
      case 476:
        s["!margins"] = val;
        break;
      case 147:
        if (!wb.Sheets[idx])
          wb.Sheets[idx] = {};
        if (val.name)
          wb.Sheets[idx].CodeName = val.name;
        if (val.above || val.left)
          s["!outline"] = { above: val.above, left: val.left };
        break;
      case 137:
        if (!wb.Views)
          wb.Views = [{}];
        if (!wb.Views[0])
          wb.Views[0] = {};
        if (val.RTL)
          wb.Views[0].RTL = true;
        break;
      case 485:
        break;
      case 64:
      case 1053:
        break;
      case 151:
        break;
      case 152:
      case 175:
      case 644:
      case 625:
      case 562:
      case 396:
      case 1112:
      case 1146:
      case 471:
      case 1050:
      case 649:
      case 1105:
      case 589:
      case 607:
      case 564:
      case 1055:
      case 168:
      case 174:
      case 1180:
      case 499:
      case 507:
      case 550:
      case 171:
      case 167:
      case 1177:
      case 169:
      case 1181:
      case 551:
      case 552:
      case 661:
      case 639:
      case 478:
      case 537:
      case 477:
      case 536:
      case 1103:
      case 680:
      case 1104:
      case 1024:
      case 663:
      case 535:
      case 678:
      case 504:
      case 1043:
      case 428:
      case 170:
      case 3072:
      case 50:
      case 2070:
      case 1045:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        pass = true;
        break;
      case 38:
        pass = false;
        break;
      default:
        if (RR.T)
          ;
        else if (!pass || opts.WTF)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  delete opts.supbooks;
  delete opts["!row"];
  if (!s["!ref"] && (refguess.s.r < 2e6 || ref && (ref.e.r > 0 || ref.e.c > 0 || ref.s.r > 0 || ref.s.c > 0)))
    s["!ref"] = encode_range(ref || refguess);
  if (opts.sheetRows && s["!ref"]) {
    var tmpref = safe_decode_range(s["!ref"]);
    if (opts.sheetRows <= +tmpref.e.r) {
      tmpref.e.r = opts.sheetRows - 1;
      if (tmpref.e.r > refguess.e.r)
        tmpref.e.r = refguess.e.r;
      if (tmpref.e.r < tmpref.s.r)
        tmpref.s.r = tmpref.e.r;
      if (tmpref.e.c > refguess.e.c)
        tmpref.e.c = refguess.e.c;
      if (tmpref.e.c < tmpref.s.c)
        tmpref.s.c = tmpref.e.c;
      s["!fullref"] = s["!ref"];
      s["!ref"] = encode_range(tmpref);
    }
  }
  if (merges.length > 0)
    s["!merges"] = merges;
  if (colinfo.length > 0)
    s["!cols"] = colinfo;
  if (rowinfo.length > 0)
    s["!rows"] = rowinfo;
  return s;
}
function write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen) {
  var o = { r: R, c: C };
  if (cell.c)
    ws["!comments"].push([encode_cell(o), cell.c]);
  if (cell.v === void 0)
    return false;
  var vv = "";
  switch (cell.t) {
    case "b":
      vv = cell.v ? "1" : "0";
      break;
    case "d":
      cell = dup(cell);
      cell.z = cell.z || table_fmt[14];
      cell.v = datenum(parseDate(cell.v));
      cell.t = "n";
      break;
    case "n":
    case "e":
      vv = "" + cell.v;
      break;
    default:
      vv = cell.v;
      break;
  }
  o.s = get_cell_style(opts.cellXfs, cell, opts);
  if (cell.l)
    ws["!links"].push([encode_cell(o), cell.l]);
  switch (cell.t) {
    case "s":
    case "str":
      if (opts.bookSST) {
        vv = get_sst_id(opts.Strings, cell.v == null ? "" : String(cell.v), opts.revStrings);
        o.t = "s";
        o.v = vv;
        if (last_seen)
          write_record(ba, 18, write_BrtShortIsst(cell, o));
        else
          write_record(ba, 7, write_BrtCellIsst(cell, o));
      } else {
        o.t = "str";
        if (last_seen)
          write_record(ba, 17, write_BrtShortSt(cell, o));
        else
          write_record(ba, 6, write_BrtCellSt(cell, o));
      }
      return true;
    case "n":
      if (cell.v == (cell.v | 0) && cell.v > -1e3 && cell.v < 1e3) {
        if (last_seen)
          write_record(ba, 13, write_BrtShortRk(cell, o));
        else
          write_record(ba, 2, write_BrtCellRk(cell, o));
      } else {
        if (last_seen)
          write_record(ba, 16, write_BrtShortReal(cell, o));
        else
          write_record(ba, 5, write_BrtCellReal(cell, o));
      }
      return true;
    case "b":
      o.t = "b";
      if (last_seen)
        write_record(ba, 15, write_BrtShortBool(cell, o));
      else
        write_record(ba, 4, write_BrtCellBool(cell, o));
      return true;
    case "e":
      o.t = "e";
      if (last_seen)
        write_record(ba, 14, write_BrtShortError(cell, o));
      else
        write_record(ba, 3, write_BrtCellError(cell, o));
      return true;
  }
  if (last_seen)
    write_record(ba, 12, write_BrtShortBlank(cell, o));
  else
    write_record(ba, 1, write_BrtCellBlank(cell, o));
  return true;
}
function write_CELLTABLE(ba, ws, idx, opts) {
  var range = safe_decode_range(ws["!ref"] || "A1"), ref, rr = "", cols = [];
  write_record(
    ba,
    145
    /* BrtBeginSheetData */
  );
  var dense = ws["!data"] != null;
  var cap = range.e.r;
  if (ws["!rows"])
    cap = Math.max(range.e.r, ws["!rows"].length - 1);
  for (var R = range.s.r; R <= cap; ++R) {
    rr = encode_row(R);
    write_row_header(ba, ws, range, R);
    var last_seen = false;
    if (R <= range.e.r)
      for (var C = range.s.c; C <= range.e.c; ++C) {
        if (R === range.s.r)
          cols[C] = encode_col(C);
        ref = cols[C] + rr;
        var cell = dense ? (ws["!data"][R] || [])[C] : ws[ref];
        if (!cell) {
          last_seen = false;
          continue;
        }
        last_seen = write_ws_bin_cell(ba, cell, R, C, opts, ws, last_seen);
      }
  }
  write_record(
    ba,
    146
    /* BrtEndSheetData */
  );
}
function write_MERGECELLS(ba, ws) {
  if (!ws || !ws["!merges"])
    return;
  write_record(ba, 177, write_BrtBeginMergeCells(ws["!merges"].length));
  ws["!merges"].forEach(function(m) {
    write_record(ba, 176, write_BrtMergeCell(m));
  });
  write_record(
    ba,
    178
    /* BrtEndMergeCells */
  );
}
function write_COLINFOS(ba, ws) {
  if (!ws || !ws["!cols"])
    return;
  write_record(
    ba,
    390
    /* BrtBeginColInfos */
  );
  ws["!cols"].forEach(function(m, i) {
    if (m)
      write_record(ba, 60, write_BrtColInfo(i, m));
  });
  write_record(
    ba,
    391
    /* BrtEndColInfos */
  );
}
function write_IGNOREECS(ba, ws) {
  if (!ws || !ws["!ref"])
    return;
  write_record(
    ba,
    648
    /* BrtBeginCellIgnoreECs */
  );
  write_record(ba, 649, write_BrtCellIgnoreEC(safe_decode_range(ws["!ref"])));
  write_record(
    ba,
    650
    /* BrtEndCellIgnoreECs */
  );
}
function write_HLINKS(ba, ws, rels) {
  ws["!links"].forEach(function(l) {
    if (!l[1].Target)
      return;
    var rId = add_rels(rels, -1, l[1].Target.replace(/#.*$/, ""), RELS.HLINK);
    write_record(ba, 494, write_BrtHLink(l, rId));
  });
  delete ws["!links"];
}
function write_LEGACYDRAWING(ba, ws, idx, rels) {
  if (ws["!comments"].length > 0) {
    var rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
    write_record(ba, 551, write_RelID("rId" + rId));
    ws["!legacy"] = rId;
  }
}
function write_AUTOFILTER(ba, ws, wb, idx) {
  if (!ws["!autofilter"])
    return;
  var data = ws["!autofilter"];
  var ref = typeof data.ref === "string" ? data.ref : encode_range(data.ref);
  if (!wb.Workbook)
    wb.Workbook = { Sheets: [] };
  if (!wb.Workbook.Names)
    wb.Workbook.Names = [];
  var names = wb.Workbook.Names;
  var range = decode_range(ref);
  if (range.s.r == range.e.r) {
    range.e.r = decode_range(ws["!ref"]).e.r;
    ref = encode_range(range);
  }
  for (var i = 0; i < names.length; ++i) {
    var name = names[i];
    if (name.Name != "_xlnm._FilterDatabase")
      continue;
    if (name.Sheet != idx)
      continue;
    name.Ref = formula_quote_sheet_name(wb.SheetNames[idx]) + "!" + fix_range(ref);
    break;
  }
  if (i == names.length)
    names.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: formula_quote_sheet_name(wb.SheetNames[idx]) + "!" + fix_range(ref) });
  write_record(ba, 161, write_UncheckedRfX(safe_decode_range(ref)));
  write_record(
    ba,
    162
    /* BrtEndAFilter */
  );
}
function write_WSVIEWS2(ba, ws, Workbook) {
  write_record(
    ba,
    133
    /* BrtBeginWsViews */
  );
  {
    write_record(ba, 137, write_BrtBeginWsView(ws, Workbook));
    write_record(
      ba,
      138
      /* BrtEndWsView */
    );
  }
  write_record(
    ba,
    134
    /* BrtEndWsViews */
  );
}
function write_SHEETPROTECT(ba, ws) {
  if (!ws["!protect"])
    return;
  write_record(ba, 535, write_BrtSheetProtection(ws["!protect"]));
}
function write_ws_bin(idx, opts, wb, rels) {
  var ba = buf_array();
  var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
  var c = s;
  try {
    if (wb && wb.Workbook)
      c = wb.Workbook.Sheets[idx].CodeName || c;
  } catch (e) {
  }
  var r = safe_decode_range(ws["!ref"] || "A1");
  if (r.e.c > 16383 || r.e.r > 1048575) {
    if (opts.WTF)
      throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
    r.e.c = Math.min(r.e.c, 16383);
    r.e.r = Math.min(r.e.c, 1048575);
  }
  ws["!links"] = [];
  ws["!comments"] = [];
  write_record(
    ba,
    129
    /* BrtBeginSheet */
  );
  if (wb.vbaraw || ws["!outline"])
    write_record(ba, 147, write_BrtWsProp(c, ws["!outline"]));
  write_record(ba, 148, write_BrtWsDim(r));
  write_WSVIEWS2(ba, ws, wb.Workbook);
  write_COLINFOS(ba, ws);
  write_CELLTABLE(ba, ws, idx, opts);
  write_SHEETPROTECT(ba, ws);
  write_AUTOFILTER(ba, ws, wb, idx);
  write_MERGECELLS(ba, ws);
  write_HLINKS(ba, ws, rels);
  if (ws["!margins"])
    write_record(ba, 476, write_BrtMargins(ws["!margins"]));
  if (!opts || opts.ignoreEC || opts.ignoreEC == void 0)
    write_IGNOREECS(ba, ws);
  write_LEGACYDRAWING(ba, ws, idx, rels);
  write_record(
    ba,
    130
    /* BrtEndSheet */
  );
  return ba.end();
}
function parse_Cache(data) {
  var col = [];
  var num = data.match(/^<c:numCache>/);
  var f;
  (data.match(/<c:pt idx="(\d*)">(.*?)<\/c:pt>/mg) || []).forEach(function(pt) {
    var q = pt.match(/<c:pt idx="(\d*?)"><c:v>(.*)<\/c:v><\/c:pt>/);
    if (!q)
      return;
    col[+q[1]] = num ? +q[2] : q[2];
  });
  var nf = unescapexml((data.match(/<c:formatCode>([\s\S]*?)<\/c:formatCode>/) || ["", "General"])[1]);
  (data.match(/<c:f>(.*?)<\/c:f>/mg) || []).forEach(function(F) {
    f = F.replace(/<.*?>/g, "");
  });
  return [col, nf, f];
}
function parse_chart(data, name, opts, rels, wb, csheet) {
  var cs = csheet || { "!type": "chart" };
  if (!data)
    return csheet;
  var C = 0, R = 0, col = "A";
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  (data.match(/<c:numCache>[\s\S]*?<\/c:numCache>/gm) || []).forEach(function(nc) {
    var cache = parse_Cache(nc);
    refguess.s.r = refguess.s.c = 0;
    refguess.e.c = C;
    col = encode_col(C);
    cache[0].forEach(function(n, i) {
      if (cs["!data"]) {
        if (!cs["!data"][i])
          cs["!data"][i] = [];
        cs["!data"][i][C] = { t: "n", v: n, z: cache[1] };
      } else
        cs[col + encode_row(i)] = { t: "n", v: n, z: cache[1] };
      R = i;
    });
    if (refguess.e.r < R)
      refguess.e.r = R;
    ++C;
  });
  if (C > 0)
    cs["!ref"] = encode_range(refguess);
  return cs;
}
function parse_cs_xml(data, opts, idx, rels, wb) {
  if (!data)
    return data;
  if (!rels)
    rels = { "!id": {} };
  var s = { "!type": "chart", "!drawel": null, "!rel": "" };
  var m;
  var sheetPr = data.match(sheetprregex);
  if (sheetPr)
    parse_ws_xml_sheetpr(sheetPr[0], s, wb, idx);
  if (m = data.match(/drawing r:id="(.*?)"/))
    s["!rel"] = m[1];
  if (rels["!id"][s["!rel"]])
    s["!drawel"] = rels["!id"][s["!rel"]];
  return s;
}
function parse_BrtCsProp(data, length2) {
  data.l += 10;
  var name = parse_XLWideString(data);
  return { name };
}
function parse_cs_bin(data, opts, idx, rels, wb) {
  if (!data)
    return data;
  if (!rels)
    rels = { "!id": {} };
  var s = { "!type": "chart", "!drawel": null, "!rel": "" };
  var pass = false;
  recordhopper(data, function cs_parse(val, R, RT) {
    switch (RT) {
      case 550:
        s["!rel"] = val;
        break;
      case 651:
        if (!wb.Sheets[idx])
          wb.Sheets[idx] = {};
        if (val.name)
          wb.Sheets[idx].CodeName = val.name;
        break;
      case 562:
      case 652:
      case 669:
      case 679:
      case 551:
      case 552:
      case 476:
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (R.T > 0)
          ;
        else if (R.T < 0)
          ;
        else if (!pass || opts.WTF)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  if (rels["!id"][s["!rel"]])
    s["!drawel"] = rels["!id"][s["!rel"]];
  return s;
}
var WBPropsDef = [
  ["allowRefreshQuery", false, "bool"],
  ["autoCompressPictures", true, "bool"],
  ["backupFile", false, "bool"],
  ["checkCompatibility", false, "bool"],
  ["CodeName", ""],
  ["date1904", false, "bool"],
  ["defaultThemeVersion", 0, "int"],
  ["filterPrivacy", false, "bool"],
  ["hidePivotFieldList", false, "bool"],
  ["promptedSolutions", false, "bool"],
  ["publishItems", false, "bool"],
  ["refreshAllConnections", false, "bool"],
  ["saveExternalLinkValues", true, "bool"],
  ["showBorderUnselectedTables", true, "bool"],
  ["showInkAnnotation", true, "bool"],
  ["showObjects", "all"],
  ["showPivotChartFilter", false, "bool"],
  ["updateLinks", "userSet"]
];
var WBViewDef = [
  ["activeTab", 0, "int"],
  ["autoFilterDateGrouping", true, "bool"],
  ["firstSheet", 0, "int"],
  ["minimized", false, "bool"],
  ["showHorizontalScroll", true, "bool"],
  ["showSheetTabs", true, "bool"],
  ["showVerticalScroll", true, "bool"],
  ["tabRatio", 600, "int"],
  ["visibility", "visible"]
  //window{Height,Width}, {x,y}Window
];
var SheetDef = [
  //['state', 'visible']
];
var CalcPrDef = [
  ["calcCompleted", "true"],
  ["calcMode", "auto"],
  ["calcOnSave", "true"],
  ["concurrentCalc", "true"],
  ["fullCalcOnLoad", "false"],
  ["fullPrecision", "true"],
  ["iterate", "false"],
  ["iterateCount", "100"],
  ["iterateDelta", "0.001"],
  ["refMode", "A1"]
];
function push_defaults_array(target, defaults) {
  for (var j = 0; j != target.length; ++j) {
    var w2 = target[j];
    for (var i = 0; i != defaults.length; ++i) {
      var z = defaults[i];
      if (w2[z[0]] == null)
        w2[z[0]] = z[1];
      else
        switch (z[2]) {
          case "bool":
            if (typeof w2[z[0]] == "string")
              w2[z[0]] = parsexmlbool(w2[z[0]]);
            break;
          case "int":
            if (typeof w2[z[0]] == "string")
              w2[z[0]] = parseInt(w2[z[0]], 10);
            break;
        }
    }
  }
}
function push_defaults(target, defaults) {
  for (var i = 0; i != defaults.length; ++i) {
    var z = defaults[i];
    if (target[z[0]] == null)
      target[z[0]] = z[1];
    else
      switch (z[2]) {
        case "bool":
          if (typeof target[z[0]] == "string")
            target[z[0]] = parsexmlbool(target[z[0]]);
          break;
        case "int":
          if (typeof target[z[0]] == "string")
            target[z[0]] = parseInt(target[z[0]], 10);
          break;
      }
  }
}
function parse_wb_defaults(wb) {
  push_defaults(wb.WBProps, WBPropsDef);
  push_defaults(wb.CalcPr, CalcPrDef);
  push_defaults_array(wb.WBView, WBViewDef);
  push_defaults_array(wb.Sheets, SheetDef);
  _ssfopts.date1904 = parsexmlbool(wb.WBProps.date1904);
}
function safe1904(wb) {
  if (!wb.Workbook)
    return "false";
  if (!wb.Workbook.WBProps)
    return "false";
  return parsexmlbool(wb.Workbook.WBProps.date1904) ? "true" : "false";
}
var badchars = /* @__PURE__ */ ":][*?/\\".split("");
function check_ws_name(n, safe) {
  try {
    if (n == "")
      throw new Error("Sheet name cannot be blank");
    if (n.length > 31)
      throw new Error("Sheet name cannot exceed 31 chars");
    if (n.charCodeAt(0) == 39 || n.charCodeAt(n.length - 1) == 39)
      throw new Error("Sheet name cannot start or end with apostrophe (')");
    if (n.toLowerCase() == "history")
      throw new Error("Sheet name cannot be 'History'");
    badchars.forEach(function(c) {
      if (n.indexOf(c) == -1)
        return;
      throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
    });
  } catch (e) {
    if (safe)
      return false;
    throw e;
  }
  return true;
}
function check_wb_names(N, S, codes) {
  N.forEach(function(n, i) {
    check_ws_name(n);
    for (var j = 0; j < i; ++j)
      if (n == N[j])
        throw new Error("Duplicate Sheet Name: " + n);
    if (codes) {
      var cn = S && S[i] && S[i].CodeName || n;
      if (cn.charCodeAt(0) == 95 && cn.length > 22)
        throw new Error("Bad Code Name: Worksheet" + cn);
    }
  });
}
function check_wb(wb) {
  if (!wb || !wb.SheetNames || !wb.Sheets)
    throw new Error("Invalid Workbook");
  if (!wb.SheetNames.length)
    throw new Error("Workbook is empty");
  var Sheets = wb.Workbook && wb.Workbook.Sheets || [];
  check_wb_names(wb.SheetNames, Sheets, !!wb.vbaraw);
  for (var i = 0; i < wb.SheetNames.length; ++i)
    check_ws(wb.Sheets[wb.SheetNames[i]], wb.SheetNames[i], i);
  wb.SheetNames.forEach(function(n, i2) {
    var ws = wb.Sheets[n];
    if (!ws || !ws["!autofilter"])
      return;
    var DN;
    if (!wb.Workbook)
      wb.Workbook = {};
    if (!wb.Workbook.Names)
      wb.Workbook.Names = [];
    wb.Workbook.Names.forEach(function(dn) {
      if (dn.Name == "_xlnm._FilterDatabase" && dn.Sheet == i2)
        DN = dn;
    });
    var nn = formula_quote_sheet_name(n) + "!" + fix_range(ws["!autofilter"].ref);
    if (DN)
      DN.Ref = nn;
    else
      wb.Workbook.Names.push({ Name: "_xlnm._FilterDatabase", Sheet: i2, Ref: nn });
  });
}
var wbnsregex = /<\w+:workbook/;
function parse_wb_xml(data, opts) {
  if (!data)
    throw new Error("Could not find file");
  var wb = (
    /*::(*/
    { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, Names: [], xmlns: "" }
  );
  var pass = false, xmlns = "xmlns";
  var dname = {}, dnstart = 0;
  data.replace(tagregex, function xml_wb(x, idx) {
    var y = parsexmltag(x);
    switch (strip_ns(y[0])) {
      case "<?xml":
        break;
      case "<workbook":
        if (x.match(wbnsregex))
          xmlns = "xmlns" + x.match(/<(\w+):/)[1];
        wb.xmlns = y[xmlns];
        break;
      case "</workbook>":
        break;
      case "<fileVersion":
        delete y[0];
        wb.AppVersion = y;
        break;
      case "<fileVersion/>":
      case "</fileVersion>":
        break;
      case "<fileSharing":
        break;
      case "<fileSharing/>":
        break;
      case "<workbookPr":
      case "<workbookPr/>":
        WBPropsDef.forEach(function(w2) {
          if (y[w2[0]] == null)
            return;
          switch (w2[2]) {
            case "bool":
              wb.WBProps[w2[0]] = parsexmlbool(y[w2[0]]);
              break;
            case "int":
              wb.WBProps[w2[0]] = parseInt(y[w2[0]], 10);
              break;
            default:
              wb.WBProps[w2[0]] = y[w2[0]];
          }
        });
        if (y.codeName)
          wb.WBProps.CodeName = utf8read(y.codeName);
        break;
      case "</workbookPr>":
        break;
      case "<workbookProtection":
        break;
      case "<workbookProtection/>":
        break;
      case "<bookViews":
      case "<bookViews>":
      case "</bookViews>":
        break;
      case "<workbookView":
      case "<workbookView/>":
        delete y[0];
        wb.WBView.push(y);
        break;
      case "</workbookView>":
        break;
      case "<sheets":
      case "<sheets>":
      case "</sheets>":
        break;
      case "<sheet":
        switch (y.state) {
          case "hidden":
            y.Hidden = 1;
            break;
          case "veryHidden":
            y.Hidden = 2;
            break;
          default:
            y.Hidden = 0;
        }
        delete y.state;
        y.name = unescapexml(utf8read(y.name));
        delete y[0];
        wb.Sheets.push(y);
        break;
      case "</sheet>":
        break;
      case "<functionGroups":
      case "<functionGroups/>":
        break;
      case "<functionGroup":
        break;
      case "<externalReferences":
      case "</externalReferences>":
      case "<externalReferences>":
        break;
      case "<externalReference":
        break;
      case "<definedNames/>":
        break;
      case "<definedNames>":
      case "<definedNames":
        pass = true;
        break;
      case "</definedNames>":
        pass = false;
        break;
      case "<definedName":
        {
          dname = {};
          dname.Name = utf8read(y.name);
          if (y.comment)
            dname.Comment = y.comment;
          if (y.localSheetId)
            dname.Sheet = +y.localSheetId;
          if (parsexmlbool(y.hidden || "0"))
            dname.Hidden = true;
          dnstart = idx + x.length;
        }
        break;
      case "</definedName>":
        {
          dname.Ref = unescapexml(utf8read(data.slice(dnstart, idx)));
          wb.Names.push(dname);
        }
        break;
      case "<definedName/>":
        break;
      case "<calcPr":
        delete y[0];
        wb.CalcPr = y;
        break;
      case "<calcPr/>":
        delete y[0];
        wb.CalcPr = y;
        break;
      case "</calcPr>":
        break;
      case "<oleSize":
        break;
      case "<customWorkbookViews>":
      case "</customWorkbookViews>":
      case "<customWorkbookViews":
        break;
      case "<customWorkbookView":
      case "</customWorkbookView>":
        break;
      case "<pivotCaches>":
      case "</pivotCaches>":
      case "<pivotCaches":
        break;
      case "<pivotCache":
        break;
      case "<smartTagPr":
      case "<smartTagPr/>":
        break;
      case "<smartTagTypes":
      case "<smartTagTypes>":
      case "</smartTagTypes>":
        break;
      case "<smartTagType":
        break;
      case "<webPublishing":
      case "<webPublishing/>":
        break;
      case "<fileRecoveryPr":
      case "<fileRecoveryPr/>":
        break;
      case "<webPublishObjects>":
      case "<webPublishObjects":
      case "</webPublishObjects>":
        break;
      case "<webPublishObject":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      case "<ArchID":
        break;
      case "<AlternateContent":
      case "<AlternateContent>":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      case "<revisionPtr":
        break;
      default:
        if (!pass && opts.WTF)
          throw new Error("unrecognized " + y[0] + " in workbook");
    }
    return x;
  });
  if (XMLNS_main.indexOf(wb.xmlns) === -1)
    throw new Error("Unknown Namespace: " + wb.xmlns);
  parse_wb_defaults(wb);
  return wb;
}
function write_wb_xml(wb) {
  var o = [XML_HEADER];
  o[o.length] = writextag("workbook", null, {
    "xmlns": XMLNS_main[0],
    //'xmlns:mx': XMLNS.mx,
    //'xmlns:s': XMLNS_main[0],
    "xmlns:r": XMLNS.r
  });
  var write_names = wb.Workbook && (wb.Workbook.Names || []).length > 0;
  var workbookPr = { codeName: "ThisWorkbook" };
  if (wb.Workbook && wb.Workbook.WBProps) {
    WBPropsDef.forEach(function(x) {
      if (wb.Workbook.WBProps[x[0]] == null)
        return;
      if (wb.Workbook.WBProps[x[0]] == x[1])
        return;
      workbookPr[x[0]] = wb.Workbook.WBProps[x[0]];
    });
    if (wb.Workbook.WBProps.CodeName) {
      workbookPr.codeName = wb.Workbook.WBProps.CodeName;
      delete workbookPr.CodeName;
    }
  }
  o[o.length] = writextag("workbookPr", null, workbookPr);
  var sheets = wb.Workbook && wb.Workbook.Sheets || [];
  var i = 0;
  if (sheets && sheets[0] && !!sheets[0].Hidden) {
    o[o.length] = "<bookViews>";
    for (i = 0; i != wb.SheetNames.length; ++i) {
      if (!sheets[i])
        break;
      if (!sheets[i].Hidden)
        break;
    }
    if (i == wb.SheetNames.length)
      i = 0;
    o[o.length] = '<workbookView firstSheet="' + i + '" activeTab="' + i + '"/>';
    o[o.length] = "</bookViews>";
  }
  o[o.length] = "<sheets>";
  for (i = 0; i != wb.SheetNames.length; ++i) {
    var sht = { name: escapexml(wb.SheetNames[i].slice(0, 31)) };
    sht.sheetId = "" + (i + 1);
    sht["r:id"] = "rId" + (i + 1);
    if (sheets[i])
      switch (sheets[i].Hidden) {
        case 1:
          sht.state = "hidden";
          break;
        case 2:
          sht.state = "veryHidden";
          break;
      }
    o[o.length] = writextag("sheet", null, sht);
  }
  o[o.length] = "</sheets>";
  if (write_names) {
    o[o.length] = "<definedNames>";
    if (wb.Workbook && wb.Workbook.Names)
      wb.Workbook.Names.forEach(function(n) {
        var d = { name: n.Name };
        if (n.Comment)
          d.comment = n.Comment;
        if (n.Sheet != null)
          d.localSheetId = "" + n.Sheet;
        if (n.Hidden)
          d.hidden = "1";
        if (!n.Ref)
          return;
        o[o.length] = writextag("definedName", escapexml(n.Ref), d);
      });
    o[o.length] = "</definedNames>";
  }
  if (o.length > 2) {
    o[o.length] = "</workbook>";
    o[1] = o[1].replace("/>", ">");
  }
  return o.join("");
}
function parse_BrtBundleSh(data, length2) {
  var z = {};
  z.Hidden = data.read_shift(4);
  z.iTabID = data.read_shift(4);
  z.strRelID = parse_RelID(data);
  z.name = parse_XLWideString(data);
  return z;
}
function write_BrtBundleSh(data, o) {
  if (!o)
    o = new_buf(127);
  o.write_shift(4, data.Hidden);
  o.write_shift(4, data.iTabID);
  write_RelID(data.strRelID, o);
  write_XLWideString(data.name.slice(0, 31), o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function parse_BrtWbProp(data, length2) {
  var o = {};
  var flags = data.read_shift(4);
  o.defaultThemeVersion = data.read_shift(4);
  var strName = length2 > 8 ? parse_XLWideString(data) : "";
  if (strName.length > 0)
    o.CodeName = strName;
  o.autoCompressPictures = !!(flags & 65536);
  o.backupFile = !!(flags & 64);
  o.checkCompatibility = !!(flags & 4096);
  o.date1904 = !!(flags & 1);
  o.filterPrivacy = !!(flags & 8);
  o.hidePivotFieldList = !!(flags & 1024);
  o.promptedSolutions = !!(flags & 16);
  o.publishItems = !!(flags & 2048);
  o.refreshAllConnections = !!(flags & 262144);
  o.saveExternalLinkValues = !!(flags & 128);
  o.showBorderUnselectedTables = !!(flags & 4);
  o.showInkAnnotation = !!(flags & 32);
  o.showObjects = ["all", "placeholders", "none"][flags >> 13 & 3];
  o.showPivotChartFilter = !!(flags & 32768);
  o.updateLinks = ["userSet", "never", "always"][flags >> 8 & 3];
  return o;
}
function write_BrtWbProp(data, o) {
  if (!o)
    o = new_buf(72);
  var flags = 0;
  if (data) {
    if (data.date1904)
      flags |= 1;
    if (data.filterPrivacy)
      flags |= 8;
  }
  o.write_shift(4, flags);
  o.write_shift(4, 0);
  write_XLSBCodeName(data && data.CodeName || "ThisWorkbook", o);
  return o.slice(0, o.l);
}
function parse_BrtFRTArchID$(data, length2) {
  var o = {};
  data.read_shift(4);
  o.ArchID = data.read_shift(4);
  data.l += length2 - 8;
  return o;
}
function parse_BrtName(data, length2, opts) {
  var end = data.l + length2;
  var flags = data.read_shift(4);
  data.l += 1;
  var itab = data.read_shift(4);
  var name = parse_XLNameWideString(data);
  var formula = parse_XLSBNameParsedFormula(data, 0, opts);
  var comment2 = parse_XLNullableWideString(data);
  if (flags & 32)
    name = "_xlnm." + name;
  data.l = end;
  var out = { Name: name, Ptg: formula, Flags: flags };
  if (itab < 268435455)
    out.Sheet = itab;
  if (comment2)
    out.Comment = comment2;
  return out;
}
function write_BrtName(name, wb) {
  var o = new_buf(9);
  var flags = 0;
  var dname = name.Name;
  if (XLSLblBuiltIn.indexOf(dname) > -1) {
    flags |= 32;
    dname = dname.slice(6);
  }
  o.write_shift(4, flags);
  o.write_shift(1, 0);
  o.write_shift(4, name.Sheet == null ? 4294967295 : name.Sheet);
  var arr = [
    o,
    write_XLWideString(dname),
    write_XLSBNameParsedFormula(name.Ref, wb)
  ];
  if (name.Comment)
    arr.push(write_XLNullableWideString(name.Comment));
  else {
    var x = new_buf(4);
    x.write_shift(4, 4294967295);
    arr.push(x);
  }
  return bconcat(arr);
}
function parse_wb_bin(data, opts) {
  var wb = { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, xmlns: "" };
  var state = [];
  var pass = false;
  if (!opts)
    opts = {};
  opts.biff = 12;
  var Names = [];
  var supbooks = [[]];
  supbooks.SheetNames = [];
  supbooks.XTI = [];
  XLSBRecordEnum[16] = { n: "BrtFRTArchID$", f: parse_BrtFRTArchID$ };
  recordhopper(data, function hopper_wb(val, R, RT) {
    switch (RT) {
      case 156:
        supbooks.SheetNames.push(val.name);
        wb.Sheets.push(val);
        break;
      case 153:
        wb.WBProps = val;
        break;
      case 39:
        if (val.Sheet != null)
          opts.SID = val.Sheet;
        val.Ref = stringify_formula(val.Ptg, null, null, supbooks, opts);
        delete opts.SID;
        delete val.Ptg;
        Names.push(val);
        break;
      case 1036:
        break;
      case 357:
      case 358:
      case 355:
      case 667:
        if (!supbooks[0].length)
          supbooks[0] = [RT, val];
        else
          supbooks.push([RT, val]);
        supbooks[supbooks.length - 1].XTI = [];
        break;
      case 362:
        if (supbooks.length === 0) {
          supbooks[0] = [];
          supbooks[0].XTI = [];
        }
        supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
        supbooks.XTI = supbooks.XTI.concat(val);
        break;
      case 361:
        break;
      case 2071:
      case 158:
      case 143:
      case 664:
      case 353:
        break;
      case 3072:
      case 3073:
      case 534:
      case 677:
      case 157:
      case 610:
      case 2050:
      case 155:
      case 548:
      case 676:
      case 128:
      case 665:
      case 2128:
      case 2125:
      case 549:
      case 2053:
      case 596:
      case 2076:
      case 2075:
      case 2082:
      case 397:
      case 154:
      case 1117:
      case 553:
      case 2091:
        break;
      case 35:
        state.push(RT);
        pass = true;
        break;
      case 36:
        state.pop();
        pass = false;
        break;
      case 37:
        state.push(RT);
        pass = true;
        break;
      case 38:
        state.pop();
        pass = false;
        break;
      case 16:
        break;
      default:
        if (R.T)
          ;
        else if (!pass || opts.WTF && state[state.length - 1] != 37 && state[state.length - 1] != 35)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  parse_wb_defaults(wb);
  wb.Names = Names;
  wb.supbooks = supbooks;
  return wb;
}
function write_BUNDLESHS(ba, wb) {
  write_record(
    ba,
    143
    /* BrtBeginBundleShs */
  );
  for (var idx = 0; idx != wb.SheetNames.length; ++idx) {
    var viz = wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx] && wb.Workbook.Sheets[idx].Hidden || 0;
    var d = { Hidden: viz, iTabID: idx + 1, strRelID: "rId" + (idx + 1), name: wb.SheetNames[idx] };
    write_record(ba, 156, write_BrtBundleSh(d));
  }
  write_record(
    ba,
    144
    /* BrtEndBundleShs */
  );
}
function write_BrtFileVersion(data, o) {
  if (!o)
    o = new_buf(127);
  for (var i = 0; i != 4; ++i)
    o.write_shift(4, 0);
  write_XLWideString("SheetJS", o);
  write_XLWideString(XLSX.version, o);
  write_XLWideString(XLSX.version, o);
  write_XLWideString("7262", o);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function write_BrtBookView(idx, o) {
  if (!o)
    o = new_buf(29);
  o.write_shift(-4, 0);
  o.write_shift(-4, 460);
  o.write_shift(4, 28800);
  o.write_shift(4, 17600);
  o.write_shift(4, 500);
  o.write_shift(4, idx);
  o.write_shift(4, idx);
  var flags = 120;
  o.write_shift(1, flags);
  return o.length > o.l ? o.slice(0, o.l) : o;
}
function write_BOOKVIEWS(ba, wb) {
  if (!wb.Workbook || !wb.Workbook.Sheets)
    return;
  var sheets = wb.Workbook.Sheets;
  var i = 0, vistab = -1, hidden = -1;
  for (; i < sheets.length; ++i) {
    if (!sheets[i] || !sheets[i].Hidden && vistab == -1)
      vistab = i;
    else if (sheets[i].Hidden == 1 && hidden == -1)
      hidden = i;
  }
  if (hidden > vistab)
    return;
  write_record(
    ba,
    135
    /* BrtBeginBookViews */
  );
  write_record(ba, 158, write_BrtBookView(vistab));
  write_record(
    ba,
    136
    /* BrtEndBookViews */
  );
}
function write_BRTNAMES(ba, wb) {
  if (!wb.Workbook || !wb.Workbook.Names)
    return;
  wb.Workbook.Names.forEach(function(name) {
    try {
      if (name.Flags & 14)
        return;
      write_record(ba, 39, write_BrtName(name, wb));
    } catch (e) {
      console.error("Could not serialize defined name " + JSON.stringify(name));
    }
  });
}
function write_SELF_EXTERNS_xlsb(wb) {
  var L = wb.SheetNames.length;
  var o = new_buf(12 * L + 28);
  o.write_shift(4, L + 2);
  o.write_shift(4, 0);
  o.write_shift(4, -2);
  o.write_shift(4, -2);
  o.write_shift(4, 0);
  o.write_shift(4, -1);
  o.write_shift(4, -1);
  for (var i = 0; i < L; ++i) {
    o.write_shift(4, 0);
    o.write_shift(4, i);
    o.write_shift(4, i);
  }
  return o;
}
function write_EXTERNALS_xlsb(ba, wb) {
  write_record(
    ba,
    353
    /* BrtBeginExternals */
  );
  write_record(
    ba,
    357
    /* BrtSupSelf */
  );
  write_record(ba, 362, write_SELF_EXTERNS_xlsb(wb));
  write_record(
    ba,
    354
    /* BrtEndExternals */
  );
}
function write_wb_bin(wb, opts) {
  var ba = buf_array();
  write_record(
    ba,
    131
    /* BrtBeginBook */
  );
  write_record(ba, 128, write_BrtFileVersion());
  write_record(ba, 153, write_BrtWbProp(wb.Workbook && wb.Workbook.WBProps || null));
  write_BOOKVIEWS(ba, wb);
  write_BUNDLESHS(ba, wb);
  write_EXTERNALS_xlsb(ba, wb);
  if ((wb.Workbook || {}).Names)
    write_BRTNAMES(ba, wb);
  write_record(
    ba,
    132
    /* BrtEndBook */
  );
  return ba.end();
}
function parse_wb(data, name, opts) {
  if (name.slice(-4) === ".bin")
    return parse_wb_bin(data, opts);
  return parse_wb_xml(data, opts);
}
function parse_ws(data, name, idx, opts, rels, wb, themes, styles2) {
  if (name.slice(-4) === ".bin")
    return parse_ws_bin(data, opts, idx, rels, wb, themes, styles2);
  return parse_ws_xml(data, opts, idx, rels, wb, themes, styles2);
}
function parse_cs(data, name, idx, opts, rels, wb, themes, styles2) {
  if (name.slice(-4) === ".bin")
    return parse_cs_bin(data, opts, idx, rels, wb);
  return parse_cs_xml(data, opts, idx, rels, wb);
}
function parse_ms(data, name, idx, opts, rels, wb, themes, styles2) {
  if (name.slice(-4) === ".bin")
    return parse_ms_bin();
  return parse_ms_xml();
}
function parse_ds(data, name, idx, opts, rels, wb, themes, styles2) {
  if (name.slice(-4) === ".bin")
    return parse_ds_bin();
  return parse_ds_xml();
}
function parse_sty(data, name, themes, opts) {
  if (name.slice(-4) === ".bin")
    return parse_sty_bin(data, themes, opts);
  return parse_sty_xml(data, themes, opts);
}
function parse_sst(data, name, opts) {
  if (name.slice(-4) === ".bin")
    return parse_sst_bin(data, opts);
  return parse_sst_xml(data, opts);
}
function parse_cmnt(data, name, opts) {
  if (name.slice(-4) === ".bin")
    return parse_comments_bin(data, opts);
  return parse_comments_xml(data, opts);
}
function parse_cc(data, name, opts) {
  if (name.slice(-4) === ".bin")
    return parse_cc_bin(data);
  return parse_cc_xml(data);
}
function parse_xlink(data, rel, name, opts) {
  if (name.slice(-4) === ".bin")
    return parse_xlink_bin(data, rel, name, opts);
  return parse_xlink_xml();
}
function parse_xlmeta(data, name, opts) {
  if (name.slice(-4) === ".bin")
    return parse_xlmeta_bin(data, name, opts);
  return parse_xlmeta_xml(data, name, opts);
}
var attregexg2 = /([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;
var attregex2 = /([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
function xlml_parsexmltag(tag, skip_root) {
  var words = tag.split(/\s+/);
  var z = [];
  if (!skip_root)
    z[0] = words[0];
  if (words.length === 1)
    return z;
  var m = tag.match(attregexg2), y, j, w2, i;
  if (m)
    for (i = 0; i != m.length; ++i) {
      y = m[i].match(attregex2);
      if ((j = y[1].indexOf(":")) === -1)
        z[y[1]] = y[2].slice(1, y[2].length - 1);
      else {
        if (y[1].slice(0, 6) === "xmlns:")
          w2 = "xmlns" + y[1].slice(6);
        else
          w2 = y[1].slice(j + 1);
        z[w2] = y[2].slice(1, y[2].length - 1);
      }
    }
  return z;
}
function xlml_parsexmltagobj(tag) {
  var words = tag.split(/\s+/);
  var z = {};
  if (words.length === 1)
    return z;
  var m = tag.match(attregexg2), y, j, w2, i;
  if (m)
    for (i = 0; i != m.length; ++i) {
      y = m[i].match(attregex2);
      if ((j = y[1].indexOf(":")) === -1)
        z[y[1]] = y[2].slice(1, y[2].length - 1);
      else {
        if (y[1].slice(0, 6) === "xmlns:")
          w2 = "xmlns" + y[1].slice(6);
        else
          w2 = y[1].slice(j + 1);
        z[w2] = y[2].slice(1, y[2].length - 1);
      }
    }
  return z;
}
var XLMLFormatMap;
function xlml_format(format2, value) {
  var fmt = XLMLFormatMap[format2] || unescapexml(format2);
  if (fmt === "General")
    return SSF_general(value);
  return SSF_format(fmt, value);
}
function xlml_set_custprop(Custprops, key, cp, val) {
  var oval = val;
  switch ((cp[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
    case "boolean":
      oval = parsexmlbool(val);
      break;
    case "i2":
    case "int":
      oval = parseInt(val, 10);
      break;
    case "r4":
    case "float":
      oval = parseFloat(val);
      break;
    case "date":
    case "dateTime.tz":
      oval = parseDate(val);
      break;
    case "i8":
    case "string":
    case "fixed":
    case "uuid":
    case "bin.base64":
      break;
    default:
      throw new Error("bad custprop:" + cp[0]);
  }
  Custprops[unescapexml(key)] = oval;
}
function safe_format_xlml(cell, nf, o) {
  if (cell.t === "z")
    return;
  if (!o || o.cellText !== false)
    try {
      if (cell.t === "e") {
        cell.w = cell.w || BErr[cell.v];
      } else if (nf === "General") {
        if (cell.t === "n") {
          if ((cell.v | 0) === cell.v)
            cell.w = cell.v.toString(10);
          else
            cell.w = SSF_general_num(cell.v);
        } else
          cell.w = SSF_general(cell.v);
      } else
        cell.w = xlml_format(nf || "General", cell.v);
    } catch (e) {
      if (o.WTF)
        throw e;
    }
  try {
    var z = XLMLFormatMap[nf] || nf || "General";
    if (o.cellNF)
      cell.z = z;
    if (o.cellDates && cell.t == "n" && fmt_is_date(z)) {
      var _d2 = SSF_parse_date_code(cell.v);
      if (_d2) {
        cell.t = "d";
        cell.v = new Date(_d2.y, _d2.m - 1, _d2.d, _d2.H, _d2.M, _d2.S, _d2.u);
      }
    }
  } catch (e) {
    if (o.WTF)
      throw e;
  }
}
function process_style_xlml(styles2, stag, opts) {
  if (opts.cellStyles) {
    if (stag.Interior) {
      var I = stag.Interior;
      if (I.Pattern)
        I.patternType = XLMLPatternTypeMap[I.Pattern] || I.Pattern;
    }
  }
  styles2[stag.ID] = stag;
}
function parse_xlml_data(xml, ss, data, cell, base, styles2, csty, row, arrayf, o) {
  var nf = "General", sid = cell.StyleID, S = {};
  o = o || {};
  var interiors = [];
  var i = 0;
  if (sid === void 0 && row)
    sid = row.StyleID;
  if (sid === void 0 && csty)
    sid = csty.StyleID;
  while (styles2[sid] !== void 0) {
    if (styles2[sid].nf)
      nf = styles2[sid].nf;
    if (styles2[sid].Interior)
      interiors.push(styles2[sid].Interior);
    if (!styles2[sid].Parent)
      break;
    sid = styles2[sid].Parent;
  }
  switch (data.Type) {
    case "Boolean":
      cell.t = "b";
      cell.v = parsexmlbool(xml);
      break;
    case "String":
      cell.t = "s";
      cell.r = xlml_fixstr(unescapexml(xml));
      cell.v = xml.indexOf("<") > -1 ? unescapexml(ss || xml).replace(/<.*?>/g, "") : cell.r;
      break;
    case "DateTime":
      if (xml.slice(-1) != "Z")
        xml += "Z";
      cell.v = (parseDate(xml) - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1e3);
      if (cell.v !== cell.v)
        cell.v = unescapexml(xml);
      else if (cell.v < 60)
        cell.v = cell.v - 1;
      if (!nf || nf == "General")
        nf = "yyyy-mm-dd";
    case "Number":
      if (cell.v === void 0)
        cell.v = +xml;
      if (!cell.t)
        cell.t = "n";
      break;
    case "Error":
      cell.t = "e";
      cell.v = RBErr[xml];
      if (o.cellText !== false)
        cell.w = xml;
      break;
    default:
      if (xml == "" && ss == "") {
        cell.t = "z";
      } else {
        cell.t = "s";
        cell.v = xlml_fixstr(ss || xml);
      }
      break;
  }
  safe_format_xlml(cell, nf, o);
  if (o.cellFormula !== false) {
    if (cell.Formula) {
      var fstr = unescapexml(cell.Formula);
      if (fstr.charCodeAt(0) == 61)
        fstr = fstr.slice(1);
      cell.f = rc_to_a1(fstr, base);
      delete cell.Formula;
      if (cell.ArrayRange == "RC")
        cell.F = rc_to_a1("RC:RC", base);
      else if (cell.ArrayRange) {
        cell.F = rc_to_a1(cell.ArrayRange, base);
        arrayf.push([safe_decode_range(cell.F), cell.F]);
      }
    } else {
      for (i = 0; i < arrayf.length; ++i)
        if (base.r >= arrayf[i][0].s.r && base.r <= arrayf[i][0].e.r) {
          if (base.c >= arrayf[i][0].s.c && base.c <= arrayf[i][0].e.c)
            cell.F = arrayf[i][1];
        }
    }
  }
  if (o.cellStyles) {
    interiors.forEach(function(x) {
      if (!S.patternType && x.patternType)
        S.patternType = x.patternType;
    });
    cell.s = S;
  }
  if (cell.StyleID !== void 0)
    cell.ixfe = cell.StyleID;
}
function xlml_prefix_dname(dname) {
  return XLSLblBuiltIn.indexOf("_xlnm." + dname) > -1 ? "_xlnm." + dname : dname;
}
function xlml_clean_comment(comment2) {
  comment2.t = comment2.v || "";
  comment2.t = comment2.t.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  comment2.v = comment2.w = comment2.ixfe = void 0;
}
function parse_xlml_xml(d, _opts) {
  var opts = _opts || {};
  make_ssf();
  var str = debom(xlml_normalize(d));
  if (opts.type == "binary" || opts.type == "array" || opts.type == "base64") {
    str = utf8read(str);
  }
  var opening = str.slice(0, 1024).toLowerCase(), ishtml = false;
  opening = opening.replace(/".*?"/g, "");
  if ((opening.indexOf(">") & 1023) > Math.min(opening.indexOf(",") & 1023, opening.indexOf(";") & 1023)) {
    var _o = dup(opts);
    _o.type = "string";
    return PRN.to_workbook(str, _o);
  }
  if (opening.indexOf("<?xml") == -1)
    ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(tag) {
      if (opening.indexOf("<" + tag) >= 0)
        ishtml = true;
    });
  if (ishtml)
    return html_to_workbook(str, opts);
  XLMLFormatMap = {
    "General Number": "General",
    "General Date": table_fmt[22],
    "Long Date": "dddd, mmmm dd, yyyy",
    "Medium Date": table_fmt[15],
    "Short Date": table_fmt[14],
    "Long Time": table_fmt[19],
    "Medium Time": table_fmt[18],
    "Short Time": table_fmt[20],
    "Currency": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    "Fixed": table_fmt[2],
    "Standard": table_fmt[4],
    "Percent": table_fmt[10],
    "Scientific": table_fmt[11],
    "Yes/No": '"Yes";"Yes";"No";@',
    "True/False": '"True";"True";"False";@',
    "On/Off": '"Yes";"Yes";"No";@'
  };
  var Rn;
  var state = [], tmp;
  var sheets = {}, sheetnames = [], cursheet = {}, sheetname = "";
  if (opts.dense)
    cursheet["!data"] = [];
  var cell = {}, row = {};
  var dtag = xlml_parsexmltag('<Data ss:Type="String">'), didx = 0;
  var c = 0, r = 0;
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var styles2 = {}, stag = {};
  var ss = "", fidx = 0;
  var merges = [];
  var Props = {}, Custprops = {}, pidx = 0, cp = [];
  var comments = [], comment2 = {};
  var cstys = [], csty, seencol = false;
  var arrayf = [];
  var rowinfo = [], rowobj = {}, cc = 0, rr = 0;
  var Workbook = { Sheets: [], WBProps: { date1904: false } }, wsprops = {};
  xlmlregex.lastIndex = 0;
  str = str.replace(/<!--([\s\S]*?)-->/mg, "");
  var raw_Rn3 = "";
  while (Rn = xlmlregex.exec(str))
    switch (Rn[3] = (raw_Rn3 = Rn[3]).toLowerCase()) {
      case "data":
        if (raw_Rn3 == "data") {
          if (Rn[1] === "/") {
            if ((tmp = state.pop())[0] !== Rn[3])
              throw new Error("Bad state: " + tmp.join("|"));
          } else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
            state.push([Rn[3], true]);
          break;
        }
        if (state[state.length - 1][1])
          break;
        if (Rn[1] === "/")
          parse_xlml_data(str.slice(didx, Rn.index), ss, dtag, state[state.length - 1][0] == /*"Comment"*/
          "comment" ? comment2 : cell, { c, r }, styles2, cstys[c], row, arrayf, opts);
        else {
          ss = "";
          dtag = xlml_parsexmltag(Rn[0]);
          didx = Rn.index + Rn[0].length;
        }
        break;
      case "cell":
        if (Rn[1] === "/") {
          if (comments.length > 0)
            cell.c = comments;
          if ((!opts.sheetRows || opts.sheetRows > r) && cell.v !== void 0) {
            if (opts.dense) {
              if (!cursheet["!data"][r])
                cursheet["!data"][r] = [];
              cursheet["!data"][r][c] = cell;
            } else
              cursheet[encode_col(c) + encode_row(r)] = cell;
          }
          if (cell.HRef) {
            cell.l = { Target: unescapexml(cell.HRef) };
            if (cell.HRefScreenTip)
              cell.l.Tooltip = cell.HRefScreenTip;
            delete cell.HRef;
            delete cell.HRefScreenTip;
          }
          if (cell.MergeAcross || cell.MergeDown) {
            cc = c + (parseInt(cell.MergeAcross, 10) | 0);
            rr = r + (parseInt(cell.MergeDown, 10) | 0);
            if (cc > c || rr > r)
              merges.push({ s: { c, r }, e: { c: cc, r: rr } });
          }
          if (!opts.sheetStubs) {
            if (cell.MergeAcross)
              c = cc + 1;
            else
              ++c;
          } else if (cell.MergeAcross || cell.MergeDown) {
            for (var cma = c; cma <= cc; ++cma) {
              for (var cmd = r; cmd <= rr; ++cmd) {
                if (cma > c || cmd > r) {
                  if (opts.dense) {
                    if (!cursheet["!data"][cmd])
                      cursheet["!data"][cmd] = [];
                    cursheet["!data"][cmd][cma] = { t: "z" };
                  } else
                    cursheet[encode_col(cma) + encode_row(cmd)] = { t: "z" };
                }
              }
            }
            c = cc + 1;
          } else
            ++c;
        } else {
          cell = xlml_parsexmltagobj(Rn[0]);
          if (cell.Index)
            c = +cell.Index - 1;
          if (c < refguess.s.c)
            refguess.s.c = c;
          if (c > refguess.e.c)
            refguess.e.c = c;
          if (Rn[0].slice(-2) === "/>")
            ++c;
          comments = [];
        }
        break;
      case "row":
        if (Rn[1] === "/" || Rn[0].slice(-2) === "/>") {
          if (r < refguess.s.r)
            refguess.s.r = r;
          if (r > refguess.e.r)
            refguess.e.r = r;
          if (Rn[0].slice(-2) === "/>") {
            row = xlml_parsexmltag(Rn[0]);
            if (row.Index)
              r = +row.Index - 1;
          }
          c = 0;
          ++r;
        } else {
          row = xlml_parsexmltag(Rn[0]);
          if (row.Index)
            r = +row.Index - 1;
          rowobj = {};
          if (row.AutoFitHeight == "0" || row.Height) {
            rowobj.hpx = parseInt(row.Height, 10);
            rowobj.hpt = px2pt(rowobj.hpx);
            rowinfo[r] = rowobj;
          }
          if (row.Hidden == "1") {
            rowobj.hidden = true;
            rowinfo[r] = rowobj;
          }
        }
        break;
      case "worksheet":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
          sheetnames.push(sheetname);
          if (refguess.s.r <= refguess.e.r && refguess.s.c <= refguess.e.c) {
            cursheet["!ref"] = encode_range(refguess);
            if (opts.sheetRows && opts.sheetRows <= refguess.e.r) {
              cursheet["!fullref"] = cursheet["!ref"];
              refguess.e.r = opts.sheetRows - 1;
              cursheet["!ref"] = encode_range(refguess);
            }
          }
          if (merges.length)
            cursheet["!merges"] = merges;
          if (cstys.length > 0)
            cursheet["!cols"] = cstys;
          if (rowinfo.length > 0)
            cursheet["!rows"] = rowinfo;
          sheets[sheetname] = cursheet;
        } else {
          refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
          r = c = 0;
          state.push([Rn[3], false]);
          tmp = xlml_parsexmltag(Rn[0]);
          sheetname = unescapexml(tmp.Name);
          cursheet = {};
          if (opts.dense)
            cursheet["!data"] = [];
          merges = [];
          arrayf = [];
          rowinfo = [];
          wsprops = { name: sheetname, Hidden: 0 };
          Workbook.Sheets.push(wsprops);
        }
        break;
      case "table":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
        } else if (Rn[0].slice(-2) == "/>")
          break;
        else {
          state.push([Rn[3], false]);
          cstys = [];
          seencol = false;
        }
        break;
      case "style":
        if (Rn[1] === "/")
          process_style_xlml(styles2, stag, opts);
        else
          stag = xlml_parsexmltag(Rn[0]);
        break;
      case "numberformat":
        stag.nf = unescapexml(xlml_parsexmltag(Rn[0]).Format || "General");
        if (XLMLFormatMap[stag.nf])
          stag.nf = XLMLFormatMap[stag.nf];
        for (var ssfidx = 0; ssfidx != 392; ++ssfidx)
          if (table_fmt[ssfidx] == stag.nf)
            break;
        if (ssfidx == 392) {
          for (ssfidx = 57; ssfidx != 392; ++ssfidx)
            if (table_fmt[ssfidx] == null) {
              SSF__load(stag.nf, ssfidx);
              break;
            }
        }
        break;
      case "column":
        if (state[state.length - 1][0] !== /*'Table'*/
        "table")
          break;
        if (Rn[1] === "/")
          break;
        csty = xlml_parsexmltag(Rn[0]);
        if (csty.Hidden) {
          csty.hidden = true;
          delete csty.Hidden;
        }
        if (csty.Width)
          csty.wpx = parseInt(csty.Width, 10);
        if (!seencol && csty.wpx > 10) {
          seencol = true;
          MDW = DEF_MDW;
          for (var _col = 0; _col < cstys.length; ++_col)
            if (cstys[_col])
              process_col(cstys[_col]);
        }
        if (seencol)
          process_col(csty);
        cstys[csty.Index - 1 || cstys.length] = csty;
        for (var i = 0; i < +csty.Span; ++i)
          cstys[cstys.length] = dup(csty);
        break;
      case "namedrange":
        if (Rn[1] === "/")
          break;
        if (!Workbook.Names)
          Workbook.Names = [];
        var _NamedRange = parsexmltag(Rn[0]);
        var _DefinedName = {
          Name: xlml_prefix_dname(_NamedRange.Name),
          Ref: rc_to_a1(_NamedRange.RefersTo.slice(1), { r: 0, c: 0 })
        };
        if (Workbook.Sheets.length > 0)
          _DefinedName.Sheet = Workbook.Sheets.length - 1;
        Workbook.Names.push(_DefinedName);
        break;
      case "namedcell":
        break;
      case "b":
        break;
      case "i":
        break;
      case "u":
        break;
      case "s":
        break;
      case "em":
        break;
      case "h2":
        break;
      case "h3":
        break;
      case "sub":
        break;
      case "sup":
        break;
      case "span":
        break;
      case "alignment":
        break;
      case "borders":
        break;
      case "border":
        break;
      case "font":
        if (Rn[0].slice(-2) === "/>")
          break;
        else if (Rn[1] === "/")
          ss += str.slice(fidx, Rn.index);
        else
          fidx = Rn.index + Rn[0].length;
        break;
      case "interior":
        if (!opts.cellStyles)
          break;
        stag.Interior = xlml_parsexmltag(Rn[0]);
        break;
      case "protection":
        break;
      case "author":
      case "title":
      case "description":
      case "created":
      case "keywords":
      case "subject":
      case "category":
      case "company":
      case "lastauthor":
      case "lastsaved":
      case "lastprinted":
      case "version":
      case "revision":
      case "totaltime":
      case "hyperlinkbase":
      case "manager":
      case "contentstatus":
      case "identifier":
      case "language":
      case "appname":
        if (Rn[0].slice(-2) === "/>")
          break;
        else if (Rn[1] === "/")
          xlml_set_prop(Props, raw_Rn3, str.slice(pidx, Rn.index));
        else
          pidx = Rn.index + Rn[0].length;
        break;
      case "paragraphs":
        break;
      case "styles":
      case "workbook":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
        } else
          state.push([Rn[3], false]);
        break;
      case "comment":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
          xlml_clean_comment(comment2);
          comments.push(comment2);
        } else {
          state.push([Rn[3], false]);
          tmp = xlml_parsexmltag(Rn[0]);
          comment2 = { a: tmp.Author };
        }
        break;
      case "autofilter":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          var AutoFilter = xlml_parsexmltag(Rn[0]);
          cursheet["!autofilter"] = { ref: rc_to_a1(AutoFilter.Range).replace(/\$/g, "") };
          state.push([Rn[3], true]);
        }
        break;
      case "name":
        break;
      case "datavalidation":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
        } else {
          if (Rn[0].charAt(Rn[0].length - 2) !== "/")
            state.push([Rn[3], true]);
        }
        break;
      case "pixelsperinch":
        break;
      case "componentoptions":
      case "documentproperties":
      case "customdocumentproperties":
      case "officedocumentsettings":
      case "pivottable":
      case "pivotcache":
      case "names":
      case "mapinfo":
      case "pagebreaks":
      case "querytable":
      case "sorting":
      case "schema":
      case "conditionalformatting":
      case "smarttagtype":
      case "smarttags":
      case "excelworkbook":
      case "workbookoptions":
      case "worksheetoptions":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw new Error("Bad state: " + tmp.join("|"));
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
          state.push([Rn[3], true]);
        break;
      case "null":
        break;
      default:
        if (state.length == 0 && Rn[3] == "document")
          return parse_fods(str, opts);
        if (state.length == 0 && Rn[3] == "uof")
          return parse_fods(str, opts);
        var seen = true;
        switch (state[state.length - 1][0]) {
          case "officedocumentsettings":
            switch (Rn[3]) {
              case "allowpng":
                break;
              case "removepersonalinformation":
                break;
              case "downloadcomponents":
                break;
              case "locationofcomponents":
                break;
              case "colors":
                break;
              case "color":
                break;
              case "index":
                break;
              case "rgb":
                break;
              case "targetscreensize":
                break;
              case "readonlyrecommended":
                break;
              default:
                seen = false;
            }
            break;
          case "componentoptions":
            switch (Rn[3]) {
              case "toolbar":
                break;
              case "hideofficelogo":
                break;
              case "spreadsheetautofit":
                break;
              case "label":
                break;
              case "caption":
                break;
              case "maxheight":
                break;
              case "maxwidth":
                break;
              case "nextsheetnumber":
                break;
              default:
                seen = false;
            }
            break;
          case "excelworkbook":
            switch (Rn[3]) {
              case "date1904":
                Workbook.WBProps.date1904 = true;
                break;
              case "windowheight":
                break;
              case "windowwidth":
                break;
              case "windowtopx":
                break;
              case "windowtopy":
                break;
              case "tabratio":
                break;
              case "protectstructure":
                break;
              case "protectwindow":
                break;
              case "protectwindows":
                break;
              case "activesheet":
                break;
              case "displayinknotes":
                break;
              case "firstvisiblesheet":
                break;
              case "supbook":
                break;
              case "sheetname":
                break;
              case "sheetindex":
                break;
              case "sheetindexfirst":
                break;
              case "sheetindexlast":
                break;
              case "dll":
                break;
              case "acceptlabelsinformulas":
                break;
              case "donotsavelinkvalues":
                break;
              case "iteration":
                break;
              case "maxiterations":
                break;
              case "maxchange":
                break;
              case "path":
                break;
              case "xct":
                break;
              case "count":
                break;
              case "selectedsheets":
                break;
              case "calculation":
                break;
              case "uncalced":
                break;
              case "startupprompt":
                break;
              case "crn":
                break;
              case "externname":
                break;
              case "formula":
                break;
              case "colfirst":
                break;
              case "collast":
                break;
              case "wantadvise":
                break;
              case "boolean":
                break;
              case "error":
                break;
              case "text":
                break;
              case "ole":
                break;
              case "noautorecover":
                break;
              case "publishobjects":
                break;
              case "donotcalculatebeforesave":
                break;
              case "number":
                break;
              case "refmoder1c1":
                break;
              case "embedsavesmarttags":
                break;
              default:
                seen = false;
            }
            break;
          case "workbookoptions":
            switch (Rn[3]) {
              case "owcversion":
                break;
              case "height":
                break;
              case "width":
                break;
              default:
                seen = false;
            }
            break;
          case "worksheetoptions":
            switch (Rn[3]) {
              case "visible":
                if (Rn[0].slice(-2) === "/>")
                  ;
                else if (Rn[1] === "/")
                  switch (str.slice(pidx, Rn.index)) {
                    case "SheetHidden":
                      wsprops.Hidden = 1;
                      break;
                    case "SheetVeryHidden":
                      wsprops.Hidden = 2;
                      break;
                  }
                else
                  pidx = Rn.index + Rn[0].length;
                break;
              case "header":
                if (!cursheet["!margins"])
                  default_margins(cursheet["!margins"] = {}, "xlml");
                if (!isNaN(+parsexmltag(Rn[0]).Margin))
                  cursheet["!margins"].header = +parsexmltag(Rn[0]).Margin;
                break;
              case "footer":
                if (!cursheet["!margins"])
                  default_margins(cursheet["!margins"] = {}, "xlml");
                if (!isNaN(+parsexmltag(Rn[0]).Margin))
                  cursheet["!margins"].footer = +parsexmltag(Rn[0]).Margin;
                break;
              case "pagemargins":
                var pagemargins = parsexmltag(Rn[0]);
                if (!cursheet["!margins"])
                  default_margins(cursheet["!margins"] = {}, "xlml");
                if (!isNaN(+pagemargins.Top))
                  cursheet["!margins"].top = +pagemargins.Top;
                if (!isNaN(+pagemargins.Left))
                  cursheet["!margins"].left = +pagemargins.Left;
                if (!isNaN(+pagemargins.Right))
                  cursheet["!margins"].right = +pagemargins.Right;
                if (!isNaN(+pagemargins.Bottom))
                  cursheet["!margins"].bottom = +pagemargins.Bottom;
                break;
              case "displayrighttoleft":
                if (!Workbook.Views)
                  Workbook.Views = [];
                if (!Workbook.Views[0])
                  Workbook.Views[0] = {};
                Workbook.Views[0].RTL = true;
                break;
              case "freezepanes":
                break;
              case "frozennosplit":
                break;
              case "splithorizontal":
              case "splitvertical":
                break;
              case "donotdisplaygridlines":
                break;
              case "activerow":
                break;
              case "activecol":
                break;
              case "toprowbottompane":
                break;
              case "leftcolumnrightpane":
                break;
              case "unsynced":
                break;
              case "print":
                break;
              case "printerrors":
                break;
              case "panes":
                break;
              case "scale":
                break;
              case "pane":
                break;
              case "number":
                break;
              case "layout":
                break;
              case "pagesetup":
                break;
              case "selected":
                break;
              case "protectobjects":
                break;
              case "enableselection":
                break;
              case "protectscenarios":
                break;
              case "validprinterinfo":
                break;
              case "horizontalresolution":
                break;
              case "verticalresolution":
                break;
              case "numberofcopies":
                break;
              case "activepane":
                break;
              case "toprowvisible":
                break;
              case "leftcolumnvisible":
                break;
              case "fittopage":
                break;
              case "rangeselection":
                break;
              case "papersizeindex":
                break;
              case "pagelayoutzoom":
                break;
              case "pagebreakzoom":
                break;
              case "filteron":
                break;
              case "fitwidth":
                break;
              case "fitheight":
                break;
              case "commentslayout":
                break;
              case "zoom":
                break;
              case "lefttoright":
                break;
              case "gridlines":
                break;
              case "allowsort":
                break;
              case "allowfilter":
                break;
              case "allowinsertrows":
                break;
              case "allowdeleterows":
                break;
              case "allowinsertcols":
                break;
              case "allowdeletecols":
                break;
              case "allowinserthyperlinks":
                break;
              case "allowformatcells":
                break;
              case "allowsizecols":
                break;
              case "allowsizerows":
                break;
              case "nosummaryrowsbelowdetail":
                if (!cursheet["!outline"])
                  cursheet["!outline"] = {};
                cursheet["!outline"].above = true;
                break;
              case "tabcolorindex":
                break;
              case "donotdisplayheadings":
                break;
              case "showpagelayoutzoom":
                break;
              case "nosummarycolumnsrightdetail":
                if (!cursheet["!outline"])
                  cursheet["!outline"] = {};
                cursheet["!outline"].left = true;
                break;
              case "blackandwhite":
                break;
              case "donotdisplayzeros":
                break;
              case "displaypagebreak":
                break;
              case "rowcolheadings":
                break;
              case "donotdisplayoutline":
                break;
              case "noorientation":
                break;
              case "allowusepivottables":
                break;
              case "zeroheight":
                break;
              case "viewablerange":
                break;
              case "selection":
                break;
              case "protectcontents":
                break;
              default:
                seen = false;
            }
            break;
          case "pivottable":
          case "pivotcache":
            switch (Rn[3]) {
              case "immediateitemsondrop":
                break;
              case "showpagemultipleitemlabel":
                break;
              case "compactrowindent":
                break;
              case "location":
                break;
              case "pivotfield":
                break;
              case "orientation":
                break;
              case "layoutform":
                break;
              case "layoutsubtotallocation":
                break;
              case "layoutcompactrow":
                break;
              case "position":
                break;
              case "pivotitem":
                break;
              case "datatype":
                break;
              case "datafield":
                break;
              case "sourcename":
                break;
              case "parentfield":
                break;
              case "ptlineitems":
                break;
              case "ptlineitem":
                break;
              case "countofsameitems":
                break;
              case "item":
                break;
              case "itemtype":
                break;
              case "ptsource":
                break;
              case "cacheindex":
                break;
              case "consolidationreference":
                break;
              case "filename":
                break;
              case "reference":
                break;
              case "nocolumngrand":
                break;
              case "norowgrand":
                break;
              case "blanklineafteritems":
                break;
              case "hidden":
                break;
              case "subtotal":
                break;
              case "basefield":
                break;
              case "mapchilditems":
                break;
              case "function":
                break;
              case "refreshonfileopen":
                break;
              case "printsettitles":
                break;
              case "mergelabels":
                break;
              case "defaultversion":
                break;
              case "refreshname":
                break;
              case "refreshdate":
                break;
              case "refreshdatecopy":
                break;
              case "versionlastrefresh":
                break;
              case "versionlastupdate":
                break;
              case "versionupdateablemin":
                break;
              case "versionrefreshablemin":
                break;
              case "calculation":
                break;
              default:
                seen = false;
            }
            break;
          case "pagebreaks":
            switch (Rn[3]) {
              case "colbreaks":
                break;
              case "colbreak":
                break;
              case "rowbreaks":
                break;
              case "rowbreak":
                break;
              case "colstart":
                break;
              case "colend":
                break;
              case "rowend":
                break;
              default:
                seen = false;
            }
            break;
          case "autofilter":
            switch (Rn[3]) {
              case "autofiltercolumn":
                break;
              case "autofiltercondition":
                break;
              case "autofilterand":
                break;
              case "autofilteror":
                break;
              default:
                seen = false;
            }
            break;
          case "querytable":
            switch (Rn[3]) {
              case "id":
                break;
              case "autoformatfont":
                break;
              case "autoformatpattern":
                break;
              case "querysource":
                break;
              case "querytype":
                break;
              case "enableredirections":
                break;
              case "refreshedinxl9":
                break;
              case "urlstring":
                break;
              case "htmltables":
                break;
              case "connection":
                break;
              case "commandtext":
                break;
              case "refreshinfo":
                break;
              case "notitles":
                break;
              case "nextid":
                break;
              case "columninfo":
                break;
              case "overwritecells":
                break;
              case "donotpromptforfile":
                break;
              case "textwizardsettings":
                break;
              case "source":
                break;
              case "number":
                break;
              case "decimal":
                break;
              case "thousandseparator":
                break;
              case "trailingminusnumbers":
                break;
              case "formatsettings":
                break;
              case "fieldtype":
                break;
              case "delimiters":
                break;
              case "tab":
                break;
              case "comma":
                break;
              case "autoformatname":
                break;
              case "versionlastedit":
                break;
              case "versionlastrefresh":
                break;
              default:
                seen = false;
            }
            break;
          case "datavalidation":
            switch (Rn[3]) {
              case "range":
                break;
              case "type":
                break;
              case "min":
                break;
              case "max":
                break;
              case "sort":
                break;
              case "descending":
                break;
              case "order":
                break;
              case "casesensitive":
                break;
              case "value":
                break;
              case "errorstyle":
                break;
              case "errormessage":
                break;
              case "errortitle":
                break;
              case "inputmessage":
                break;
              case "inputtitle":
                break;
              case "combohide":
                break;
              case "inputhide":
                break;
              case "condition":
                break;
              case "qualifier":
                break;
              case "useblank":
                break;
              case "value1":
                break;
              case "value2":
                break;
              case "format":
                break;
              case "cellrangelist":
                break;
              default:
                seen = false;
            }
            break;
          case "sorting":
          case "conditionalformatting":
            switch (Rn[3]) {
              case "range":
                break;
              case "type":
                break;
              case "min":
                break;
              case "max":
                break;
              case "sort":
                break;
              case "descending":
                break;
              case "order":
                break;
              case "casesensitive":
                break;
              case "value":
                break;
              case "errorstyle":
                break;
              case "errormessage":
                break;
              case "errortitle":
                break;
              case "cellrangelist":
                break;
              case "inputmessage":
                break;
              case "inputtitle":
                break;
              case "combohide":
                break;
              case "inputhide":
                break;
              case "condition":
                break;
              case "qualifier":
                break;
              case "useblank":
                break;
              case "value1":
                break;
              case "value2":
                break;
              case "format":
                break;
              default:
                seen = false;
            }
            break;
          case "mapinfo":
          case "schema":
          case "data":
            switch (Rn[3]) {
              case "map":
                break;
              case "entry":
                break;
              case "range":
                break;
              case "xpath":
                break;
              case "field":
                break;
              case "xsdtype":
                break;
              case "filteron":
                break;
              case "aggregate":
                break;
              case "elementtype":
                break;
              case "attributetype":
                break;
              case "schema":
              case "element":
              case "complextype":
              case "datatype":
              case "all":
              case "attribute":
              case "extends":
                break;
              case "row":
                break;
              default:
                seen = false;
            }
            break;
          case "smarttags":
            break;
          default:
            seen = false;
            break;
        }
        if (seen)
          break;
        if (Rn[3].match(/!\[CDATA/))
          break;
        if (!state[state.length - 1][1])
          throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
        if (state[state.length - 1][0] === /*'CustomDocumentProperties'*/
        "customdocumentproperties") {
          if (Rn[0].slice(-2) === "/>")
            break;
          else if (Rn[1] === "/")
            xlml_set_custprop(Custprops, raw_Rn3, cp, str.slice(pidx, Rn.index));
          else {
            cp = Rn;
            pidx = Rn.index + Rn[0].length;
          }
          break;
        }
        if (opts.WTF)
          throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
    }
  var out = {};
  if (!opts.bookSheets && !opts.bookProps)
    out.Sheets = sheets;
  out.SheetNames = sheetnames;
  out.Workbook = Workbook;
  out.SSF = dup(table_fmt);
  out.Props = Props;
  out.Custprops = Custprops;
  out.bookType = "xlml";
  return out;
}
function parse_xlml(data, opts) {
  fix_read_opts(opts = opts || {});
  switch (opts.type || "base64") {
    case "base64":
      return parse_xlml_xml(Base64_decode(data), opts);
    case "binary":
    case "buffer":
    case "file":
      return parse_xlml_xml(data, opts);
    case "array":
      return parse_xlml_xml(a2s(data), opts);
  }
}
function write_props_xlml(wb, opts) {
  var o = [];
  if (wb.Props)
    o.push(xlml_write_docprops(wb.Props, opts));
  if (wb.Custprops)
    o.push(xlml_write_custprops(wb.Props, wb.Custprops));
  return o.join("");
}
function write_wb_xlml(wb) {
  if ((((wb || {}).Workbook || {}).WBProps || {}).date1904)
    return '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel"><Date1904/></ExcelWorkbook>';
  return "";
}
function write_sty_xlml(wb, opts) {
  var styles2 = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
  opts.cellXfs.forEach(function(xf, id) {
    var payload = [];
    payload.push(writextag("NumberFormat", null, { "ss:Format": escapexml(table_fmt[xf.numFmtId]) }));
    var o = (
      /*::(*/
      { "ss:ID": "s" + (21 + id) }
    );
    styles2.push(writextag("Style", payload.join(""), o));
  });
  return writextag("Styles", styles2.join(""));
}
function write_name_xlml(n) {
  return writextag("NamedRange", null, { "ss:Name": n.Name.slice(0, 6) == "_xlnm." ? n.Name.slice(6) : n.Name, "ss:RefersTo": "=" + a1_to_rc(n.Ref, { r: 0, c: 0 }) });
}
function write_names_xlml(wb) {
  if (!((wb || {}).Workbook || {}).Names)
    return "";
  var names = wb.Workbook.Names;
  var out = [];
  for (var i = 0; i < names.length; ++i) {
    var n = names[i];
    if (n.Sheet != null)
      continue;
    if (n.Name.match(/^_xlfn\./))
      continue;
    out.push(write_name_xlml(n));
  }
  return writextag("Names", out.join(""));
}
function write_ws_xlml_names(ws, opts, idx, wb) {
  if (!ws)
    return "";
  if (!((wb || {}).Workbook || {}).Names)
    return "";
  var names = wb.Workbook.Names;
  var out = [];
  for (var i = 0; i < names.length; ++i) {
    var n = names[i];
    if (n.Sheet != idx)
      continue;
    if (n.Name.match(/^_xlfn\./))
      continue;
    out.push(write_name_xlml(n));
  }
  return out.join("");
}
function write_ws_xlml_wsopts(ws, opts, idx, wb) {
  if (!ws)
    return "";
  var o = [];
  if (ws["!margins"]) {
    o.push("<PageSetup>");
    if (ws["!margins"].header)
      o.push(writextag("Header", null, { "x:Margin": ws["!margins"].header }));
    if (ws["!margins"].footer)
      o.push(writextag("Footer", null, { "x:Margin": ws["!margins"].footer }));
    o.push(writextag("PageMargins", null, {
      "x:Bottom": ws["!margins"].bottom || "0.75",
      "x:Left": ws["!margins"].left || "0.7",
      "x:Right": ws["!margins"].right || "0.7",
      "x:Top": ws["!margins"].top || "0.75"
    }));
    o.push("</PageSetup>");
  }
  if (wb && wb.Workbook && wb.Workbook.Sheets && wb.Workbook.Sheets[idx]) {
    if (wb.Workbook.Sheets[idx].Hidden)
      o.push(writextag("Visible", wb.Workbook.Sheets[idx].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden", {}));
    else {
      for (var i = 0; i < idx; ++i)
        if (wb.Workbook.Sheets[i] && !wb.Workbook.Sheets[i].Hidden)
          break;
      if (i == idx)
        o.push("<Selected/>");
    }
  }
  if (((((wb || {}).Workbook || {}).Views || [])[0] || {}).RTL)
    o.push("<DisplayRightToLeft/>");
  if (ws["!protect"]) {
    o.push(writetag("ProtectContents", "True"));
    if (ws["!protect"].objects)
      o.push(writetag("ProtectObjects", "True"));
    if (ws["!protect"].scenarios)
      o.push(writetag("ProtectScenarios", "True"));
    if (ws["!protect"].selectLockedCells != null && !ws["!protect"].selectLockedCells)
      o.push(writetag("EnableSelection", "NoSelection"));
    else if (ws["!protect"].selectUnlockedCells != null && !ws["!protect"].selectUnlockedCells)
      o.push(writetag("EnableSelection", "UnlockedCells"));
    [
      ["formatCells", "AllowFormatCells"],
      ["formatColumns", "AllowSizeCols"],
      ["formatRows", "AllowSizeRows"],
      ["insertColumns", "AllowInsertCols"],
      ["insertRows", "AllowInsertRows"],
      ["insertHyperlinks", "AllowInsertHyperlinks"],
      ["deleteColumns", "AllowDeleteCols"],
      ["deleteRows", "AllowDeleteRows"],
      ["sort", "AllowSort"],
      ["autoFilter", "AllowFilter"],
      ["pivotTables", "AllowUsePivotTables"]
    ].forEach(function(x) {
      if (ws["!protect"][x[0]])
        o.push("<" + x[1] + "/>");
    });
  }
  if (o.length == 0)
    return "";
  return writextag("WorksheetOptions", o.join(""), { xmlns: XLMLNS.x });
}
function write_ws_xlml_comment(comments) {
  return comments.map(function(c) {
    var t = xlml_unfixstr(c.t || "");
    var d = writextag("ss:Data", t, { "xmlns": "http://www.w3.org/TR/REC-html40" });
    return writextag("Comment", d, { "ss:Author": c.a });
  }).join("");
}
function write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr) {
  if (!cell || cell.v == void 0 && cell.f == void 0)
    return "";
  var attr = {};
  if (cell.f)
    attr["ss:Formula"] = "=" + escapexml(a1_to_rc(cell.f, addr));
  if (cell.F && cell.F.slice(0, ref.length) == ref) {
    var end = decode_cell(cell.F.slice(ref.length + 1));
    attr["ss:ArrayRange"] = "RC:R" + (end.r == addr.r ? "" : "[" + (end.r - addr.r) + "]") + "C" + (end.c == addr.c ? "" : "[" + (end.c - addr.c) + "]");
  }
  if (cell.l && cell.l.Target) {
    attr["ss:HRef"] = escapexml(cell.l.Target);
    if (cell.l.Tooltip)
      attr["x:HRefScreenTip"] = escapexml(cell.l.Tooltip);
  }
  if (ws["!merges"]) {
    var marr = ws["!merges"];
    for (var mi = 0; mi != marr.length; ++mi) {
      if (marr[mi].s.c != addr.c || marr[mi].s.r != addr.r)
        continue;
      if (marr[mi].e.c > marr[mi].s.c)
        attr["ss:MergeAcross"] = marr[mi].e.c - marr[mi].s.c;
      if (marr[mi].e.r > marr[mi].s.r)
        attr["ss:MergeDown"] = marr[mi].e.r - marr[mi].s.r;
    }
  }
  var t = "", p = "";
  switch (cell.t) {
    case "z":
      if (!opts.sheetStubs)
        return "";
      break;
    case "n":
      t = "Number";
      p = String(cell.v);
      break;
    case "b":
      t = "Boolean";
      p = cell.v ? "1" : "0";
      break;
    case "e":
      t = "Error";
      p = BErr[cell.v];
      break;
    case "d":
      t = "DateTime";
      p = new Date(cell.v).toISOString();
      if (cell.z == null)
        cell.z = cell.z || table_fmt[14];
      break;
    case "s":
      t = "String";
      p = escapexlml(cell.v || "");
      break;
  }
  var os = get_cell_style(opts.cellXfs, cell, opts);
  attr["ss:StyleID"] = "s" + (21 + os);
  attr["ss:Index"] = addr.c + 1;
  var _v = cell.v != null ? p : "";
  var m = cell.t == "z" ? "" : '<Data ss:Type="' + t + '">' + _v + "</Data>";
  if ((cell.c || []).length > 0)
    m += write_ws_xlml_comment(cell.c);
  return writextag("Cell", m, attr);
}
function write_ws_xlml_row(R, row) {
  var o = '<Row ss:Index="' + (R + 1) + '"';
  if (row) {
    if (row.hpt && !row.hpx)
      row.hpx = pt2px(row.hpt);
    if (row.hpx)
      o += ' ss:AutoFitHeight="0" ss:Height="' + row.hpx + '"';
    if (row.hidden)
      o += ' ss:Hidden="1"';
  }
  return o + ">";
}
function write_ws_xlml_table(ws, opts, idx, wb) {
  if (!ws["!ref"])
    return "";
  var range = safe_decode_range(ws["!ref"]);
  var marr = ws["!merges"] || [], mi = 0;
  var o = [];
  if (ws["!cols"])
    ws["!cols"].forEach(function(n, i) {
      process_col(n);
      var w2 = !!n.width;
      var p = col_obj_w(i, n);
      var k = { "ss:Index": i + 1 };
      if (w2)
        k["ss:Width"] = width2px(p.width);
      if (n.hidden)
        k["ss:Hidden"] = "1";
      o.push(writextag("Column", null, k));
    });
  var dense = ws["!data"] != null;
  for (var R = range.s.r; R <= range.e.r; ++R) {
    var row = [write_ws_xlml_row(R, (ws["!rows"] || [])[R])];
    for (var C = range.s.c; C <= range.e.c; ++C) {
      var skip = false;
      for (mi = 0; mi != marr.length; ++mi) {
        if (marr[mi].s.c > C)
          continue;
        if (marr[mi].s.r > R)
          continue;
        if (marr[mi].e.c < C)
          continue;
        if (marr[mi].e.r < R)
          continue;
        if (marr[mi].s.c != C || marr[mi].s.r != R)
          skip = true;
        break;
      }
      if (skip)
        continue;
      var addr = { r: R, c: C };
      var ref = encode_col(C) + encode_row(R), cell = dense ? (ws["!data"][R] || [])[C] : ws[ref];
      row.push(write_ws_xlml_cell(cell, ref, ws, opts, idx, wb, addr));
    }
    row.push("</Row>");
    if (row.length > 2)
      o.push(row.join(""));
  }
  return o.join("");
}
function write_ws_xlml(idx, opts, wb) {
  var o = [];
  var s = wb.SheetNames[idx];
  var ws = wb.Sheets[s];
  var t = ws ? write_ws_xlml_names(ws, opts, idx, wb) : "";
  if (t.length > 0)
    o.push("<Names>" + t + "</Names>");
  t = ws ? write_ws_xlml_table(ws, opts, idx, wb) : "";
  if (t.length > 0)
    o.push("<Table>" + t + "</Table>");
  o.push(write_ws_xlml_wsopts(ws, opts, idx, wb));
  if (ws["!autofilter"])
    o.push('<AutoFilter x:Range="' + a1_to_rc(fix_range(ws["!autofilter"].ref), { r: 0, c: 0 }) + '" xmlns="urn:schemas-microsoft-com:office:excel"></AutoFilter>');
  return o.join("");
}
function write_xlml(wb, opts) {
  if (!opts)
    opts = {};
  if (!wb.SSF)
    wb.SSF = dup(table_fmt);
  if (wb.SSF) {
    make_ssf();
    SSF_load_table(wb.SSF);
    opts.revssf = evert_num(wb.SSF);
    opts.revssf[wb.SSF[65535]] = 0;
    opts.ssf = wb.SSF;
    opts.cellXfs = [];
    get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
  }
  var d = [];
  d.push(write_props_xlml(wb, opts));
  d.push(write_wb_xlml(wb));
  d.push("");
  d.push("");
  for (var i = 0; i < wb.SheetNames.length; ++i)
    d.push(writextag("Worksheet", write_ws_xlml(i, opts, wb), { "ss:Name": escapexml(wb.SheetNames[i]) }));
  d[2] = write_sty_xlml(wb, opts);
  d[3] = write_names_xlml(wb);
  return XML_HEADER + writextag("Workbook", d.join(""), {
    "xmlns": XLMLNS.ss,
    "xmlns:o": XLMLNS.o,
    "xmlns:x": XLMLNS.x,
    "xmlns:ss": XLMLNS.ss,
    "xmlns:dt": XLMLNS.dt,
    "xmlns:html": XLMLNS.html
  });
}
function parse_compobj(obj) {
  var v = {};
  var o = obj.content;
  o.l = 28;
  v.AnsiUserType = o.read_shift(0, "lpstr-ansi");
  v.AnsiClipboardFormat = parse_ClipboardFormatOrAnsiString(o);
  if (o.length - o.l <= 4)
    return v;
  var m = o.read_shift(4);
  if (m == 0 || m > 40)
    return v;
  o.l -= 4;
  v.Reserved1 = o.read_shift(0, "lpstr-ansi");
  if (o.length - o.l <= 4)
    return v;
  m = o.read_shift(4);
  if (m !== 1907505652)
    return v;
  v.UnicodeClipboardFormat = parse_ClipboardFormatOrUnicodeString(o);
  m = o.read_shift(4);
  if (m == 0 || m > 40)
    return v;
  o.l -= 4;
  v.Reserved2 = o.read_shift(0, "lpwstr");
}
var CONTINUE_RT = [60, 1084, 2066, 2165, 2175];
function slurp(RecordType, R, blob2, length2, opts) {
  var l = length2;
  var bufs = [];
  var d = blob2.slice(blob2.l, blob2.l + l);
  if (opts && opts.enc && opts.enc.insitu && d.length > 0)
    switch (RecordType) {
      case 9:
      case 521:
      case 1033:
      case 2057:
      case 47:
      case 405:
      case 225:
      case 406:
      case 312:
      case 404:
      case 10:
        break;
      case 133:
        break;
      default:
        opts.enc.insitu(d);
    }
  bufs.push(d);
  blob2.l += l;
  var nextrt = __readUInt16LE(blob2, blob2.l), next2 = XLSRecordEnum[nextrt];
  var start = 0;
  while (next2 != null && CONTINUE_RT.indexOf(nextrt) > -1) {
    l = __readUInt16LE(blob2, blob2.l + 2);
    start = blob2.l + 4;
    if (nextrt == 2066)
      start += 4;
    else if (nextrt == 2165 || nextrt == 2175) {
      start += 12;
    }
    d = blob2.slice(start, blob2.l + 4 + l);
    bufs.push(d);
    blob2.l += 4 + l;
    next2 = XLSRecordEnum[nextrt = __readUInt16LE(blob2, blob2.l)];
  }
  var b = bconcat(bufs);
  prep_blob(b, 0);
  var ll = 0;
  b.lens = [];
  for (var j = 0; j < bufs.length; ++j) {
    b.lens.push(ll);
    ll += bufs[j].length;
  }
  if (b.length < length2)
    throw "XLS Record 0x" + RecordType.toString(16) + " Truncated: " + b.length + " < " + length2;
  return R.f(b, b.length, opts);
}
function safe_format_xf(p, opts, date1904) {
  if (p.t === "z")
    return;
  if (!p.XF)
    return;
  var fmtid = 0;
  try {
    fmtid = p.z || p.XF.numFmtId || 0;
    if (opts.cellNF)
      p.z = table_fmt[fmtid];
  } catch (e) {
    if (opts.WTF)
      throw e;
  }
  if (!opts || opts.cellText !== false)
    try {
      if (p.t === "e") {
        p.w = p.w || BErr[p.v];
      } else if (fmtid === 0 || fmtid == "General") {
        if (p.t === "n") {
          if ((p.v | 0) === p.v)
            p.w = p.v.toString(10);
          else
            p.w = SSF_general_num(p.v);
        } else
          p.w = SSF_general(p.v);
      } else
        p.w = SSF_format(fmtid, p.v, { date1904: !!date1904, dateNF: opts && opts.dateNF });
    } catch (e) {
      if (opts.WTF)
        throw e;
    }
  if (opts.cellDates && fmtid && p.t == "n" && fmt_is_date(table_fmt[fmtid] || String(fmtid))) {
    var _d2 = SSF_parse_date_code(p.v);
    if (_d2) {
      p.t = "d";
      p.v = new Date(_d2.y, _d2.m - 1, _d2.d, _d2.H, _d2.M, _d2.S, _d2.u);
    }
  }
}
function make_cell(val, ixfe, t) {
  return { v: val, ixfe, t };
}
function parse_workbook(blob2, options2) {
  var wb = { opts: {} };
  var Sheets = {};
  var out = {};
  if (options2.dense)
    out["!data"] = [];
  var Directory = {};
  var range = {};
  var last_formula = null;
  var sst = [];
  var cur_sheet = "";
  var Preamble = {};
  var lastcell, last_cell = "", cc, cmnt, rngC, rngR;
  var sharedf = {};
  var arrayf = [];
  var temp_val;
  var country;
  var XFs = [];
  var palette = [];
  var Workbook = { Sheets: [], WBProps: { date1904: false }, Views: [{}] }, wsprops = {};
  var get_rgb = function getrgb(icv) {
    if (icv < 8)
      return XLSIcv[icv];
    if (icv < 64)
      return palette[icv - 8] || XLSIcv[icv];
    return XLSIcv[icv];
  };
  var process_cell_style = function pcs(cell, line2, options3) {
    var xfd = line2.XF.data;
    if (!xfd || !xfd.patternType || !options3 || !options3.cellStyles)
      return;
    line2.s = {};
    line2.s.patternType = xfd.patternType;
    var t;
    if (t = rgb2Hex(get_rgb(xfd.icvFore))) {
      line2.s.fgColor = { rgb: t };
    }
    if (t = rgb2Hex(get_rgb(xfd.icvBack))) {
      line2.s.bgColor = { rgb: t };
    }
  };
  var addcell = function addcell2(cell, line2, options3) {
    if (file_depth > 1)
      return;
    if (options3.sheetRows && cell.r >= options3.sheetRows)
      return;
    if (options3.cellStyles && line2.XF && line2.XF.data)
      process_cell_style(cell, line2, options3);
    delete line2.ixfe;
    delete line2.XF;
    lastcell = cell;
    last_cell = encode_cell(cell);
    if (!range || !range.s || !range.e)
      range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    if (cell.r < range.s.r)
      range.s.r = cell.r;
    if (cell.c < range.s.c)
      range.s.c = cell.c;
    if (cell.r + 1 > range.e.r)
      range.e.r = cell.r + 1;
    if (cell.c + 1 > range.e.c)
      range.e.c = cell.c + 1;
    if (options3.cellFormula && line2.f) {
      for (var afi = 0; afi < arrayf.length; ++afi) {
        if (arrayf[afi][0].s.c > cell.c || arrayf[afi][0].s.r > cell.r)
          continue;
        if (arrayf[afi][0].e.c < cell.c || arrayf[afi][0].e.r < cell.r)
          continue;
        line2.F = encode_range(arrayf[afi][0]);
        if (arrayf[afi][0].s.c != cell.c || arrayf[afi][0].s.r != cell.r)
          delete line2.f;
        if (line2.f)
          line2.f = "" + stringify_formula(arrayf[afi][1], range, cell, supbooks, opts);
        break;
      }
    }
    {
      if (options3.dense) {
        if (!out["!data"][cell.r])
          out["!data"][cell.r] = [];
        out["!data"][cell.r][cell.c] = line2;
      } else
        out[last_cell] = line2;
    }
  };
  var opts = {
    enc: false,
    // encrypted
    sbcch: 0,
    // cch in the preceding SupBook
    snames: [],
    // sheetnames
    sharedf,
    // shared formulae by address
    arrayf,
    // array formulae array
    rrtabid: [],
    // RRTabId
    lastuser: "",
    // Last User from WriteAccess
    biff: 8,
    // BIFF version
    codepage: 0,
    // CP from CodePage record
    winlocked: 0,
    // fLockWn from WinProtect
    cellStyles: !!options2 && !!options2.cellStyles,
    WTF: !!options2 && !!options2.wtf
  };
  if (options2.password)
    opts.password = options2.password;
  var themes;
  var merges = [];
  var objects = [];
  var colinfo = [], rowinfo = [];
  var seencol = false;
  var supbooks = [];
  supbooks.SheetNames = opts.snames;
  supbooks.sharedf = opts.sharedf;
  supbooks.arrayf = opts.arrayf;
  supbooks.names = [];
  supbooks.XTI = [];
  var last_RT = 0;
  var file_depth = 0;
  var BIFF2Fmt = 0, BIFF2FmtTable = [];
  var FilterDatabases = [];
  var last_lbl;
  opts.codepage = 1200;
  set_cp(1200);
  var seen_codepage = false;
  while (blob2.l < blob2.length - 1) {
    var s = blob2.l;
    var RecordType = blob2.read_shift(2);
    if (RecordType === 0 && last_RT === 10)
      break;
    var length2 = blob2.l === blob2.length ? 0 : blob2.read_shift(2);
    var R = XLSRecordEnum[RecordType];
    if (file_depth == 0 && [9, 521, 1033, 2057].indexOf(RecordType) == -1)
      break;
    if (R && R.f) {
      if (options2.bookSheets) {
        if (last_RT === 133 && RecordType !== 133)
          break;
      }
      last_RT = RecordType;
      if (R.r === 2 || R.r == 12) {
        var rt = blob2.read_shift(2);
        length2 -= 2;
        if (!opts.enc && rt !== RecordType && ((rt & 255) << 8 | rt >> 8) !== RecordType)
          throw new Error("rt mismatch: " + rt + "!=" + RecordType);
        if (R.r == 12) {
          blob2.l += 10;
          length2 -= 10;
        }
      }
      var val = {};
      if (RecordType === 10)
        val = /*::(*/
        R.f(blob2, length2, opts);
      else
        val = /*::(*/
        slurp(RecordType, R, blob2, length2, opts);
      if (file_depth == 0 && [9, 521, 1033, 2057].indexOf(last_RT) === -1)
        continue;
      switch (RecordType) {
        case 34:
          wb.opts.Date1904 = Workbook.WBProps.date1904 = val;
          break;
        case 134:
          wb.opts.WriteProtect = true;
          break;
        case 47:
          if (!opts.enc)
            blob2.l = 0;
          opts.enc = val;
          if (!options2.password)
            throw new Error("File is password-protected");
          if (val.valid == null)
            throw new Error("Encryption scheme unsupported");
          if (!val.valid)
            throw new Error("Password is incorrect");
          break;
        case 92:
          opts.lastuser = val;
          break;
        case 66:
          var cpval = Number(val);
          switch (cpval) {
            case 21010:
              cpval = 1200;
              break;
            case 32768:
              cpval = 1e4;
              break;
            case 32769:
              cpval = 1252;
              break;
          }
          set_cp(opts.codepage = cpval);
          seen_codepage = true;
          break;
        case 317:
          opts.rrtabid = val;
          break;
        case 25:
          opts.winlocked = val;
          break;
        case 439:
          wb.opts["RefreshAll"] = val;
          break;
        case 12:
          wb.opts["CalcCount"] = val;
          break;
        case 16:
          wb.opts["CalcDelta"] = val;
          break;
        case 17:
          wb.opts["CalcIter"] = val;
          break;
        case 13:
          wb.opts["CalcMode"] = val;
          break;
        case 14:
          wb.opts["CalcPrecision"] = val;
          break;
        case 95:
          wb.opts["CalcSaveRecalc"] = val;
          break;
        case 15:
          opts.CalcRefMode = val;
          break;
        case 2211:
          wb.opts.FullCalc = val;
          break;
        case 129:
          if (val.fDialog)
            out["!type"] = "dialog";
          if (!val.fBelow)
            (out["!outline"] || (out["!outline"] = {})).above = true;
          if (!val.fRight)
            (out["!outline"] || (out["!outline"] = {})).left = true;
          break;
        case 224:
          XFs.push(val);
          break;
        case 430:
          supbooks.push([val]);
          supbooks[supbooks.length - 1].XTI = [];
          break;
        case 35:
        case 547:
          supbooks[supbooks.length - 1].push(val);
          break;
        case 24:
        case 536:
          last_lbl = {
            Name: val.Name,
            Ref: stringify_formula(val.rgce, range, null, supbooks, opts)
          };
          if (val.itab > 0)
            last_lbl.Sheet = val.itab - 1;
          supbooks.names.push(last_lbl);
          if (!supbooks[0]) {
            supbooks[0] = [];
            supbooks[0].XTI = [];
          }
          supbooks[supbooks.length - 1].push(val);
          if (val.Name == "_xlnm._FilterDatabase" && val.itab > 0) {
            if (val.rgce && val.rgce[0] && val.rgce[0][0] && val.rgce[0][0][0] == "PtgArea3d")
              FilterDatabases[val.itab - 1] = { ref: encode_range(val.rgce[0][0][1][2]) };
          }
          break;
        case 22:
          opts.ExternCount = val;
          break;
        case 23:
          if (supbooks.length == 0) {
            supbooks[0] = [];
            supbooks[0].XTI = [];
          }
          supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
          supbooks.XTI = supbooks.XTI.concat(val);
          break;
        case 2196:
          if (opts.biff < 8)
            break;
          if (last_lbl != null)
            last_lbl.Comment = val[1];
          break;
        case 18:
          out["!protect"] = val;
          break;
        case 19:
          if (val !== 0 && opts.WTF)
            console.error("Password verifier: " + val);
          break;
        case 133:
          {
            Directory[val.pos] = val;
            opts.snames.push(val.name);
          }
          break;
        case 10:
          {
            if (--file_depth)
              break;
            if (range.e) {
              if (range.e.r > 0 && range.e.c > 0) {
                range.e.r--;
                range.e.c--;
                out["!ref"] = encode_range(range);
                if (options2.sheetRows && options2.sheetRows <= range.e.r) {
                  var tmpri = range.e.r;
                  range.e.r = options2.sheetRows - 1;
                  out["!fullref"] = out["!ref"];
                  out["!ref"] = encode_range(range);
                  range.e.r = tmpri;
                }
                range.e.r++;
                range.e.c++;
              }
              if (merges.length > 0)
                out["!merges"] = merges;
              if (objects.length > 0)
                out["!objects"] = objects;
              if (colinfo.length > 0)
                out["!cols"] = colinfo;
              if (rowinfo.length > 0)
                out["!rows"] = rowinfo;
              Workbook.Sheets.push(wsprops);
            }
            if (cur_sheet === "")
              Preamble = out;
            else
              Sheets[cur_sheet] = out;
            out = {};
            if (options2.dense)
              out["!data"] = [];
          }
          break;
        case 9:
        case 521:
        case 1033:
        case 2057:
          {
            if (opts.biff === 8)
              opts.biff = {
                /*::[*/
                9: 2,
                /*::[*/
                521: 3,
                /*::[*/
                1033: 4
              }[RecordType] || {
                /*::[*/
                512: 2,
                /*::[*/
                768: 3,
                /*::[*/
                1024: 4,
                /*::[*/
                1280: 5,
                /*::[*/
                1536: 8,
                /*::[*/
                2: 2,
                /*::[*/
                7: 2
              }[val.BIFFVer] || 8;
            opts.biffguess = val.BIFFVer == 0;
            if (val.BIFFVer == 0 && val.dt == 4096) {
              opts.biff = 5;
              seen_codepage = true;
              set_cp(opts.codepage = 28591);
            }
            if (opts.biff == 8 && val.BIFFVer == 0 && val.dt == 16)
              opts.biff = 2;
            if (file_depth++)
              break;
            out = {};
            if (options2.dense)
              out["!data"] = [];
            if (opts.biff < 8 && !seen_codepage) {
              seen_codepage = true;
              set_cp(opts.codepage = options2.codepage || 1252);
            }
            if (opts.biff < 5 || val.BIFFVer == 0 && val.dt == 4096) {
              if (cur_sheet === "")
                cur_sheet = "Sheet1";
              range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              var fakebs8 = { pos: blob2.l - length2, name: cur_sheet };
              Directory[fakebs8.pos] = fakebs8;
              opts.snames.push(cur_sheet);
            } else
              cur_sheet = (Directory[s] || { name: "" }).name;
            if (val.dt == 32)
              out["!type"] = "chart";
            if (val.dt == 64)
              out["!type"] = "macro";
            merges = [];
            objects = [];
            opts.arrayf = arrayf = [];
            colinfo = [];
            rowinfo = [];
            seencol = false;
            wsprops = { Hidden: (Directory[s] || { hs: 0 }).hs, name: cur_sheet };
          }
          break;
        case 515:
        case 3:
        case 2:
          {
            if (out["!type"] == "chart") {
              if (options2.dense ? (out["!data"][val.r] || [])[val.c] : out[encode_col(val.c) + encode_row(val.r)])
                ++val.c;
            }
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe] || {}, v: val.val, t: "n" };
            if (BIFF2Fmt > 0)
              temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options2, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options2);
          }
          break;
        case 5:
        case 517:
          {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], v: val.val, t: val.t };
            if (BIFF2Fmt > 0)
              temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options2, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options2);
          }
          break;
        case 638:
          {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], v: val.rknum, t: "n" };
            if (BIFF2Fmt > 0)
              temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options2, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options2);
          }
          break;
        case 189:
          {
            for (var j = val.c; j <= val.C; ++j) {
              var ixfe = val.rkrec[j - val.c][0];
              temp_val = { ixfe, XF: XFs[ixfe], v: val.rkrec[j - val.c][1], t: "n" };
              if (BIFF2Fmt > 0)
                temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options2, wb.opts.Date1904);
              addcell({ c: j, r: val.r }, temp_val, options2);
            }
          }
          break;
        case 6:
        case 518:
        case 1030:
          {
            if (val.val == "String") {
              last_formula = val;
              break;
            }
            temp_val = make_cell(val.val, val.cell.ixfe, val.tt);
            temp_val.XF = XFs[temp_val.ixfe];
            if (options2.cellFormula) {
              var _f = val.formula;
              if (_f && _f[0] && _f[0][0] && _f[0][0][0] == "PtgExp") {
                var _fr = _f[0][0][1][0], _fc = _f[0][0][1][1];
                var _fe = encode_cell({ r: _fr, c: _fc });
                if (sharedf[_fe])
                  temp_val.f = "" + stringify_formula(val.formula, range, val.cell, supbooks, opts);
                else
                  temp_val.F = ((options2.dense ? (out["!data"][_fr] || [])[_fc] : out[_fe]) || {}).F;
              } else
                temp_val.f = "" + stringify_formula(val.formula, range, val.cell, supbooks, opts);
            }
            if (BIFF2Fmt > 0)
              temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options2, wb.opts.Date1904);
            addcell(val.cell, temp_val, options2);
            last_formula = val;
          }
          break;
        case 7:
        case 519:
          {
            if (last_formula) {
              last_formula.val = val;
              temp_val = make_cell(val, last_formula.cell.ixfe, "s");
              temp_val.XF = XFs[temp_val.ixfe];
              if (options2.cellFormula) {
                temp_val.f = "" + stringify_formula(last_formula.formula, range, last_formula.cell, supbooks, opts);
              }
              if (BIFF2Fmt > 0)
                temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options2, wb.opts.Date1904);
              addcell(last_formula.cell, temp_val, options2);
              last_formula = null;
            } else
              throw new Error("String record expects Formula");
          }
          break;
        case 33:
        case 545:
          {
            arrayf.push(val);
            var _arraystart = encode_cell(val[0].s);
            cc = options2.dense ? (out["!data"][val[0].s.r] || [])[val[0].s.c] : out[_arraystart];
            if (options2.cellFormula && cc) {
              if (!last_formula)
                break;
              if (!_arraystart || !cc)
                break;
              cc.f = "" + stringify_formula(val[1], range, val[0], supbooks, opts);
              cc.F = encode_range(val[0]);
            }
          }
          break;
        case 1212:
          {
            if (!options2.cellFormula)
              break;
            if (last_cell) {
              if (!last_formula)
                break;
              sharedf[encode_cell(last_formula.cell)] = val[0];
              cc = options2.dense ? (out["!data"][last_formula.cell.r] || [])[last_formula.cell.c] : out[encode_cell(last_formula.cell)];
              (cc || {}).f = "" + stringify_formula(val[0], range, lastcell, supbooks, opts);
            }
          }
          break;
        case 253:
          temp_val = make_cell(sst[val.isst].t, val.ixfe, "s");
          if (sst[val.isst].h)
            temp_val.h = sst[val.isst].h;
          temp_val.XF = XFs[temp_val.ixfe];
          if (BIFF2Fmt > 0)
            temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
          safe_format_xf(temp_val, options2, wb.opts.Date1904);
          addcell({ c: val.c, r: val.r }, temp_val, options2);
          break;
        case 513:
          if (options2.sheetStubs) {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], t: "z" };
            if (BIFF2Fmt > 0)
              temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options2, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options2);
          }
          break;
        case 190:
          if (options2.sheetStubs) {
            for (var _j = val.c; _j <= val.C; ++_j) {
              var _ixfe = val.ixfe[_j - val.c];
              temp_val = { ixfe: _ixfe, XF: XFs[_ixfe], t: "z" };
              if (BIFF2Fmt > 0)
                temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options2, wb.opts.Date1904);
              addcell({ c: _j, r: val.r }, temp_val, options2);
            }
          }
          break;
        case 214:
        case 516:
        case 4:
          temp_val = make_cell(val.val, val.ixfe, "s");
          temp_val.XF = XFs[temp_val.ixfe];
          if (BIFF2Fmt > 0)
            temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
          safe_format_xf(temp_val, options2, wb.opts.Date1904);
          addcell({ c: val.c, r: val.r }, temp_val, options2);
          break;
        case 0:
        case 512:
          {
            if (file_depth === 1)
              range = val;
          }
          break;
        case 252:
          {
            sst = val;
          }
          break;
        case 1054:
          {
            if (opts.biff == 4) {
              BIFF2FmtTable[BIFF2Fmt++] = val[1];
              for (var b4idx = 0; b4idx < BIFF2Fmt + 163; ++b4idx)
                if (table_fmt[b4idx] == val[1])
                  break;
              if (b4idx >= 163)
                SSF__load(val[1], BIFF2Fmt + 163);
            } else
              SSF__load(val[1], val[0]);
          }
          break;
        case 30:
          {
            BIFF2FmtTable[BIFF2Fmt++] = val;
            for (var b2idx = 0; b2idx < BIFF2Fmt + 163; ++b2idx)
              if (table_fmt[b2idx] == val)
                break;
            if (b2idx >= 163)
              SSF__load(val, BIFF2Fmt + 163);
          }
          break;
        case 229:
          merges = merges.concat(val);
          break;
        case 93:
          objects[val.cmo[0]] = opts.lastobj = val;
          break;
        case 438:
          opts.lastobj.TxO = val;
          break;
        case 127:
          opts.lastobj.ImData = val;
          break;
        case 440:
          {
            for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
              for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                cc = options2.dense ? (out["!data"][rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                if (cc)
                  cc.l = val[1];
              }
          }
          break;
        case 2048:
          {
            for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
              for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                cc = options2.dense ? (out["!data"][rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                if (cc && cc.l)
                  cc.l.Tooltip = val[1];
              }
          }
          break;
        case 28:
          {
            if (opts.biff <= 5 && opts.biff >= 2)
              break;
            cc = options2.dense ? (out["!data"][val[0].r] || [])[val[0].c] : out[encode_cell(val[0])];
            var noteobj = objects[val[2]];
            if (!cc) {
              if (options2.dense) {
                if (!out["!data"][val[0].r])
                  out["!data"][val[0].r] = [];
                cc = out["!data"][val[0].r][val[0].c] = { t: "z" };
              } else {
                cc = out[encode_cell(val[0])] = { t: "z" };
              }
              range.e.r = Math.max(range.e.r, val[0].r);
              range.s.r = Math.min(range.s.r, val[0].r);
              range.e.c = Math.max(range.e.c, val[0].c);
              range.s.c = Math.min(range.s.c, val[0].c);
            }
            if (!cc.c)
              cc.c = [];
            cmnt = { a: val[1], t: noteobj.TxO.t };
            cc.c.push(cmnt);
          }
          break;
        case 2173:
          update_xfext(XFs[val.ixfe], val.ext);
          break;
        case 125:
          {
            if (!opts.cellStyles)
              break;
            while (val.e >= val.s) {
              colinfo[val.e--] = { width: val.w / 256, level: val.level || 0, hidden: !!(val.flags & 1) };
              if (!seencol) {
                seencol = true;
                find_mdw_colw(val.w / 256);
              }
              process_col(colinfo[val.e + 1]);
            }
          }
          break;
        case 520:
          {
            var rowobj = {};
            if (val.level != null) {
              rowinfo[val.r] = rowobj;
              rowobj.level = val.level;
            }
            if (val.hidden) {
              rowinfo[val.r] = rowobj;
              rowobj.hidden = true;
            }
            if (val.hpt) {
              rowinfo[val.r] = rowobj;
              rowobj.hpt = val.hpt;
              rowobj.hpx = pt2px(val.hpt);
            }
          }
          break;
        case 38:
        case 39:
        case 40:
        case 41:
          if (!out["!margins"])
            default_margins(out["!margins"] = {});
          out["!margins"][{ 38: "left", 39: "right", 40: "top", 41: "bottom" }[RecordType]] = val;
          break;
        case 161:
          if (!out["!margins"])
            default_margins(out["!margins"] = {});
          out["!margins"].header = val.header;
          out["!margins"].footer = val.footer;
          break;
        case 574:
          if (val.RTL)
            Workbook.Views[0].RTL = true;
          break;
        case 146:
          palette = val;
          break;
        case 2198:
          themes = val;
          break;
        case 140:
          country = val;
          break;
        case 442:
          {
            if (!cur_sheet)
              Workbook.WBProps.CodeName = val || "ThisWorkbook";
            else
              wsprops.CodeName = val || wsprops.name;
          }
          break;
      }
    } else {
      if (!R)
        console.error("Missing Info for XLS Record 0x" + RecordType.toString(16));
      blob2.l += length2;
    }
  }
  wb.SheetNames = keys(Directory).sort(function(a, b) {
    return Number(a) - Number(b);
  }).map(function(x) {
    return Directory[x].name;
  });
  if (!options2.bookSheets)
    wb.Sheets = Sheets;
  if (!wb.SheetNames.length && Preamble["!ref"]) {
    wb.SheetNames.push("Sheet1");
    if (wb.Sheets)
      wb.Sheets["Sheet1"] = Preamble;
  } else
    wb.Preamble = Preamble;
  if (wb.Sheets)
    FilterDatabases.forEach(function(r, i) {
      wb.Sheets[wb.SheetNames[i]]["!autofilter"] = r;
    });
  wb.Strings = sst;
  wb.SSF = dup(table_fmt);
  if (opts.enc)
    wb.Encryption = opts.enc;
  if (themes)
    wb.Themes = themes;
  wb.Metadata = {};
  if (country !== void 0)
    wb.Metadata.Country = country;
  if (supbooks.names.length > 0)
    Workbook.Names = supbooks.names;
  wb.Workbook = Workbook;
  return wb;
}
var PSCLSID = {
  SI: "e0859ff2f94f6810ab9108002b27b3d9",
  DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
};
function parse_xls_props(cfb, props, o) {
  var DSI = CFB.find(cfb, "/!DocumentSummaryInformation");
  if (DSI && DSI.size > 0)
    try {
      var DocSummary = parse_PropertySetStream(DSI, DocSummaryPIDDSI, PSCLSID.DSI);
      for (var d in DocSummary)
        props[d] = DocSummary[d];
    } catch (e) {
      if (o.WTF)
        throw e;
    }
  var SI = CFB.find(cfb, "/!SummaryInformation");
  if (SI && SI.size > 0)
    try {
      var Summary = parse_PropertySetStream(SI, SummaryPIDSI, PSCLSID.SI);
      for (var s in Summary)
        if (props[s] == null)
          props[s] = Summary[s];
    } catch (e) {
      if (o.WTF)
        throw e;
    }
  if (props.HeadingPairs && props.TitlesOfParts) {
    load_props_pairs(props.HeadingPairs, props.TitlesOfParts, props, o);
    delete props.HeadingPairs;
    delete props.TitlesOfParts;
  }
}
function write_xls_props(wb, cfb) {
  var DSEntries = [], SEntries = [], CEntries = [];
  var i = 0, Keys;
  var DocSummaryRE = evert_key(DocSummaryPIDDSI, "n");
  var SummaryRE = evert_key(SummaryPIDSI, "n");
  if (wb.Props) {
    Keys = keys(wb.Props);
    for (i = 0; i < Keys.length; ++i)
      (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Props[Keys[i]]]);
  }
  if (wb.Custprops) {
    Keys = keys(wb.Custprops);
    for (i = 0; i < Keys.length; ++i)
      if (!Object.prototype.hasOwnProperty.call(wb.Props || {}, Keys[i]))
        (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i]) ? SEntries : CEntries).push([Keys[i], wb.Custprops[Keys[i]]]);
  }
  var CEntries2 = [];
  for (i = 0; i < CEntries.length; ++i) {
    if (XLSPSSkip.indexOf(CEntries[i][0]) > -1 || PseudoPropsPairs.indexOf(CEntries[i][0]) > -1)
      continue;
    if (CEntries[i][1] == null)
      continue;
    CEntries2.push(CEntries[i]);
  }
  if (SEntries.length)
    CFB.utils.cfb_add(cfb, "/SummaryInformation", write_PropertySetStream(SEntries, PSCLSID.SI, SummaryRE, SummaryPIDSI));
  if (DSEntries.length || CEntries2.length)
    CFB.utils.cfb_add(cfb, "/DocumentSummaryInformation", write_PropertySetStream(DSEntries, PSCLSID.DSI, DocSummaryRE, DocSummaryPIDDSI, CEntries2.length ? CEntries2 : null, PSCLSID.UDI));
}
function parse_xlscfb(cfb, options2) {
  if (!options2)
    options2 = {};
  fix_read_opts(options2);
  reset_cp();
  if (options2.codepage)
    set_ansi(options2.codepage);
  var CompObj, WB;
  if (cfb.FullPaths) {
    if (CFB.find(cfb, "/encryption"))
      throw new Error("File is password-protected");
    CompObj = CFB.find(cfb, "!CompObj");
    WB = CFB.find(cfb, "/Workbook") || CFB.find(cfb, "/Book");
  } else {
    switch (options2.type) {
      case "base64":
        cfb = s2a(Base64_decode(cfb));
        break;
      case "binary":
        cfb = s2a(cfb);
        break;
      case "buffer":
        break;
      case "array":
        if (!Array.isArray(cfb))
          cfb = Array.prototype.slice.call(cfb);
        break;
    }
    prep_blob(cfb, 0);
    WB = { content: cfb };
  }
  var WorkbookP;
  var _data;
  if (CompObj)
    parse_compobj(CompObj);
  if (options2.bookProps && !options2.bookSheets)
    WorkbookP = {};
  else {
    var T = has_buf ? "buffer" : "array";
    if (WB && WB.content)
      WorkbookP = parse_workbook(WB.content, options2);
    else if ((_data = CFB.find(cfb, "PerfectOffice_MAIN")) && _data.content)
      WorkbookP = WK_.to_workbook(_data.content, (options2.type = T, options2));
    else if ((_data = CFB.find(cfb, "NativeContent_MAIN")) && _data.content)
      WorkbookP = WK_.to_workbook(_data.content, (options2.type = T, options2));
    else if ((_data = CFB.find(cfb, "MN0")) && _data.content)
      throw new Error("Unsupported Works 4 for Mac file");
    else
      throw new Error("Cannot find Workbook stream");
    if (options2.bookVBA && cfb.FullPaths && CFB.find(cfb, "/_VBA_PROJECT_CUR/VBA/dir"))
      WorkbookP.vbaraw = make_vba_xls(cfb);
  }
  var props = {};
  if (cfb.FullPaths)
    parse_xls_props(
      /*::((*/
      cfb,
      props,
      options2
    );
  WorkbookP.Props = WorkbookP.Custprops = props;
  if (options2.bookFiles)
    WorkbookP.cfb = cfb;
  return WorkbookP;
}
function write_xlscfb(wb, opts) {
  var o = opts || {};
  var cfb = CFB.utils.cfb_new({ root: "R" });
  var wbpath = "/Workbook";
  switch (o.bookType || "xls") {
    case "xls":
      o.bookType = "biff8";
    case "xla":
      if (!o.bookType)
        o.bookType = "xla";
    case "biff8":
      wbpath = "/Workbook";
      o.biff = 8;
      break;
    case "biff5":
      wbpath = "/Book";
      o.biff = 5;
      break;
    default:
      throw new Error("invalid type " + o.bookType + " for XLS CFB");
  }
  CFB.utils.cfb_add(cfb, wbpath, write_biff_buf(wb, o));
  if (o.biff == 8 && (wb.Props || wb.Custprops))
    write_xls_props(wb, cfb);
  if (o.biff == 8 && wb.vbaraw)
    fill_vba_xls(cfb, CFB.read(wb.vbaraw, { type: typeof wb.vbaraw == "string" ? "binary" : "buffer" }));
  return cfb;
}
var XLSBRecordEnum = {
  /*::[*/
  0: {
    /* n:"BrtRowHdr", */
    f: parse_BrtRowHdr
  },
  /*::[*/
  1: {
    /* n:"BrtCellBlank", */
    f: parse_BrtCellBlank
  },
  /*::[*/
  2: {
    /* n:"BrtCellRk", */
    f: parse_BrtCellRk
  },
  /*::[*/
  3: {
    /* n:"BrtCellError", */
    f: parse_BrtCellError
  },
  /*::[*/
  4: {
    /* n:"BrtCellBool", */
    f: parse_BrtCellBool
  },
  /*::[*/
  5: {
    /* n:"BrtCellReal", */
    f: parse_BrtCellReal
  },
  /*::[*/
  6: {
    /* n:"BrtCellSt", */
    f: parse_BrtCellSt
  },
  /*::[*/
  7: {
    /* n:"BrtCellIsst", */
    f: parse_BrtCellIsst
  },
  /*::[*/
  8: {
    /* n:"BrtFmlaString", */
    f: parse_BrtFmlaString
  },
  /*::[*/
  9: {
    /* n:"BrtFmlaNum", */
    f: parse_BrtFmlaNum
  },
  /*::[*/
  10: {
    /* n:"BrtFmlaBool", */
    f: parse_BrtFmlaBool
  },
  /*::[*/
  11: {
    /* n:"BrtFmlaError", */
    f: parse_BrtFmlaError
  },
  /*::[*/
  12: {
    /* n:"BrtShortBlank", */
    f: parse_BrtShortBlank
  },
  /*::[*/
  13: {
    /* n:"BrtShortRk", */
    f: parse_BrtShortRk
  },
  /*::[*/
  14: {
    /* n:"BrtShortError", */
    f: parse_BrtShortError
  },
  /*::[*/
  15: {
    /* n:"BrtShortBool", */
    f: parse_BrtShortBool
  },
  /*::[*/
  16: {
    /* n:"BrtShortReal", */
    f: parse_BrtShortReal
  },
  /*::[*/
  17: {
    /* n:"BrtShortSt", */
    f: parse_BrtShortSt
  },
  /*::[*/
  18: {
    /* n:"BrtShortIsst", */
    f: parse_BrtShortIsst
  },
  /*::[*/
  19: {
    /* n:"BrtSSTItem", */
    f: parse_RichStr
  },
  /*::[*/
  20: {
    /* n:"BrtPCDIMissing" */
  },
  /*::[*/
  21: {
    /* n:"BrtPCDINumber" */
  },
  /*::[*/
  22: {
    /* n:"BrtPCDIBoolean" */
  },
  /*::[*/
  23: {
    /* n:"BrtPCDIError" */
  },
  /*::[*/
  24: {
    /* n:"BrtPCDIString" */
  },
  /*::[*/
  25: {
    /* n:"BrtPCDIDatetime" */
  },
  /*::[*/
  26: {
    /* n:"BrtPCDIIndex" */
  },
  /*::[*/
  27: {
    /* n:"BrtPCDIAMissing" */
  },
  /*::[*/
  28: {
    /* n:"BrtPCDIANumber" */
  },
  /*::[*/
  29: {
    /* n:"BrtPCDIABoolean" */
  },
  /*::[*/
  30: {
    /* n:"BrtPCDIAError" */
  },
  /*::[*/
  31: {
    /* n:"BrtPCDIAString" */
  },
  /*::[*/
  32: {
    /* n:"BrtPCDIADatetime" */
  },
  /*::[*/
  33: {
    /* n:"BrtPCRRecord" */
  },
  /*::[*/
  34: {
    /* n:"BrtPCRRecordDt" */
  },
  /*::[*/
  35: {
    /* n:"BrtFRTBegin", */
    T: 1
  },
  /*::[*/
  36: {
    /* n:"BrtFRTEnd", */
    T: -1
  },
  /*::[*/
  37: {
    /* n:"BrtACBegin", */
    T: 1
  },
  /*::[*/
  38: {
    /* n:"BrtACEnd", */
    T: -1
  },
  /*::[*/
  39: {
    /* n:"BrtName", */
    f: parse_BrtName
  },
  /*::[*/
  40: {
    /* n:"BrtIndexRowBlock" */
  },
  /*::[*/
  42: {
    /* n:"BrtIndexBlock" */
  },
  /*::[*/
  43: {
    /* n:"BrtFont", */
    f: parse_BrtFont
  },
  /*::[*/
  44: {
    /* n:"BrtFmt", */
    f: parse_BrtFmt
  },
  /*::[*/
  45: {
    /* n:"BrtFill", */
    f: parse_BrtFill
  },
  /*::[*/
  46: {
    /* n:"BrtBorder", */
    f: parse_BrtBorder
  },
  /*::[*/
  47: {
    /* n:"BrtXF", */
    f: parse_BrtXF
  },
  /*::[*/
  48: {
    /* n:"BrtStyle" */
  },
  /*::[*/
  49: {
    /* n:"BrtCellMeta", */
    f: parse_Int32LE
  },
  /*::[*/
  50: {
    /* n:"BrtValueMeta" */
  },
  /*::[*/
  51: {
    /* n:"BrtMdb" */
    f: parse_BrtMdb
  },
  /*::[*/
  52: {
    /* n:"BrtBeginFmd", */
    T: 1
  },
  /*::[*/
  53: {
    /* n:"BrtEndFmd", */
    T: -1
  },
  /*::[*/
  54: {
    /* n:"BrtBeginMdx", */
    T: 1
  },
  /*::[*/
  55: {
    /* n:"BrtEndMdx", */
    T: -1
  },
  /*::[*/
  56: {
    /* n:"BrtBeginMdxTuple", */
    T: 1
  },
  /*::[*/
  57: {
    /* n:"BrtEndMdxTuple", */
    T: -1
  },
  /*::[*/
  58: {
    /* n:"BrtMdxMbrIstr" */
  },
  /*::[*/
  59: {
    /* n:"BrtStr" */
  },
  /*::[*/
  60: {
    /* n:"BrtColInfo", */
    f: parse_ColInfo
  },
  /*::[*/
  62: {
    /* n:"BrtCellRString", */
    f: parse_BrtCellRString
  },
  /*::[*/
  63: {
    /* n:"BrtCalcChainItem$", */
    f: parse_BrtCalcChainItem$
  },
  /*::[*/
  64: {
    /* n:"BrtDVal", */
    f: parse_BrtDVal
  },
  /*::[*/
  65: {
    /* n:"BrtSxvcellNum" */
  },
  /*::[*/
  66: {
    /* n:"BrtSxvcellStr" */
  },
  /*::[*/
  67: {
    /* n:"BrtSxvcellBool" */
  },
  /*::[*/
  68: {
    /* n:"BrtSxvcellErr" */
  },
  /*::[*/
  69: {
    /* n:"BrtSxvcellDate" */
  },
  /*::[*/
  70: {
    /* n:"BrtSxvcellNil" */
  },
  /*::[*/
  128: {
    /* n:"BrtFileVersion" */
  },
  /*::[*/
  129: {
    /* n:"BrtBeginSheet", */
    T: 1
  },
  /*::[*/
  130: {
    /* n:"BrtEndSheet", */
    T: -1
  },
  /*::[*/
  131: {
    /* n:"BrtBeginBook", */
    T: 1,
    f: parsenoop,
    p: 0
  },
  /*::[*/
  132: {
    /* n:"BrtEndBook", */
    T: -1
  },
  /*::[*/
  133: {
    /* n:"BrtBeginWsViews", */
    T: 1
  },
  /*::[*/
  134: {
    /* n:"BrtEndWsViews", */
    T: -1
  },
  /*::[*/
  135: {
    /* n:"BrtBeginBookViews", */
    T: 1
  },
  /*::[*/
  136: {
    /* n:"BrtEndBookViews", */
    T: -1
  },
  /*::[*/
  137: {
    /* n:"BrtBeginWsView", */
    T: 1,
    f: parse_BrtBeginWsView
  },
  /*::[*/
  138: {
    /* n:"BrtEndWsView", */
    T: -1
  },
  /*::[*/
  139: {
    /* n:"BrtBeginCsViews", */
    T: 1
  },
  /*::[*/
  140: {
    /* n:"BrtEndCsViews", */
    T: -1
  },
  /*::[*/
  141: {
    /* n:"BrtBeginCsView", */
    T: 1
  },
  /*::[*/
  142: {
    /* n:"BrtEndCsView", */
    T: -1
  },
  /*::[*/
  143: {
    /* n:"BrtBeginBundleShs", */
    T: 1
  },
  /*::[*/
  144: {
    /* n:"BrtEndBundleShs", */
    T: -1
  },
  /*::[*/
  145: {
    /* n:"BrtBeginSheetData", */
    T: 1
  },
  /*::[*/
  146: {
    /* n:"BrtEndSheetData", */
    T: -1
  },
  /*::[*/
  147: {
    /* n:"BrtWsProp", */
    f: parse_BrtWsProp
  },
  /*::[*/
  148: {
    /* n:"BrtWsDim", */
    f: parse_BrtWsDim,
    p: 16
  },
  /*::[*/
  151: {
    /* n:"BrtPane", */
    f: parse_BrtPane
  },
  /*::[*/
  152: {
    /* n:"BrtSel" */
  },
  /*::[*/
  153: {
    /* n:"BrtWbProp", */
    f: parse_BrtWbProp
  },
  /*::[*/
  154: {
    /* n:"BrtWbFactoid" */
  },
  /*::[*/
  155: {
    /* n:"BrtFileRecover" */
  },
  /*::[*/
  156: {
    /* n:"BrtBundleSh", */
    f: parse_BrtBundleSh
  },
  /*::[*/
  157: {
    /* n:"BrtCalcProp" */
  },
  /*::[*/
  158: {
    /* n:"BrtBookView" */
  },
  /*::[*/
  159: {
    /* n:"BrtBeginSst", */
    T: 1,
    f: parse_BrtBeginSst
  },
  /*::[*/
  160: {
    /* n:"BrtEndSst", */
    T: -1
  },
  /*::[*/
  161: {
    /* n:"BrtBeginAFilter", */
    T: 1,
    f: parse_UncheckedRfX
  },
  /*::[*/
  162: {
    /* n:"BrtEndAFilter", */
    T: -1
  },
  /*::[*/
  163: {
    /* n:"BrtBeginFilterColumn", */
    T: 1
  },
  /*::[*/
  164: {
    /* n:"BrtEndFilterColumn", */
    T: -1
  },
  /*::[*/
  165: {
    /* n:"BrtBeginFilters", */
    T: 1
  },
  /*::[*/
  166: {
    /* n:"BrtEndFilters", */
    T: -1
  },
  /*::[*/
  167: {
    /* n:"BrtFilter" */
  },
  /*::[*/
  168: {
    /* n:"BrtColorFilter" */
  },
  /*::[*/
  169: {
    /* n:"BrtIconFilter" */
  },
  /*::[*/
  170: {
    /* n:"BrtTop10Filter" */
  },
  /*::[*/
  171: {
    /* n:"BrtDynamicFilter" */
  },
  /*::[*/
  172: {
    /* n:"BrtBeginCustomFilters", */
    T: 1
  },
  /*::[*/
  173: {
    /* n:"BrtEndCustomFilters", */
    T: -1
  },
  /*::[*/
  174: {
    /* n:"BrtCustomFilter" */
  },
  /*::[*/
  175: {
    /* n:"BrtAFilterDateGroupItem" */
  },
  /*::[*/
  176: {
    /* n:"BrtMergeCell", */
    f: parse_BrtMergeCell
  },
  /*::[*/
  177: {
    /* n:"BrtBeginMergeCells", */
    T: 1
  },
  /*::[*/
  178: {
    /* n:"BrtEndMergeCells", */
    T: -1
  },
  /*::[*/
  179: {
    /* n:"BrtBeginPivotCacheDef", */
    T: 1
  },
  /*::[*/
  180: {
    /* n:"BrtEndPivotCacheDef", */
    T: -1
  },
  /*::[*/
  181: {
    /* n:"BrtBeginPCDFields", */
    T: 1
  },
  /*::[*/
  182: {
    /* n:"BrtEndPCDFields", */
    T: -1
  },
  /*::[*/
  183: {
    /* n:"BrtBeginPCDField", */
    T: 1
  },
  /*::[*/
  184: {
    /* n:"BrtEndPCDField", */
    T: -1
  },
  /*::[*/
  185: {
    /* n:"BrtBeginPCDSource", */
    T: 1
  },
  /*::[*/
  186: {
    /* n:"BrtEndPCDSource", */
    T: -1
  },
  /*::[*/
  187: {
    /* n:"BrtBeginPCDSRange", */
    T: 1
  },
  /*::[*/
  188: {
    /* n:"BrtEndPCDSRange", */
    T: -1
  },
  /*::[*/
  189: {
    /* n:"BrtBeginPCDFAtbl", */
    T: 1
  },
  /*::[*/
  190: {
    /* n:"BrtEndPCDFAtbl", */
    T: -1
  },
  /*::[*/
  191: {
    /* n:"BrtBeginPCDIRun", */
    T: 1
  },
  /*::[*/
  192: {
    /* n:"BrtEndPCDIRun", */
    T: -1
  },
  /*::[*/
  193: {
    /* n:"BrtBeginPivotCacheRecords", */
    T: 1
  },
  /*::[*/
  194: {
    /* n:"BrtEndPivotCacheRecords", */
    T: -1
  },
  /*::[*/
  195: {
    /* n:"BrtBeginPCDHierarchies", */
    T: 1
  },
  /*::[*/
  196: {
    /* n:"BrtEndPCDHierarchies", */
    T: -1
  },
  /*::[*/
  197: {
    /* n:"BrtBeginPCDHierarchy", */
    T: 1
  },
  /*::[*/
  198: {
    /* n:"BrtEndPCDHierarchy", */
    T: -1
  },
  /*::[*/
  199: {
    /* n:"BrtBeginPCDHFieldsUsage", */
    T: 1
  },
  /*::[*/
  200: {
    /* n:"BrtEndPCDHFieldsUsage", */
    T: -1
  },
  /*::[*/
  201: {
    /* n:"BrtBeginExtConnection", */
    T: 1
  },
  /*::[*/
  202: {
    /* n:"BrtEndExtConnection", */
    T: -1
  },
  /*::[*/
  203: {
    /* n:"BrtBeginECDbProps", */
    T: 1
  },
  /*::[*/
  204: {
    /* n:"BrtEndECDbProps", */
    T: -1
  },
  /*::[*/
  205: {
    /* n:"BrtBeginECOlapProps", */
    T: 1
  },
  /*::[*/
  206: {
    /* n:"BrtEndECOlapProps", */
    T: -1
  },
  /*::[*/
  207: {
    /* n:"BrtBeginPCDSConsol", */
    T: 1
  },
  /*::[*/
  208: {
    /* n:"BrtEndPCDSConsol", */
    T: -1
  },
  /*::[*/
  209: {
    /* n:"BrtBeginPCDSCPages", */
    T: 1
  },
  /*::[*/
  210: {
    /* n:"BrtEndPCDSCPages", */
    T: -1
  },
  /*::[*/
  211: {
    /* n:"BrtBeginPCDSCPage", */
    T: 1
  },
  /*::[*/
  212: {
    /* n:"BrtEndPCDSCPage", */
    T: -1
  },
  /*::[*/
  213: {
    /* n:"BrtBeginPCDSCPItem", */
    T: 1
  },
  /*::[*/
  214: {
    /* n:"BrtEndPCDSCPItem", */
    T: -1
  },
  /*::[*/
  215: {
    /* n:"BrtBeginPCDSCSets", */
    T: 1
  },
  /*::[*/
  216: {
    /* n:"BrtEndPCDSCSets", */
    T: -1
  },
  /*::[*/
  217: {
    /* n:"BrtBeginPCDSCSet", */
    T: 1
  },
  /*::[*/
  218: {
    /* n:"BrtEndPCDSCSet", */
    T: -1
  },
  /*::[*/
  219: {
    /* n:"BrtBeginPCDFGroup", */
    T: 1
  },
  /*::[*/
  220: {
    /* n:"BrtEndPCDFGroup", */
    T: -1
  },
  /*::[*/
  221: {
    /* n:"BrtBeginPCDFGItems", */
    T: 1
  },
  /*::[*/
  222: {
    /* n:"BrtEndPCDFGItems", */
    T: -1
  },
  /*::[*/
  223: {
    /* n:"BrtBeginPCDFGRange", */
    T: 1
  },
  /*::[*/
  224: {
    /* n:"BrtEndPCDFGRange", */
    T: -1
  },
  /*::[*/
  225: {
    /* n:"BrtBeginPCDFGDiscrete", */
    T: 1
  },
  /*::[*/
  226: {
    /* n:"BrtEndPCDFGDiscrete", */
    T: -1
  },
  /*::[*/
  227: {
    /* n:"BrtBeginPCDSDTupleCache", */
    T: 1
  },
  /*::[*/
  228: {
    /* n:"BrtEndPCDSDTupleCache", */
    T: -1
  },
  /*::[*/
  229: {
    /* n:"BrtBeginPCDSDTCEntries", */
    T: 1
  },
  /*::[*/
  230: {
    /* n:"BrtEndPCDSDTCEntries", */
    T: -1
  },
  /*::[*/
  231: {
    /* n:"BrtBeginPCDSDTCEMembers", */
    T: 1
  },
  /*::[*/
  232: {
    /* n:"BrtEndPCDSDTCEMembers", */
    T: -1
  },
  /*::[*/
  233: {
    /* n:"BrtBeginPCDSDTCEMember", */
    T: 1
  },
  /*::[*/
  234: {
    /* n:"BrtEndPCDSDTCEMember", */
    T: -1
  },
  /*::[*/
  235: {
    /* n:"BrtBeginPCDSDTCQueries", */
    T: 1
  },
  /*::[*/
  236: {
    /* n:"BrtEndPCDSDTCQueries", */
    T: -1
  },
  /*::[*/
  237: {
    /* n:"BrtBeginPCDSDTCQuery", */
    T: 1
  },
  /*::[*/
  238: {
    /* n:"BrtEndPCDSDTCQuery", */
    T: -1
  },
  /*::[*/
  239: {
    /* n:"BrtBeginPCDSDTCSets", */
    T: 1
  },
  /*::[*/
  240: {
    /* n:"BrtEndPCDSDTCSets", */
    T: -1
  },
  /*::[*/
  241: {
    /* n:"BrtBeginPCDSDTCSet", */
    T: 1
  },
  /*::[*/
  242: {
    /* n:"BrtEndPCDSDTCSet", */
    T: -1
  },
  /*::[*/
  243: {
    /* n:"BrtBeginPCDCalcItems", */
    T: 1
  },
  /*::[*/
  244: {
    /* n:"BrtEndPCDCalcItems", */
    T: -1
  },
  /*::[*/
  245: {
    /* n:"BrtBeginPCDCalcItem", */
    T: 1
  },
  /*::[*/
  246: {
    /* n:"BrtEndPCDCalcItem", */
    T: -1
  },
  /*::[*/
  247: {
    /* n:"BrtBeginPRule", */
    T: 1
  },
  /*::[*/
  248: {
    /* n:"BrtEndPRule", */
    T: -1
  },
  /*::[*/
  249: {
    /* n:"BrtBeginPRFilters", */
    T: 1
  },
  /*::[*/
  250: {
    /* n:"BrtEndPRFilters", */
    T: -1
  },
  /*::[*/
  251: {
    /* n:"BrtBeginPRFilter", */
    T: 1
  },
  /*::[*/
  252: {
    /* n:"BrtEndPRFilter", */
    T: -1
  },
  /*::[*/
  253: {
    /* n:"BrtBeginPNames", */
    T: 1
  },
  /*::[*/
  254: {
    /* n:"BrtEndPNames", */
    T: -1
  },
  /*::[*/
  255: {
    /* n:"BrtBeginPName", */
    T: 1
  },
  /*::[*/
  256: {
    /* n:"BrtEndPName", */
    T: -1
  },
  /*::[*/
  257: {
    /* n:"BrtBeginPNPairs", */
    T: 1
  },
  /*::[*/
  258: {
    /* n:"BrtEndPNPairs", */
    T: -1
  },
  /*::[*/
  259: {
    /* n:"BrtBeginPNPair", */
    T: 1
  },
  /*::[*/
  260: {
    /* n:"BrtEndPNPair", */
    T: -1
  },
  /*::[*/
  261: {
    /* n:"BrtBeginECWebProps", */
    T: 1
  },
  /*::[*/
  262: {
    /* n:"BrtEndECWebProps", */
    T: -1
  },
  /*::[*/
  263: {
    /* n:"BrtBeginEcWpTables", */
    T: 1
  },
  /*::[*/
  264: {
    /* n:"BrtEndECWPTables", */
    T: -1
  },
  /*::[*/
  265: {
    /* n:"BrtBeginECParams", */
    T: 1
  },
  /*::[*/
  266: {
    /* n:"BrtEndECParams", */
    T: -1
  },
  /*::[*/
  267: {
    /* n:"BrtBeginECParam", */
    T: 1
  },
  /*::[*/
  268: {
    /* n:"BrtEndECParam", */
    T: -1
  },
  /*::[*/
  269: {
    /* n:"BrtBeginPCDKPIs", */
    T: 1
  },
  /*::[*/
  270: {
    /* n:"BrtEndPCDKPIs", */
    T: -1
  },
  /*::[*/
  271: {
    /* n:"BrtBeginPCDKPI", */
    T: 1
  },
  /*::[*/
  272: {
    /* n:"BrtEndPCDKPI", */
    T: -1
  },
  /*::[*/
  273: {
    /* n:"BrtBeginDims", */
    T: 1
  },
  /*::[*/
  274: {
    /* n:"BrtEndDims", */
    T: -1
  },
  /*::[*/
  275: {
    /* n:"BrtBeginDim", */
    T: 1
  },
  /*::[*/
  276: {
    /* n:"BrtEndDim", */
    T: -1
  },
  /*::[*/
  277: {
    /* n:"BrtIndexPartEnd" */
  },
  /*::[*/
  278: {
    /* n:"BrtBeginStyleSheet", */
    T: 1
  },
  /*::[*/
  279: {
    /* n:"BrtEndStyleSheet", */
    T: -1
  },
  /*::[*/
  280: {
    /* n:"BrtBeginSXView", */
    T: 1
  },
  /*::[*/
  281: {
    /* n:"BrtEndSXVI", */
    T: -1
  },
  /*::[*/
  282: {
    /* n:"BrtBeginSXVI", */
    T: 1
  },
  /*::[*/
  283: {
    /* n:"BrtBeginSXVIs", */
    T: 1
  },
  /*::[*/
  284: {
    /* n:"BrtEndSXVIs", */
    T: -1
  },
  /*::[*/
  285: {
    /* n:"BrtBeginSXVD", */
    T: 1
  },
  /*::[*/
  286: {
    /* n:"BrtEndSXVD", */
    T: -1
  },
  /*::[*/
  287: {
    /* n:"BrtBeginSXVDs", */
    T: 1
  },
  /*::[*/
  288: {
    /* n:"BrtEndSXVDs", */
    T: -1
  },
  /*::[*/
  289: {
    /* n:"BrtBeginSXPI", */
    T: 1
  },
  /*::[*/
  290: {
    /* n:"BrtEndSXPI", */
    T: -1
  },
  /*::[*/
  291: {
    /* n:"BrtBeginSXPIs", */
    T: 1
  },
  /*::[*/
  292: {
    /* n:"BrtEndSXPIs", */
    T: -1
  },
  /*::[*/
  293: {
    /* n:"BrtBeginSXDI", */
    T: 1
  },
  /*::[*/
  294: {
    /* n:"BrtEndSXDI", */
    T: -1
  },
  /*::[*/
  295: {
    /* n:"BrtBeginSXDIs", */
    T: 1
  },
  /*::[*/
  296: {
    /* n:"BrtEndSXDIs", */
    T: -1
  },
  /*::[*/
  297: {
    /* n:"BrtBeginSXLI", */
    T: 1
  },
  /*::[*/
  298: {
    /* n:"BrtEndSXLI", */
    T: -1
  },
  /*::[*/
  299: {
    /* n:"BrtBeginSXLIRws", */
    T: 1
  },
  /*::[*/
  300: {
    /* n:"BrtEndSXLIRws", */
    T: -1
  },
  /*::[*/
  301: {
    /* n:"BrtBeginSXLICols", */
    T: 1
  },
  /*::[*/
  302: {
    /* n:"BrtEndSXLICols", */
    T: -1
  },
  /*::[*/
  303: {
    /* n:"BrtBeginSXFormat", */
    T: 1
  },
  /*::[*/
  304: {
    /* n:"BrtEndSXFormat", */
    T: -1
  },
  /*::[*/
  305: {
    /* n:"BrtBeginSXFormats", */
    T: 1
  },
  /*::[*/
  306: {
    /* n:"BrtEndSxFormats", */
    T: -1
  },
  /*::[*/
  307: {
    /* n:"BrtBeginSxSelect", */
    T: 1
  },
  /*::[*/
  308: {
    /* n:"BrtEndSxSelect", */
    T: -1
  },
  /*::[*/
  309: {
    /* n:"BrtBeginISXVDRws", */
    T: 1
  },
  /*::[*/
  310: {
    /* n:"BrtEndISXVDRws", */
    T: -1
  },
  /*::[*/
  311: {
    /* n:"BrtBeginISXVDCols", */
    T: 1
  },
  /*::[*/
  312: {
    /* n:"BrtEndISXVDCols", */
    T: -1
  },
  /*::[*/
  313: {
    /* n:"BrtEndSXLocation", */
    T: -1
  },
  /*::[*/
  314: {
    /* n:"BrtBeginSXLocation", */
    T: 1
  },
  /*::[*/
  315: {
    /* n:"BrtEndSXView", */
    T: -1
  },
  /*::[*/
  316: {
    /* n:"BrtBeginSXTHs", */
    T: 1
  },
  /*::[*/
  317: {
    /* n:"BrtEndSXTHs", */
    T: -1
  },
  /*::[*/
  318: {
    /* n:"BrtBeginSXTH", */
    T: 1
  },
  /*::[*/
  319: {
    /* n:"BrtEndSXTH", */
    T: -1
  },
  /*::[*/
  320: {
    /* n:"BrtBeginISXTHRws", */
    T: 1
  },
  /*::[*/
  321: {
    /* n:"BrtEndISXTHRws", */
    T: -1
  },
  /*::[*/
  322: {
    /* n:"BrtBeginISXTHCols", */
    T: 1
  },
  /*::[*/
  323: {
    /* n:"BrtEndISXTHCols", */
    T: -1
  },
  /*::[*/
  324: {
    /* n:"BrtBeginSXTDMPS", */
    T: 1
  },
  /*::[*/
  325: {
    /* n:"BrtEndSXTDMPs", */
    T: -1
  },
  /*::[*/
  326: {
    /* n:"BrtBeginSXTDMP", */
    T: 1
  },
  /*::[*/
  327: {
    /* n:"BrtEndSXTDMP", */
    T: -1
  },
  /*::[*/
  328: {
    /* n:"BrtBeginSXTHItems", */
    T: 1
  },
  /*::[*/
  329: {
    /* n:"BrtEndSXTHItems", */
    T: -1
  },
  /*::[*/
  330: {
    /* n:"BrtBeginSXTHItem", */
    T: 1
  },
  /*::[*/
  331: {
    /* n:"BrtEndSXTHItem", */
    T: -1
  },
  /*::[*/
  332: {
    /* n:"BrtBeginMetadata", */
    T: 1
  },
  /*::[*/
  333: {
    /* n:"BrtEndMetadata", */
    T: -1
  },
  /*::[*/
  334: {
    /* n:"BrtBeginEsmdtinfo", */
    T: 1
  },
  /*::[*/
  335: {
    /* n:"BrtMdtinfo", */
    f: parse_BrtMdtinfo
  },
  /*::[*/
  336: {
    /* n:"BrtEndEsmdtinfo", */
    T: -1
  },
  /*::[*/
  337: {
    /* n:"BrtBeginEsmdb", */
    f: parse_BrtBeginEsmdb,
    T: 1
  },
  /*::[*/
  338: {
    /* n:"BrtEndEsmdb", */
    T: -1
  },
  /*::[*/
  339: {
    /* n:"BrtBeginEsfmd", */
    T: 1
  },
  /*::[*/
  340: {
    /* n:"BrtEndEsfmd", */
    T: -1
  },
  /*::[*/
  341: {
    /* n:"BrtBeginSingleCells", */
    T: 1
  },
  /*::[*/
  342: {
    /* n:"BrtEndSingleCells", */
    T: -1
  },
  /*::[*/
  343: {
    /* n:"BrtBeginList", */
    T: 1
  },
  /*::[*/
  344: {
    /* n:"BrtEndList", */
    T: -1
  },
  /*::[*/
  345: {
    /* n:"BrtBeginListCols", */
    T: 1
  },
  /*::[*/
  346: {
    /* n:"BrtEndListCols", */
    T: -1
  },
  /*::[*/
  347: {
    /* n:"BrtBeginListCol", */
    T: 1
  },
  /*::[*/
  348: {
    /* n:"BrtEndListCol", */
    T: -1
  },
  /*::[*/
  349: {
    /* n:"BrtBeginListXmlCPr", */
    T: 1
  },
  /*::[*/
  350: {
    /* n:"BrtEndListXmlCPr", */
    T: -1
  },
  /*::[*/
  351: {
    /* n:"BrtListCCFmla" */
  },
  /*::[*/
  352: {
    /* n:"BrtListTrFmla" */
  },
  /*::[*/
  353: {
    /* n:"BrtBeginExternals", */
    T: 1
  },
  /*::[*/
  354: {
    /* n:"BrtEndExternals", */
    T: -1
  },
  /*::[*/
  355: {
    /* n:"BrtSupBookSrc", */
    f: parse_RelID
  },
  /*::[*/
  357: {
    /* n:"BrtSupSelf" */
  },
  /*::[*/
  358: {
    /* n:"BrtSupSame" */
  },
  /*::[*/
  359: {
    /* n:"BrtSupTabs" */
  },
  /*::[*/
  360: {
    /* n:"BrtBeginSupBook", */
    T: 1
  },
  /*::[*/
  361: {
    /* n:"BrtPlaceholderName" */
  },
  /*::[*/
  362: {
    /* n:"BrtExternSheet", */
    f: parse_ExternSheet
  },
  /*::[*/
  363: {
    /* n:"BrtExternTableStart" */
  },
  /*::[*/
  364: {
    /* n:"BrtExternTableEnd" */
  },
  /*::[*/
  366: {
    /* n:"BrtExternRowHdr" */
  },
  /*::[*/
  367: {
    /* n:"BrtExternCellBlank" */
  },
  /*::[*/
  368: {
    /* n:"BrtExternCellReal" */
  },
  /*::[*/
  369: {
    /* n:"BrtExternCellBool" */
  },
  /*::[*/
  370: {
    /* n:"BrtExternCellError" */
  },
  /*::[*/
  371: {
    /* n:"BrtExternCellString" */
  },
  /*::[*/
  372: {
    /* n:"BrtBeginEsmdx", */
    T: 1
  },
  /*::[*/
  373: {
    /* n:"BrtEndEsmdx", */
    T: -1
  },
  /*::[*/
  374: {
    /* n:"BrtBeginMdxSet", */
    T: 1
  },
  /*::[*/
  375: {
    /* n:"BrtEndMdxSet", */
    T: -1
  },
  /*::[*/
  376: {
    /* n:"BrtBeginMdxMbrProp", */
    T: 1
  },
  /*::[*/
  377: {
    /* n:"BrtEndMdxMbrProp", */
    T: -1
  },
  /*::[*/
  378: {
    /* n:"BrtBeginMdxKPI", */
    T: 1
  },
  /*::[*/
  379: {
    /* n:"BrtEndMdxKPI", */
    T: -1
  },
  /*::[*/
  380: {
    /* n:"BrtBeginEsstr", */
    T: 1
  },
  /*::[*/
  381: {
    /* n:"BrtEndEsstr", */
    T: -1
  },
  /*::[*/
  382: {
    /* n:"BrtBeginPRFItem", */
    T: 1
  },
  /*::[*/
  383: {
    /* n:"BrtEndPRFItem", */
    T: -1
  },
  /*::[*/
  384: {
    /* n:"BrtBeginPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  385: {
    /* n:"BrtEndPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  386: {
    /* n:"BrtBeginPivotCacheID", */
    T: 1
  },
  /*::[*/
  387: {
    /* n:"BrtEndPivotCacheID", */
    T: -1
  },
  /*::[*/
  388: {
    /* n:"BrtBeginISXVIs", */
    T: 1
  },
  /*::[*/
  389: {
    /* n:"BrtEndISXVIs", */
    T: -1
  },
  /*::[*/
  390: {
    /* n:"BrtBeginColInfos", */
    T: 1
  },
  /*::[*/
  391: {
    /* n:"BrtEndColInfos", */
    T: -1
  },
  /*::[*/
  392: {
    /* n:"BrtBeginRwBrk", */
    T: 1
  },
  /*::[*/
  393: {
    /* n:"BrtEndRwBrk", */
    T: -1
  },
  /*::[*/
  394: {
    /* n:"BrtBeginColBrk", */
    T: 1
  },
  /*::[*/
  395: {
    /* n:"BrtEndColBrk", */
    T: -1
  },
  /*::[*/
  396: {
    /* n:"BrtBrk" */
  },
  /*::[*/
  397: {
    /* n:"BrtUserBookView" */
  },
  /*::[*/
  398: {
    /* n:"BrtInfo" */
  },
  /*::[*/
  399: {
    /* n:"BrtCUsr" */
  },
  /*::[*/
  400: {
    /* n:"BrtUsr" */
  },
  /*::[*/
  401: {
    /* n:"BrtBeginUsers", */
    T: 1
  },
  /*::[*/
  403: {
    /* n:"BrtEOF" */
  },
  /*::[*/
  404: {
    /* n:"BrtUCR" */
  },
  /*::[*/
  405: {
    /* n:"BrtRRInsDel" */
  },
  /*::[*/
  406: {
    /* n:"BrtRREndInsDel" */
  },
  /*::[*/
  407: {
    /* n:"BrtRRMove" */
  },
  /*::[*/
  408: {
    /* n:"BrtRREndMove" */
  },
  /*::[*/
  409: {
    /* n:"BrtRRChgCell" */
  },
  /*::[*/
  410: {
    /* n:"BrtRREndChgCell" */
  },
  /*::[*/
  411: {
    /* n:"BrtRRHeader" */
  },
  /*::[*/
  412: {
    /* n:"BrtRRUserView" */
  },
  /*::[*/
  413: {
    /* n:"BrtRRRenSheet" */
  },
  /*::[*/
  414: {
    /* n:"BrtRRInsertSh" */
  },
  /*::[*/
  415: {
    /* n:"BrtRRDefName" */
  },
  /*::[*/
  416: {
    /* n:"BrtRRNote" */
  },
  /*::[*/
  417: {
    /* n:"BrtRRConflict" */
  },
  /*::[*/
  418: {
    /* n:"BrtRRTQSIF" */
  },
  /*::[*/
  419: {
    /* n:"BrtRRFormat" */
  },
  /*::[*/
  420: {
    /* n:"BrtRREndFormat" */
  },
  /*::[*/
  421: {
    /* n:"BrtRRAutoFmt" */
  },
  /*::[*/
  422: {
    /* n:"BrtBeginUserShViews", */
    T: 1
  },
  /*::[*/
  423: {
    /* n:"BrtBeginUserShView", */
    T: 1
  },
  /*::[*/
  424: {
    /* n:"BrtEndUserShView", */
    T: -1
  },
  /*::[*/
  425: {
    /* n:"BrtEndUserShViews", */
    T: -1
  },
  /*::[*/
  426: {
    /* n:"BrtArrFmla", */
    f: parse_BrtArrFmla
  },
  /*::[*/
  427: {
    /* n:"BrtShrFmla", */
    f: parse_BrtShrFmla
  },
  /*::[*/
  428: {
    /* n:"BrtTable" */
  },
  /*::[*/
  429: {
    /* n:"BrtBeginExtConnections", */
    T: 1
  },
  /*::[*/
  430: {
    /* n:"BrtEndExtConnections", */
    T: -1
  },
  /*::[*/
  431: {
    /* n:"BrtBeginPCDCalcMems", */
    T: 1
  },
  /*::[*/
  432: {
    /* n:"BrtEndPCDCalcMems", */
    T: -1
  },
  /*::[*/
  433: {
    /* n:"BrtBeginPCDCalcMem", */
    T: 1
  },
  /*::[*/
  434: {
    /* n:"BrtEndPCDCalcMem", */
    T: -1
  },
  /*::[*/
  435: {
    /* n:"BrtBeginPCDHGLevels", */
    T: 1
  },
  /*::[*/
  436: {
    /* n:"BrtEndPCDHGLevels", */
    T: -1
  },
  /*::[*/
  437: {
    /* n:"BrtBeginPCDHGLevel", */
    T: 1
  },
  /*::[*/
  438: {
    /* n:"BrtEndPCDHGLevel", */
    T: -1
  },
  /*::[*/
  439: {
    /* n:"BrtBeginPCDHGLGroups", */
    T: 1
  },
  /*::[*/
  440: {
    /* n:"BrtEndPCDHGLGroups", */
    T: -1
  },
  /*::[*/
  441: {
    /* n:"BrtBeginPCDHGLGroup", */
    T: 1
  },
  /*::[*/
  442: {
    /* n:"BrtEndPCDHGLGroup", */
    T: -1
  },
  /*::[*/
  443: {
    /* n:"BrtBeginPCDHGLGMembers", */
    T: 1
  },
  /*::[*/
  444: {
    /* n:"BrtEndPCDHGLGMembers", */
    T: -1
  },
  /*::[*/
  445: {
    /* n:"BrtBeginPCDHGLGMember", */
    T: 1
  },
  /*::[*/
  446: {
    /* n:"BrtEndPCDHGLGMember", */
    T: -1
  },
  /*::[*/
  447: {
    /* n:"BrtBeginQSI", */
    T: 1
  },
  /*::[*/
  448: {
    /* n:"BrtEndQSI", */
    T: -1
  },
  /*::[*/
  449: {
    /* n:"BrtBeginQSIR", */
    T: 1
  },
  /*::[*/
  450: {
    /* n:"BrtEndQSIR", */
    T: -1
  },
  /*::[*/
  451: {
    /* n:"BrtBeginDeletedNames", */
    T: 1
  },
  /*::[*/
  452: {
    /* n:"BrtEndDeletedNames", */
    T: -1
  },
  /*::[*/
  453: {
    /* n:"BrtBeginDeletedName", */
    T: 1
  },
  /*::[*/
  454: {
    /* n:"BrtEndDeletedName", */
    T: -1
  },
  /*::[*/
  455: {
    /* n:"BrtBeginQSIFs", */
    T: 1
  },
  /*::[*/
  456: {
    /* n:"BrtEndQSIFs", */
    T: -1
  },
  /*::[*/
  457: {
    /* n:"BrtBeginQSIF", */
    T: 1
  },
  /*::[*/
  458: {
    /* n:"BrtEndQSIF", */
    T: -1
  },
  /*::[*/
  459: {
    /* n:"BrtBeginAutoSortScope", */
    T: 1
  },
  /*::[*/
  460: {
    /* n:"BrtEndAutoSortScope", */
    T: -1
  },
  /*::[*/
  461: {
    /* n:"BrtBeginConditionalFormatting", */
    T: 1
  },
  /*::[*/
  462: {
    /* n:"BrtEndConditionalFormatting", */
    T: -1
  },
  /*::[*/
  463: {
    /* n:"BrtBeginCFRule", */
    T: 1
  },
  /*::[*/
  464: {
    /* n:"BrtEndCFRule", */
    T: -1
  },
  /*::[*/
  465: {
    /* n:"BrtBeginIconSet", */
    T: 1
  },
  /*::[*/
  466: {
    /* n:"BrtEndIconSet", */
    T: -1
  },
  /*::[*/
  467: {
    /* n:"BrtBeginDatabar", */
    T: 1
  },
  /*::[*/
  468: {
    /* n:"BrtEndDatabar", */
    T: -1
  },
  /*::[*/
  469: {
    /* n:"BrtBeginColorScale", */
    T: 1
  },
  /*::[*/
  470: {
    /* n:"BrtEndColorScale", */
    T: -1
  },
  /*::[*/
  471: {
    /* n:"BrtCFVO" */
  },
  /*::[*/
  472: {
    /* n:"BrtExternValueMeta" */
  },
  /*::[*/
  473: {
    /* n:"BrtBeginColorPalette", */
    T: 1
  },
  /*::[*/
  474: {
    /* n:"BrtEndColorPalette", */
    T: -1
  },
  /*::[*/
  475: {
    /* n:"BrtIndexedColor" */
  },
  /*::[*/
  476: {
    /* n:"BrtMargins", */
    f: parse_BrtMargins
  },
  /*::[*/
  477: {
    /* n:"BrtPrintOptions" */
  },
  /*::[*/
  478: {
    /* n:"BrtPageSetup" */
  },
  /*::[*/
  479: {
    /* n:"BrtBeginHeaderFooter", */
    T: 1
  },
  /*::[*/
  480: {
    /* n:"BrtEndHeaderFooter", */
    T: -1
  },
  /*::[*/
  481: {
    /* n:"BrtBeginSXCrtFormat", */
    T: 1
  },
  /*::[*/
  482: {
    /* n:"BrtEndSXCrtFormat", */
    T: -1
  },
  /*::[*/
  483: {
    /* n:"BrtBeginSXCrtFormats", */
    T: 1
  },
  /*::[*/
  484: {
    /* n:"BrtEndSXCrtFormats", */
    T: -1
  },
  /*::[*/
  485: {
    /* n:"BrtWsFmtInfo", */
    f: parse_BrtWsFmtInfo
  },
  /*::[*/
  486: {
    /* n:"BrtBeginMgs", */
    T: 1
  },
  /*::[*/
  487: {
    /* n:"BrtEndMGs", */
    T: -1
  },
  /*::[*/
  488: {
    /* n:"BrtBeginMGMaps", */
    T: 1
  },
  /*::[*/
  489: {
    /* n:"BrtEndMGMaps", */
    T: -1
  },
  /*::[*/
  490: {
    /* n:"BrtBeginMG", */
    T: 1
  },
  /*::[*/
  491: {
    /* n:"BrtEndMG", */
    T: -1
  },
  /*::[*/
  492: {
    /* n:"BrtBeginMap", */
    T: 1
  },
  /*::[*/
  493: {
    /* n:"BrtEndMap", */
    T: -1
  },
  /*::[*/
  494: {
    /* n:"BrtHLink", */
    f: parse_BrtHLink
  },
  /*::[*/
  495: {
    /* n:"BrtBeginDCon", */
    T: 1
  },
  /*::[*/
  496: {
    /* n:"BrtEndDCon", */
    T: -1
  },
  /*::[*/
  497: {
    /* n:"BrtBeginDRefs", */
    T: 1
  },
  /*::[*/
  498: {
    /* n:"BrtEndDRefs", */
    T: -1
  },
  /*::[*/
  499: {
    /* n:"BrtDRef" */
  },
  /*::[*/
  500: {
    /* n:"BrtBeginScenMan", */
    T: 1
  },
  /*::[*/
  501: {
    /* n:"BrtEndScenMan", */
    T: -1
  },
  /*::[*/
  502: {
    /* n:"BrtBeginSct", */
    T: 1
  },
  /*::[*/
  503: {
    /* n:"BrtEndSct", */
    T: -1
  },
  /*::[*/
  504: {
    /* n:"BrtSlc" */
  },
  /*::[*/
  505: {
    /* n:"BrtBeginDXFs", */
    T: 1
  },
  /*::[*/
  506: {
    /* n:"BrtEndDXFs", */
    T: -1
  },
  /*::[*/
  507: {
    /* n:"BrtDXF" */
  },
  /*::[*/
  508: {
    /* n:"BrtBeginTableStyles", */
    T: 1
  },
  /*::[*/
  509: {
    /* n:"BrtEndTableStyles", */
    T: -1
  },
  /*::[*/
  510: {
    /* n:"BrtBeginTableStyle", */
    T: 1
  },
  /*::[*/
  511: {
    /* n:"BrtEndTableStyle", */
    T: -1
  },
  /*::[*/
  512: {
    /* n:"BrtTableStyleElement" */
  },
  /*::[*/
  513: {
    /* n:"BrtTableStyleClient" */
  },
  /*::[*/
  514: {
    /* n:"BrtBeginVolDeps", */
    T: 1
  },
  /*::[*/
  515: {
    /* n:"BrtEndVolDeps", */
    T: -1
  },
  /*::[*/
  516: {
    /* n:"BrtBeginVolType", */
    T: 1
  },
  /*::[*/
  517: {
    /* n:"BrtEndVolType", */
    T: -1
  },
  /*::[*/
  518: {
    /* n:"BrtBeginVolMain", */
    T: 1
  },
  /*::[*/
  519: {
    /* n:"BrtEndVolMain", */
    T: -1
  },
  /*::[*/
  520: {
    /* n:"BrtBeginVolTopic", */
    T: 1
  },
  /*::[*/
  521: {
    /* n:"BrtEndVolTopic", */
    T: -1
  },
  /*::[*/
  522: {
    /* n:"BrtVolSubtopic" */
  },
  /*::[*/
  523: {
    /* n:"BrtVolRef" */
  },
  /*::[*/
  524: {
    /* n:"BrtVolNum" */
  },
  /*::[*/
  525: {
    /* n:"BrtVolErr" */
  },
  /*::[*/
  526: {
    /* n:"BrtVolStr" */
  },
  /*::[*/
  527: {
    /* n:"BrtVolBool" */
  },
  /*::[*/
  528: {
    /* n:"BrtBeginCalcChain$", */
    T: 1
  },
  /*::[*/
  529: {
    /* n:"BrtEndCalcChain$", */
    T: -1
  },
  /*::[*/
  530: {
    /* n:"BrtBeginSortState", */
    T: 1
  },
  /*::[*/
  531: {
    /* n:"BrtEndSortState", */
    T: -1
  },
  /*::[*/
  532: {
    /* n:"BrtBeginSortCond", */
    T: 1
  },
  /*::[*/
  533: {
    /* n:"BrtEndSortCond", */
    T: -1
  },
  /*::[*/
  534: {
    /* n:"BrtBookProtection" */
  },
  /*::[*/
  535: {
    /* n:"BrtSheetProtection" */
  },
  /*::[*/
  536: {
    /* n:"BrtRangeProtection" */
  },
  /*::[*/
  537: {
    /* n:"BrtPhoneticInfo" */
  },
  /*::[*/
  538: {
    /* n:"BrtBeginECTxtWiz", */
    T: 1
  },
  /*::[*/
  539: {
    /* n:"BrtEndECTxtWiz", */
    T: -1
  },
  /*::[*/
  540: {
    /* n:"BrtBeginECTWFldInfoLst", */
    T: 1
  },
  /*::[*/
  541: {
    /* n:"BrtEndECTWFldInfoLst", */
    T: -1
  },
  /*::[*/
  542: {
    /* n:"BrtBeginECTwFldInfo", */
    T: 1
  },
  /*::[*/
  548: {
    /* n:"BrtFileSharing" */
  },
  /*::[*/
  549: {
    /* n:"BrtOleSize" */
  },
  /*::[*/
  550: {
    /* n:"BrtDrawing", */
    f: parse_RelID
  },
  /*::[*/
  551: {
    /* n:"BrtLegacyDrawing" */
  },
  /*::[*/
  552: {
    /* n:"BrtLegacyDrawingHF" */
  },
  /*::[*/
  553: {
    /* n:"BrtWebOpt" */
  },
  /*::[*/
  554: {
    /* n:"BrtBeginWebPubItems", */
    T: 1
  },
  /*::[*/
  555: {
    /* n:"BrtEndWebPubItems", */
    T: -1
  },
  /*::[*/
  556: {
    /* n:"BrtBeginWebPubItem", */
    T: 1
  },
  /*::[*/
  557: {
    /* n:"BrtEndWebPubItem", */
    T: -1
  },
  /*::[*/
  558: {
    /* n:"BrtBeginSXCondFmt", */
    T: 1
  },
  /*::[*/
  559: {
    /* n:"BrtEndSXCondFmt", */
    T: -1
  },
  /*::[*/
  560: {
    /* n:"BrtBeginSXCondFmts", */
    T: 1
  },
  /*::[*/
  561: {
    /* n:"BrtEndSXCondFmts", */
    T: -1
  },
  /*::[*/
  562: {
    /* n:"BrtBkHim" */
  },
  /*::[*/
  564: {
    /* n:"BrtColor" */
  },
  /*::[*/
  565: {
    /* n:"BrtBeginIndexedColors", */
    T: 1
  },
  /*::[*/
  566: {
    /* n:"BrtEndIndexedColors", */
    T: -1
  },
  /*::[*/
  569: {
    /* n:"BrtBeginMRUColors", */
    T: 1
  },
  /*::[*/
  570: {
    /* n:"BrtEndMRUColors", */
    T: -1
  },
  /*::[*/
  572: {
    /* n:"BrtMRUColor" */
  },
  /*::[*/
  573: {
    /* n:"BrtBeginDVals", */
    T: 1
  },
  /*::[*/
  574: {
    /* n:"BrtEndDVals", */
    T: -1
  },
  /*::[*/
  577: {
    /* n:"BrtSupNameStart" */
  },
  /*::[*/
  578: {
    /* n:"BrtSupNameValueStart" */
  },
  /*::[*/
  579: {
    /* n:"BrtSupNameValueEnd" */
  },
  /*::[*/
  580: {
    /* n:"BrtSupNameNum" */
  },
  /*::[*/
  581: {
    /* n:"BrtSupNameErr" */
  },
  /*::[*/
  582: {
    /* n:"BrtSupNameSt" */
  },
  /*::[*/
  583: {
    /* n:"BrtSupNameNil" */
  },
  /*::[*/
  584: {
    /* n:"BrtSupNameBool" */
  },
  /*::[*/
  585: {
    /* n:"BrtSupNameFmla" */
  },
  /*::[*/
  586: {
    /* n:"BrtSupNameBits" */
  },
  /*::[*/
  587: {
    /* n:"BrtSupNameEnd" */
  },
  /*::[*/
  588: {
    /* n:"BrtEndSupBook", */
    T: -1
  },
  /*::[*/
  589: {
    /* n:"BrtCellSmartTagProperty" */
  },
  /*::[*/
  590: {
    /* n:"BrtBeginCellSmartTag", */
    T: 1
  },
  /*::[*/
  591: {
    /* n:"BrtEndCellSmartTag", */
    T: -1
  },
  /*::[*/
  592: {
    /* n:"BrtBeginCellSmartTags", */
    T: 1
  },
  /*::[*/
  593: {
    /* n:"BrtEndCellSmartTags", */
    T: -1
  },
  /*::[*/
  594: {
    /* n:"BrtBeginSmartTags", */
    T: 1
  },
  /*::[*/
  595: {
    /* n:"BrtEndSmartTags", */
    T: -1
  },
  /*::[*/
  596: {
    /* n:"BrtSmartTagType" */
  },
  /*::[*/
  597: {
    /* n:"BrtBeginSmartTagTypes", */
    T: 1
  },
  /*::[*/
  598: {
    /* n:"BrtEndSmartTagTypes", */
    T: -1
  },
  /*::[*/
  599: {
    /* n:"BrtBeginSXFilters", */
    T: 1
  },
  /*::[*/
  600: {
    /* n:"BrtEndSXFilters", */
    T: -1
  },
  /*::[*/
  601: {
    /* n:"BrtBeginSXFILTER", */
    T: 1
  },
  /*::[*/
  602: {
    /* n:"BrtEndSXFilter", */
    T: -1
  },
  /*::[*/
  603: {
    /* n:"BrtBeginFills", */
    T: 1
  },
  /*::[*/
  604: {
    /* n:"BrtEndFills", */
    T: -1
  },
  /*::[*/
  605: {
    /* n:"BrtBeginCellWatches", */
    T: 1
  },
  /*::[*/
  606: {
    /* n:"BrtEndCellWatches", */
    T: -1
  },
  /*::[*/
  607: {
    /* n:"BrtCellWatch" */
  },
  /*::[*/
  608: {
    /* n:"BrtBeginCRErrs", */
    T: 1
  },
  /*::[*/
  609: {
    /* n:"BrtEndCRErrs", */
    T: -1
  },
  /*::[*/
  610: {
    /* n:"BrtCrashRecErr" */
  },
  /*::[*/
  611: {
    /* n:"BrtBeginFonts", */
    T: 1
  },
  /*::[*/
  612: {
    /* n:"BrtEndFonts", */
    T: -1
  },
  /*::[*/
  613: {
    /* n:"BrtBeginBorders", */
    T: 1
  },
  /*::[*/
  614: {
    /* n:"BrtEndBorders", */
    T: -1
  },
  /*::[*/
  615: {
    /* n:"BrtBeginFmts", */
    T: 1
  },
  /*::[*/
  616: {
    /* n:"BrtEndFmts", */
    T: -1
  },
  /*::[*/
  617: {
    /* n:"BrtBeginCellXFs", */
    T: 1
  },
  /*::[*/
  618: {
    /* n:"BrtEndCellXFs", */
    T: -1
  },
  /*::[*/
  619: {
    /* n:"BrtBeginStyles", */
    T: 1
  },
  /*::[*/
  620: {
    /* n:"BrtEndStyles", */
    T: -1
  },
  /*::[*/
  625: {
    /* n:"BrtBigName" */
  },
  /*::[*/
  626: {
    /* n:"BrtBeginCellStyleXFs", */
    T: 1
  },
  /*::[*/
  627: {
    /* n:"BrtEndCellStyleXFs", */
    T: -1
  },
  /*::[*/
  628: {
    /* n:"BrtBeginComments", */
    T: 1
  },
  /*::[*/
  629: {
    /* n:"BrtEndComments", */
    T: -1
  },
  /*::[*/
  630: {
    /* n:"BrtBeginCommentAuthors", */
    T: 1
  },
  /*::[*/
  631: {
    /* n:"BrtEndCommentAuthors", */
    T: -1
  },
  /*::[*/
  632: {
    /* n:"BrtCommentAuthor", */
    f: parse_BrtCommentAuthor
  },
  /*::[*/
  633: {
    /* n:"BrtBeginCommentList", */
    T: 1
  },
  /*::[*/
  634: {
    /* n:"BrtEndCommentList", */
    T: -1
  },
  /*::[*/
  635: {
    /* n:"BrtBeginComment", */
    T: 1,
    f: parse_BrtBeginComment
  },
  /*::[*/
  636: {
    /* n:"BrtEndComment", */
    T: -1
  },
  /*::[*/
  637: {
    /* n:"BrtCommentText", */
    f: parse_BrtCommentText
  },
  /*::[*/
  638: {
    /* n:"BrtBeginOleObjects", */
    T: 1
  },
  /*::[*/
  639: {
    /* n:"BrtOleObject" */
  },
  /*::[*/
  640: {
    /* n:"BrtEndOleObjects", */
    T: -1
  },
  /*::[*/
  641: {
    /* n:"BrtBeginSxrules", */
    T: 1
  },
  /*::[*/
  642: {
    /* n:"BrtEndSxRules", */
    T: -1
  },
  /*::[*/
  643: {
    /* n:"BrtBeginActiveXControls", */
    T: 1
  },
  /*::[*/
  644: {
    /* n:"BrtActiveX" */
  },
  /*::[*/
  645: {
    /* n:"BrtEndActiveXControls", */
    T: -1
  },
  /*::[*/
  646: {
    /* n:"BrtBeginPCDSDTCEMembersSortBy", */
    T: 1
  },
  /*::[*/
  648: {
    /* n:"BrtBeginCellIgnoreECs", */
    T: 1
  },
  /*::[*/
  649: {
    /* n:"BrtCellIgnoreEC" */
  },
  /*::[*/
  650: {
    /* n:"BrtEndCellIgnoreECs", */
    T: -1
  },
  /*::[*/
  651: {
    /* n:"BrtCsProp", */
    f: parse_BrtCsProp
  },
  /*::[*/
  652: {
    /* n:"BrtCsPageSetup" */
  },
  /*::[*/
  653: {
    /* n:"BrtBeginUserCsViews", */
    T: 1
  },
  /*::[*/
  654: {
    /* n:"BrtEndUserCsViews", */
    T: -1
  },
  /*::[*/
  655: {
    /* n:"BrtBeginUserCsView", */
    T: 1
  },
  /*::[*/
  656: {
    /* n:"BrtEndUserCsView", */
    T: -1
  },
  /*::[*/
  657: {
    /* n:"BrtBeginPcdSFCIEntries", */
    T: 1
  },
  /*::[*/
  658: {
    /* n:"BrtEndPCDSFCIEntries", */
    T: -1
  },
  /*::[*/
  659: {
    /* n:"BrtPCDSFCIEntry" */
  },
  /*::[*/
  660: {
    /* n:"BrtBeginListParts", */
    T: 1
  },
  /*::[*/
  661: {
    /* n:"BrtListPart" */
  },
  /*::[*/
  662: {
    /* n:"BrtEndListParts", */
    T: -1
  },
  /*::[*/
  663: {
    /* n:"BrtSheetCalcProp" */
  },
  /*::[*/
  664: {
    /* n:"BrtBeginFnGroup", */
    T: 1
  },
  /*::[*/
  665: {
    /* n:"BrtFnGroup" */
  },
  /*::[*/
  666: {
    /* n:"BrtEndFnGroup", */
    T: -1
  },
  /*::[*/
  667: {
    /* n:"BrtSupAddin" */
  },
  /*::[*/
  668: {
    /* n:"BrtSXTDMPOrder" */
  },
  /*::[*/
  669: {
    /* n:"BrtCsProtection" */
  },
  /*::[*/
  671: {
    /* n:"BrtBeginWsSortMap", */
    T: 1
  },
  /*::[*/
  672: {
    /* n:"BrtEndWsSortMap", */
    T: -1
  },
  /*::[*/
  673: {
    /* n:"BrtBeginRRSort", */
    T: 1
  },
  /*::[*/
  674: {
    /* n:"BrtEndRRSort", */
    T: -1
  },
  /*::[*/
  675: {
    /* n:"BrtRRSortItem" */
  },
  /*::[*/
  676: {
    /* n:"BrtFileSharingIso" */
  },
  /*::[*/
  677: {
    /* n:"BrtBookProtectionIso" */
  },
  /*::[*/
  678: {
    /* n:"BrtSheetProtectionIso" */
  },
  /*::[*/
  679: {
    /* n:"BrtCsProtectionIso" */
  },
  /*::[*/
  680: {
    /* n:"BrtRangeProtectionIso" */
  },
  /*::[*/
  681: {
    /* n:"BrtDValList" */
  },
  /*::[*/
  1024: {
    /* n:"BrtRwDescent" */
  },
  /*::[*/
  1025: {
    /* n:"BrtKnownFonts" */
  },
  /*::[*/
  1026: {
    /* n:"BrtBeginSXTupleSet", */
    T: 1
  },
  /*::[*/
  1027: {
    /* n:"BrtEndSXTupleSet", */
    T: -1
  },
  /*::[*/
  1028: {
    /* n:"BrtBeginSXTupleSetHeader", */
    T: 1
  },
  /*::[*/
  1029: {
    /* n:"BrtEndSXTupleSetHeader", */
    T: -1
  },
  /*::[*/
  1030: {
    /* n:"BrtSXTupleSetHeaderItem" */
  },
  /*::[*/
  1031: {
    /* n:"BrtBeginSXTupleSetData", */
    T: 1
  },
  /*::[*/
  1032: {
    /* n:"BrtEndSXTupleSetData", */
    T: -1
  },
  /*::[*/
  1033: {
    /* n:"BrtBeginSXTupleSetRow", */
    T: 1
  },
  /*::[*/
  1034: {
    /* n:"BrtEndSXTupleSetRow", */
    T: -1
  },
  /*::[*/
  1035: {
    /* n:"BrtSXTupleSetRowItem" */
  },
  /*::[*/
  1036: {
    /* n:"BrtNameExt" */
  },
  /*::[*/
  1037: {
    /* n:"BrtPCDH14" */
  },
  /*::[*/
  1038: {
    /* n:"BrtBeginPCDCalcMem14", */
    T: 1
  },
  /*::[*/
  1039: {
    /* n:"BrtEndPCDCalcMem14", */
    T: -1
  },
  /*::[*/
  1040: {
    /* n:"BrtSXTH14" */
  },
  /*::[*/
  1041: {
    /* n:"BrtBeginSparklineGroup", */
    T: 1
  },
  /*::[*/
  1042: {
    /* n:"BrtEndSparklineGroup", */
    T: -1
  },
  /*::[*/
  1043: {
    /* n:"BrtSparkline" */
  },
  /*::[*/
  1044: {
    /* n:"BrtSXDI14" */
  },
  /*::[*/
  1045: {
    /* n:"BrtWsFmtInfoEx14" */
  },
  /*::[*/
  1046: {
    /* n:"BrtBeginConditionalFormatting14", */
    T: 1
  },
  /*::[*/
  1047: {
    /* n:"BrtEndConditionalFormatting14", */
    T: -1
  },
  /*::[*/
  1048: {
    /* n:"BrtBeginCFRule14", */
    T: 1
  },
  /*::[*/
  1049: {
    /* n:"BrtEndCFRule14", */
    T: -1
  },
  /*::[*/
  1050: {
    /* n:"BrtCFVO14" */
  },
  /*::[*/
  1051: {
    /* n:"BrtBeginDatabar14", */
    T: 1
  },
  /*::[*/
  1052: {
    /* n:"BrtBeginIconSet14", */
    T: 1
  },
  /*::[*/
  1053: {
    /* n:"BrtDVal14", */
    f: parse_BrtDVal14
  },
  /*::[*/
  1054: {
    /* n:"BrtBeginDVals14", */
    T: 1
  },
  /*::[*/
  1055: {
    /* n:"BrtColor14" */
  },
  /*::[*/
  1056: {
    /* n:"BrtBeginSparklines", */
    T: 1
  },
  /*::[*/
  1057: {
    /* n:"BrtEndSparklines", */
    T: -1
  },
  /*::[*/
  1058: {
    /* n:"BrtBeginSparklineGroups", */
    T: 1
  },
  /*::[*/
  1059: {
    /* n:"BrtEndSparklineGroups", */
    T: -1
  },
  /*::[*/
  1061: {
    /* n:"BrtSXVD14" */
  },
  /*::[*/
  1062: {
    /* n:"BrtBeginSXView14", */
    T: 1
  },
  /*::[*/
  1063: {
    /* n:"BrtEndSXView14", */
    T: -1
  },
  /*::[*/
  1064: {
    /* n:"BrtBeginSXView16", */
    T: 1
  },
  /*::[*/
  1065: {
    /* n:"BrtEndSXView16", */
    T: -1
  },
  /*::[*/
  1066: {
    /* n:"BrtBeginPCD14", */
    T: 1
  },
  /*::[*/
  1067: {
    /* n:"BrtEndPCD14", */
    T: -1
  },
  /*::[*/
  1068: {
    /* n:"BrtBeginExtConn14", */
    T: 1
  },
  /*::[*/
  1069: {
    /* n:"BrtEndExtConn14", */
    T: -1
  },
  /*::[*/
  1070: {
    /* n:"BrtBeginSlicerCacheIDs", */
    T: 1
  },
  /*::[*/
  1071: {
    /* n:"BrtEndSlicerCacheIDs", */
    T: -1
  },
  /*::[*/
  1072: {
    /* n:"BrtBeginSlicerCacheID", */
    T: 1
  },
  /*::[*/
  1073: {
    /* n:"BrtEndSlicerCacheID", */
    T: -1
  },
  /*::[*/
  1075: {
    /* n:"BrtBeginSlicerCache", */
    T: 1
  },
  /*::[*/
  1076: {
    /* n:"BrtEndSlicerCache", */
    T: -1
  },
  /*::[*/
  1077: {
    /* n:"BrtBeginSlicerCacheDef", */
    T: 1
  },
  /*::[*/
  1078: {
    /* n:"BrtEndSlicerCacheDef", */
    T: -1
  },
  /*::[*/
  1079: {
    /* n:"BrtBeginSlicersEx", */
    T: 1
  },
  /*::[*/
  1080: {
    /* n:"BrtEndSlicersEx", */
    T: -1
  },
  /*::[*/
  1081: {
    /* n:"BrtBeginSlicerEx", */
    T: 1
  },
  /*::[*/
  1082: {
    /* n:"BrtEndSlicerEx", */
    T: -1
  },
  /*::[*/
  1083: {
    /* n:"BrtBeginSlicer", */
    T: 1
  },
  /*::[*/
  1084: {
    /* n:"BrtEndSlicer", */
    T: -1
  },
  /*::[*/
  1085: {
    /* n:"BrtSlicerCachePivotTables" */
  },
  /*::[*/
  1086: {
    /* n:"BrtBeginSlicerCacheOlapImpl", */
    T: 1
  },
  /*::[*/
  1087: {
    /* n:"BrtEndSlicerCacheOlapImpl", */
    T: -1
  },
  /*::[*/
  1088: {
    /* n:"BrtBeginSlicerCacheLevelsData", */
    T: 1
  },
  /*::[*/
  1089: {
    /* n:"BrtEndSlicerCacheLevelsData", */
    T: -1
  },
  /*::[*/
  1090: {
    /* n:"BrtBeginSlicerCacheLevelData", */
    T: 1
  },
  /*::[*/
  1091: {
    /* n:"BrtEndSlicerCacheLevelData", */
    T: -1
  },
  /*::[*/
  1092: {
    /* n:"BrtBeginSlicerCacheSiRanges", */
    T: 1
  },
  /*::[*/
  1093: {
    /* n:"BrtEndSlicerCacheSiRanges", */
    T: -1
  },
  /*::[*/
  1094: {
    /* n:"BrtBeginSlicerCacheSiRange", */
    T: 1
  },
  /*::[*/
  1095: {
    /* n:"BrtEndSlicerCacheSiRange", */
    T: -1
  },
  /*::[*/
  1096: {
    /* n:"BrtSlicerCacheOlapItem" */
  },
  /*::[*/
  1097: {
    /* n:"BrtBeginSlicerCacheSelections", */
    T: 1
  },
  /*::[*/
  1098: {
    /* n:"BrtSlicerCacheSelection" */
  },
  /*::[*/
  1099: {
    /* n:"BrtEndSlicerCacheSelections", */
    T: -1
  },
  /*::[*/
  1100: {
    /* n:"BrtBeginSlicerCacheNative", */
    T: 1
  },
  /*::[*/
  1101: {
    /* n:"BrtEndSlicerCacheNative", */
    T: -1
  },
  /*::[*/
  1102: {
    /* n:"BrtSlicerCacheNativeItem" */
  },
  /*::[*/
  1103: {
    /* n:"BrtRangeProtection14" */
  },
  /*::[*/
  1104: {
    /* n:"BrtRangeProtectionIso14" */
  },
  /*::[*/
  1105: {
    /* n:"BrtCellIgnoreEC14" */
  },
  /*::[*/
  1111: {
    /* n:"BrtList14" */
  },
  /*::[*/
  1112: {
    /* n:"BrtCFIcon" */
  },
  /*::[*/
  1113: {
    /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  1114: {
    /* n:"BrtEndSlicerCachesPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  1115: {
    /* n:"BrtBeginSlicers", */
    T: 1
  },
  /*::[*/
  1116: {
    /* n:"BrtEndSlicers", */
    T: -1
  },
  /*::[*/
  1117: {
    /* n:"BrtWbProp14" */
  },
  /*::[*/
  1118: {
    /* n:"BrtBeginSXEdit", */
    T: 1
  },
  /*::[*/
  1119: {
    /* n:"BrtEndSXEdit", */
    T: -1
  },
  /*::[*/
  1120: {
    /* n:"BrtBeginSXEdits", */
    T: 1
  },
  /*::[*/
  1121: {
    /* n:"BrtEndSXEdits", */
    T: -1
  },
  /*::[*/
  1122: {
    /* n:"BrtBeginSXChange", */
    T: 1
  },
  /*::[*/
  1123: {
    /* n:"BrtEndSXChange", */
    T: -1
  },
  /*::[*/
  1124: {
    /* n:"BrtBeginSXChanges", */
    T: 1
  },
  /*::[*/
  1125: {
    /* n:"BrtEndSXChanges", */
    T: -1
  },
  /*::[*/
  1126: {
    /* n:"BrtSXTupleItems" */
  },
  /*::[*/
  1128: {
    /* n:"BrtBeginSlicerStyle", */
    T: 1
  },
  /*::[*/
  1129: {
    /* n:"BrtEndSlicerStyle", */
    T: -1
  },
  /*::[*/
  1130: {
    /* n:"BrtSlicerStyleElement" */
  },
  /*::[*/
  1131: {
    /* n:"BrtBeginStyleSheetExt14", */
    T: 1
  },
  /*::[*/
  1132: {
    /* n:"BrtEndStyleSheetExt14", */
    T: -1
  },
  /*::[*/
  1133: {
    /* n:"BrtBeginSlicerCachesPivotCacheID", */
    T: 1
  },
  /*::[*/
  1134: {
    /* n:"BrtEndSlicerCachesPivotCacheID", */
    T: -1
  },
  /*::[*/
  1135: {
    /* n:"BrtBeginConditionalFormattings", */
    T: 1
  },
  /*::[*/
  1136: {
    /* n:"BrtEndConditionalFormattings", */
    T: -1
  },
  /*::[*/
  1137: {
    /* n:"BrtBeginPCDCalcMemExt", */
    T: 1
  },
  /*::[*/
  1138: {
    /* n:"BrtEndPCDCalcMemExt", */
    T: -1
  },
  /*::[*/
  1139: {
    /* n:"BrtBeginPCDCalcMemsExt", */
    T: 1
  },
  /*::[*/
  1140: {
    /* n:"BrtEndPCDCalcMemsExt", */
    T: -1
  },
  /*::[*/
  1141: {
    /* n:"BrtPCDField14" */
  },
  /*::[*/
  1142: {
    /* n:"BrtBeginSlicerStyles", */
    T: 1
  },
  /*::[*/
  1143: {
    /* n:"BrtEndSlicerStyles", */
    T: -1
  },
  /*::[*/
  1144: {
    /* n:"BrtBeginSlicerStyleElements", */
    T: 1
  },
  /*::[*/
  1145: {
    /* n:"BrtEndSlicerStyleElements", */
    T: -1
  },
  /*::[*/
  1146: {
    /* n:"BrtCFRuleExt" */
  },
  /*::[*/
  1147: {
    /* n:"BrtBeginSXCondFmt14", */
    T: 1
  },
  /*::[*/
  1148: {
    /* n:"BrtEndSXCondFmt14", */
    T: -1
  },
  /*::[*/
  1149: {
    /* n:"BrtBeginSXCondFmts14", */
    T: 1
  },
  /*::[*/
  1150: {
    /* n:"BrtEndSXCondFmts14", */
    T: -1
  },
  /*::[*/
  1152: {
    /* n:"BrtBeginSortCond14", */
    T: 1
  },
  /*::[*/
  1153: {
    /* n:"BrtEndSortCond14", */
    T: -1
  },
  /*::[*/
  1154: {
    /* n:"BrtEndDVals14", */
    T: -1
  },
  /*::[*/
  1155: {
    /* n:"BrtEndIconSet14", */
    T: -1
  },
  /*::[*/
  1156: {
    /* n:"BrtEndDatabar14", */
    T: -1
  },
  /*::[*/
  1157: {
    /* n:"BrtBeginColorScale14", */
    T: 1
  },
  /*::[*/
  1158: {
    /* n:"BrtEndColorScale14", */
    T: -1
  },
  /*::[*/
  1159: {
    /* n:"BrtBeginSxrules14", */
    T: 1
  },
  /*::[*/
  1160: {
    /* n:"BrtEndSxrules14", */
    T: -1
  },
  /*::[*/
  1161: {
    /* n:"BrtBeginPRule14", */
    T: 1
  },
  /*::[*/
  1162: {
    /* n:"BrtEndPRule14", */
    T: -1
  },
  /*::[*/
  1163: {
    /* n:"BrtBeginPRFilters14", */
    T: 1
  },
  /*::[*/
  1164: {
    /* n:"BrtEndPRFilters14", */
    T: -1
  },
  /*::[*/
  1165: {
    /* n:"BrtBeginPRFilter14", */
    T: 1
  },
  /*::[*/
  1166: {
    /* n:"BrtEndPRFilter14", */
    T: -1
  },
  /*::[*/
  1167: {
    /* n:"BrtBeginPRFItem14", */
    T: 1
  },
  /*::[*/
  1168: {
    /* n:"BrtEndPRFItem14", */
    T: -1
  },
  /*::[*/
  1169: {
    /* n:"BrtBeginCellIgnoreECs14", */
    T: 1
  },
  /*::[*/
  1170: {
    /* n:"BrtEndCellIgnoreECs14", */
    T: -1
  },
  /*::[*/
  1171: {
    /* n:"BrtDxf14" */
  },
  /*::[*/
  1172: {
    /* n:"BrtBeginDxF14s", */
    T: 1
  },
  /*::[*/
  1173: {
    /* n:"BrtEndDxf14s", */
    T: -1
  },
  /*::[*/
  1177: {
    /* n:"BrtFilter14" */
  },
  /*::[*/
  1178: {
    /* n:"BrtBeginCustomFilters14", */
    T: 1
  },
  /*::[*/
  1180: {
    /* n:"BrtCustomFilter14" */
  },
  /*::[*/
  1181: {
    /* n:"BrtIconFilter14" */
  },
  /*::[*/
  1182: {
    /* n:"BrtPivotCacheConnectionName" */
  },
  /*::[*/
  2048: {
    /* n:"BrtBeginDecoupledPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2049: {
    /* n:"BrtEndDecoupledPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2050: {
    /* n:"BrtDecoupledPivotCacheID" */
  },
  /*::[*/
  2051: {
    /* n:"BrtBeginPivotTableRefs", */
    T: 1
  },
  /*::[*/
  2052: {
    /* n:"BrtEndPivotTableRefs", */
    T: -1
  },
  /*::[*/
  2053: {
    /* n:"BrtPivotTableRef" */
  },
  /*::[*/
  2054: {
    /* n:"BrtSlicerCacheBookPivotTables" */
  },
  /*::[*/
  2055: {
    /* n:"BrtBeginSxvcells", */
    T: 1
  },
  /*::[*/
  2056: {
    /* n:"BrtEndSxvcells", */
    T: -1
  },
  /*::[*/
  2057: {
    /* n:"BrtBeginSxRow", */
    T: 1
  },
  /*::[*/
  2058: {
    /* n:"BrtEndSxRow", */
    T: -1
  },
  /*::[*/
  2060: {
    /* n:"BrtPcdCalcMem15" */
  },
  /*::[*/
  2067: {
    /* n:"BrtQsi15" */
  },
  /*::[*/
  2068: {
    /* n:"BrtBeginWebExtensions", */
    T: 1
  },
  /*::[*/
  2069: {
    /* n:"BrtEndWebExtensions", */
    T: -1
  },
  /*::[*/
  2070: {
    /* n:"BrtWebExtension" */
  },
  /*::[*/
  2071: {
    /* n:"BrtAbsPath15" */
  },
  /*::[*/
  2072: {
    /* n:"BrtBeginPivotTableUISettings", */
    T: 1
  },
  /*::[*/
  2073: {
    /* n:"BrtEndPivotTableUISettings", */
    T: -1
  },
  /*::[*/
  2075: {
    /* n:"BrtTableSlicerCacheIDs" */
  },
  /*::[*/
  2076: {
    /* n:"BrtTableSlicerCacheID" */
  },
  /*::[*/
  2077: {
    /* n:"BrtBeginTableSlicerCache", */
    T: 1
  },
  /*::[*/
  2078: {
    /* n:"BrtEndTableSlicerCache", */
    T: -1
  },
  /*::[*/
  2079: {
    /* n:"BrtSxFilter15" */
  },
  /*::[*/
  2080: {
    /* n:"BrtBeginTimelineCachePivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2081: {
    /* n:"BrtEndTimelineCachePivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2082: {
    /* n:"BrtTimelineCachePivotCacheID" */
  },
  /*::[*/
  2083: {
    /* n:"BrtBeginTimelineCacheIDs", */
    T: 1
  },
  /*::[*/
  2084: {
    /* n:"BrtEndTimelineCacheIDs", */
    T: -1
  },
  /*::[*/
  2085: {
    /* n:"BrtBeginTimelineCacheID", */
    T: 1
  },
  /*::[*/
  2086: {
    /* n:"BrtEndTimelineCacheID", */
    T: -1
  },
  /*::[*/
  2087: {
    /* n:"BrtBeginTimelinesEx", */
    T: 1
  },
  /*::[*/
  2088: {
    /* n:"BrtEndTimelinesEx", */
    T: -1
  },
  /*::[*/
  2089: {
    /* n:"BrtBeginTimelineEx", */
    T: 1
  },
  /*::[*/
  2090: {
    /* n:"BrtEndTimelineEx", */
    T: -1
  },
  /*::[*/
  2091: {
    /* n:"BrtWorkBookPr15" */
  },
  /*::[*/
  2092: {
    /* n:"BrtPCDH15" */
  },
  /*::[*/
  2093: {
    /* n:"BrtBeginTimelineStyle", */
    T: 1
  },
  /*::[*/
  2094: {
    /* n:"BrtEndTimelineStyle", */
    T: -1
  },
  /*::[*/
  2095: {
    /* n:"BrtTimelineStyleElement" */
  },
  /*::[*/
  2096: {
    /* n:"BrtBeginTimelineStylesheetExt15", */
    T: 1
  },
  /*::[*/
  2097: {
    /* n:"BrtEndTimelineStylesheetExt15", */
    T: -1
  },
  /*::[*/
  2098: {
    /* n:"BrtBeginTimelineStyles", */
    T: 1
  },
  /*::[*/
  2099: {
    /* n:"BrtEndTimelineStyles", */
    T: -1
  },
  /*::[*/
  2100: {
    /* n:"BrtBeginTimelineStyleElements", */
    T: 1
  },
  /*::[*/
  2101: {
    /* n:"BrtEndTimelineStyleElements", */
    T: -1
  },
  /*::[*/
  2102: {
    /* n:"BrtDxf15" */
  },
  /*::[*/
  2103: {
    /* n:"BrtBeginDxfs15", */
    T: 1
  },
  /*::[*/
  2104: {
    /* n:"BrtEndDxfs15", */
    T: -1
  },
  /*::[*/
  2105: {
    /* n:"BrtSlicerCacheHideItemsWithNoData" */
  },
  /*::[*/
  2106: {
    /* n:"BrtBeginItemUniqueNames", */
    T: 1
  },
  /*::[*/
  2107: {
    /* n:"BrtEndItemUniqueNames", */
    T: -1
  },
  /*::[*/
  2108: {
    /* n:"BrtItemUniqueName" */
  },
  /*::[*/
  2109: {
    /* n:"BrtBeginExtConn15", */
    T: 1
  },
  /*::[*/
  2110: {
    /* n:"BrtEndExtConn15", */
    T: -1
  },
  /*::[*/
  2111: {
    /* n:"BrtBeginOledbPr15", */
    T: 1
  },
  /*::[*/
  2112: {
    /* n:"BrtEndOledbPr15", */
    T: -1
  },
  /*::[*/
  2113: {
    /* n:"BrtBeginDataFeedPr15", */
    T: 1
  },
  /*::[*/
  2114: {
    /* n:"BrtEndDataFeedPr15", */
    T: -1
  },
  /*::[*/
  2115: {
    /* n:"BrtTextPr15" */
  },
  /*::[*/
  2116: {
    /* n:"BrtRangePr15" */
  },
  /*::[*/
  2117: {
    /* n:"BrtDbCommand15" */
  },
  /*::[*/
  2118: {
    /* n:"BrtBeginDbTables15", */
    T: 1
  },
  /*::[*/
  2119: {
    /* n:"BrtEndDbTables15", */
    T: -1
  },
  /*::[*/
  2120: {
    /* n:"BrtDbTable15" */
  },
  /*::[*/
  2121: {
    /* n:"BrtBeginDataModel", */
    T: 1
  },
  /*::[*/
  2122: {
    /* n:"BrtEndDataModel", */
    T: -1
  },
  /*::[*/
  2123: {
    /* n:"BrtBeginModelTables", */
    T: 1
  },
  /*::[*/
  2124: {
    /* n:"BrtEndModelTables", */
    T: -1
  },
  /*::[*/
  2125: {
    /* n:"BrtModelTable" */
  },
  /*::[*/
  2126: {
    /* n:"BrtBeginModelRelationships", */
    T: 1
  },
  /*::[*/
  2127: {
    /* n:"BrtEndModelRelationships", */
    T: -1
  },
  /*::[*/
  2128: {
    /* n:"BrtModelRelationship" */
  },
  /*::[*/
  2129: {
    /* n:"BrtBeginECTxtWiz15", */
    T: 1
  },
  /*::[*/
  2130: {
    /* n:"BrtEndECTxtWiz15", */
    T: -1
  },
  /*::[*/
  2131: {
    /* n:"BrtBeginECTWFldInfoLst15", */
    T: 1
  },
  /*::[*/
  2132: {
    /* n:"BrtEndECTWFldInfoLst15", */
    T: -1
  },
  /*::[*/
  2133: {
    /* n:"BrtBeginECTWFldInfo15", */
    T: 1
  },
  /*::[*/
  2134: {
    /* n:"BrtFieldListActiveItem" */
  },
  /*::[*/
  2135: {
    /* n:"BrtPivotCacheIdVersion" */
  },
  /*::[*/
  2136: {
    /* n:"BrtSXDI15" */
  },
  /*::[*/
  2137: {
    /* n:"BrtBeginModelTimeGroupings", */
    T: 1
  },
  /*::[*/
  2138: {
    /* n:"BrtEndModelTimeGroupings", */
    T: -1
  },
  /*::[*/
  2139: {
    /* n:"BrtBeginModelTimeGrouping", */
    T: 1
  },
  /*::[*/
  2140: {
    /* n:"BrtEndModelTimeGrouping", */
    T: -1
  },
  /*::[*/
  2141: {
    /* n:"BrtModelTimeGroupingCalcCol" */
  },
  /*::[*/
  3072: {
    /* n:"BrtUid" */
  },
  /*::[*/
  3073: {
    /* n:"BrtRevisionPtr" */
  },
  /*::[*/
  4096: {
    /* n:"BrtBeginDynamicArrayPr", */
    T: 1
  },
  /*::[*/
  4097: {
    /* n:"BrtEndDynamicArrayPr", */
    T: -1
  },
  /*::[*/
  5002: {
    /* n:"BrtBeginRichValueBlock", */
    T: 1
  },
  /*::[*/
  5003: {
    /* n:"BrtEndRichValueBlock", */
    T: -1
  },
  /*::[*/
  5081: {
    /* n:"BrtBeginRichFilters", */
    T: 1
  },
  /*::[*/
  5082: {
    /* n:"BrtEndRichFilters", */
    T: -1
  },
  /*::[*/
  5083: {
    /* n:"BrtRichFilter" */
  },
  /*::[*/
  5084: {
    /* n:"BrtBeginRichFilterColumn", */
    T: 1
  },
  /*::[*/
  5085: {
    /* n:"BrtEndRichFilterColumn", */
    T: -1
  },
  /*::[*/
  5086: {
    /* n:"BrtBeginCustomRichFilters", */
    T: 1
  },
  /*::[*/
  5087: {
    /* n:"BrtEndCustomRichFilters", */
    T: -1
  },
  /*::[*/
  5088: {
    /* n:"BrtCustomRichFilter" */
  },
  /*::[*/
  5089: {
    /* n:"BrtTop10RichFilter" */
  },
  /*::[*/
  5090: {
    /* n:"BrtDynamicRichFilter" */
  },
  /*::[*/
  5092: {
    /* n:"BrtBeginRichSortCondition", */
    T: 1
  },
  /*::[*/
  5093: {
    /* n:"BrtEndRichSortCondition", */
    T: -1
  },
  /*::[*/
  5094: {
    /* n:"BrtRichFilterDateGroupItem" */
  },
  /*::[*/
  5095: {
    /* n:"BrtBeginCalcFeatures", */
    T: 1
  },
  /*::[*/
  5096: {
    /* n:"BrtEndCalcFeatures", */
    T: -1
  },
  /*::[*/
  5097: {
    /* n:"BrtCalcFeature" */
  },
  /*::[*/
  5099: {
    /* n:"BrtExternalLinksPr" */
  },
  /*::[*/
  65535: { n: "" }
};
var XLSRecordEnum = {
  /* [MS-XLS] 2.3 Record Enumeration 2021-08-17 */
  /*::[*/
  6: {
    /* n:"Formula", */
    f: parse_Formula
  },
  /*::[*/
  10: {
    /* n:"EOF", */
    f: parsenoop2
  },
  /*::[*/
  12: {
    /* n:"CalcCount", */
    f: parseuint16
  },
  //
  /*::[*/
  13: {
    /* n:"CalcMode", */
    f: parseuint16
  },
  //
  /*::[*/
  14: {
    /* n:"CalcPrecision", */
    f: parsebool
  },
  //
  /*::[*/
  15: {
    /* n:"CalcRefMode", */
    f: parsebool
  },
  //
  /*::[*/
  16: {
    /* n:"CalcDelta", */
    f: parse_Xnum
  },
  //
  /*::[*/
  17: {
    /* n:"CalcIter", */
    f: parsebool
  },
  //
  /*::[*/
  18: {
    /* n:"Protect", */
    f: parsebool
  },
  /*::[*/
  19: {
    /* n:"Password", */
    f: parseuint16
  },
  /*::[*/
  20: {
    /* n:"Header", */
    f: parse_XLHeaderFooter
  },
  /*::[*/
  21: {
    /* n:"Footer", */
    f: parse_XLHeaderFooter
  },
  /*::[*/
  23: {
    /* n:"ExternSheet", */
    f: parse_ExternSheet
  },
  /*::[*/
  24: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  /*::[*/
  25: {
    /* n:"WinProtect", */
    f: parsebool
  },
  /*::[*/
  26: {
    /* n:"VerticalPageBreaks", */
  },
  /*::[*/
  27: {
    /* n:"HorizontalPageBreaks", */
  },
  /*::[*/
  28: {
    /* n:"Note", */
    f: parse_Note
  },
  /*::[*/
  29: {
    /* n:"Selection", */
  },
  /*::[*/
  34: {
    /* n:"Date1904", */
    f: parsebool
  },
  /*::[*/
  35: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  /*::[*/
  38: {
    /* n:"LeftMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  39: {
    /* n:"RightMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  40: {
    /* n:"TopMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  41: {
    /* n:"BottomMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  42: {
    /* n:"PrintRowCol", */
    f: parsebool
  },
  /*::[*/
  43: {
    /* n:"PrintGrid", */
    f: parsebool
  },
  /*::[*/
  47: {
    /* n:"FilePass", */
    f: parse_FilePass
  },
  /*::[*/
  49: {
    /* n:"Font", */
    f: parse_Font
  },
  /*::[*/
  51: {
    /* n:"PrintSize", */
    f: parseuint16
  },
  /*::[*/
  60: {
    /* n:"Continue", */
  },
  /*::[*/
  61: {
    /* n:"Window1", */
    f: parse_Window1
  },
  /*::[*/
  64: {
    /* n:"Backup", */
    f: parsebool
  },
  /*::[*/
  65: {
    /* n:"Pane", */
    f: parse_Pane
  },
  /*::[*/
  66: {
    /* n:"CodePage", */
    f: parseuint16
  },
  /*::[*/
  77: {
    /* n:"Pls", */
  },
  /*::[*/
  80: {
    /* n:"DCon", */
  },
  /*::[*/
  81: {
    /* n:"DConRef", */
  },
  /*::[*/
  82: {
    /* n:"DConName", */
  },
  /*::[*/
  85: {
    /* n:"DefColWidth", */
    f: parseuint16
  },
  /*::[*/
  89: {
    /* n:"XCT", */
  },
  /*::[*/
  90: {
    /* n:"CRN", */
  },
  /*::[*/
  91: {
    /* n:"FileSharing", */
  },
  /*::[*/
  92: {
    /* n:"WriteAccess", */
    f: parse_WriteAccess
  },
  /*::[*/
  93: {
    /* n:"Obj", */
    f: parse_Obj
  },
  /*::[*/
  94: {
    /* n:"Uncalced", */
  },
  /*::[*/
  95: {
    /* n:"CalcSaveRecalc", */
    f: parsebool
  },
  //
  /*::[*/
  96: {
    /* n:"Template", */
  },
  /*::[*/
  97: {
    /* n:"Intl", */
  },
  /*::[*/
  99: {
    /* n:"ObjProtect", */
    f: parsebool
  },
  /*::[*/
  125: {
    /* n:"ColInfo", */
    f: parse_ColInfo
  },
  /*::[*/
  128: {
    /* n:"Guts", */
    f: parse_Guts
  },
  /*::[*/
  129: {
    /* n:"WsBool", */
    f: parse_WsBool
  },
  /*::[*/
  130: {
    /* n:"GridSet", */
    f: parseuint16
  },
  /*::[*/
  131: {
    /* n:"HCenter", */
    f: parsebool
  },
  /*::[*/
  132: {
    /* n:"VCenter", */
    f: parsebool
  },
  /*::[*/
  133: {
    /* n:"BoundSheet8", */
    f: parse_BoundSheet8
  },
  /*::[*/
  134: {
    /* n:"WriteProtect", */
  },
  /*::[*/
  140: {
    /* n:"Country", */
    f: parse_Country
  },
  /*::[*/
  141: {
    /* n:"HideObj", */
    f: parseuint16
  },
  /*::[*/
  144: {
    /* n:"Sort", */
  },
  /*::[*/
  146: {
    /* n:"Palette", */
    f: parse_Palette
  },
  /*::[*/
  151: {
    /* n:"Sync", */
  },
  /*::[*/
  152: {
    /* n:"LPr", */
  },
  /*::[*/
  153: {
    /* n:"DxGCol", */
  },
  /*::[*/
  154: {
    /* n:"FnGroupName", */
  },
  /*::[*/
  155: {
    /* n:"FilterMode", */
  },
  /*::[*/
  156: {
    /* n:"BuiltInFnGroupCount", */
    f: parseuint16
  },
  /*::[*/
  157: {
    /* n:"AutoFilterInfo", */
  },
  /*::[*/
  158: {
    /* n:"AutoFilter", */
  },
  /*::[*/
  160: {
    /* n:"Scl", */
    f: parse_Scl
  },
  /*::[*/
  161: {
    /* n:"Setup", */
    f: parse_Setup
  },
  /*::[*/
  174: {
    /* n:"ScenMan", */
  },
  /*::[*/
  175: {
    /* n:"SCENARIO", */
  },
  /*::[*/
  176: {
    /* n:"SxView", */
  },
  /*::[*/
  177: {
    /* n:"Sxvd", */
  },
  /*::[*/
  178: {
    /* n:"SXVI", */
  },
  /*::[*/
  180: {
    /* n:"SxIvd", */
  },
  /*::[*/
  181: {
    /* n:"SXLI", */
  },
  /*::[*/
  182: {
    /* n:"SXPI", */
  },
  /*::[*/
  184: {
    /* n:"DocRoute", */
  },
  /*::[*/
  185: {
    /* n:"RecipName", */
  },
  /*::[*/
  189: {
    /* n:"MulRk", */
    f: parse_MulRk
  },
  /*::[*/
  190: {
    /* n:"MulBlank", */
    f: parse_MulBlank
  },
  /*::[*/
  193: {
    /* n:"Mms", */
    f: parsenoop2
  },
  /*::[*/
  197: {
    /* n:"SXDI", */
  },
  /*::[*/
  198: {
    /* n:"SXDB", */
  },
  /*::[*/
  199: {
    /* n:"SXFDB", */
  },
  /*::[*/
  200: {
    /* n:"SXDBB", */
  },
  /*::[*/
  201: {
    /* n:"SXNum", */
  },
  /*::[*/
  202: {
    /* n:"SxBool", */
    f: parsebool
  },
  /*::[*/
  203: {
    /* n:"SxErr", */
  },
  /*::[*/
  204: {
    /* n:"SXInt", */
  },
  /*::[*/
  205: {
    /* n:"SXString", */
  },
  /*::[*/
  206: {
    /* n:"SXDtr", */
  },
  /*::[*/
  207: {
    /* n:"SxNil", */
  },
  /*::[*/
  208: {
    /* n:"SXTbl", */
  },
  /*::[*/
  209: {
    /* n:"SXTBRGIITM", */
  },
  /*::[*/
  210: {
    /* n:"SxTbpg", */
  },
  /*::[*/
  211: {
    /* n:"ObProj", */
  },
  /*::[*/
  213: {
    /* n:"SXStreamID", */
  },
  /*::[*/
  215: {
    /* n:"DBCell", */
  },
  /*::[*/
  216: {
    /* n:"SXRng", */
  },
  /*::[*/
  217: {
    /* n:"SxIsxoper", */
  },
  /*::[*/
  218: {
    /* n:"BookBool", */
    f: parseuint16
  },
  /*::[*/
  220: {
    /* n:"DbOrParamQry", */
  },
  /*::[*/
  221: {
    /* n:"ScenarioProtect", */
    f: parsebool
  },
  /*::[*/
  222: {
    /* n:"OleObjectSize", */
  },
  /*::[*/
  224: {
    /* n:"XF", */
    f: parse_XF
  },
  /*::[*/
  225: {
    /* n:"InterfaceHdr", */
    f: parse_InterfaceHdr
  },
  /*::[*/
  226: {
    /* n:"InterfaceEnd", */
    f: parsenoop2
  },
  /*::[*/
  227: {
    /* n:"SXVS", */
  },
  /*::[*/
  229: {
    /* n:"MergeCells", */
    f: parse_MergeCells
  },
  /*::[*/
  233: {
    /* n:"BkHim", */
  },
  /*::[*/
  235: {
    /* n:"MsoDrawingGroup", */
  },
  /*::[*/
  236: {
    /* n:"MsoDrawing", */
  },
  /*::[*/
  237: {
    /* n:"MsoDrawingSelection", */
  },
  /*::[*/
  239: {
    /* n:"PhoneticInfo", */
  },
  /*::[*/
  240: {
    /* n:"SxRule", */
  },
  /*::[*/
  241: {
    /* n:"SXEx", */
  },
  /*::[*/
  242: {
    /* n:"SxFilt", */
  },
  /*::[*/
  244: {
    /* n:"SxDXF", */
  },
  /*::[*/
  245: {
    /* n:"SxItm", */
  },
  /*::[*/
  246: {
    /* n:"SxName", */
  },
  /*::[*/
  247: {
    /* n:"SxSelect", */
  },
  /*::[*/
  248: {
    /* n:"SXPair", */
  },
  /*::[*/
  249: {
    /* n:"SxFmla", */
  },
  /*::[*/
  251: {
    /* n:"SxFormat", */
  },
  /*::[*/
  252: {
    /* n:"SST", */
    f: parse_SST
  },
  /*::[*/
  253: {
    /* n:"LabelSst", */
    f: parse_LabelSst
  },
  /*::[*/
  255: {
    /* n:"ExtSST", */
    f: parse_ExtSST
  },
  /*::[*/
  256: {
    /* n:"SXVDEx", */
  },
  /*::[*/
  259: {
    /* n:"SXFormula", */
  },
  /*::[*/
  290: {
    /* n:"SXDBEx", */
  },
  /*::[*/
  311: {
    /* n:"RRDInsDel", */
  },
  /*::[*/
  312: {
    /* n:"RRDHead", */
  },
  /*::[*/
  315: {
    /* n:"RRDChgCell", */
  },
  /*::[*/
  317: {
    /* n:"RRTabId", */
    f: parseuint16a
  },
  /*::[*/
  318: {
    /* n:"RRDRenSheet", */
  },
  /*::[*/
  319: {
    /* n:"RRSort", */
  },
  /*::[*/
  320: {
    /* n:"RRDMove", */
  },
  /*::[*/
  330: {
    /* n:"RRFormat", */
  },
  /*::[*/
  331: {
    /* n:"RRAutoFmt", */
  },
  /*::[*/
  333: {
    /* n:"RRInsertSh", */
  },
  /*::[*/
  334: {
    /* n:"RRDMoveBegin", */
  },
  /*::[*/
  335: {
    /* n:"RRDMoveEnd", */
  },
  /*::[*/
  336: {
    /* n:"RRDInsDelBegin", */
  },
  /*::[*/
  337: {
    /* n:"RRDInsDelEnd", */
  },
  /*::[*/
  338: {
    /* n:"RRDConflict", */
  },
  /*::[*/
  339: {
    /* n:"RRDDefName", */
  },
  /*::[*/
  340: {
    /* n:"RRDRstEtxp", */
  },
  /*::[*/
  351: {
    /* n:"LRng", */
  },
  /*::[*/
  352: {
    /* n:"UsesELFs", */
    f: parsebool
  },
  /*::[*/
  353: {
    /* n:"DSF", */
    f: parsenoop2
  },
  /*::[*/
  401: {
    /* n:"CUsr", */
  },
  /*::[*/
  402: {
    /* n:"CbUsr", */
  },
  /*::[*/
  403: {
    /* n:"UsrInfo", */
  },
  /*::[*/
  404: {
    /* n:"UsrExcl", */
  },
  /*::[*/
  405: {
    /* n:"FileLock", */
  },
  /*::[*/
  406: {
    /* n:"RRDInfo", */
  },
  /*::[*/
  407: {
    /* n:"BCUsrs", */
  },
  /*::[*/
  408: {
    /* n:"UsrChk", */
  },
  /*::[*/
  425: {
    /* n:"UserBView", */
  },
  /*::[*/
  426: {
    /* n:"UserSViewBegin", */
  },
  /*::[*/
  427: {
    /* n:"UserSViewEnd", */
  },
  /*::[*/
  428: {
    /* n:"RRDUserView", */
  },
  /*::[*/
  429: {
    /* n:"Qsi", */
  },
  /*::[*/
  430: {
    /* n:"SupBook", */
    f: parse_SupBook
  },
  /*::[*/
  431: {
    /* n:"Prot4Rev", */
    f: parsebool
  },
  /*::[*/
  432: {
    /* n:"CondFmt", */
  },
  /*::[*/
  433: {
    /* n:"CF", */
  },
  /*::[*/
  434: {
    /* n:"DVal", */
  },
  /*::[*/
  437: {
    /* n:"DConBin", */
  },
  /*::[*/
  438: {
    /* n:"TxO", */
    f: parse_TxO
  },
  /*::[*/
  439: {
    /* n:"RefreshAll", */
    f: parsebool
  },
  //
  /*::[*/
  440: {
    /* n:"HLink", */
    f: parse_HLink
  },
  /*::[*/
  441: {
    /* n:"Lel", */
  },
  /*::[*/
  442: {
    /* n:"CodeName", */
    f: parse_XLUnicodeString
  },
  /*::[*/
  443: {
    /* n:"SXFDBType", */
  },
  /*::[*/
  444: {
    /* n:"Prot4RevPass", */
    f: parseuint16
  },
  /*::[*/
  445: {
    /* n:"ObNoMacros", */
  },
  /*::[*/
  446: {
    /* n:"Dv", */
  },
  /*::[*/
  448: {
    /* n:"Excel9File", */
    f: parsenoop2
  },
  /*::[*/
  449: {
    /* n:"RecalcId", */
    f: parse_RecalcId,
    r: 2
  },
  /*::[*/
  450: {
    /* n:"EntExU2", */
    f: parsenoop2
  },
  /*::[*/
  512: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  /*::[*/
  513: {
    /* n:"Blank", */
    f: parse_Blank
  },
  /*::[*/
  515: {
    /* n:"Number", */
    f: parse_Number
  },
  /*::[*/
  516: {
    /* n:"Label", */
    f: parse_Label
  },
  /*::[*/
  517: {
    /* n:"BoolErr", */
    f: parse_BoolErr
  },
  /*::[*/
  519: {
    /* n:"String", */
    f: parse_String
  },
  /*::[*/
  520: {
    /* n:"Row", */
    f: parse_Row
  },
  /*::[*/
  523: {
    /* n:"Index", */
  },
  /*::[*/
  545: {
    /* n:"Array", */
    f: parse_Array
  },
  /*::[*/
  549: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  /*::[*/
  566: {
    /* n:"Table", */
  },
  /*::[*/
  574: {
    /* n:"Window2", */
    f: parse_Window2
  },
  /*::[*/
  638: {
    /* n:"RK", */
    f: parse_RK
  },
  /*::[*/
  659: {
    /* n:"Style", */
  },
  /*::[*/
  1048: {
    /* n:"BigName", */
  },
  /*::[*/
  1054: {
    /* n:"Format", */
    f: parse_Format
  },
  /*::[*/
  1084: {
    /* n:"ContinueBigName", */
  },
  /*::[*/
  1212: {
    /* n:"ShrFmla", */
    f: parse_ShrFmla
  },
  /*::[*/
  2048: {
    /* n:"HLinkTooltip", */
    f: parse_HLinkTooltip
  },
  /*::[*/
  2049: {
    /* n:"WebPub", */
  },
  /*::[*/
  2050: {
    /* n:"QsiSXTag", */
  },
  /*::[*/
  2051: {
    /* n:"DBQueryExt", */
  },
  /*::[*/
  2052: {
    /* n:"ExtString", */
  },
  /*::[*/
  2053: {
    /* n:"TxtQry", */
  },
  /*::[*/
  2054: {
    /* n:"Qsir", */
  },
  /*::[*/
  2055: {
    /* n:"Qsif", */
  },
  /*::[*/
  2056: {
    /* n:"RRDTQSIF", */
  },
  /*::[*/
  2057: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  2058: {
    /* n:"OleDbConn", */
  },
  /*::[*/
  2059: {
    /* n:"WOpt", */
  },
  /*::[*/
  2060: {
    /* n:"SXViewEx", */
  },
  /*::[*/
  2061: {
    /* n:"SXTH", */
  },
  /*::[*/
  2062: {
    /* n:"SXPIEx", */
  },
  /*::[*/
  2063: {
    /* n:"SXVDTEx", */
  },
  /*::[*/
  2064: {
    /* n:"SXViewEx9", */
  },
  /*::[*/
  2066: {
    /* n:"ContinueFrt", */
  },
  /*::[*/
  2067: {
    /* n:"RealTimeData", */
  },
  /*::[*/
  2128: {
    /* n:"ChartFrtInfo", */
  },
  /*::[*/
  2129: {
    /* n:"FrtWrapper", */
  },
  /*::[*/
  2130: {
    /* n:"StartBlock", */
  },
  /*::[*/
  2131: {
    /* n:"EndBlock", */
  },
  /*::[*/
  2132: {
    /* n:"StartObject", */
  },
  /*::[*/
  2133: {
    /* n:"EndObject", */
  },
  /*::[*/
  2134: {
    /* n:"CatLab", */
  },
  /*::[*/
  2135: {
    /* n:"YMult", */
  },
  /*::[*/
  2136: {
    /* n:"SXViewLink", */
  },
  /*::[*/
  2137: {
    /* n:"PivotChartBits", */
  },
  /*::[*/
  2138: {
    /* n:"FrtFontList", */
  },
  /*::[*/
  2146: {
    /* n:"SheetExt", */
  },
  /*::[*/
  2147: {
    /* n:"BookExt", */
    r: 12
  },
  /*::[*/
  2148: {
    /* n:"SXAddl", */
  },
  /*::[*/
  2149: {
    /* n:"CrErr", */
  },
  /*::[*/
  2150: {
    /* n:"HFPicture", */
  },
  /*::[*/
  2151: {
    /* n:"FeatHdr", */
    f: parsenoop2
  },
  /*::[*/
  2152: {
    /* n:"Feat", */
  },
  /*::[*/
  2154: {
    /* n:"DataLabExt", */
  },
  /*::[*/
  2155: {
    /* n:"DataLabExtContents", */
  },
  /*::[*/
  2156: {
    /* n:"CellWatch", */
  },
  /*::[*/
  2161: {
    /* n:"FeatHdr11", */
  },
  /*::[*/
  2162: {
    /* n:"Feature11", */
  },
  /*::[*/
  2164: {
    /* n:"DropDownObjIds", */
  },
  /*::[*/
  2165: {
    /* n:"ContinueFrt11", */
  },
  /*::[*/
  2166: {
    /* n:"DConn", */
  },
  /*::[*/
  2167: {
    /* n:"List12", */
  },
  /*::[*/
  2168: {
    /* n:"Feature12", */
  },
  /*::[*/
  2169: {
    /* n:"CondFmt12", */
  },
  /*::[*/
  2170: {
    /* n:"CF12", */
  },
  /*::[*/
  2171: {
    /* n:"CFEx", */
  },
  /*::[*/
  2172: {
    /* n:"XFCRC", */
    f: parse_XFCRC,
    r: 12
  },
  /*::[*/
  2173: {
    /* n:"XFExt", */
    f: parse_XFExt,
    r: 12
  },
  /*::[*/
  2174: {
    /* n:"AutoFilter12", */
  },
  /*::[*/
  2175: {
    /* n:"ContinueFrt12", */
  },
  /*::[*/
  2180: {
    /* n:"MDTInfo", */
  },
  /*::[*/
  2181: {
    /* n:"MDXStr", */
  },
  /*::[*/
  2182: {
    /* n:"MDXTuple", */
  },
  /*::[*/
  2183: {
    /* n:"MDXSet", */
  },
  /*::[*/
  2184: {
    /* n:"MDXProp", */
  },
  /*::[*/
  2185: {
    /* n:"MDXKPI", */
  },
  /*::[*/
  2186: {
    /* n:"MDB", */
  },
  /*::[*/
  2187: {
    /* n:"PLV", */
  },
  /*::[*/
  2188: {
    /* n:"Compat12", */
    f: parsebool,
    r: 12
  },
  /*::[*/
  2189: {
    /* n:"DXF", */
  },
  /*::[*/
  2190: {
    /* n:"TableStyles", */
    r: 12
  },
  /*::[*/
  2191: {
    /* n:"TableStyle", */
  },
  /*::[*/
  2192: {
    /* n:"TableStyleElement", */
  },
  /*::[*/
  2194: {
    /* n:"StyleExt", */
  },
  /*::[*/
  2195: {
    /* n:"NamePublish", */
  },
  /*::[*/
  2196: {
    /* n:"NameCmt", */
    f: parse_NameCmt,
    r: 12
  },
  /*::[*/
  2197: {
    /* n:"SortData", */
  },
  /*::[*/
  2198: {
    /* n:"Theme", */
    f: parse_Theme,
    r: 12
  },
  /*::[*/
  2199: {
    /* n:"GUIDTypeLib", */
  },
  /*::[*/
  2200: {
    /* n:"FnGrp12", */
  },
  /*::[*/
  2201: {
    /* n:"NameFnGrp12", */
  },
  /*::[*/
  2202: {
    /* n:"MTRSettings", */
    f: parse_MTRSettings,
    r: 12
  },
  /*::[*/
  2203: {
    /* n:"CompressPictures", */
    f: parsenoop2
  },
  /*::[*/
  2204: {
    /* n:"HeaderFooter", */
  },
  /*::[*/
  2205: {
    /* n:"CrtLayout12", */
  },
  /*::[*/
  2206: {
    /* n:"CrtMlFrt", */
  },
  /*::[*/
  2207: {
    /* n:"CrtMlFrtContinue", */
  },
  /*::[*/
  2211: {
    /* n:"ForceFullCalculation", */
    f: parse_ForceFullCalculation
  },
  /*::[*/
  2212: {
    /* n:"ShapePropsStream", */
  },
  /*::[*/
  2213: {
    /* n:"TextPropsStream", */
  },
  /*::[*/
  2214: {
    /* n:"RichTextStream", */
  },
  /*::[*/
  2215: {
    /* n:"CrtLayout12A", */
  },
  /*::[*/
  4097: {
    /* n:"Units", */
  },
  /*::[*/
  4098: {
    /* n:"Chart", */
  },
  /*::[*/
  4099: {
    /* n:"Series", */
  },
  /*::[*/
  4102: {
    /* n:"DataFormat", */
  },
  /*::[*/
  4103: {
    /* n:"LineFormat", */
  },
  /*::[*/
  4105: {
    /* n:"MarkerFormat", */
  },
  /*::[*/
  4106: {
    /* n:"AreaFormat", */
  },
  /*::[*/
  4107: {
    /* n:"PieFormat", */
  },
  /*::[*/
  4108: {
    /* n:"AttachedLabel", */
  },
  /*::[*/
  4109: {
    /* n:"SeriesText", */
  },
  /*::[*/
  4116: {
    /* n:"ChartFormat", */
  },
  /*::[*/
  4117: {
    /* n:"Legend", */
  },
  /*::[*/
  4118: {
    /* n:"SeriesList", */
  },
  /*::[*/
  4119: {
    /* n:"Bar", */
  },
  /*::[*/
  4120: {
    /* n:"Line", */
  },
  /*::[*/
  4121: {
    /* n:"Pie", */
  },
  /*::[*/
  4122: {
    /* n:"Area", */
  },
  /*::[*/
  4123: {
    /* n:"Scatter", */
  },
  /*::[*/
  4124: {
    /* n:"CrtLine", */
  },
  /*::[*/
  4125: {
    /* n:"Axis", */
  },
  /*::[*/
  4126: {
    /* n:"Tick", */
  },
  /*::[*/
  4127: {
    /* n:"ValueRange", */
  },
  /*::[*/
  4128: {
    /* n:"CatSerRange", */
  },
  /*::[*/
  4129: {
    /* n:"AxisLine", */
  },
  /*::[*/
  4130: {
    /* n:"CrtLink", */
  },
  /*::[*/
  4132: {
    /* n:"DefaultText", */
  },
  /*::[*/
  4133: {
    /* n:"Text", */
  },
  /*::[*/
  4134: {
    /* n:"FontX", */
    f: parseuint16
  },
  /*::[*/
  4135: {
    /* n:"ObjectLink", */
  },
  /*::[*/
  4146: {
    /* n:"Frame", */
  },
  /*::[*/
  4147: {
    /* n:"Begin", */
  },
  /*::[*/
  4148: {
    /* n:"End", */
  },
  /*::[*/
  4149: {
    /* n:"PlotArea", */
  },
  /*::[*/
  4154: {
    /* n:"Chart3d", */
  },
  /*::[*/
  4156: {
    /* n:"PicF", */
  },
  /*::[*/
  4157: {
    /* n:"DropBar", */
  },
  /*::[*/
  4158: {
    /* n:"Radar", */
  },
  /*::[*/
  4159: {
    /* n:"Surf", */
  },
  /*::[*/
  4160: {
    /* n:"RadarArea", */
  },
  /*::[*/
  4161: {
    /* n:"AxisParent", */
  },
  /*::[*/
  4163: {
    /* n:"LegendException", */
  },
  /*::[*/
  4164: {
    /* n:"ShtProps", */
    f: parse_ShtProps
  },
  /*::[*/
  4165: {
    /* n:"SerToCrt", */
  },
  /*::[*/
  4166: {
    /* n:"AxesUsed", */
  },
  /*::[*/
  4168: {
    /* n:"SBaseRef", */
  },
  /*::[*/
  4170: {
    /* n:"SerParent", */
  },
  /*::[*/
  4171: {
    /* n:"SerAuxTrend", */
  },
  /*::[*/
  4174: {
    /* n:"IFmtRecord", */
  },
  /*::[*/
  4175: {
    /* n:"Pos", */
  },
  /*::[*/
  4176: {
    /* n:"AlRuns", */
  },
  /*::[*/
  4177: {
    /* n:"BRAI", */
  },
  /*::[*/
  4187: {
    /* n:"SerAuxErrBar", */
  },
  /*::[*/
  4188: {
    /* n:"ClrtClient", */
    f: parse_ClrtClient
  },
  /*::[*/
  4189: {
    /* n:"SerFmt", */
  },
  /*::[*/
  4191: {
    /* n:"Chart3DBarShape", */
  },
  /*::[*/
  4192: {
    /* n:"Fbi", */
  },
  /*::[*/
  4193: {
    /* n:"BopPop", */
  },
  /*::[*/
  4194: {
    /* n:"AxcExt", */
  },
  /*::[*/
  4195: {
    /* n:"Dat", */
  },
  /*::[*/
  4196: {
    /* n:"PlotGrowth", */
  },
  /*::[*/
  4197: {
    /* n:"SIIndex", */
  },
  /*::[*/
  4198: {
    /* n:"GelFrame", */
  },
  /*::[*/
  4199: {
    /* n:"BopPopCustom", */
  },
  /*::[*/
  4200: {
    /* n:"Fbi2", */
  },
  /*::[*/
  0: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  /*::[*/
  1: {
    /* n:"BIFF2BLANK", */
  },
  /*::[*/
  2: {
    /* n:"BIFF2INT", */
    f: parse_BIFF2INT
  },
  /*::[*/
  3: {
    /* n:"BIFF2NUM", */
    f: parse_BIFF2NUM
  },
  /*::[*/
  4: {
    /* n:"BIFF2STR", */
    f: parse_BIFF2STR
  },
  /*::[*/
  5: {
    /* n:"BoolErr", */
    f: parse_BoolErr
  },
  /*::[*/
  7: {
    /* n:"String", */
    f: parse_BIFF2STRING
  },
  /*::[*/
  8: {
    /* n:"BIFF2ROW", */
  },
  /*::[*/
  9: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  11: {
    /* n:"Index", */
  },
  /*::[*/
  22: {
    /* n:"ExternCount", */
    f: parseuint16
  },
  /*::[*/
  30: {
    /* n:"BIFF2FORMAT", */
    f: parse_BIFF2Format
  },
  /*::[*/
  31: {
    /* n:"BIFF2FMTCNT", */
  },
  /* 16-bit cnt of BIFF2FORMAT records */
  /*::[*/
  32: {
    /* n:"BIFF2COLINFO", */
  },
  /*::[*/
  33: {
    /* n:"Array", */
    f: parse_Array
  },
  /*::[*/
  36: {
    /* n:"COLWIDTH", */
  },
  /*::[*/
  37: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  // 0x2c ??
  // 0x2d ??
  // 0x2e ??
  // 0x30 FONTCOUNT: number of fonts
  /*::[*/
  50: {
    /* n:"BIFF2FONTXTRA", */
    f: parse_BIFF2FONTXTRA
  },
  // 0x35: INFOOPTS
  // 0x36: TABLE (BIFF2 only)
  // 0x37: TABLE2 (BIFF2 only)
  // 0x38: WNDESK
  // 0x39 ??
  // 0x3a: BEGINPREF
  // 0x3b: ENDPREF
  /*::[*/
  62: {
    /* n:"BIFF2WINDOW2", */
  },
  // 0x3f ??
  // 0x46: SHOWSCROLL
  // 0x47: SHOWFORMULA
  // 0x48: STATUSBAR
  // 0x49: SHORTMENUS
  // 0x4A:
  // 0x4B:
  // 0x4C:
  // 0x4E:
  // 0x4F:
  // 0x58: TOOLBAR (BIFF3)
  /* - - - */
  /*::[*/
  52: {
    /* n:"DDEObjName", */
  },
  /*::[*/
  67: {
    /* n:"BIFF2XF", */
  },
  /*::[*/
  68: {
    /* n:"BIFF2XFINDEX", */
    f: parseuint16
  },
  /*::[*/
  69: {
    /* n:"BIFF2FONTCLR", */
  },
  /*::[*/
  86: {
    /* n:"BIFF4FMTCNT", */
  },
  /* 16-bit cnt, similar to BIFF2 */
  /*::[*/
  126: {
    /* n:"RK", */
  },
  /* Not necessarily same as 0x027e */
  /*::[*/
  127: {
    /* n:"ImData", */
    f: parse_ImData
  },
  /*::[*/
  135: {
    /* n:"Addin", */
  },
  /*::[*/
  136: {
    /* n:"Edg", */
  },
  /*::[*/
  137: {
    /* n:"Pub", */
  },
  // 0x8A
  // 0x8B LH: alternate menu key flag (BIFF3/4)
  // 0x8E
  // 0x8F
  /*::[*/
  145: {
    /* n:"Sub", */
  },
  // 0x93 STYLE
  /*::[*/
  148: {
    /* n:"LHRecord", */
  },
  /*::[*/
  149: {
    /* n:"LHNGraph", */
  },
  /*::[*/
  150: {
    /* n:"Sound", */
  },
  // 0xA2 FNPROTO: function prototypes (BIFF4)
  // 0xA3
  // 0xA8
  /*::[*/
  169: {
    /* n:"CoordList", */
  },
  /*::[*/
  171: {
    /* n:"GCW", */
  },
  /*::[*/
  188: {
    /* n:"ShrFmla", */
  },
  /* Not necessarily same as 0x04bc */
  /*::[*/
  191: {
    /* n:"ToolbarHdr", */
  },
  /*::[*/
  192: {
    /* n:"ToolbarEnd", */
  },
  /*::[*/
  194: {
    /* n:"AddMenu", */
  },
  /*::[*/
  195: {
    /* n:"DelMenu", */
  },
  /*::[*/
  214: {
    /* n:"RString", */
    f: parse_RString
  },
  /*::[*/
  223: {
    /* n:"UDDesc", */
  },
  /*::[*/
  234: {
    /* n:"TabIdConf", */
  },
  /*::[*/
  354: {
    /* n:"XL5Modify", */
  },
  /*::[*/
  421: {
    /* n:"FileSharing2", */
  },
  /*::[*/
  518: {
    /* n:"Formula", */
    f: parse_Formula
  },
  /*::[*/
  521: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  536: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  /*::[*/
  547: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  /*::[*/
  561: {
    /* n:"Font", */
  },
  /*::[*/
  579: {
    /* n:"BIFF3XF", */
  },
  /*::[*/
  1030: {
    /* n:"Formula", */
    f: parse_Formula
  },
  /*::[*/
  1033: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  1091: {
    /* n:"BIFF4XF", */
  },
  /*::[*/
  2157: {
    /* n:"FeatInfo", */
  },
  /*::[*/
  2163: {
    /* n:"FeatInfo11", */
  },
  /*::[*/
  2177: {
    /* n:"SXAddl12", */
  },
  /*::[*/
  2240: {
    /* n:"AutoWebPub", */
  },
  /*::[*/
  2241: {
    /* n:"ListObj", */
  },
  /*::[*/
  2242: {
    /* n:"ListField", */
  },
  /*::[*/
  2243: {
    /* n:"ListDV", */
  },
  /*::[*/
  2244: {
    /* n:"ListCondFmt", */
  },
  /*::[*/
  2245: {
    /* n:"ListCF", */
  },
  /*::[*/
  2246: {
    /* n:"FMQry", */
  },
  /*::[*/
  2247: {
    /* n:"FMSQry", */
  },
  /*::[*/
  2248: {
    /* n:"PLV", */
  },
  /*::[*/
  2249: {
    /* n:"LnExt", */
  },
  /*::[*/
  2250: {
    /* n:"MkrExt", */
  },
  /*::[*/
  2251: {
    /* n:"CrtCoopt", */
  },
  /*::[*/
  2262: {
    /* n:"FRTArchId$", */
    r: 12
  },
  /* --- multiplan 4 records --- */
  /*::[*/
  101: {
    /* n:"", */
  },
  // one per window
  /*::[*/
  102: {
    /* n:"", */
  },
  // calc settings
  /*::[*/
  105: {
    /* n:"", */
  },
  // print header
  /*::[*/
  106: {
    /* n:"", */
  },
  // print footer
  /*::[*/
  107: {
    /* n:"", */
  },
  // print settings
  /*::[*/
  109: {
    /* n:"", */
  },
  // one per window
  /*::[*/
  112: {
    /* n:"", */
  },
  // includes default col width
  /*::[*/
  114: {
    /* n:"", */
  },
  // includes selected cell
  /*::[*/
  29282: {}
};
function write_biff_rec(ba, type, payload, length2) {
  var t = type;
  if (isNaN(t))
    return;
  var len = length2 || (payload || []).length || 0;
  var o = ba.next(4);
  o.write_shift(2, t);
  o.write_shift(2, len);
  if (
    /*:: len != null &&*/
    len > 0 && is_buf(payload)
  )
    ba.push(payload);
}
function write_biff_continue(ba, type, payload, length2) {
  var len = length2 || (payload || []).length || 0;
  if (len <= 8224)
    return write_biff_rec(ba, type, payload, len);
  var t = type;
  if (isNaN(t))
    return;
  var parts = payload.parts || [], sidx = 0;
  var i = 0, w2 = 0;
  while (w2 + (parts[sidx] || 8224) <= 8224) {
    w2 += parts[sidx] || 8224;
    sidx++;
  }
  var o = ba.next(4);
  o.write_shift(2, t);
  o.write_shift(2, w2);
  ba.push(payload.slice(i, i + w2));
  i += w2;
  while (i < len) {
    o = ba.next(4);
    o.write_shift(2, 60);
    w2 = 0;
    while (w2 + (parts[sidx] || 8224) <= 8224) {
      w2 += parts[sidx] || 8224;
      sidx++;
    }
    o.write_shift(2, w2);
    ba.push(payload.slice(i, i + w2));
    i += w2;
  }
}
function write_BIFF2Cell(out, r, c) {
  if (!out)
    out = new_buf(7);
  out.write_shift(2, r);
  out.write_shift(2, c);
  out.write_shift(2, 0);
  out.write_shift(1, 0);
  return out;
}
function write_BIFF2BERR(r, c, val, t) {
  var out = new_buf(9);
  write_BIFF2Cell(out, r, c);
  write_Bes(val, t || "b", out);
  return out;
}
function write_BIFF2LABEL(r, c, val) {
  var out = new_buf(8 + 2 * val.length);
  write_BIFF2Cell(out, r, c);
  out.write_shift(1, val.length);
  out.write_shift(val.length, val, "sbcs");
  return out.l < out.length ? out.slice(0, out.l) : out;
}
function write_ws_biff2_cell(ba, cell, R, C) {
  if (cell.v != null)
    switch (cell.t) {
      case "d":
      case "n":
        var v = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
        if (v == (v | 0) && v >= 0 && v < 65536)
          write_biff_rec(ba, 2, write_BIFF2INT(R, C, v));
        else
          write_biff_rec(ba, 3, write_BIFF2NUM(R, C, v));
        return;
      case "b":
      case "e":
        write_biff_rec(ba, 5, write_BIFF2BERR(R, C, cell.v, cell.t));
        return;
      case "s":
      case "str":
        write_biff_rec(ba, 4, write_BIFF2LABEL(R, C, cell.v == null ? "" : String(cell.v).slice(0, 255)));
        return;
    }
  write_biff_rec(ba, 1, write_BIFF2Cell(null, R, C));
}
function write_ws_biff2(ba, ws, idx, opts) {
  var dense = ws["!data"] != null;
  var range = safe_decode_range(ws["!ref"] || "A1"), rr = "", cols = [];
  if (range.e.c > 255 || range.e.r > 16383) {
    if (opts.WTF)
      throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    range.e.c = Math.min(range.e.c, 255);
    range.e.r = Math.min(range.e.c, 16383);
  }
  var row = [];
  for (var C = range.s.c; C <= range.e.c; ++C)
    cols[C] = encode_col(C);
  for (var R = range.s.r; R <= range.e.r; ++R) {
    if (dense)
      row = ws["!data"][R] || [];
    rr = encode_row(R);
    for (C = range.s.c; C <= range.e.c; ++C) {
      var cell = dense ? row[C] : ws[cols[C] + rr];
      if (!cell)
        continue;
      write_ws_biff2_cell(ba, cell, R, C);
    }
  }
}
function write_biff2_buf(wb, opts) {
  var o = opts || {};
  var ba = buf_array();
  var idx = 0;
  for (var i = 0; i < wb.SheetNames.length; ++i)
    if (wb.SheetNames[i] == o.sheet)
      idx = i;
  if (idx == 0 && !!o.sheet && wb.SheetNames[0] != o.sheet)
    throw new Error("Sheet not found: " + o.sheet);
  write_biff_rec(ba, o.biff == 4 ? 1033 : o.biff == 3 ? 521 : 9, write_BOF(wb, 16, o));
  write_ws_biff2(ba, wb.Sheets[wb.SheetNames[idx]], idx, o);
  write_biff_rec(ba, 10);
  return ba.end();
}
function write_FONTS_biff8(ba, data, opts) {
  write_biff_rec(ba, 49, write_Font({
    sz: 12,
    color: { theme: 1 },
    name: "Arial",
    family: 2,
    scheme: "minor"
  }, opts));
}
function write_FMTS_biff8(ba, NF, opts) {
  if (!NF)
    return;
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r) {
    for (var i = r[0]; i <= r[1]; ++i)
      if (NF[i] != null)
        write_biff_rec(ba, 1054, write_Format(i, NF[i], opts));
  });
}
function write_FEAT(ba, ws) {
  var o = new_buf(19);
  o.write_shift(4, 2151);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  o.write_shift(2, 3);
  o.write_shift(1, 1);
  o.write_shift(4, 0);
  write_biff_rec(ba, 2151, o);
  o = new_buf(39);
  o.write_shift(4, 2152);
  o.write_shift(4, 0);
  o.write_shift(4, 0);
  o.write_shift(2, 3);
  o.write_shift(1, 0);
  o.write_shift(4, 0);
  o.write_shift(2, 1);
  o.write_shift(4, 4);
  o.write_shift(2, 0);
  write_Ref8U(safe_decode_range(ws["!ref"] || "A1"), o);
  o.write_shift(4, 4);
  write_biff_rec(ba, 2152, o);
}
function write_CELLXFS_biff8(ba, opts) {
  for (var i = 0; i < 16; ++i)
    write_biff_rec(ba, 224, write_XF({ numFmtId: 0, style: true }, 0, opts));
  opts.cellXfs.forEach(function(c) {
    write_biff_rec(ba, 224, write_XF(c, 0, opts));
  });
}
function write_ws_biff8_hlinks(ba, ws) {
  for (var R = 0; R < ws["!links"].length; ++R) {
    var HL = ws["!links"][R];
    write_biff_rec(ba, 440, write_HLink(HL));
    if (HL[1].Tooltip)
      write_biff_rec(ba, 2048, write_HLinkTooltip(HL));
  }
  delete ws["!links"];
}
function write_ws_cols_biff8(ba, cols) {
  if (!cols)
    return;
  var cnt = 0;
  cols.forEach(function(col, idx) {
    if (++cnt <= 256 && col) {
      write_biff_rec(ba, 125, write_ColInfo(col_obj_w(idx, col), idx));
    }
  });
}
function write_ws_biff8_cell(ba, cell, R, C, opts) {
  var os = 16 + get_cell_style(opts.cellXfs, cell, opts);
  if (cell.v == null && !cell.bf) {
    write_biff_rec(ba, 513, write_XLSCell(R, C, os));
    return;
  }
  if (cell.bf)
    write_biff_rec(ba, 6, write_Formula(cell, R, C, opts, os));
  else
    switch (cell.t) {
      case "d":
      case "n":
        var v = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
        write_biff_rec(ba, 515, write_Number(R, C, v, os));
        break;
      case "b":
      case "e":
        write_biff_rec(ba, 517, write_BoolErr(R, C, cell.v, os, opts, cell.t));
        break;
      case "s":
      case "str":
        if (opts.bookSST) {
          var isst = get_sst_id(opts.Strings, cell.v == null ? "" : String(cell.v), opts.revStrings);
          write_biff_rec(ba, 253, write_LabelSst(R, C, isst, os));
        } else
          write_biff_rec(ba, 516, write_Label(R, C, (cell.v == null ? "" : String(cell.v)).slice(0, 255), os, opts));
        break;
      default:
        write_biff_rec(ba, 513, write_XLSCell(R, C, os));
    }
}
function write_ws_biff8(idx, opts, wb) {
  var ba = buf_array();
  var s = wb.SheetNames[idx], ws = wb.Sheets[s] || {};
  var _WB = (wb || {}).Workbook || {};
  var _sheet = (_WB.Sheets || [])[idx] || {};
  var dense = ws["!data"] != null;
  var b8 = opts.biff == 8;
  var ref, rr = "", cols = [];
  var range = safe_decode_range(ws["!ref"] || "A1");
  var MAX_ROWS = b8 ? 65536 : 16384;
  if (range.e.c > 255 || range.e.r >= MAX_ROWS) {
    if (opts.WTF)
      throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    range.e.c = Math.min(range.e.c, 255);
    range.e.r = Math.min(range.e.c, MAX_ROWS - 1);
  }
  write_biff_rec(ba, 2057, write_BOF(wb, 16, opts));
  write_biff_rec(ba, 13, writeuint16(1));
  write_biff_rec(ba, 12, writeuint16(100));
  write_biff_rec(ba, 15, writebool(true));
  write_biff_rec(ba, 17, writebool(false));
  write_biff_rec(ba, 16, write_Xnum(1e-3));
  write_biff_rec(ba, 95, writebool(true));
  write_biff_rec(ba, 42, writebool(false));
  write_biff_rec(ba, 43, writebool(false));
  write_biff_rec(ba, 130, writeuint16(1));
  write_biff_rec(ba, 128, write_Guts([0, 0]));
  write_biff_rec(ba, 131, writebool(false));
  write_biff_rec(ba, 132, writebool(false));
  if (b8)
    write_ws_cols_biff8(ba, ws["!cols"]);
  write_biff_rec(ba, 512, write_Dimensions(range, opts));
  if (b8)
    ws["!links"] = [];
  var comments = [];
  var row = [];
  for (var C = range.s.c; C <= range.e.c; ++C)
    cols[C] = encode_col(C);
  for (var R = range.s.r; R <= range.e.r; ++R) {
    if (dense)
      row = ws["!data"][R] || [];
    rr = encode_row(R);
    for (C = range.s.c; C <= range.e.c; ++C) {
      ref = cols[C] + rr;
      var cell = dense ? row[C] : ws[ref];
      if (!cell)
        continue;
      write_ws_biff8_cell(ba, cell, R, C, opts);
      if (b8 && cell.l)
        ws["!links"].push([ref, cell.l]);
      if (b8 && cell.c)
        comments.push([ref, cell.c]);
    }
  }
  var cname = _sheet.CodeName || _sheet.name || s;
  if (b8)
    write_biff_rec(ba, 574, write_Window2((_WB.Views || [])[0]));
  if (b8 && (ws["!merges"] || []).length)
    write_biff_rec(ba, 229, write_MergeCells(ws["!merges"]));
  if (b8)
    write_ws_biff8_hlinks(ba, ws);
  write_biff_rec(ba, 442, write_XLUnicodeString(cname));
  if (b8)
    write_FEAT(ba, ws);
  write_biff_rec(
    ba,
    10
    /* EOF */
  );
  return ba.end();
}
function write_biff8_global(wb, bufs, opts) {
  var A = buf_array();
  var _WB = (wb || {}).Workbook || {};
  var _sheets = _WB.Sheets || [];
  var _wb = (
    /*::((*/
    _WB.WBProps || {
      /*::CodeName:"ThisWorkbook"*/
    }
  );
  var b8 = opts.biff == 8, b5 = opts.biff == 5;
  write_biff_rec(A, 2057, write_BOF(wb, 5, opts));
  if (opts.bookType == "xla")
    write_biff_rec(
      A,
      135
      /* Addin */
    );
  write_biff_rec(A, 225, b8 ? writeuint16(1200) : null);
  write_biff_rec(A, 193, writezeroes(2));
  if (b5)
    write_biff_rec(
      A,
      191
      /* ToolbarHdr */
    );
  if (b5)
    write_biff_rec(
      A,
      192
      /* ToolbarEnd */
    );
  write_biff_rec(
    A,
    226
    /* InterfaceEnd */
  );
  write_biff_rec(A, 92, write_WriteAccess("SheetJS", opts));
  write_biff_rec(A, 66, writeuint16(b8 ? 1200 : 1252));
  if (b8)
    write_biff_rec(A, 353, writeuint16(0));
  if (b8)
    write_biff_rec(
      A,
      448
      /* Excel9File */
    );
  write_biff_rec(A, 317, write_RRTabId(wb.SheetNames.length));
  if (b8 && wb.vbaraw)
    write_biff_rec(
      A,
      211
      /* ObProj */
    );
  if (b8 && wb.vbaraw) {
    var cname = _wb.CodeName || "ThisWorkbook";
    write_biff_rec(A, 442, write_XLUnicodeString(cname));
  }
  write_biff_rec(A, 156, writeuint16(17));
  write_biff_rec(A, 25, writebool(false));
  write_biff_rec(A, 18, writebool(false));
  write_biff_rec(A, 19, writeuint16(0));
  if (b8)
    write_biff_rec(A, 431, writebool(false));
  if (b8)
    write_biff_rec(A, 444, writeuint16(0));
  write_biff_rec(A, 61, write_Window1());
  write_biff_rec(A, 64, writebool(false));
  write_biff_rec(A, 141, writeuint16(0));
  write_biff_rec(A, 34, writebool(safe1904(wb) == "true"));
  write_biff_rec(A, 14, writebool(true));
  if (b8)
    write_biff_rec(A, 439, writebool(false));
  write_biff_rec(A, 218, writeuint16(0));
  write_FONTS_biff8(A, wb, opts);
  write_FMTS_biff8(A, wb.SSF, opts);
  write_CELLXFS_biff8(A, opts);
  if (b8)
    write_biff_rec(A, 352, writebool(false));
  var a = A.end();
  var C = buf_array();
  if (b8)
    write_biff_rec(C, 140, write_Country());
  if (b8 && opts.Strings)
    write_biff_continue(C, 252, write_SST(opts.Strings));
  write_biff_rec(
    C,
    10
    /* EOF */
  );
  var c = C.end();
  var B = buf_array();
  var blen = 0, j = 0;
  for (j = 0; j < wb.SheetNames.length; ++j)
    blen += (b8 ? 12 : 11) + (b8 ? 2 : 1) * wb.SheetNames[j].length;
  var start = a.length + blen + c.length;
  for (j = 0; j < wb.SheetNames.length; ++j) {
    var _sheet = _sheets[j] || {};
    write_biff_rec(B, 133, write_BoundSheet8({ pos: start, hs: _sheet.Hidden || 0, dt: 0, name: wb.SheetNames[j] }, opts));
    start += bufs[j].length;
  }
  var b = B.end();
  if (blen != b.length)
    throw new Error("BS8 " + blen + " != " + b.length);
  var out = [];
  if (a.length)
    out.push(a);
  if (b.length)
    out.push(b);
  if (c.length)
    out.push(c);
  return bconcat(out);
}
function write_biff8_buf(wb, opts) {
  var o = opts || {};
  var bufs = [];
  if (wb && !wb.SSF) {
    wb.SSF = dup(table_fmt);
  }
  if (wb && wb.SSF) {
    make_ssf();
    SSF_load_table(wb.SSF);
    o.revssf = evert_num(wb.SSF);
    o.revssf[wb.SSF[65535]] = 0;
    o.ssf = wb.SSF;
  }
  o.Strings = /*::((*/
  [];
  o.Strings.Count = 0;
  o.Strings.Unique = 0;
  fix_write_opts(o);
  o.cellXfs = [];
  get_cell_style(o.cellXfs, {}, { revssf: { "General": 0 } });
  if (!wb.Props)
    wb.Props = {};
  for (var i = 0; i < wb.SheetNames.length; ++i)
    bufs[bufs.length] = write_ws_biff8(i, o, wb);
  bufs.unshift(write_biff8_global(wb, bufs, o));
  return bconcat(bufs);
}
function write_biff_buf(wb, opts) {
  for (var i = 0; i <= wb.SheetNames.length; ++i) {
    var ws = wb.Sheets[wb.SheetNames[i]];
    if (!ws || !ws["!ref"])
      continue;
    var range = decode_range(ws["!ref"]);
    if (range.e.c > 255) {
      if (typeof console != "undefined" && console.error)
        console.error("Worksheet '" + wb.SheetNames[i] + "' extends beyond column IV (255).  Data may be lost.");
    }
  }
  var o = opts || {};
  switch (o.biff || 2) {
    case 8:
    case 5:
      return write_biff8_buf(wb, opts);
    case 4:
    case 3:
    case 2:
      return write_biff2_buf(wb, opts);
  }
  throw new Error("invalid type " + o.bookType + " for BIFF");
}
function html_to_sheet(str, _opts) {
  var opts = _opts || {};
  var dense = opts.dense != null ? opts.dense : DENSE;
  var ws = {};
  if (dense)
    ws["!data"] = [];
  str = str.replace(/<!--.*?-->/g, "");
  var mtch = str.match(/<table/i);
  if (!mtch)
    throw new Error("Invalid HTML: could not find <table>");
  var mtch2 = str.match(/<\/table/i);
  var i = mtch.index, j = mtch2 && mtch2.index || str.length;
  var rows = split_regex(str.slice(i, j), /(:?<tr[^>]*>)/i, "<tr>");
  var R = -1, C = 0, RS = 0, CS = 0;
  var range = { s: { r: 1e7, c: 1e7 }, e: { r: 0, c: 0 } };
  var merges = [];
  for (i = 0; i < rows.length; ++i) {
    var row = rows[i].trim();
    var hd = row.slice(0, 3).toLowerCase();
    if (hd == "<tr") {
      ++R;
      if (opts.sheetRows && opts.sheetRows <= R) {
        --R;
        break;
      }
      C = 0;
      continue;
    }
    if (hd != "<td" && hd != "<th")
      continue;
    var cells = row.split(/<\/t[dh]>/i);
    for (j = 0; j < cells.length; ++j) {
      var cell = cells[j].trim();
      if (!cell.match(/<t[dh]/i))
        continue;
      var m = cell, cc = 0;
      while (m.charAt(0) == "<" && (cc = m.indexOf(">")) > -1)
        m = m.slice(cc + 1);
      for (var midx = 0; midx < merges.length; ++midx) {
        var _merge2 = merges[midx];
        if (_merge2.s.c == C && _merge2.s.r < R && R <= _merge2.e.r) {
          C = _merge2.e.c + 1;
          midx = -1;
        }
      }
      var tag = parsexmltag(cell.slice(0, cell.indexOf(">")));
      CS = tag.colspan ? +tag.colspan : 1;
      if ((RS = +tag.rowspan) > 1 || CS > 1)
        merges.push({ s: { r: R, c: C }, e: { r: R + (RS || 1) - 1, c: C + CS - 1 } });
      var _t = tag.t || tag["data-t"] || "";
      if (!m.length) {
        C += CS;
        continue;
      }
      m = htmldecode(m);
      if (range.s.r > R)
        range.s.r = R;
      if (range.e.r < R)
        range.e.r = R;
      if (range.s.c > C)
        range.s.c = C;
      if (range.e.c < C)
        range.e.c = C;
      if (!m.length) {
        C += CS;
        continue;
      }
      var o = { t: "s", v: m };
      if (opts.raw || !m.trim().length || _t == "s")
        ;
      else if (m === "TRUE")
        o = { t: "b", v: true };
      else if (m === "FALSE")
        o = { t: "b", v: false };
      else if (!isNaN(fuzzynum(m)))
        o = { t: "n", v: fuzzynum(m) };
      else if (!isNaN(fuzzydate(m).getDate())) {
        o = { t: "d", v: parseDate(m) };
        if (!opts.cellDates)
          o = { t: "n", v: datenum(o.v) };
        o.z = opts.dateNF || table_fmt[14];
      }
      if (dense) {
        if (!ws["!data"][R])
          ws["!data"][R] = [];
        ws["!data"][R][C] = o;
      } else
        ws[encode_cell({ r: R, c: C })] = o;
      C += CS;
    }
  }
  ws["!ref"] = encode_range(range);
  if (merges.length)
    ws["!merges"] = merges;
  return ws;
}
function make_html_row(ws, r, R, o) {
  var M = ws["!merges"] || [];
  var oo = [];
  var sp = {};
  var dense = ws["!data"] != null;
  for (var C = r.s.c; C <= r.e.c; ++C) {
    var RS = 0, CS = 0;
    for (var j = 0; j < M.length; ++j) {
      if (M[j].s.r > R || M[j].s.c > C)
        continue;
      if (M[j].e.r < R || M[j].e.c < C)
        continue;
      if (M[j].s.r < R || M[j].s.c < C) {
        RS = -1;
        break;
      }
      RS = M[j].e.r - M[j].s.r + 1;
      CS = M[j].e.c - M[j].s.c + 1;
      break;
    }
    if (RS < 0)
      continue;
    var coord = encode_col(C) + encode_row(R);
    var cell = dense ? (ws["!data"][R] || [])[C] : ws[coord];
    var w2 = cell && cell.v != null && (cell.h || escapehtml(cell.w || (format_cell(cell), cell.w) || "")) || "";
    sp = {};
    if (RS > 1)
      sp.rowspan = RS;
    if (CS > 1)
      sp.colspan = CS;
    if (o.editable)
      w2 = '<span contenteditable="true">' + w2 + "</span>";
    else if (cell) {
      sp["data-t"] = cell && cell.t || "z";
      if (cell.v != null)
        sp["data-v"] = cell.v;
      if (cell.z != null)
        sp["data-z"] = cell.z;
      if (cell.l && (cell.l.Target || "#").charAt(0) != "#")
        w2 = '<a href="' + escapehtml(cell.l.Target) + '">' + w2 + "</a>";
    }
    sp.id = (o.id || "sjs") + "-" + coord;
    oo.push(writextag("td", w2, sp));
  }
  var preamble = "<tr>";
  return preamble + oo.join("") + "</tr>";
}
var HTML_BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';
var HTML_END = "</body></html>";
function html_to_workbook(str, opts) {
  var mtch = str.match(/<table[\s\S]*?>[\s\S]*?<\/table>/gi);
  if (!mtch || mtch.length == 0)
    throw new Error("Invalid HTML: could not find <table>");
  if (mtch.length == 1) {
    var w2 = sheet_to_workbook(html_to_sheet(mtch[0], opts), opts);
    w2.bookType = "html";
    return w2;
  }
  var wb = book_new();
  mtch.forEach(function(s, idx) {
    book_append_sheet(wb, html_to_sheet(s, opts), "Sheet" + (idx + 1));
  });
  wb.bookType = "html";
  return wb;
}
function make_html_preamble(ws, R, o) {
  var out = [];
  return out.join("") + "<table" + (o && o.id ? ' id="' + o.id + '"' : "") + ">";
}
function sheet_to_html(ws, opts) {
  var o = opts || {};
  var header = o.header != null ? o.header : HTML_BEGIN;
  var footer = o.footer != null ? o.footer : HTML_END;
  var out = [header];
  var r = decode_range(ws["!ref"]);
  out.push(make_html_preamble(ws, r, o));
  for (var R = r.s.r; R <= r.e.r; ++R)
    out.push(make_html_row(ws, r, R, o));
  out.push("</table>" + footer);
  return out.join("");
}
function sheet_add_dom(ws, table, _opts) {
  var rows = table.rows;
  if (!rows) {
    throw "Unsupported origin when " + table.tagName + " is not a TABLE";
  }
  var opts = _opts || {};
  var dense = ws["!data"] != null;
  var or_R = 0, or_C = 0;
  if (opts.origin != null) {
    if (typeof opts.origin == "number")
      or_R = opts.origin;
    else {
      var _origin = typeof opts.origin == "string" ? decode_cell(opts.origin) : opts.origin;
      or_R = _origin.r;
      or_C = _origin.c;
    }
  }
  var sheetRows = Math.min(opts.sheetRows || 1e7, rows.length);
  var range = { s: { r: 0, c: 0 }, e: { r: or_R, c: or_C } };
  if (ws["!ref"]) {
    var _range = decode_range(ws["!ref"]);
    range.s.r = Math.min(range.s.r, _range.s.r);
    range.s.c = Math.min(range.s.c, _range.s.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    range.e.c = Math.max(range.e.c, _range.e.c);
    if (or_R == -1)
      range.e.r = or_R = _range.e.r + 1;
  }
  var merges = [], midx = 0;
  var rowinfo = ws["!rows"] || (ws["!rows"] = []);
  var _R = 0, R = 0, _C = 0, C = 0, RS = 0, CS = 0;
  if (!ws["!cols"])
    ws["!cols"] = [];
  for (; _R < rows.length && R < sheetRows; ++_R) {
    var row = rows[_R];
    if (is_dom_element_hidden(row)) {
      if (opts.display)
        continue;
      rowinfo[R] = { hidden: true };
    }
    var elts = row.cells;
    for (_C = C = 0; _C < elts.length; ++_C) {
      var elt = elts[_C];
      if (opts.display && is_dom_element_hidden(elt))
        continue;
      var v = elt.hasAttribute("data-v") ? elt.getAttribute("data-v") : elt.hasAttribute("v") ? elt.getAttribute("v") : htmldecode(elt.innerHTML);
      var z = elt.getAttribute("data-z") || elt.getAttribute("z");
      for (midx = 0; midx < merges.length; ++midx) {
        var m = merges[midx];
        if (m.s.c == C + or_C && m.s.r < R + or_R && R + or_R <= m.e.r) {
          C = m.e.c + 1 - or_C;
          midx = -1;
        }
      }
      CS = +elt.getAttribute("colspan") || 1;
      if ((RS = +elt.getAttribute("rowspan") || 1) > 1 || CS > 1)
        merges.push({ s: { r: R + or_R, c: C + or_C }, e: { r: R + or_R + (RS || 1) - 1, c: C + or_C + (CS || 1) - 1 } });
      var o = { t: "s", v };
      var _t = elt.getAttribute("data-t") || elt.getAttribute("t") || "";
      if (v != null) {
        if (v.length == 0)
          o.t = _t || "z";
        else if (opts.raw || v.trim().length == 0 || _t == "s")
          ;
        else if (v === "TRUE")
          o = { t: "b", v: true };
        else if (v === "FALSE")
          o = { t: "b", v: false };
        else if (!isNaN(fuzzynum(v)))
          o = { t: "n", v: fuzzynum(v) };
        else if (!isNaN(fuzzydate(v).getDate())) {
          o = { t: "d", v: parseDate(v) };
          if (!opts.cellDates)
            o = { t: "n", v: datenum(o.v) };
          o.z = opts.dateNF || table_fmt[14];
        }
      }
      if (o.z === void 0 && z != null)
        o.z = z;
      var l = "", Aelts = elt.getElementsByTagName("A");
      if (Aelts && Aelts.length) {
        for (var Aelti = 0; Aelti < Aelts.length; ++Aelti)
          if (Aelts[Aelti].hasAttribute("href")) {
            l = Aelts[Aelti].getAttribute("href");
            if (l.charAt(0) != "#")
              break;
          }
      }
      if (l && l.charAt(0) != "#" && l.slice(0, 11).toLowerCase() != "javascript:")
        o.l = { Target: l };
      if (dense) {
        if (!ws["!data"][R + or_R])
          ws["!data"][R + or_R] = [];
        ws["!data"][R + or_R][C + or_C] = o;
      } else
        ws[encode_cell({ c: C + or_C, r: R + or_R })] = o;
      if (range.e.c < C + or_C)
        range.e.c = C + or_C;
      C += CS;
    }
    ++R;
  }
  if (merges.length)
    ws["!merges"] = (ws["!merges"] || []).concat(merges);
  range.e.r = Math.max(range.e.r, R - 1 + or_R);
  ws["!ref"] = encode_range(range);
  if (R >= sheetRows)
    ws["!fullref"] = encode_range((range.e.r = rows.length - _R + R - 1 + or_R, range));
  return ws;
}
function parse_dom_table(table, _opts) {
  var opts = _opts || {};
  var ws = {};
  if (opts.dense)
    ws["!data"] = [];
  return sheet_add_dom(ws, table, _opts);
}
function table_to_book(table, opts) {
  var o = sheet_to_workbook(parse_dom_table(table, opts), opts);
  return o;
}
function is_dom_element_hidden(element) {
  var display = "";
  var get_computed_style = get_get_computed_style_function(element);
  if (get_computed_style)
    display = get_computed_style(element).getPropertyValue("display");
  if (!display)
    display = element.style && element.style.display;
  return display === "none";
}
function get_get_computed_style_function(element) {
  if (element.ownerDocument.defaultView && typeof element.ownerDocument.defaultView.getComputedStyle === "function")
    return element.ownerDocument.defaultView.getComputedStyle;
  if (typeof getComputedStyle === "function")
    return getComputedStyle;
  return null;
}
function parse_text_p(text) {
  var fixed = text.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function($$, $1) {
    return Array(parseInt($1, 10) + 1).join(" ");
  }).replace(/<text:tab[^>]*\/>/g, "	").replace(/<text:line-break\/>/g, "\n");
  var v = unescapexml(fixed.replace(/<[^>]*>/g, ""));
  return [v];
}
function parse_ods_styles(d, _opts, _nfm) {
  var number_format_map = _nfm || {};
  var str = xlml_normalize(d);
  xlmlregex.lastIndex = 0;
  str = str.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
  var Rn, NFtag, NF = "", tNF = "", y, etpos = 0, tidx = -1, payload = "";
  while (Rn = xlmlregex.exec(str)) {
    switch (Rn[3] = Rn[3].replace(/_.*$/, "")) {
      case "number-style":
      case "currency-style":
      case "percentage-style":
      case "date-style":
      case "time-style":
      case "text-style":
        if (Rn[1] === "/") {
          if (NFtag["truncate-on-overflow"] == "false") {
            if (NF.match(/h/))
              NF = NF.replace(/h+/, "[$&]");
            else if (NF.match(/m/))
              NF = NF.replace(/m+/, "[$&]");
            else if (NF.match(/s/))
              NF = NF.replace(/s+/, "[$&]");
          }
          number_format_map[NFtag.name] = NF;
          NF = "";
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          NF = "";
          NFtag = parsexmltag(Rn[0], false);
        }
        break;
      case "boolean-style":
        if (Rn[1] === "/") {
          number_format_map[NFtag.name] = "General";
          NF = "";
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          NF = "";
          NFtag = parsexmltag(Rn[0], false);
        }
        break;
      case "boolean":
        NF += "General";
        break;
      case "text":
        if (Rn[1] === "/") {
          payload = str.slice(tidx, xlmlregex.lastIndex - Rn[0].length);
          if (payload == "%" && NFtag[0] == "<number:percentage-style")
            NF += "%";
          else
            NF += '"' + payload.replace(/"/g, '""') + '"';
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          tidx = xlmlregex.lastIndex;
        }
        break;
      case "day":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "d";
              break;
            case "long":
              NF += "dd";
              break;
            default:
              NF += "dd";
              break;
          }
        }
        break;
      case "day-of-week":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "ddd";
              break;
            case "long":
              NF += "dddd";
              break;
            default:
              NF += "ddd";
              break;
          }
        }
        break;
      case "era":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "ee";
              break;
            case "long":
              NF += "eeee";
              break;
            default:
              NF += "eeee";
              break;
          }
        }
        break;
      case "hours":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "h";
              break;
            case "long":
              NF += "hh";
              break;
            default:
              NF += "hh";
              break;
          }
        }
        break;
      case "minutes":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "m";
              break;
            case "long":
              NF += "mm";
              break;
            default:
              NF += "mm";
              break;
          }
        }
        break;
      case "month":
        {
          y = parsexmltag(Rn[0], false);
          if (y["textual"])
            NF += "mm";
          switch (y["style"]) {
            case "short":
              NF += "m";
              break;
            case "long":
              NF += "mm";
              break;
            default:
              NF += "m";
              break;
          }
        }
        break;
      case "seconds":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "s";
              break;
            case "long":
              NF += "ss";
              break;
            default:
              NF += "ss";
              break;
          }
          if (y["decimal-places"])
            NF += "." + fill("0", +y["decimal-places"]);
        }
        break;
      case "year":
        {
          y = parsexmltag(Rn[0], false);
          switch (y["style"]) {
            case "short":
              NF += "yy";
              break;
            case "long":
              NF += "yyyy";
              break;
            default:
              NF += "yy";
              break;
          }
        }
        break;
      case "am-pm":
        NF += "AM/PM";
        break;
      case "week-of-year":
      case "quarter":
        console.error("Excel does not support ODS format token " + Rn[3]);
        break;
      case "fill-character":
        if (Rn[1] === "/") {
          payload = str.slice(tidx, xlmlregex.lastIndex - Rn[0].length);
          NF += '"' + payload.replace(/"/g, '""') + '"*';
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          tidx = xlmlregex.lastIndex;
        }
        break;
      case "scientific-number":
        y = parsexmltag(Rn[0], false);
        NF += "0." + fill("0", +y["min-decimal-places"] || +y["decimal-places"] || 2) + fill("?", +y["decimal-places"] - +y["min-decimal-places"] || 0) + "E" + (parsexmlbool(y["forced-exponent-sign"]) ? "+" : "") + fill("0", +y["min-exponent-digits"] || 2);
        break;
      case "fraction":
        y = parsexmltag(Rn[0], false);
        if (!+y["min-integer-digits"])
          NF += "#";
        else
          NF += fill("0", +y["min-integer-digits"]);
        NF += " ";
        NF += fill("?", +y["min-numerator-digits"] || 1);
        NF += "/";
        if (+y["denominator-value"])
          NF += y["denominator-value"];
        else
          NF += fill("?", +y["min-denominator-digits"] || 1);
        break;
      case "currency-symbol":
        if (Rn[1] === "/") {
          NF += '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"';
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          tidx = xlmlregex.lastIndex;
        } else
          NF += "$";
        break;
      case "text-properties":
        y = parsexmltag(Rn[0], false);
        switch ((y["color"] || "").toLowerCase().replace("#", "")) {
          case "ff0000":
          case "red":
            NF = "[Red]" + NF;
            break;
        }
        break;
      case "text-content":
        NF += "@";
        break;
      case "map":
        y = parsexmltag(Rn[0], false);
        if (unescapexml(y["condition"]) == "value()>=0")
          NF = number_format_map[y["apply-style-name"]] + ";" + NF;
        else
          console.error("ODS number format may be incorrect: " + y["condition"]);
        break;
      case "number":
        if (Rn[1] === "/")
          break;
        y = parsexmltag(Rn[0], false);
        tNF = "";
        tNF += fill("0", +y["min-integer-digits"] || 1);
        if (parsexmlbool(y["grouping"]))
          tNF = commaify(fill("#", Math.max(0, 4 - tNF.length)) + tNF);
        if (+y["min-decimal-places"] || +y["decimal-places"])
          tNF += ".";
        if (+y["min-decimal-places"])
          tNF += fill("0", +y["min-decimal-places"] || 1);
        if (+y["decimal-places"] - (+y["min-decimal-places"] || 0))
          tNF += fill("0", +y["decimal-places"] - (+y["min-decimal-places"] || 0));
        NF += tNF;
        break;
      case "embedded-text":
        if (Rn[1] === "/") {
          if (etpos == 0)
            NF += '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"';
          else
            NF = NF.slice(0, etpos) + '"' + str.slice(tidx, xlmlregex.lastIndex - Rn[0].length).replace(/"/g, '""') + '"' + NF.slice(etpos);
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          tidx = xlmlregex.lastIndex;
          etpos = -+parsexmltag(Rn[0], false)["position"] || 0;
        }
        break;
    }
  }
  return number_format_map;
}
function parse_content_xml(d, _opts, _nfm) {
  var opts = _opts || {};
  var str = xlml_normalize(d);
  var state = [], tmp;
  var tag;
  var nfidx, NF = "", pidx = 0;
  var sheetag;
  var rowtag;
  var Sheets = {}, SheetNames = [];
  var ws = {};
  if (opts.dense)
    ws["!data"] = [];
  var Rn, q;
  var ctag = { value: "" };
  var textp = "", textpidx = 0;
  var textR = [];
  var R = -1, C = -1, range = { s: { r: 1e6, c: 1e7 }, e: { r: 0, c: 0 } };
  var row_ol = 0;
  var number_format_map = _nfm || {}, styles2 = {};
  var merges = [], mrange = {}, mR = 0, mC = 0;
  var rowinfo = [], rowpeat = 1, colpeat = 1;
  var arrayf = [];
  var WB = { Names: [], WBProps: {} };
  var atag = {};
  var _Ref = ["", ""];
  var comments = [], comment2 = {};
  var creator = "", creatoridx = 0;
  var isstub = false, intable = false;
  var i = 0;
  var baddate = 0;
  xlmlregex.lastIndex = 0;
  str = str.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
  while (Rn = xlmlregex.exec(str))
    switch (Rn[3] = Rn[3].replace(/_.*$/, "")) {
      case "table":
      case "工作表":
        if (Rn[1] === "/") {
          if (range.e.c >= range.s.c && range.e.r >= range.s.r)
            ws["!ref"] = encode_range(range);
          else
            ws["!ref"] = "A1:A1";
          if (opts.sheetRows > 0 && opts.sheetRows <= range.e.r) {
            ws["!fullref"] = ws["!ref"];
            range.e.r = opts.sheetRows - 1;
            ws["!ref"] = encode_range(range);
          }
          if (merges.length)
            ws["!merges"] = merges;
          if (rowinfo.length)
            ws["!rows"] = rowinfo;
          sheetag.name = sheetag["名称"] || sheetag.name;
          if (typeof JSON !== "undefined")
            JSON.stringify(sheetag);
          SheetNames.push(sheetag.name);
          Sheets[sheetag.name] = ws;
          intable = false;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          sheetag = parsexmltag(Rn[0], false);
          R = C = -1;
          range.s.r = range.s.c = 1e7;
          range.e.r = range.e.c = 0;
          ws = {};
          if (opts.dense)
            ws["!data"] = [];
          merges = [];
          rowinfo = [];
          intable = true;
        }
        break;
      case "table-row-group":
        if (Rn[1] === "/")
          --row_ol;
        else
          ++row_ol;
        break;
      case "table-row":
      case "行":
        if (Rn[1] === "/") {
          R += rowpeat;
          rowpeat = 1;
          break;
        }
        rowtag = parsexmltag(Rn[0], false);
        if (rowtag["行号"])
          R = rowtag["行号"] - 1;
        else if (R == -1)
          R = 0;
        rowpeat = +rowtag["number-rows-repeated"] || 1;
        if (rowpeat < 10) {
          for (i = 0; i < rowpeat; ++i)
            if (row_ol > 0)
              rowinfo[R + i] = { level: row_ol };
        }
        C = -1;
        break;
      case "covered-table-cell":
        if (Rn[1] !== "/")
          ++C;
        if (opts.sheetStubs) {
          if (opts.dense) {
            if (!ws["!data"][R])
              ws["!data"][R] = [];
            ws["!data"][R][C] = { t: "z" };
          } else
            ws[encode_cell({ r: R, c: C })] = { t: "z" };
        }
        textp = "";
        textR = [];
        break;
      case "table-cell":
      case "数据":
        if (Rn[0].charAt(Rn[0].length - 2) === "/") {
          ++C;
          ctag = parsexmltag(Rn[0], false);
          colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
          q = {
            t: "z",
            v: null
            /*:: , z:null, w:"",c:[]*/
          };
          if (ctag.formula && opts.cellFormula != false)
            q.f = ods_to_csf_formula(unescapexml(ctag.formula));
          if (ctag["style-name"] && styles2[ctag["style-name"]])
            q.z = styles2[ctag["style-name"]];
          if ((ctag["数据类型"] || ctag["value-type"]) == "string") {
            q.t = "s";
            q.v = unescapexml(ctag["string-value"] || "");
            if (opts.dense) {
              if (!ws["!data"][R])
                ws["!data"][R] = [];
              ws["!data"][R][C] = q;
            } else {
              ws[encode_col(C) + encode_row(R)] = q;
            }
          }
          C += colpeat - 1;
        } else if (Rn[1] !== "/") {
          ++C;
          textp = "";
          textpidx = 0;
          textR = [];
          colpeat = 1;
          var rptR = rowpeat ? R + rowpeat - 1 : R;
          if (C > range.e.c)
            range.e.c = C;
          if (C < range.s.c)
            range.s.c = C;
          if (R < range.s.r)
            range.s.r = R;
          if (rptR > range.e.r)
            range.e.r = rptR;
          ctag = parsexmltag(Rn[0], false);
          comments = [];
          comment2 = {};
          q = {
            t: ctag["数据类型"] || ctag["value-type"],
            v: null
            /*:: , z:null, w:"",c:[]*/
          };
          if (ctag["style-name"] && styles2[ctag["style-name"]])
            q.z = styles2[ctag["style-name"]];
          if (opts.cellFormula) {
            if (ctag.formula)
              ctag.formula = unescapexml(ctag.formula);
            if (ctag["number-matrix-columns-spanned"] && ctag["number-matrix-rows-spanned"]) {
              mR = parseInt(ctag["number-matrix-rows-spanned"], 10) || 0;
              mC = parseInt(ctag["number-matrix-columns-spanned"], 10) || 0;
              mrange = { s: { r: R, c: C }, e: { r: R + mR - 1, c: C + mC - 1 } };
              q.F = encode_range(mrange);
              arrayf.push([mrange, q.F]);
            }
            if (ctag.formula)
              q.f = ods_to_csf_formula(ctag.formula);
            else
              for (i = 0; i < arrayf.length; ++i)
                if (R >= arrayf[i][0].s.r && R <= arrayf[i][0].e.r) {
                  if (C >= arrayf[i][0].s.c && C <= arrayf[i][0].e.c)
                    q.F = arrayf[i][1];
                }
          }
          if (ctag["number-columns-spanned"] || ctag["number-rows-spanned"]) {
            mR = parseInt(ctag["number-rows-spanned"], 10) || 0;
            mC = parseInt(ctag["number-columns-spanned"], 10) || 0;
            mrange = { s: { r: R, c: C }, e: { r: R + mR - 1, c: C + mC - 1 } };
            merges.push(mrange);
          }
          if (ctag["number-columns-repeated"])
            colpeat = parseInt(ctag["number-columns-repeated"], 10);
          switch (q.t) {
            case "boolean":
              q.t = "b";
              q.v = parsexmlbool(ctag["boolean-value"]) || +ctag["boolean-value"] >= 1;
              break;
            case "float":
              q.t = "n";
              q.v = parseFloat(ctag.value);
              break;
            case "percentage":
              q.t = "n";
              q.v = parseFloat(ctag.value);
              break;
            case "currency":
              q.t = "n";
              q.v = parseFloat(ctag.value);
              break;
            case "date":
              q.t = "d";
              q.v = parseDate(ctag["date-value"]);
              if (!opts.cellDates) {
                q.t = "n";
                q.v = datenum(q.v, WB.WBProps.date1904) - baddate;
              }
              if (!q.z)
                q.z = "m/d/yy";
              break;
            case "time":
              q.t = "n";
              q.v = parse_isodur(ctag["time-value"]) / 86400;
              if (opts.cellDates) {
                q.t = "d";
                q.v = numdate(q.v);
              }
              if (!q.z)
                q.z = "HH:MM:SS";
              break;
            case "number":
              q.t = "n";
              q.v = parseFloat(ctag["数据数值"]);
              break;
            default:
              if (q.t === "string" || q.t === "text" || !q.t) {
                q.t = "s";
                if (ctag["string-value"] != null) {
                  textp = unescapexml(ctag["string-value"]);
                  textR = [];
                }
              } else
                throw new Error("Unsupported value type " + q.t);
          }
        } else {
          isstub = false;
          if (q.t === "s") {
            q.v = textp || "";
            if (textR.length)
              q.R = textR;
            isstub = textpidx == 0;
          }
          if (atag.Target)
            q.l = atag;
          if (comments.length > 0) {
            q.c = comments;
            comments = [];
          }
          if (textp && opts.cellText !== false)
            q.w = textp;
          if (isstub) {
            q.t = "z";
            delete q.v;
          }
          if (!isstub || opts.sheetStubs) {
            if (!(opts.sheetRows && opts.sheetRows <= R)) {
              for (var rpt = 0; rpt < rowpeat; ++rpt) {
                colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
                if (opts.dense) {
                  if (!ws["!data"][R + rpt])
                    ws["!data"][R + rpt] = [];
                  ws["!data"][R + rpt][C] = rpt == 0 ? q : dup(q);
                  while (--colpeat > 0)
                    ws["!data"][R + rpt][C + colpeat] = dup(q);
                } else {
                  ws[encode_cell({ r: R + rpt, c: C })] = q;
                  while (--colpeat > 0)
                    ws[encode_cell({ r: R + rpt, c: C + colpeat })] = dup(q);
                }
                if (range.e.c <= C)
                  range.e.c = C;
              }
            }
          }
          colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
          C += colpeat - 1;
          colpeat = 0;
          q = {
            /*:: t:"", v:null, z:null, w:"",c:[]*/
          };
          textp = "";
          textR = [];
        }
        atag = {};
        break;
      case "document":
      case "document-content":
      case "电子表格文档":
      case "spreadsheet":
      case "主体":
      case "scripts":
      case "styles":
      case "font-face-decls":
      case "master-styles":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw "Bad state: " + tmp;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
          state.push([Rn[3], true]);
        break;
      case "annotation":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw "Bad state: " + tmp;
          comment2.t = textp;
          if (textR.length)
            comment2.R = textR;
          comment2.a = creator;
          comments.push(comment2);
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          state.push([Rn[3], false]);
        }
        creator = "";
        creatoridx = 0;
        textp = "";
        textpidx = 0;
        textR = [];
        break;
      case "creator":
        if (Rn[1] === "/") {
          creator = str.slice(creatoridx, Rn.index);
        } else
          creatoridx = Rn.index + Rn[0].length;
        break;
      case "meta":
      case "元数据":
      case "settings":
      case "config-item-set":
      case "config-item-map-indexed":
      case "config-item-map-entry":
      case "config-item-map-named":
      case "shapes":
      case "frame":
      case "text-box":
      case "image":
      case "data-pilot-tables":
      case "list-style":
      case "form":
      case "dde-links":
      case "event-listeners":
      case "chart":
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3])
            throw "Bad state: " + tmp;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
          state.push([Rn[3], false]);
        textp = "";
        textpidx = 0;
        textR = [];
        break;
      case "scientific-number":
      case "currency-symbol":
      case "fill-character":
        break;
      case "text-style":
      case "boolean-style":
      case "number-style":
      case "currency-style":
      case "percentage-style":
      case "date-style":
      case "time-style":
        if (Rn[1] === "/") {
          var xlmlidx = xlmlregex.lastIndex;
          parse_ods_styles(str.slice(nfidx, xlmlregex.lastIndex), _opts, number_format_map);
          xlmlregex.lastIndex = xlmlidx;
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
          nfidx = xlmlregex.lastIndex - Rn[0].length;
        }
        break;
      case "script":
        break;
      case "libraries":
        break;
      case "automatic-styles":
        break;
      case "default-style":
      case "page-layout":
        break;
      case "style":
        {
          var styletag = parsexmltag(Rn[0], false);
          if (styletag["family"] == "table-cell" && number_format_map[styletag["data-style-name"]])
            styles2[styletag["name"]] = number_format_map[styletag["data-style-name"]];
        }
        break;
      case "map":
        break;
      case "font-face":
        break;
      case "paragraph-properties":
        break;
      case "table-properties":
        break;
      case "table-column-properties":
        break;
      case "table-row-properties":
        break;
      case "table-cell-properties":
        break;
      case "number":
        break;
      case "fraction":
        break;
      case "day":
      case "month":
      case "year":
      case "era":
      case "day-of-week":
      case "week-of-year":
      case "quarter":
      case "hours":
      case "minutes":
      case "seconds":
      case "am-pm":
        break;
      case "boolean":
        break;
      case "text":
        if (Rn[0].slice(-2) === "/>")
          break;
        else if (Rn[1] === "/")
          switch (state[state.length - 1][0]) {
            case "number-style":
            case "date-style":
            case "time-style":
              NF += str.slice(pidx, Rn.index);
              break;
          }
        else
          pidx = Rn.index + Rn[0].length;
        break;
      case "named-range":
        tag = parsexmltag(Rn[0], false);
        _Ref = ods_to_csf_3D(tag["cell-range-address"]);
        var nrange = { Name: tag.name, Ref: _Ref[0] + "!" + _Ref[1] };
        if (intable)
          nrange.Sheet = SheetNames.length;
        WB.Names.push(nrange);
        break;
      case "text-content":
        break;
      case "text-properties":
        break;
      case "embedded-text":
        break;
      case "body":
      case "电子表格":
        break;
      case "forms":
        break;
      case "table-column":
        break;
      case "table-header-rows":
        break;
      case "table-rows":
        break;
      case "table-column-group":
        break;
      case "table-header-columns":
        break;
      case "table-columns":
        break;
      case "null-date":
        tag = parsexmltag(Rn[0], false);
        switch (tag["date-value"]) {
          case "1904-01-01":
            WB.WBProps.date1904 = true;
          case "1900-01-01":
            baddate = 0;
        }
        break;
      case "graphic-properties":
        break;
      case "calculation-settings":
        break;
      case "named-expressions":
        break;
      case "label-range":
        break;
      case "label-ranges":
        break;
      case "named-expression":
        break;
      case "sort":
        break;
      case "sort-by":
        break;
      case "sort-groups":
        break;
      case "tab":
        break;
      case "line-break":
        break;
      case "span":
        break;
      case "p":
      case "文本串":
        if (["master-styles"].indexOf(state[state.length - 1][0]) > -1)
          break;
        if (Rn[1] === "/" && (!ctag || !ctag["string-value"])) {
          var ptp = parse_text_p(str.slice(textpidx, Rn.index));
          textp = (textp.length > 0 ? textp + "\n" : "") + ptp[0];
        } else {
          parsexmltag(Rn[0], false);
          textpidx = Rn.index + Rn[0].length;
        }
        break;
      case "s":
        break;
      case "database-range":
        if (Rn[1] === "/")
          break;
        try {
          _Ref = ods_to_csf_3D(parsexmltag(Rn[0])["target-range-address"]);
          Sheets[_Ref[0]]["!autofilter"] = { ref: _Ref[1] };
        } catch (e) {
        }
        break;
      case "date":
        break;
      case "object":
        break;
      case "title":
      case "标题":
        break;
      case "desc":
        break;
      case "binary-data":
        break;
      case "table-source":
        break;
      case "scenario":
        break;
      case "iteration":
        break;
      case "content-validations":
        break;
      case "content-validation":
        break;
      case "help-message":
        break;
      case "error-message":
        break;
      case "database-ranges":
        break;
      case "filter":
        break;
      case "filter-and":
        break;
      case "filter-or":
        break;
      case "filter-condition":
        break;
      case "list-level-style-bullet":
        break;
      case "list-level-style-number":
        break;
      case "list-level-properties":
        break;
      case "sender-firstname":
      case "sender-lastname":
      case "sender-initials":
      case "sender-title":
      case "sender-position":
      case "sender-email":
      case "sender-phone-private":
      case "sender-fax":
      case "sender-company":
      case "sender-phone-work":
      case "sender-street":
      case "sender-city":
      case "sender-postal-code":
      case "sender-country":
      case "sender-state-or-province":
      case "author-name":
      case "author-initials":
      case "chapter":
      case "file-name":
      case "template-name":
      case "sheet-name":
        break;
      case "event-listener":
        break;
      case "initial-creator":
      case "creation-date":
      case "print-date":
      case "generator":
      case "document-statistic":
      case "user-defined":
      case "editing-duration":
      case "editing-cycles":
        break;
      case "config-item":
        break;
      case "page-number":
        break;
      case "page-count":
        break;
      case "time":
        break;
      case "cell-range-source":
        break;
      case "detective":
        break;
      case "operation":
        break;
      case "highlighted-range":
        break;
      case "data-pilot-table":
      case "source-cell-range":
      case "source-service":
      case "data-pilot-field":
      case "data-pilot-level":
      case "data-pilot-subtotals":
      case "data-pilot-subtotal":
      case "data-pilot-members":
      case "data-pilot-member":
      case "data-pilot-display-info":
      case "data-pilot-sort-info":
      case "data-pilot-layout-info":
      case "data-pilot-field-reference":
      case "data-pilot-groups":
      case "data-pilot-group":
      case "data-pilot-group-member":
        break;
      case "rect":
        break;
      case "dde-connection-decls":
      case "dde-connection-decl":
      case "dde-link":
      case "dde-source":
        break;
      case "properties":
        break;
      case "property":
        break;
      case "a":
        if (Rn[1] !== "/") {
          atag = parsexmltag(Rn[0], false);
          if (!atag.href)
            break;
          atag.Target = unescapexml(atag.href);
          delete atag.href;
          if (atag.Target.charAt(0) == "#" && atag.Target.indexOf(".") > -1) {
            _Ref = ods_to_csf_3D(atag.Target.slice(1));
            atag.Target = "#" + _Ref[0] + "!" + _Ref[1];
          } else if (atag.Target.match(/^\.\.[\\\/]/))
            atag.Target = atag.Target.slice(3);
        }
        break;
      case "table-protection":
        break;
      case "data-pilot-grand-total":
        break;
      case "office-document-common-attrs":
        break;
      default:
        switch (Rn[2]) {
          case "dc:":
          case "calcext:":
          case "loext:":
          case "ooo:":
          case "chartooo:":
          case "draw:":
          case "style:":
          case "chart:":
          case "form:":
          case "uof:":
          case "表:":
          case "字:":
            break;
          default:
            if (opts.WTF)
              throw new Error(Rn);
        }
    }
  var out = {
    Sheets,
    SheetNames,
    Workbook: WB
  };
  if (opts.bookSheets)
    delete /*::(*/
    out.Sheets;
  return out;
}
function parse_ods(zip, opts) {
  opts = opts || {};
  if (safegetzipfile(zip, "META-INF/manifest.xml"))
    parse_manifest(getzipdata(zip, "META-INF/manifest.xml"), opts);
  var styles2 = getzipstr(zip, "styles.xml");
  var Styles = styles2 && parse_ods_styles(utf8read(styles2));
  var content = getzipstr(zip, "content.xml");
  if (!content)
    throw new Error("Missing content.xml in ODS / UOF file");
  var wb = parse_content_xml(utf8read(content), opts, Styles);
  if (safegetzipfile(zip, "meta.xml"))
    wb.Props = parse_core_props(getzipdata(zip, "meta.xml"));
  wb.bookType = "ods";
  return wb;
}
function parse_fods(data, opts) {
  var wb = parse_content_xml(data, opts);
  wb.bookType = "fods";
  return wb;
}
var write_styles_ods = /* @__PURE__ */ function() {
  var master_styles = [
    "<office:master-styles>",
    '<style:master-page style:name="mp1" style:page-layout-name="mp1">',
    "<style:header/>",
    '<style:header-left style:display="false"/>',
    "<style:footer/>",
    '<style:footer-left style:display="false"/>',
    "</style:master-page>",
    "</office:master-styles>"
  ].join("");
  var payload = "<office:document-styles " + wxt_helper({
    "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
    "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
    "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
    "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
    "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
    "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    "xmlns:dc": "http://purl.org/dc/elements/1.1/",
    "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
    "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
    "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
    "office:version": "1.2"
  }) + ">" + master_styles + "</office:document-styles>";
  return function wso() {
    return XML_HEADER + payload;
  };
}();
function write_number_format_ods(nf, nfidx) {
  var type = "number", payload = "", nopts = { "style:name": nfidx }, c = "", i = 0;
  nf = nf.replace(/"[$]"/g, "$");
  j: {
    if (nf.indexOf(";") > -1) {
      console.error("Unsupported ODS Style Map exported.  Using first branch of " + nf);
      nf = nf.slice(0, nf.indexOf(";"));
    }
    if (nf == "@") {
      type = "text";
      payload = "<number:text-content/>";
      break j;
    }
    if (nf.indexOf(/\$/) > -1) {
      type = "currency";
    }
    if (nf[i] == '"') {
      c = "";
      while (nf[++i] != '"' || nf[++i] == '"')
        c += nf[i];
      --i;
      if (nf[i + 1] == "*") {
        i++;
        payload += "<number:fill-character>" + escapexml(c.replace(/""/g, '"')) + "</number:fill-character>";
      } else {
        payload += "<number:text>" + escapexml(c.replace(/""/g, '"')) + "</number:text>";
      }
      nf = nf.slice(i + 1);
      i = 0;
    }
    var t = nf.match(/# (\?+)\/(\?+)/);
    if (t) {
      payload += writextag("number:fraction", null, { "number:min-integer-digits": 0, "number:min-numerator-digits": t[1].length, "number:max-denominator-value": Math.max(+t[1].replace(/./g, "9"), +t[2].replace(/./g, "9")) });
      break j;
    }
    if (t = nf.match(/# (\?+)\/(\d+)/)) {
      payload += writextag("number:fraction", null, { "number:min-integer-digits": 0, "number:min-numerator-digits": t[1].length, "number:denominator-value": +t[2] });
      break j;
    }
    if (t = nf.match(/(\d+)(|\.\d+)%/)) {
      type = "percentage";
      payload += writextag("number:number", null, { "number:decimal-places": t[2] && t.length - 1 || 0, "number:min-decimal-places": t[2] && t.length - 1 || 0, "number:min-integer-digits": t[1].length }) + "<number:text>%</number:text>";
      break j;
    }
    var has_time = false;
    if (["y", "m", "d"].indexOf(nf[0]) > -1) {
      type = "date";
      k:
        for (; i < nf.length; ++i)
          switch (c = nf[i].toLowerCase()) {
            case "h":
            case "s":
              has_time = true;
              --i;
              break k;
            case "m":
              l:
                for (var h = i + 1; h < nf.length; ++h)
                  switch (nf[h]) {
                    case "y":
                    case "d":
                      break l;
                    case "h":
                    case "s":
                      has_time = true;
                      --i;
                      break k;
                  }
            case "y":
            case "d":
              while ((nf[++i] || "").toLowerCase() == c[0])
                c += c[0];
              --i;
              switch (c) {
                case "y":
                case "yy":
                  payload += "<number:year/>";
                  break;
                case "yyy":
                case "yyyy":
                  payload += '<number:year number:style="long"/>';
                  break;
                case "mmmmm":
                  console.error("ODS has no equivalent of format |mmmmm|");
                case "m":
                case "mm":
                case "mmm":
                case "mmmm":
                  payload += '<number:month number:style="' + (c.length % 2 ? "short" : "long") + '" number:textual="' + (c.length >= 3 ? "true" : "false") + '"/>';
                  break;
                case "d":
                case "dd":
                  payload += '<number:day number:style="' + (c.length % 2 ? "short" : "long") + '"/>';
                  break;
                case "ddd":
                case "dddd":
                  payload += '<number:day-of-week number:style="' + (c.length % 2 ? "short" : "long") + '"/>';
                  break;
              }
              break;
            case '"':
              while (nf[++i] != '"' || nf[++i] == '"')
                c += nf[i];
              --i;
              payload += "<number:text>" + escapexml(c.slice(1).replace(/""/g, '"')) + "</number:text>";
              break;
            case "/":
              payload += "<number:text>" + escapexml(c) + "</number:text>";
              break;
            default:
              console.error("unrecognized character " + c + " in ODF format " + nf);
          }
      if (!has_time)
        break j;
      nf = nf.slice(i + 1);
      i = 0;
    }
    if (nf.match(/^\[?[hms]/)) {
      if (type == "number")
        type = "time";
      if (nf.match(/\[/)) {
        nf = nf.replace(/[\[\]]/g, "");
        nopts["number:truncate-on-overflow"] = "false";
      }
      for (; i < nf.length; ++i)
        switch (c = nf[i].toLowerCase()) {
          case "h":
          case "m":
          case "s":
            while ((nf[++i] || "").toLowerCase() == c[0])
              c += c[0];
            --i;
            switch (c) {
              case "h":
              case "hh":
                payload += '<number:hours number:style="' + (c.length % 2 ? "short" : "long") + '"/>';
                break;
              case "m":
              case "mm":
                payload += '<number:minutes number:style="' + (c.length % 2 ? "short" : "long") + '"/>';
                break;
              case "s":
              case "ss":
                if (nf[i + 1] == ".")
                  do {
                    c += nf[i + 1];
                    ++i;
                  } while (nf[i + 1] == "0");
                payload += '<number:seconds number:style="' + (c.match("ss") ? "long" : "short") + '"' + (c.match(/\./) ? ' number:decimal-places="' + (c.match(/0+/) || [""])[0].length + '"' : "") + "/>";
                break;
            }
            break;
          case '"':
            while (nf[++i] != '"' || nf[++i] == '"')
              c += nf[i];
            --i;
            payload += "<number:text>" + escapexml(c.slice(1).replace(/""/g, '"')) + "</number:text>";
            break;
          case "/":
            payload += "<number:text>" + escapexml(c) + "</number:text>";
            break;
          case "a":
            if (nf.slice(i, i + 3).toLowerCase() == "a/p") {
              payload += "<number:am-pm/>";
              i += 2;
              break;
            }
            if (nf.slice(i, i + 5).toLowerCase() == "am/pm") {
              payload += "<number:am-pm/>";
              i += 4;
              break;
            }
          default:
            console.error("unrecognized character " + c + " in ODF format " + nf);
        }
      break j;
    }
    if (nf.indexOf(/\$/) > -1) {
      type = "currency";
    }
    if (nf[0] == "$") {
      payload += '<number:currency-symbol number:language="en" number:country="US">$</number:currency-symbol>';
      nf = nf.slice(1);
      i = 0;
    }
    i = 0;
    if (nf[i] == '"') {
      while (nf[++i] != '"' || nf[++i] == '"')
        c += nf[i];
      --i;
      if (nf[i + 1] == "*") {
        i++;
        payload += "<number:fill-character>" + escapexml(c.replace(/""/g, '"')) + "</number:fill-character>";
      } else {
        payload += "<number:text>" + escapexml(c.replace(/""/g, '"')) + "</number:text>";
      }
      nf = nf.slice(i + 1);
      i = 0;
    }
    var np = nf.match(/([#0][0#,]*)(\.[0#]*|)(E[+]?0*|)/i);
    if (!np || !np[0])
      console.error("Could not find numeric part of " + nf);
    else {
      var base = np[1].replace(/,/g, "");
      payload += "<number:" + (np[3] ? "scientific-" : "") + 'number number:min-integer-digits="' + (base.indexOf("0") == -1 ? "0" : base.length - base.indexOf("0")) + '"' + (np[0].indexOf(",") > -1 ? ' number:grouping="true"' : "") + (np[2] && ' number:decimal-places="' + (np[2].length - 1) + '"' || ' number:decimal-places="0"') + (np[3] && np[3].indexOf("+") > -1 ? ' number:forced-exponent-sign="true"' : "") + (np[3] ? ' number:min-exponent-digits="' + np[3].match(/0+/)[0].length + '"' : "") + "></number:" + (np[3] ? "scientific-" : "") + "number>";
      i = np.index + np[0].length;
    }
    if (nf[i] == '"') {
      c = "";
      while (nf[++i] != '"' || nf[++i] == '"')
        c += nf[i];
      --i;
      payload += "<number:text>" + escapexml(c.replace(/""/g, '"')) + "</number:text>";
    }
  }
  if (!payload) {
    console.error("Could not generate ODS number format for |" + nf + "|");
    return "";
  }
  return writextag("number:" + type + "-style", payload, nopts);
}
function write_names_ods(Names, SheetNames, idx) {
  var scoped = Names.filter(function(name) {
    return name.Sheet == (idx == -1 ? null : idx);
  });
  if (!scoped.length)
    return "";
  return "      <table:named-expressions>\n" + scoped.map(function(name) {
    var odsref = csf_to_ods_3D(name.Ref);
    return "        " + writextag("table:named-range", null, {
      "table:name": name.Name,
      "table:cell-range-address": odsref,
      "table:base-cell-address": odsref.replace(/[\.]?[^\.]*$/, ".$A$1")
    });
  }).join("\n") + "\n      </table:named-expressions>\n";
}
var write_content_ods = /* @__PURE__ */ function() {
  var write_text_p = function(text) {
    return escapexml(text).replace(/  +/g, function($$) {
      return '<text:s text:c="' + $$.length + '"/>';
    }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "</text:p><text:p>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
  };
  var null_cell_xml = "          <table:table-cell />\n";
  var covered_cell_xml = "          <table:covered-table-cell/>\n";
  var write_ws = function(ws, wb, i, opts, nfs) {
    var o = [];
    o.push('      <table:table table:name="' + escapexml(wb.SheetNames[i]) + '" table:style-name="ta1">\n');
    var R = 0, C = 0, range = decode_range(ws["!ref"] || "A1");
    var marr = ws["!merges"] || [], mi = 0;
    var dense = ws["!data"] != null;
    if (ws["!cols"]) {
      for (C = 0; C <= range.e.c; ++C)
        o.push("        <table:table-column" + (ws["!cols"][C] ? ' table:style-name="co' + ws["!cols"][C].ods + '"' : "") + "></table:table-column>\n");
    }
    var H = "", ROWS = ws["!rows"] || [];
    for (R = 0; R < range.s.r; ++R) {
      H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";
      o.push("        <table:table-row" + H + "></table:table-row>\n");
    }
    for (; R <= range.e.r; ++R) {
      H = ROWS[R] ? ' table:style-name="ro' + ROWS[R].ods + '"' : "";
      o.push("        <table:table-row" + H + ">\n");
      for (C = 0; C < range.s.c; ++C)
        o.push(null_cell_xml);
      for (; C <= range.e.c; ++C) {
        var skip = false, ct = {}, textp = "";
        for (mi = 0; mi != marr.length; ++mi) {
          if (marr[mi].s.c > C)
            continue;
          if (marr[mi].s.r > R)
            continue;
          if (marr[mi].e.c < C)
            continue;
          if (marr[mi].e.r < R)
            continue;
          if (marr[mi].s.c != C || marr[mi].s.r != R)
            skip = true;
          ct["table:number-columns-spanned"] = marr[mi].e.c - marr[mi].s.c + 1;
          ct["table:number-rows-spanned"] = marr[mi].e.r - marr[mi].s.r + 1;
          break;
        }
        if (skip) {
          o.push(covered_cell_xml);
          continue;
        }
        var ref = encode_cell({ r: R, c: C }), cell = dense ? (ws["!data"][R] || [])[C] : ws[ref];
        if (cell && cell.f) {
          ct["table:formula"] = escapexml(csf_to_ods_formula(cell.f));
          if (cell.F) {
            if (cell.F.slice(0, ref.length) == ref) {
              var _Fref = decode_range(cell.F);
              ct["table:number-matrix-columns-spanned"] = _Fref.e.c - _Fref.s.c + 1;
              ct["table:number-matrix-rows-spanned"] = _Fref.e.r - _Fref.s.r + 1;
            }
          }
        }
        if (!cell) {
          o.push(null_cell_xml);
          continue;
        }
        switch (cell.t) {
          case "b":
            textp = cell.v ? "TRUE" : "FALSE";
            ct["office:value-type"] = "boolean";
            ct["office:boolean-value"] = cell.v ? "true" : "false";
            break;
          case "n":
            textp = cell.w || String(cell.v || 0);
            ct["office:value-type"] = "float";
            ct["office:value"] = cell.v || 0;
            break;
          case "s":
          case "str":
            textp = cell.v == null ? "" : cell.v;
            ct["office:value-type"] = "string";
            break;
          case "d":
            textp = cell.w || parseDate(cell.v).toISOString();
            ct["office:value-type"] = "date";
            ct["office:date-value"] = parseDate(cell.v).toISOString();
            ct["table:style-name"] = "ce1";
            break;
          default:
            o.push(null_cell_xml);
            continue;
        }
        var text_p = write_text_p(textp);
        if (cell.l && cell.l.Target) {
          var _tgt = cell.l.Target;
          _tgt = _tgt.charAt(0) == "#" ? "#" + csf_to_ods_3D(_tgt.slice(1)) : _tgt;
          if (_tgt.charAt(0) != "#" && !_tgt.match(/^\w+:/))
            _tgt = "../" + _tgt;
          text_p = writextag("text:a", text_p, { "xlink:href": _tgt.replace(/&/g, "&amp;") });
        }
        if (nfs[cell.z])
          ct["table:style-name"] = "ce" + nfs[cell.z].slice(1);
        o.push("          " + writextag("table:table-cell", writextag("text:p", text_p, {}), ct) + "\n");
      }
      o.push("        </table:table-row>\n");
    }
    if ((wb.Workbook || {}).Names)
      o.push(write_names_ods(wb.Workbook.Names, wb.SheetNames, i));
    o.push("      </table:table>\n");
    return o.join("");
  };
  var write_automatic_styles_ods = function(o, wb) {
    o.push(" <office:automatic-styles>\n");
    var cidx = 0;
    wb.SheetNames.map(function(n) {
      return wb.Sheets[n];
    }).forEach(function(ws) {
      if (!ws)
        return;
      if (ws["!cols"]) {
        for (var C = 0; C < ws["!cols"].length; ++C)
          if (ws["!cols"][C]) {
            var colobj = ws["!cols"][C];
            if (colobj.width == null && colobj.wpx == null && colobj.wch == null)
              continue;
            process_col(colobj);
            colobj.ods = cidx;
            var w2 = ws["!cols"][C].wpx + "px";
            o.push('  <style:style style:name="co' + cidx + '" style:family="table-column">\n');
            o.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + w2 + '"/>\n');
            o.push("  </style:style>\n");
            ++cidx;
          }
      }
    });
    var ridx = 0;
    wb.SheetNames.map(function(n) {
      return wb.Sheets[n];
    }).forEach(function(ws) {
      if (!ws)
        return;
      if (ws["!rows"]) {
        for (var R = 0; R < ws["!rows"].length; ++R)
          if (ws["!rows"][R]) {
            ws["!rows"][R].ods = ridx;
            var h = ws["!rows"][R].hpx + "px";
            o.push('  <style:style style:name="ro' + ridx + '" style:family="table-row">\n');
            o.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + h + '"/>\n');
            o.push("  </style:style>\n");
            ++ridx;
          }
      }
    });
    o.push('  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">\n');
    o.push('   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>\n');
    o.push("  </style:style>\n");
    o.push('  <number:date-style style:name="N37" number:automatic-order="true">\n');
    o.push('   <number:month number:style="long"/>\n');
    o.push("   <number:text>/</number:text>\n");
    o.push('   <number:day number:style="long"/>\n');
    o.push("   <number:text>/</number:text>\n");
    o.push("   <number:year/>\n");
    o.push("  </number:date-style>\n");
    var nfs = {};
    var nfi = 69;
    wb.SheetNames.map(function(n) {
      return wb.Sheets[n];
    }).forEach(function(ws) {
      if (!ws)
        return;
      var dense = ws["!data"] != null;
      var range = decode_range(ws["!ref"]);
      for (var R = 0; R <= range.e.r; ++R)
        for (var C = 0; C <= range.e.c; ++C) {
          var c = dense ? (ws["!data"][R] || [])[C] : ws[encode_cell({ r: R, c: C })];
          if (!c || !c.z || c.z.toLowerCase() == "general")
            continue;
          if (!nfs[c.z]) {
            var out = write_number_format_ods(c.z, "N" + nfi);
            if (out) {
              nfs[c.z] = "N" + nfi;
              ++nfi;
              o.push(out + "\n");
            }
          }
        }
    });
    o.push('  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>\n');
    keys(nfs).forEach(function(nf) {
      o.push('<style:style style:name="ce' + nfs[nf].slice(1) + '" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="' + nfs[nf] + '"/>\n');
    });
    o.push(" </office:automatic-styles>\n");
    return nfs;
  };
  return function wcx(wb, opts) {
    var o = [XML_HEADER];
    var attr = wxt_helper({
      "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
      "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
      "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
      "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
      "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
      "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "xmlns:dc": "http://purl.org/dc/elements/1.1/",
      "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
      "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
      "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
      "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
      "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
      "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
      "xmlns:math": "http://www.w3.org/1998/Math/MathML",
      "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
      "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
      "xmlns:ooo": "http://openoffice.org/2004/office",
      "xmlns:ooow": "http://openoffice.org/2004/writer",
      "xmlns:oooc": "http://openoffice.org/2004/calc",
      "xmlns:dom": "http://www.w3.org/2001/xml-events",
      "xmlns:xforms": "http://www.w3.org/2002/xforms",
      "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
      "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
      "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
      "xmlns:rpt": "http://openoffice.org/2005/report",
      "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
      "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
      "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
      "xmlns:tableooo": "http://openoffice.org/2009/table",
      "xmlns:drawooo": "http://openoffice.org/2010/draw",
      "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
      "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
      "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
      "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
      "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
      "office:version": "1.2"
    });
    var fods = wxt_helper({
      "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
      "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
    });
    if (opts.bookType == "fods") {
      o.push("<office:document" + attr + fods + ">\n");
      o.push(write_meta_ods().replace(/<office:document-meta.*?>/, "").replace(/<\/office:document-meta>/, "") + "\n");
    } else
      o.push("<office:document-content" + attr + ">\n");
    var nfs = write_automatic_styles_ods(o, wb);
    o.push("  <office:body>\n");
    o.push("    <office:spreadsheet>\n");
    if (((wb.Workbook || {}).WBProps || {}).date1904)
      o.push('      <table:calculation-settings table:case-sensitive="false" table:search-criteria-must-apply-to-whole-cell="true" table:use-wildcards="true" table:use-regular-expressions="false" table:automatic-find-labels="false">\n        <table:null-date table:date-value="1904-01-01"/>\n      </table:calculation-settings>\n');
    for (var i = 0; i != wb.SheetNames.length; ++i)
      o.push(write_ws(wb.Sheets[wb.SheetNames[i]], wb, i, opts, nfs));
    if ((wb.Workbook || {}).Names)
      o.push(write_names_ods(wb.Workbook.Names, wb.SheetNames, -1));
    o.push("    </office:spreadsheet>\n");
    o.push("  </office:body>\n");
    if (opts.bookType == "fods")
      o.push("</office:document>");
    else
      o.push("</office:document-content>");
    return o.join("");
  };
}();
function write_ods(wb, opts) {
  if (opts.bookType == "fods")
    return write_content_ods(wb, opts);
  var zip = zip_new();
  var f = "";
  var manifest = [];
  var rdf = [];
  f = "mimetype";
  zip_add_file(zip, f, "application/vnd.oasis.opendocument.spreadsheet");
  f = "content.xml";
  zip_add_file(zip, f, write_content_ods(wb, opts));
  manifest.push([f, "text/xml"]);
  rdf.push([f, "ContentFile"]);
  f = "styles.xml";
  zip_add_file(zip, f, write_styles_ods(wb, opts));
  manifest.push([f, "text/xml"]);
  rdf.push([f, "StylesFile"]);
  f = "meta.xml";
  zip_add_file(zip, f, XML_HEADER + write_meta_ods(
    /*::wb, opts*/
  ));
  manifest.push([f, "text/xml"]);
  rdf.push([f, "MetadataFile"]);
  f = "manifest.rdf";
  zip_add_file(zip, f, write_rdf(
    rdf
    /*, opts*/
  ));
  manifest.push([f, "application/rdf+xml"]);
  f = "META-INF/manifest.xml";
  zip_add_file(zip, f, write_manifest(
    manifest
    /*, opts*/
  ));
  return zip;
}
/*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
var subarray = function() {
  try {
    if (typeof Uint8Array == "undefined")
      return "slice";
    if (typeof Uint8Array.prototype.subarray == "undefined")
      return "slice";
    if (typeof Buffer !== "undefined") {
      if (typeof Buffer.prototype.subarray == "undefined")
        return "slice";
      if ((typeof Buffer.from == "function" ? Buffer.from([72, 62]) : new Buffer([72, 62])) instanceof Uint8Array)
        return "subarray";
      return "slice";
    }
    return "subarray";
  } catch (e) {
    return "slice";
  }
}();
function u8_to_dataview(array) {
  return new DataView(array.buffer, array.byteOffset, array.byteLength);
}
function u8str(u8) {
  return typeof TextDecoder != "undefined" ? new TextDecoder().decode(u8) : utf8read(a2s(u8));
}
function stru8(str) {
  return typeof TextEncoder != "undefined" ? new TextEncoder().encode(str) : s2a(utf8write(str));
}
function u8concat(u8a) {
  var len = 0;
  for (var i = 0; i < u8a.length; ++i)
    len += u8a[i].length;
  var out = new Uint8Array(len);
  var off = 0;
  for (i = 0; i < u8a.length; ++i) {
    var u8 = u8a[i], L = u8.length;
    if (L < 250) {
      for (var j = 0; j < L; ++j)
        out[off++] = u8[j];
    } else {
      out.set(u8, off);
      off += L;
    }
  }
  return out;
}
function popcnt(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  return (x + (x >> 4) & 252645135) * 16843009 >>> 24;
}
function readDecimal128LE(buf, offset) {
  var exp = (buf[offset + 15] & 127) << 7 | buf[offset + 14] >> 1;
  var mantissa = buf[offset + 14] & 1;
  for (var j = offset + 13; j >= offset; --j)
    mantissa = mantissa * 256 + buf[j];
  return (buf[offset + 15] & 128 ? -mantissa : mantissa) * Math.pow(10, exp - 6176);
}
function writeDecimal128LE(buf, offset, value) {
  var exp = Math.floor(value == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(value))) + 6176 - 16;
  var mantissa = value / Math.pow(10, exp - 6176);
  buf[offset + 15] |= exp >> 7;
  buf[offset + 14] |= (exp & 127) << 1;
  for (var i = 0; mantissa >= 1; ++i, mantissa /= 256)
    buf[offset + i] = mantissa & 255;
  buf[offset + 15] |= value >= 0 ? 0 : 128;
}
function parse_varint49(buf, ptr) {
  var l = ptr.l;
  var usz = buf[l] & 127;
  varint:
    if (buf[l++] >= 128) {
      usz |= (buf[l] & 127) << 7;
      if (buf[l++] < 128)
        break varint;
      usz |= (buf[l] & 127) << 14;
      if (buf[l++] < 128)
        break varint;
      usz |= (buf[l] & 127) << 21;
      if (buf[l++] < 128)
        break varint;
      usz += (buf[l] & 127) * Math.pow(2, 28);
      ++l;
      if (buf[l++] < 128)
        break varint;
      usz += (buf[l] & 127) * Math.pow(2, 35);
      ++l;
      if (buf[l++] < 128)
        break varint;
      usz += (buf[l] & 127) * Math.pow(2, 42);
      ++l;
      if (buf[l++] < 128)
        break varint;
    }
  ptr.l = l;
  return usz;
}
function write_varint49(v) {
  var usz = new Uint8Array(7);
  usz[0] = v & 127;
  var L = 1;
  sz:
    if (v > 127) {
      usz[L - 1] |= 128;
      usz[L] = v >> 7 & 127;
      ++L;
      if (v <= 16383)
        break sz;
      usz[L - 1] |= 128;
      usz[L] = v >> 14 & 127;
      ++L;
      if (v <= 2097151)
        break sz;
      usz[L - 1] |= 128;
      usz[L] = v >> 21 & 127;
      ++L;
      if (v <= 268435455)
        break sz;
      usz[L - 1] |= 128;
      usz[L] = v / 256 >>> 21 & 127;
      ++L;
      if (v <= 34359738367)
        break sz;
      usz[L - 1] |= 128;
      usz[L] = v / 65536 >>> 21 & 127;
      ++L;
      if (v <= 4398046511103)
        break sz;
      usz[L - 1] |= 128;
      usz[L] = v / 16777216 >>> 21 & 127;
      ++L;
    }
  return usz[subarray](0, L);
}
function parse_packed_varints(buf) {
  var ptr = { l: 0 };
  var out = [];
  while (ptr.l < buf.length)
    out.push(parse_varint49(buf, ptr));
  return out;
}
function write_packed_varints(nums) {
  return u8concat(nums.map(function(x) {
    return write_varint49(x);
  }));
}
function varint_to_i32(buf) {
  var l = 0, i32 = buf[l] & 127;
  varint:
    if (buf[l++] >= 128) {
      i32 |= (buf[l] & 127) << 7;
      if (buf[l++] < 128)
        break varint;
      i32 |= (buf[l] & 127) << 14;
      if (buf[l++] < 128)
        break varint;
      i32 |= (buf[l] & 127) << 21;
      if (buf[l++] < 128)
        break varint;
      i32 |= (buf[l] & 127) << 28;
    }
  return i32;
}
function parse_shallow(buf) {
  var out = [], ptr = { l: 0 };
  while (ptr.l < buf.length) {
    var off = ptr.l;
    var num = parse_varint49(buf, ptr);
    var type = num & 7;
    num = num / 8 | 0;
    var data;
    var l = ptr.l;
    switch (type) {
      case 0:
        {
          while (buf[l++] >= 128)
            ;
          data = buf[subarray](ptr.l, l);
          ptr.l = l;
        }
        break;
      case 1:
        {
          data = buf[subarray](l, l + 8);
          ptr.l = l + 8;
        }
        break;
      case 2:
        {
          var len = parse_varint49(buf, ptr);
          data = buf[subarray](ptr.l, ptr.l + len);
          ptr.l += len;
        }
        break;
      case 5:
        {
          data = buf[subarray](l, l + 4);
          ptr.l = l + 4;
        }
        break;
      default:
        throw new Error("PB Type ".concat(type, " for Field ").concat(num, " at offset ").concat(off));
    }
    var v = { data, type };
    if (out[num] == null)
      out[num] = [];
    out[num].push(v);
  }
  return out;
}
function write_shallow(proto) {
  var out = [];
  proto.forEach(function(field, idx) {
    if (idx == 0)
      return;
    field.forEach(function(item) {
      if (!item.data)
        return;
      out.push(write_varint49(idx * 8 + item.type));
      if (item.type == 2)
        out.push(write_varint49(item.data.length));
      out.push(item.data);
    });
  });
  return u8concat(out);
}
function mappa(data, cb) {
  return (data == null ? void 0 : data.map(function(d) {
    return cb(d.data);
  })) || [];
}
function parse_iwa_file(buf) {
  var _a2;
  var out = [], ptr = { l: 0 };
  while (ptr.l < buf.length) {
    var len = parse_varint49(buf, ptr);
    var ai = parse_shallow(buf[subarray](ptr.l, ptr.l + len));
    ptr.l += len;
    var res = {
      id: varint_to_i32(ai[1][0].data),
      messages: []
    };
    ai[2].forEach(function(b) {
      var mi = parse_shallow(b.data);
      var fl = varint_to_i32(mi[3][0].data);
      res.messages.push({
        meta: mi,
        data: buf[subarray](ptr.l, ptr.l + fl)
      });
      ptr.l += fl;
    });
    if ((_a2 = ai[3]) == null ? void 0 : _a2[0])
      res.merge = varint_to_i32(ai[3][0].data) >>> 0 > 0;
    out.push(res);
  }
  return out;
}
function write_iwa_file(ias) {
  var bufs = [];
  ias.forEach(function(ia) {
    var ai = [
      [],
      [{ data: write_varint49(ia.id), type: 0 }],
      []
    ];
    if (ia.merge != null)
      ai[3] = [{ data: write_varint49(+!!ia.merge), type: 0 }];
    var midata = [];
    ia.messages.forEach(function(mi) {
      midata.push(mi.data);
      mi.meta[3] = [{ type: 0, data: write_varint49(mi.data.length) }];
      ai[2].push({ data: write_shallow(mi.meta), type: 2 });
    });
    var aipayload = write_shallow(ai);
    bufs.push(write_varint49(aipayload.length));
    bufs.push(aipayload);
    midata.forEach(function(mid) {
      return bufs.push(mid);
    });
  });
  return u8concat(bufs);
}
function parse_snappy_chunk(type, buf) {
  if (type != 0)
    throw new Error("Unexpected Snappy chunk type ".concat(type));
  var ptr = { l: 0 };
  var usz = parse_varint49(buf, ptr);
  var chunks = [];
  var l = ptr.l;
  while (l < buf.length) {
    var tag = buf[l] & 3;
    if (tag == 0) {
      var len = buf[l++] >> 2;
      if (len < 60)
        ++len;
      else {
        var c = len - 59;
        len = buf[l];
        if (c > 1)
          len |= buf[l + 1] << 8;
        if (c > 2)
          len |= buf[l + 2] << 16;
        if (c > 3)
          len |= buf[l + 3] << 24;
        len >>>= 0;
        len++;
        l += c;
      }
      chunks.push(buf[subarray](l, l + len));
      l += len;
      continue;
    } else {
      var offset = 0, length2 = 0;
      if (tag == 1) {
        length2 = (buf[l] >> 2 & 7) + 4;
        offset = (buf[l++] & 224) << 3;
        offset |= buf[l++];
      } else {
        length2 = (buf[l++] >> 2) + 1;
        if (tag == 2) {
          offset = buf[l] | buf[l + 1] << 8;
          l += 2;
        } else {
          offset = (buf[l] | buf[l + 1] << 8 | buf[l + 2] << 16 | buf[l + 3] << 24) >>> 0;
          l += 4;
        }
      }
      if (offset == 0)
        throw new Error("Invalid offset 0");
      var j = chunks.length - 1, off = offset;
      while (j >= 0 && off >= chunks[j].length) {
        off -= chunks[j].length;
        --j;
      }
      if (j < 0) {
        if (off == 0)
          off = chunks[j = 0].length;
        else
          throw new Error("Invalid offset beyond length");
      }
      if (length2 < off)
        chunks.push(chunks[j][subarray](chunks[j].length - off, chunks[j].length - off + length2));
      else {
        if (off > 0) {
          chunks.push(chunks[j][subarray](chunks[j].length - off));
          length2 -= off;
        }
        ++j;
        while (length2 >= chunks[j].length) {
          chunks.push(chunks[j]);
          length2 -= chunks[j].length;
          ++j;
        }
        if (length2)
          chunks.push(chunks[j][subarray](0, length2));
      }
      if (chunks.length > 25)
        chunks = [u8concat(chunks)];
    }
  }
  var clen = 0;
  for (var u8i = 0; u8i < chunks.length; ++u8i)
    clen += chunks[u8i].length;
  if (clen != usz)
    throw new Error("Unexpected length: ".concat(clen, " != ").concat(usz));
  return chunks;
}
function decompress_iwa_file(buf) {
  if (Array.isArray(buf))
    buf = new Uint8Array(buf);
  var out = [];
  var l = 0;
  while (l < buf.length) {
    var t = buf[l++];
    var len = buf[l] | buf[l + 1] << 8 | buf[l + 2] << 16;
    l += 3;
    out.push.apply(out, parse_snappy_chunk(t, buf[subarray](l, l + len)));
    l += len;
  }
  if (l !== buf.length)
    throw new Error("data is not a valid framed stream!");
  return out.length == 1 ? out[0] : u8concat(out);
}
function compress_iwa_file(buf) {
  var out = [];
  var l = 0;
  while (l < buf.length) {
    var c = Math.min(buf.length - l, 268435455);
    var frame = new Uint8Array(4);
    out.push(frame);
    var usz = write_varint49(c);
    var L = usz.length;
    out.push(usz);
    if (c <= 60) {
      L++;
      out.push(new Uint8Array([c - 1 << 2]));
    } else if (c <= 256) {
      L += 2;
      out.push(new Uint8Array([240, c - 1 & 255]));
    } else if (c <= 65536) {
      L += 3;
      out.push(new Uint8Array([244, c - 1 & 255, c - 1 >> 8 & 255]));
    } else if (c <= 16777216) {
      L += 4;
      out.push(new Uint8Array([248, c - 1 & 255, c - 1 >> 8 & 255, c - 1 >> 16 & 255]));
    } else if (c <= 4294967296) {
      L += 5;
      out.push(new Uint8Array([252, c - 1 & 255, c - 1 >> 8 & 255, c - 1 >> 16 & 255, c - 1 >>> 24 & 255]));
    }
    out.push(buf[subarray](l, l + c));
    L += c;
    frame[0] = 0;
    frame[1] = L & 255;
    frame[2] = L >> 8 & 255;
    frame[3] = L >> 16 & 255;
    l += c;
  }
  return u8concat(out);
}
var numbers_lut_new = function() {
  return { sst: [], rsst: [], ofmt: [], nfmt: [] };
};
function numbers_format_cell(cell, t, flags, ofmt, nfmt) {
  var _a2, _b2, _c2, _d2;
  var ctype = t & 255, ver = t >> 8;
  var fmt = ver >= 5 ? nfmt : ofmt;
  dur:
    if (flags & (ver > 4 ? 8 : 4) && cell.t == "n" && ctype == 7) {
      var dstyle = ((_a2 = fmt[7]) == null ? void 0 : _a2[0]) ? varint_to_i32(fmt[7][0].data) : -1;
      if (dstyle == -1)
        break dur;
      var dmin = ((_b2 = fmt[15]) == null ? void 0 : _b2[0]) ? varint_to_i32(fmt[15][0].data) : -1;
      var dmax = ((_c2 = fmt[16]) == null ? void 0 : _c2[0]) ? varint_to_i32(fmt[16][0].data) : -1;
      var auto = ((_d2 = fmt[40]) == null ? void 0 : _d2[0]) ? varint_to_i32(fmt[40][0].data) : -1;
      var d = cell.v, dd = d;
      autodur:
        if (auto) {
          if (d == 0) {
            dmin = dmax = 2;
            break autodur;
          }
          if (d >= 604800)
            dmin = 1;
          else if (d >= 86400)
            dmin = 2;
          else if (d >= 3600)
            dmin = 4;
          else if (d >= 60)
            dmin = 8;
          else if (d >= 1)
            dmin = 16;
          else
            dmin = 32;
          if (Math.floor(d) != d)
            dmax = 32;
          else if (d % 60)
            dmax = 16;
          else if (d % 3600)
            dmax = 8;
          else if (d % 86400)
            dmax = 4;
          else if (d % 604800)
            dmax = 2;
          if (dmax < dmin)
            dmax = dmin;
        }
      if (dmin == -1 || dmax == -1)
        break dur;
      var dstr = [], zstr = [];
      if (dmin == 1) {
        dd = d / 604800;
        if (dmax == 1) {
          zstr.push('d"d"');
        } else {
          dd |= 0;
          d -= 604800 * dd;
        }
        dstr.push(dd + (dstyle == 2 ? " week" + (dd == 1 ? "" : "s") : dstyle == 1 ? "w" : ""));
      }
      if (dmin <= 2 && dmax >= 2) {
        dd = d / 86400;
        if (dmax > 2) {
          dd |= 0;
          d -= 86400 * dd;
        }
        zstr.push('d"d"');
        dstr.push(dd + (dstyle == 2 ? " day" + (dd == 1 ? "" : "s") : dstyle == 1 ? "d" : ""));
      }
      if (dmin <= 4 && dmax >= 4) {
        dd = d / 3600;
        if (dmax > 4) {
          dd |= 0;
          d -= 3600 * dd;
        }
        zstr.push((dmin >= 4 ? "[h]" : "h") + '"h"');
        dstr.push(dd + (dstyle == 2 ? " hour" + (dd == 1 ? "" : "s") : dstyle == 1 ? "h" : ""));
      }
      if (dmin <= 8 && dmax >= 8) {
        dd = d / 60;
        if (dmax > 8) {
          dd |= 0;
          d -= 60 * dd;
        }
        zstr.push((dmin >= 8 ? "[m]" : "m") + '"m"');
        if (dstyle == 0)
          dstr.push((dmin == 8 && dmax == 8 || dd >= 10 ? "" : "0") + dd);
        else
          dstr.push(dd + (dstyle == 2 ? " minute" + (dd == 1 ? "" : "s") : dstyle == 1 ? "m" : ""));
      }
      if (dmin <= 16 && dmax >= 16) {
        dd = d;
        if (dmax > 16) {
          dd |= 0;
          d -= dd;
        }
        zstr.push((dmin >= 16 ? "[s]" : "s") + '"s"');
        if (dstyle == 0)
          dstr.push((dmax == 16 && dmin == 16 || dd >= 10 ? "" : "0") + dd);
        else
          dstr.push(dd + (dstyle == 2 ? " second" + (dd == 1 ? "" : "s") : dstyle == 1 ? "s" : ""));
      }
      if (dmax >= 32) {
        dd = Math.round(1e3 * d);
        if (dmin < 32)
          zstr.push('.000"ms"');
        if (dstyle == 0)
          dstr.push((dd >= 100 ? "" : dd >= 10 ? "0" : "00") + dd);
        else
          dstr.push(dd + (dstyle == 2 ? " millisecond" + (dd == 1 ? "" : "s") : dstyle == 1 ? "ms" : ""));
      }
      cell.w = dstr.join(dstyle == 0 ? ":" : " ");
      cell.z = zstr.join(dstyle == 0 ? '":"' : " ");
      if (dstyle == 0)
        cell.w = cell.w.replace(/:(\d\d\d)$/, ".$1");
    }
}
function parse_old_storage(buf, lut, v) {
  var dv = u8_to_dataview(buf);
  var flags = dv.getUint32(4, true);
  var ridx = -1, sidx = -1, zidx = -1, ieee = NaN, dt = new Date(2001, 0, 1);
  var doff = v > 1 ? 12 : 8;
  if (flags & 2) {
    zidx = dv.getUint32(doff, true);
    doff += 4;
  }
  doff += popcnt(flags & (v > 1 ? 3468 : 396)) * 4;
  if (flags & 512) {
    ridx = dv.getUint32(doff, true);
    doff += 4;
  }
  doff += popcnt(flags & (v > 1 ? 12288 : 4096)) * 4;
  if (flags & 16) {
    sidx = dv.getUint32(doff, true);
    doff += 4;
  }
  if (flags & 32) {
    ieee = dv.getFloat64(doff, true);
    doff += 8;
  }
  if (flags & 64) {
    dt.setTime(dt.getTime() + dv.getFloat64(doff, true) * 1e3);
    doff += 8;
  }
  if (v > 1) {
    flags = dv.getUint32(8, true) >>> 16;
    if (flags & 255) {
      if (zidx == -1)
        zidx = dv.getUint32(doff, true);
      doff += 4;
    }
  }
  var ret;
  var t = buf[v >= 4 ? 1 : 2];
  switch (t) {
    case 0:
      return void 0;
    case 2:
      ret = { t: "n", v: ieee };
      break;
    case 3:
      ret = { t: "s", v: lut.sst[sidx] };
      break;
    case 5:
      ret = { t: "d", v: dt };
      break;
    case 6:
      ret = { t: "b", v: ieee > 0 };
      break;
    case 7:
      ret = { t: "n", v: ieee };
      break;
    case 8:
      ret = { t: "e", v: 0 };
      break;
    case 9:
      {
        if (ridx > -1)
          ret = { t: "s", v: lut.rsst[ridx] };
        else
          throw new Error("Unsupported cell type ".concat(buf[subarray](0, 4)));
      }
      break;
    default:
      throw new Error("Unsupported cell type ".concat(buf[subarray](0, 4)));
  }
  if (zidx > -1)
    numbers_format_cell(ret, t | v << 8, flags, lut.ofmt[zidx], lut.nfmt[zidx]);
  if (t == 7)
    ret.v /= 86400;
  return ret;
}
function parse_new_storage(buf, lut) {
  var dv = u8_to_dataview(buf);
  dv.getUint32(4, true);
  var fields = dv.getUint32(8, true);
  var doff = 12;
  var ridx = -1, sidx = -1, zidx = -1, d128 = NaN, ieee = NaN, dt = new Date(2001, 0, 1);
  if (fields & 1) {
    d128 = readDecimal128LE(buf, doff);
    doff += 16;
  }
  if (fields & 2) {
    ieee = dv.getFloat64(doff, true);
    doff += 8;
  }
  if (fields & 4) {
    dt.setTime(dt.getTime() + dv.getFloat64(doff, true) * 1e3);
    doff += 8;
  }
  if (fields & 8) {
    sidx = dv.getUint32(doff, true);
    doff += 4;
  }
  if (fields & 16) {
    ridx = dv.getUint32(doff, true);
    doff += 4;
  }
  var ret;
  var t = buf[1];
  switch (t) {
    case 0:
      return void 0;
    case 2:
      ret = { t: "n", v: d128 };
      break;
    case 3:
      ret = { t: "s", v: lut.sst[sidx] };
      break;
    case 5:
      ret = { t: "d", v: dt };
      break;
    case 6:
      ret = { t: "b", v: ieee > 0 };
      break;
    case 7:
      ret = { t: "n", v: ieee };
      break;
    case 8:
      ret = { t: "e", v: 0 };
      break;
    case 9:
      ret = { t: "s", v: lut.rsst[ridx] };
      break;
    case 10:
      ret = { t: "n", v: d128 };
      break;
    default:
      throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(fields & 31, " : ").concat(buf[subarray](0, 4)));
  }
  doff += popcnt(fields & 8160) * 4;
  if (fields & 516096) {
    if (zidx == -1)
      zidx = dv.getUint32(doff, true);
    doff += 4;
  }
  if (zidx > -1)
    numbers_format_cell(ret, t | 5 << 8, fields >> 13, lut.ofmt[zidx], lut.nfmt[zidx]);
  if (t == 7)
    ret.v /= 86400;
  return ret;
}
function write_new_storage(cell, sst) {
  var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, flags = 0;
  out[0] = 5;
  switch (cell.t) {
    case "n":
      out[1] = 2;
      writeDecimal128LE(out, l, cell.v);
      flags |= 1;
      l += 16;
      break;
    case "b":
      out[1] = 6;
      dv.setFloat64(l, cell.v ? 1 : 0, true);
      flags |= 2;
      l += 8;
      break;
    case "s":
      var s = cell.v == null ? "" : String(cell.v);
      var isst = sst.indexOf(s);
      if (isst == -1)
        sst[isst = sst.length] = s;
      out[1] = 3;
      dv.setUint32(l, isst, true);
      flags |= 8;
      l += 4;
      break;
    default:
      throw "unsupported cell type " + cell.t;
  }
  dv.setUint32(8, flags, true);
  return out[subarray](0, l);
}
function write_old_storage(cell, sst) {
  var out = new Uint8Array(32), dv = u8_to_dataview(out), l = 12, flags = 0;
  out[0] = 4;
  switch (cell.t) {
    case "n":
      out[2] = 2;
      dv.setFloat64(l, cell.v, true);
      flags |= 32;
      l += 8;
      break;
    case "b":
      out[2] = 6;
      dv.setFloat64(l, cell.v ? 1 : 0, true);
      flags |= 32;
      l += 8;
      break;
    case "s":
      var s = cell.v == null ? "" : String(cell.v);
      var isst = sst.indexOf(s);
      if (isst == -1)
        sst[isst = sst.length] = s;
      out[2] = 3;
      dv.setUint32(l, isst, true);
      flags |= 16;
      l += 4;
      break;
    default:
      throw "unsupported cell type " + cell.t;
  }
  dv.setUint32(8, flags, true);
  return out[subarray](0, l);
}
function parse_cell_storage(buf, lut) {
  switch (buf[0]) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return parse_old_storage(buf, lut, buf[0]);
    case 5:
      return parse_new_storage(buf, lut);
    default:
      throw new Error("Unsupported payload version ".concat(buf[0]));
  }
}
function parse_TSP_Reference(buf) {
  var pb = parse_shallow(buf);
  return varint_to_i32(pb[1][0].data);
}
function write_TSP_Reference(idx) {
  return write_shallow([
    [],
    [{ type: 0, data: write_varint49(idx) }]
  ]);
}
function numbers_add_oref(iwa, ref) {
  var _a2;
  var orefs = ((_a2 = iwa.messages[0].meta[5]) == null ? void 0 : _a2[0]) ? parse_packed_varints(iwa.messages[0].meta[5][0].data) : [];
  var orefidx = orefs.indexOf(ref);
  if (orefidx == -1) {
    orefs.push(ref);
    iwa.messages[0].meta[5] = [{ type: 2, data: write_packed_varints(orefs) }];
  }
}
function numbers_del_oref(iwa, ref) {
  var _a2;
  var orefs = ((_a2 = iwa.messages[0].meta[5]) == null ? void 0 : _a2[0]) ? parse_packed_varints(iwa.messages[0].meta[5][0].data) : [];
  iwa.messages[0].meta[5] = [{ type: 2, data: write_packed_varints(orefs.filter(function(r) {
    return r != ref;
  })) }];
}
function parse_TST_TableDataList(M, root2) {
  var pb = parse_shallow(root2.data);
  var type = varint_to_i32(pb[1][0].data);
  var entries = pb[3];
  var data = [];
  (entries || []).forEach(function(entry) {
    var le = parse_shallow(entry.data);
    if (!le[1])
      return;
    var key = varint_to_i32(le[1][0].data) >>> 0;
    switch (type) {
      case 1:
        data[key] = u8str(le[3][0].data);
        break;
      case 8:
        {
          var rt = M[parse_TSP_Reference(le[9][0].data)][0];
          var rtp = parse_shallow(rt.data);
          var rtpref = M[parse_TSP_Reference(rtp[1][0].data)][0];
          var mtype = varint_to_i32(rtpref.meta[1][0].data);
          if (mtype != 2001)
            throw new Error("2000 unexpected reference to ".concat(mtype));
          var tswpsa = parse_shallow(rtpref.data);
          data[key] = tswpsa[3].map(function(x) {
            return u8str(x.data);
          }).join("");
        }
        break;
      case 2:
        data[key] = parse_shallow(le[6][0].data);
        break;
      default:
        throw type;
    }
  });
  return data;
}
function parse_TST_TileRowInfo(u8, type) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  var pb = parse_shallow(u8);
  var R = varint_to_i32(pb[1][0].data) >>> 0;
  var cnt = varint_to_i32(pb[2][0].data) >>> 0;
  var wide_offsets = ((_b2 = (_a2 = pb[8]) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.data) && varint_to_i32(pb[8][0].data) > 0 || false;
  var used_storage_u8, used_storage;
  if (((_d2 = (_c2 = pb[7]) == null ? void 0 : _c2[0]) == null ? void 0 : _d2.data) && type != 0) {
    used_storage_u8 = (_f = (_e2 = pb[7]) == null ? void 0 : _e2[0]) == null ? void 0 : _f.data;
    used_storage = (_h = (_g = pb[6]) == null ? void 0 : _g[0]) == null ? void 0 : _h.data;
  } else if (((_j = (_i = pb[4]) == null ? void 0 : _i[0]) == null ? void 0 : _j.data) && type != 1) {
    used_storage_u8 = (_l = (_k = pb[4]) == null ? void 0 : _k[0]) == null ? void 0 : _l.data;
    used_storage = (_n = (_m = pb[3]) == null ? void 0 : _m[0]) == null ? void 0 : _n.data;
  } else
    throw "NUMBERS Tile missing ".concat(type, " cell storage");
  var width = wide_offsets ? 4 : 1;
  var used_storage_offsets = u8_to_dataview(used_storage_u8);
  var offsets = [];
  for (var C = 0; C < used_storage_u8.length / 2; ++C) {
    var off = used_storage_offsets.getUint16(C * 2, true);
    if (off < 65535)
      offsets.push([C, off]);
  }
  if (offsets.length != cnt)
    throw "Expected ".concat(cnt, " cells, found ").concat(offsets.length);
  var cells = [];
  for (C = 0; C < offsets.length - 1; ++C)
    cells[offsets[C][0]] = used_storage[subarray](offsets[C][1] * width, offsets[C + 1][1] * width);
  if (offsets.length >= 1)
    cells[offsets[offsets.length - 1][0]] = used_storage[subarray](offsets[offsets.length - 1][1] * width);
  return { R, cells };
}
function parse_TST_Tile(M, root2) {
  var _a2;
  var pb = parse_shallow(root2.data);
  var storage = -1;
  if ((_a2 = pb == null ? void 0 : pb[7]) == null ? void 0 : _a2[0]) {
    if (varint_to_i32(pb[7][0].data) >>> 0)
      storage = 1;
    else
      storage = 0;
  }
  var ri = mappa(pb[5], function(u8) {
    return parse_TST_TileRowInfo(u8, storage);
  });
  return {
    nrows: varint_to_i32(pb[4][0].data) >>> 0,
    data: ri.reduce(function(acc, x) {
      if (!acc[x.R])
        acc[x.R] = [];
      x.cells.forEach(function(cell, C) {
        if (acc[x.R][C])
          throw new Error("Duplicate cell r=".concat(x.R, " c=").concat(C));
        acc[x.R][C] = cell;
      });
      return acc;
    }, [])
  };
}
function parse_TST_TableModelArchive(M, root2, ws) {
  var _a2, _b2, _c2, _d2, _e2, _f;
  var pb = parse_shallow(root2.data);
  var range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  range.e.r = (varint_to_i32(pb[6][0].data) >>> 0) - 1;
  if (range.e.r < 0)
    throw new Error("Invalid row varint ".concat(pb[6][0].data));
  range.e.c = (varint_to_i32(pb[7][0].data) >>> 0) - 1;
  if (range.e.c < 0)
    throw new Error("Invalid col varint ".concat(pb[7][0].data));
  ws["!ref"] = encode_range(range);
  var dense = ws["!data"] != null, dws = ws;
  var store = parse_shallow(pb[4][0].data);
  var lut = numbers_lut_new();
  if ((_a2 = store[4]) == null ? void 0 : _a2[0])
    lut.sst = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[4][0].data)][0]);
  if ((_b2 = store[11]) == null ? void 0 : _b2[0])
    lut.ofmt = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[11][0].data)][0]);
  if ((_c2 = store[17]) == null ? void 0 : _c2[0])
    lut.rsst = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[17][0].data)][0]);
  if ((_d2 = store[22]) == null ? void 0 : _d2[0])
    lut.nfmt = parse_TST_TableDataList(M, M[parse_TSP_Reference(store[22][0].data)][0]);
  var tile = parse_shallow(store[3][0].data);
  var _R = 0;
  tile[1].forEach(function(t) {
    var tl = parse_shallow(t.data);
    var ref2 = M[parse_TSP_Reference(tl[2][0].data)][0];
    var mtype2 = varint_to_i32(ref2.meta[1][0].data);
    if (mtype2 != 6002)
      throw new Error("6001 unexpected reference to ".concat(mtype2));
    var _tile = parse_TST_Tile(M, ref2);
    _tile.data.forEach(function(row, R) {
      row.forEach(function(buf, C) {
        var res = parse_cell_storage(buf, lut);
        if (res) {
          if (dense) {
            if (!dws["!data"][_R + R])
              dws["!data"][_R + R] = [];
            dws["!data"][_R + R][C] = res;
          } else {
            ws[encode_col(C) + encode_row(_R + R)] = res;
          }
        }
      });
    });
    _R += _tile.nrows;
  });
  if ((_e2 = store[13]) == null ? void 0 : _e2[0]) {
    var ref = M[parse_TSP_Reference(store[13][0].data)][0];
    var mtype = varint_to_i32(ref.meta[1][0].data);
    if (mtype != 6144)
      throw new Error("Expected merge type 6144, found ".concat(mtype));
    ws["!merges"] = (_f = parse_shallow(ref.data)) == null ? void 0 : _f[1].map(function(pi) {
      var merge2 = parse_shallow(pi.data);
      var origin = u8_to_dataview(parse_shallow(merge2[1][0].data)[1][0].data), size = u8_to_dataview(parse_shallow(merge2[2][0].data)[1][0].data);
      return {
        s: { r: origin.getUint16(0, true), c: origin.getUint16(2, true) },
        e: {
          r: origin.getUint16(0, true) + size.getUint16(0, true) - 1,
          c: origin.getUint16(2, true) + size.getUint16(2, true) - 1
        }
      };
    });
  }
}
function parse_TST_TableInfoArchive(M, root2, opts) {
  var pb = parse_shallow(root2.data);
  var out = { "!ref": "A1" };
  if (opts == null ? void 0 : opts.dense)
    out["!data"] = [];
  var tableref = M[parse_TSP_Reference(pb[2][0].data)];
  var mtype = varint_to_i32(tableref[0].meta[1][0].data);
  if (mtype != 6001)
    throw new Error("6000 unexpected reference to ".concat(mtype));
  parse_TST_TableModelArchive(M, tableref[0], out);
  return out;
}
function parse_TN_SheetArchive(M, root2, opts) {
  var _a2;
  var pb = parse_shallow(root2.data);
  var out = {
    name: ((_a2 = pb[1]) == null ? void 0 : _a2[0]) ? u8str(pb[1][0].data) : "",
    sheets: []
  };
  var shapeoffs = mappa(pb[2], parse_TSP_Reference);
  shapeoffs.forEach(function(off) {
    M[off].forEach(function(m) {
      var mtype = varint_to_i32(m.meta[1][0].data);
      if (mtype == 6e3)
        out.sheets.push(parse_TST_TableInfoArchive(M, m, opts));
    });
  });
  return out;
}
function parse_TN_DocumentArchive(M, root2, opts) {
  var _a2;
  var out = book_new();
  var pb = parse_shallow(root2.data);
  if ((_a2 = pb[2]) == null ? void 0 : _a2[0])
    throw new Error("Keynote presentations are not supported");
  var sheetoffs = mappa(pb[1], parse_TSP_Reference);
  sheetoffs.forEach(function(off) {
    M[off].forEach(function(m) {
      var mtype = varint_to_i32(m.meta[1][0].data);
      if (mtype == 2) {
        var root22 = parse_TN_SheetArchive(M, m, opts);
        root22.sheets.forEach(function(sheet, idx) {
          book_append_sheet(out, sheet, idx == 0 ? root22.name : root22.name + "_" + idx, true);
        });
      }
    });
  });
  if (out.SheetNames.length == 0)
    throw new Error("Empty NUMBERS file");
  out.bookType = "numbers";
  return out;
}
function parse_numbers_iwa(cfb, opts) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g;
  var M = {}, indices = [];
  cfb.FullPaths.forEach(function(p) {
    if (p.match(/\.iwpv2/))
      throw new Error("Unsupported password protection");
  });
  cfb.FileIndex.forEach(function(s) {
    if (!s.name.match(/\.iwa$/))
      return;
    if (s.content[0] != 0)
      return;
    var o;
    try {
      o = decompress_iwa_file(s.content);
    } catch (e) {
      return console.log("?? " + s.content.length + " " + (e.message || e));
    }
    var packets;
    try {
      packets = parse_iwa_file(o);
    } catch (e) {
      return console.log("## " + (e.message || e));
    }
    packets.forEach(function(packet) {
      M[packet.id] = packet.messages;
      indices.push(packet.id);
    });
  });
  if (!indices.length)
    throw new Error("File has no messages");
  if (((_c2 = (_b2 = (_a2 = M == null ? void 0 : M[1]) == null ? void 0 : _a2[0].meta) == null ? void 0 : _b2[1]) == null ? void 0 : _c2[0].data) && varint_to_i32(M[1][0].meta[1][0].data) == 1e4)
    throw new Error("Pages documents are not supported");
  var docroot = ((_g = (_f = (_e2 = (_d2 = M == null ? void 0 : M[1]) == null ? void 0 : _d2[0]) == null ? void 0 : _e2.meta) == null ? void 0 : _f[1]) == null ? void 0 : _g[0].data) && varint_to_i32(M[1][0].meta[1][0].data) == 1 && M[1][0];
  if (!docroot)
    indices.forEach(function(idx) {
      M[idx].forEach(function(iwam) {
        var mtype = varint_to_i32(iwam.meta[1][0].data) >>> 0;
        if (mtype == 1) {
          if (!docroot)
            docroot = iwam;
          else
            throw new Error("Document has multiple roots");
        }
      });
    });
  if (!docroot)
    throw new Error("Cannot find Document root");
  return parse_TN_DocumentArchive(M, docroot, opts);
}
function write_TST_TileRowInfo(data, SST, wide) {
  var _a2, _b2;
  var tri = [
    [],
    [{ type: 0, data: write_varint49(0) }],
    [{ type: 0, data: write_varint49(0) }],
    [{ type: 2, data: new Uint8Array([]) }],
    [{ type: 2, data: new Uint8Array(Array.from({ length: 510 }, function() {
      return 255;
    })) }],
    [{ type: 0, data: write_varint49(5) }],
    [{ type: 2, data: new Uint8Array([]) }],
    [{ type: 2, data: new Uint8Array(Array.from({ length: 510 }, function() {
      return 255;
    })) }],
    [{ type: 0, data: write_varint49(1) }]
  ];
  if (!((_a2 = tri[6]) == null ? void 0 : _a2[0]) || !((_b2 = tri[7]) == null ? void 0 : _b2[0]))
    throw "Mutation only works on post-BNC storages!";
  var cnt = 0;
  if (tri[7][0].data.length < 2 * data.length) {
    var new_7 = new Uint8Array(2 * data.length);
    new_7.set(tri[7][0].data);
    tri[7][0].data = new_7;
  }
  if (tri[4][0].data.length < 2 * data.length) {
    var new_4 = new Uint8Array(2 * data.length);
    new_4.set(tri[4][0].data);
    tri[4][0].data = new_4;
  }
  var dv = u8_to_dataview(tri[7][0].data), last_offset = 0, cell_storage = [];
  var _dv = u8_to_dataview(tri[4][0].data), _last_offset = 0, _cell_storage = [];
  var width = wide ? 4 : 1;
  for (var C = 0; C < data.length; ++C) {
    if (data[C] == null) {
      dv.setUint16(C * 2, 65535, true);
      _dv.setUint16(C * 2, 65535);
      continue;
    }
    dv.setUint16(C * 2, last_offset / width, true);
    _dv.setUint16(C * 2, _last_offset / width, true);
    var celload, _celload;
    switch (typeof data[C]) {
      case "string":
        celload = write_new_storage({ t: "s", v: data[C] }, SST);
        _celload = write_old_storage({ t: "s", v: data[C] }, SST);
        break;
      case "number":
        celload = write_new_storage({ t: "n", v: data[C] }, SST);
        _celload = write_old_storage({ t: "n", v: data[C] }, SST);
        break;
      case "boolean":
        celload = write_new_storage({ t: "b", v: data[C] }, SST);
        _celload = write_old_storage({ t: "b", v: data[C] }, SST);
        break;
      default:
        if (data[C] instanceof Date) {
          celload = write_new_storage({ t: "s", v: data[C].toISOString() }, SST);
          _celload = write_old_storage({ t: "s", v: data[C].toISOString() }, SST);
          break;
        }
        throw new Error("Unsupported value " + data[C]);
    }
    cell_storage.push(celload);
    last_offset += celload.length;
    {
      _cell_storage.push(_celload);
      _last_offset += _celload.length;
    }
    ++cnt;
  }
  tri[2][0].data = write_varint49(cnt);
  tri[5][0].data = write_varint49(5);
  for (; C < tri[7][0].data.length / 2; ++C) {
    dv.setUint16(C * 2, 65535, true);
    _dv.setUint16(C * 2, 65535, true);
  }
  tri[6][0].data = u8concat(cell_storage);
  tri[3][0].data = u8concat(_cell_storage);
  tri[8] = [{ type: 0, data: write_varint49(wide ? 1 : 0) }];
  return tri;
}
function write_iwam(type, payload) {
  return {
    meta: [
      [],
      [{ type: 0, data: write_varint49(type) }]
    ],
    data: payload
  };
}
function get_unique_msgid(dep, dependents) {
  if (!dependents.last)
    dependents.last = 927262;
  for (var i = dependents.last; i < 2e6; ++i)
    if (!dependents[i]) {
      dependents[dependents.last = i] = dep;
      return i;
    }
  throw new Error("Too many messages");
}
function build_numbers_deps(cfb) {
  var dependents = {};
  var indices = [];
  cfb.FileIndex.map(function(fi, idx) {
    return [fi, cfb.FullPaths[idx]];
  }).forEach(function(row) {
    var fi = row[0], fp = row[1];
    if (fi.type != 2)
      return;
    if (!fi.name.match(/\.iwa/))
      return;
    if (fi.content[0] != 0)
      return;
    parse_iwa_file(decompress_iwa_file(fi.content)).forEach(function(packet) {
      indices.push(packet.id);
      dependents[packet.id] = { deps: [], location: fp, type: varint_to_i32(packet.messages[0].meta[1][0].data) };
    });
  });
  cfb.FileIndex.forEach(function(fi) {
    if (!fi.name.match(/\.iwa/))
      return;
    if (fi.content[0] != 0)
      return;
    parse_iwa_file(decompress_iwa_file(fi.content)).forEach(function(ia) {
      ia.messages.forEach(function(mess) {
        [5, 6].forEach(function(f) {
          if (!mess.meta[f])
            return;
          mess.meta[f].forEach(function(x) {
            dependents[ia.id].deps.push(varint_to_i32(x.data));
          });
        });
      });
    });
  });
  return dependents;
}
function write_numbers_iwa(wb, opts) {
  if (!opts || !opts.numbers)
    throw new Error("Must pass a `numbers` option -- check the README");
  var cfb = CFB.read(opts.numbers, { type: "base64" });
  var deps = build_numbers_deps(cfb);
  var docroot = numbers_iwa_find(cfb, deps, 1);
  if (docroot == null)
    throw "Could not find message ".concat(1, " in Numbers template");
  var sheetrefs = mappa(parse_shallow(docroot.messages[0].data)[1], parse_TSP_Reference);
  if (sheetrefs.length > 1)
    throw new Error("Template NUMBERS file must have exactly one sheet");
  wb.SheetNames.forEach(function(name, idx) {
    if (idx >= 1) {
      numbers_add_ws(cfb, deps, idx + 1);
      docroot = numbers_iwa_find(cfb, deps, 1);
      sheetrefs = mappa(parse_shallow(docroot.messages[0].data)[1], parse_TSP_Reference);
    }
    write_numbers_ws(cfb, deps, wb.Sheets[name], name, idx, sheetrefs[idx]);
  });
  return cfb;
}
function numbers_iwa_doit(cfb, deps, id, cb) {
  var entry = CFB.find(cfb, deps[id].location);
  if (!entry)
    throw "Could not find ".concat(deps[id].location, " in Numbers template");
  var x = parse_iwa_file(decompress_iwa_file(entry.content));
  var ainfo = x.find(function(packet) {
    return packet.id == id;
  });
  cb(ainfo, x);
  entry.content = compress_iwa_file(write_iwa_file(x));
  entry.size = entry.content.length;
}
function numbers_iwa_find(cfb, deps, id) {
  var entry = CFB.find(cfb, deps[id].location);
  if (!entry)
    throw "Could not find ".concat(deps[id].location, " in Numbers template");
  var x = parse_iwa_file(decompress_iwa_file(entry.content));
  var ainfo = x.find(function(packet) {
    return packet.id == id;
  });
  return ainfo;
}
function numbers_add_ws(cfb, deps, wsidx) {
  var sheetref = -1, newsheetref = -1;
  var remap = {};
  numbers_iwa_doit(cfb, deps, 1, function(docroot, arch) {
    var doc = parse_shallow(docroot.messages[0].data);
    sheetref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[1][0].data);
    newsheetref = get_unique_msgid({ deps: [1], location: deps[sheetref].location, type: 2 }, deps);
    remap[sheetref] = newsheetref;
    numbers_add_oref(docroot, newsheetref);
    doc[1].push({ type: 2, data: write_TSP_Reference(newsheetref) });
    var sheet = numbers_iwa_find(cfb, deps, sheetref);
    sheet.id = newsheetref;
    if (deps[1].location == deps[newsheetref].location)
      arch.push(sheet);
    else
      numbers_iwa_doit(cfb, deps, newsheetref, function(_, x) {
        return x.push(sheet);
      });
    docroot.messages[0].data = write_shallow(doc);
  });
  var tiaref = -1;
  numbers_iwa_doit(cfb, deps, newsheetref, function(sheetroot, arch) {
    var sa = parse_shallow(sheetroot.messages[0].data);
    for (var i = 3; i <= 69; ++i)
      delete sa[i];
    var drawables = mappa(sa[2], parse_TSP_Reference);
    drawables.forEach(function(n) {
      return numbers_del_oref(sheetroot, n);
    });
    tiaref = get_unique_msgid({ deps: [newsheetref], location: deps[drawables[0]].location, type: deps[drawables[0]].type }, deps);
    numbers_add_oref(sheetroot, tiaref);
    remap[drawables[0]] = tiaref;
    sa[2] = [{ type: 2, data: write_TSP_Reference(tiaref) }];
    var tia = numbers_iwa_find(cfb, deps, drawables[0]);
    tia.id = tiaref;
    if (deps[drawables[0]].location == deps[newsheetref].location)
      arch.push(tia);
    else {
      var loc2 = deps[newsheetref].location;
      loc2 = loc2.replace(/^Root Entry\//, "");
      loc2 = loc2.replace(/^Index\//, "").replace(/\.iwa$/, "");
      numbers_iwa_doit(cfb, deps, 2, function(ai) {
        var mlist = parse_shallow(ai.messages[0].data);
        var parentidx = mlist[3].findIndex(function(m) {
          var _a2, _b2;
          var mm = parse_shallow(m.data);
          if ((_a2 = mm[3]) == null ? void 0 : _a2[0])
            return u8str(mm[3][0].data) == loc2;
          if (((_b2 = mm[2]) == null ? void 0 : _b2[0]) && u8str(mm[2][0].data) == loc2)
            return true;
          return false;
        });
        var parent = parse_shallow(mlist[3][parentidx].data);
        if (!parent[6])
          parent[6] = [];
        parent[6].push({
          type: 2,
          data: write_shallow([
            [],
            [{ type: 0, data: write_varint49(tiaref) }]
          ])
        });
        mlist[3][parentidx].data = write_shallow(parent);
        ai.messages[0].data = write_shallow(mlist);
      });
      numbers_iwa_doit(cfb, deps, tiaref, function(_, x) {
        return x.push(tia);
      });
    }
    sheetroot.messages[0].data = write_shallow(sa);
  });
  var tmaref = -1;
  numbers_iwa_doit(cfb, deps, tiaref, function(tiaroot, arch) {
    var tia = parse_shallow(tiaroot.messages[0].data);
    var da = parse_shallow(tia[1][0].data);
    for (var i = 3; i <= 69; ++i)
      delete da[i];
    var dap = parse_TSP_Reference(da[2][0].data);
    da[2][0].data = write_TSP_Reference(remap[dap]);
    tia[1][0].data = write_shallow(da);
    var oldtmaref = parse_TSP_Reference(tia[2][0].data);
    numbers_del_oref(tiaroot, oldtmaref);
    tmaref = get_unique_msgid({ deps: [tiaref], location: deps[oldtmaref].location, type: deps[oldtmaref].type }, deps);
    numbers_add_oref(tiaroot, tmaref);
    remap[oldtmaref] = tmaref;
    tia[2][0].data = write_TSP_Reference(tmaref);
    var tma = numbers_iwa_find(cfb, deps, oldtmaref);
    tma.id = tmaref;
    if (deps[tiaref].location == deps[tmaref].location)
      arch.push(tma);
    else
      numbers_iwa_doit(cfb, deps, tmaref, function(_, x) {
        return x.push(tma);
      });
    tiaroot.messages[0].data = write_shallow(tia);
  });
  var loc = deps[tmaref].location;
  loc = loc.replace(/^Root Entry\//, "");
  loc = loc.replace(/^Index\//, "").replace(/\.iwa$/, "");
  numbers_iwa_doit(cfb, deps, tmaref, function(tmaroot, arch) {
    var _a2, _b2;
    var tma = parse_shallow(tmaroot.messages[0].data);
    var uuid = u8str(tma[1][0].data), new_uuid = uuid.replace(/-[A-Z0-9]*/, "-".concat(wsidx.toString(16).padStart(4, "0")));
    tma[1][0].data = stru8(new_uuid);
    [12, 13, 29, 31, 32, 33, 39, 44, 47, 81, 82, 84].forEach(function(n) {
      return delete tma[n];
    });
    if (tma[45]) {
      var srrta = parse_shallow(tma[45][0].data);
      var ref = parse_TSP_Reference(srrta[1][0].data);
      numbers_del_oref(tmaroot, ref);
      delete tma[45];
    }
    if (tma[70]) {
      var hsoa = parse_shallow(tma[70][0].data);
      (_a2 = hsoa[2]) == null ? void 0 : _a2.forEach(function(item) {
        var hsa = parse_shallow(item.data);
        [2, 3].map(function(n) {
          return hsa[n][0];
        }).forEach(function(hseadata) {
          var hsea = parse_shallow(hseadata.data);
          if (!hsea[8])
            return;
          var ref2 = parse_TSP_Reference(hsea[8][0].data);
          numbers_del_oref(tmaroot, ref2);
        });
      });
      delete tma[70];
    }
    [
      46,
      30,
      34,
      35,
      36,
      38,
      48,
      49,
      60,
      61,
      62,
      63,
      64,
      71,
      72,
      73,
      74,
      75,
      85,
      86,
      87,
      88,
      89
    ].forEach(function(n) {
      if (!tma[n])
        return;
      var ref2 = parse_TSP_Reference(tma[n][0].data);
      delete tma[n];
      numbers_del_oref(tmaroot, ref2);
    });
    var store = parse_shallow(tma[4][0].data);
    {
      [2, 4, 5, 6, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22].forEach(function(n) {
        var _a22;
        if (!((_a22 = store[n]) == null ? void 0 : _a22[0]))
          return;
        var oldref = parse_TSP_Reference(store[n][0].data);
        var newref = get_unique_msgid({ deps: [tmaref], location: deps[oldref].location, type: deps[oldref].type }, deps);
        numbers_del_oref(tmaroot, oldref);
        numbers_add_oref(tmaroot, newref);
        remap[oldref] = newref;
        var msg = numbers_iwa_find(cfb, deps, oldref);
        msg.id = newref;
        if (deps[oldref].location == deps[tmaref].location)
          arch.push(msg);
        else {
          deps[newref].location = deps[oldref].location.replace(oldref.toString(), newref.toString());
          if (deps[newref].location == deps[oldref].location)
            deps[newref].location = deps[newref].location.replace(/\.iwa/, "-".concat(newref, ".iwa"));
          CFB.utils.cfb_add(cfb, deps[newref].location, compress_iwa_file(write_iwa_file([msg])));
          var newloc = deps[newref].location;
          newloc = newloc.replace(/^Root Entry\//, "");
          newloc = newloc.replace(/^Index\//, "").replace(/\.iwa$/, "");
          numbers_iwa_doit(cfb, deps, 2, function(ai) {
            var mlist = parse_shallow(ai.messages[0].data);
            mlist[3].push({ type: 2, data: write_shallow([
              [],
              [{ type: 0, data: write_varint49(newref) }],
              [{ type: 2, data: stru8(newloc.replace(/-.*$/, "")) }],
              [{ type: 2, data: stru8(newloc) }],
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
              [],
              [],
              [],
              [],
              [{ type: 0, data: write_varint49(0) }],
              [],
              [{ type: 0, data: write_varint49(0) }]
            ]) });
            mlist[1] = [{ type: 0, data: write_varint49(Math.max(newref + 1, varint_to_i32(mlist[1][0].data))) }];
            var parentidx = mlist[3].findIndex(function(m) {
              var _a3, _b22;
              var mm = parse_shallow(m.data);
              if ((_a3 = mm[3]) == null ? void 0 : _a3[0])
                return u8str(mm[3][0].data) == loc;
              if (((_b22 = mm[2]) == null ? void 0 : _b22[0]) && u8str(mm[2][0].data) == loc)
                return true;
              return false;
            });
            var parent = parse_shallow(mlist[3][parentidx].data);
            if (!parent[6])
              parent[6] = [];
            parent[6].push({
              type: 2,
              data: write_shallow([
                [],
                [{ type: 0, data: write_varint49(newref) }]
              ])
            });
            mlist[3][parentidx].data = write_shallow(parent);
            ai.messages[0].data = write_shallow(mlist);
          });
        }
        store[n][0].data = write_TSP_Reference(newref);
      });
      var row_headers = parse_shallow(store[1][0].data);
      {
        (_b2 = row_headers[2]) == null ? void 0 : _b2.forEach(function(tspref) {
          var oldref = parse_TSP_Reference(tspref.data);
          var newref = get_unique_msgid({ deps: [tmaref], location: deps[oldref].location, type: deps[oldref].type }, deps);
          numbers_del_oref(tmaroot, oldref);
          numbers_add_oref(tmaroot, newref);
          remap[oldref] = newref;
          var msg = numbers_iwa_find(cfb, deps, oldref);
          msg.id = newref;
          if (deps[oldref].location == deps[tmaref].location) {
            arch.push(msg);
          } else {
            deps[newref].location = deps[oldref].location.replace(oldref.toString(), newref.toString());
            if (deps[newref].location == deps[oldref].location)
              deps[newref].location = deps[newref].location.replace(/\.iwa/, "-".concat(newref, ".iwa"));
            CFB.utils.cfb_add(cfb, deps[newref].location, compress_iwa_file(write_iwa_file([msg])));
            var newloc = deps[newref].location;
            newloc = newloc.replace(/^Root Entry\//, "");
            newloc = newloc.replace(/^Index\//, "").replace(/\.iwa$/, "");
            numbers_iwa_doit(cfb, deps, 2, function(ai) {
              var mlist = parse_shallow(ai.messages[0].data);
              mlist[3].push({ type: 2, data: write_shallow([
                [],
                [{ type: 0, data: write_varint49(newref) }],
                [{ type: 2, data: stru8(newloc.replace(/-.*$/, "")) }],
                [{ type: 2, data: stru8(newloc) }],
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
                [],
                [],
                [],
                [],
                [{ type: 0, data: write_varint49(0) }],
                [],
                [{ type: 0, data: write_varint49(0) }]
              ]) });
              mlist[1] = [{ type: 0, data: write_varint49(Math.max(newref + 1, varint_to_i32(mlist[1][0].data))) }];
              var parentidx = mlist[3].findIndex(function(m) {
                var _a22, _b22;
                var mm = parse_shallow(m.data);
                if ((_a22 = mm[3]) == null ? void 0 : _a22[0])
                  return u8str(mm[3][0].data) == loc;
                if (((_b22 = mm[2]) == null ? void 0 : _b22[0]) && u8str(mm[2][0].data) == loc)
                  return true;
                return false;
              });
              var parent = parse_shallow(mlist[3][parentidx].data);
              if (!parent[6])
                parent[6] = [];
              parent[6].push({
                type: 2,
                data: write_shallow([
                  [],
                  [{ type: 0, data: write_varint49(newref) }]
                ])
              });
              mlist[3][parentidx].data = write_shallow(parent);
              ai.messages[0].data = write_shallow(mlist);
            });
          }
          tspref.data = write_TSP_Reference(newref);
        });
      }
      store[1][0].data = write_shallow(row_headers);
      var tiles = parse_shallow(store[3][0].data);
      {
        tiles[1].forEach(function(t) {
          var tst = parse_shallow(t.data);
          var oldtileref = parse_TSP_Reference(tst[2][0].data);
          var newtileref = remap[oldtileref];
          if (!remap[oldtileref]) {
            newtileref = get_unique_msgid({ deps: [tmaref], location: "", type: deps[oldtileref].type }, deps);
            deps[newtileref].location = "Root Entry/Index/Tables/Tile-".concat(newtileref, ".iwa");
            remap[oldtileref] = newtileref;
            var oldtile = numbers_iwa_find(cfb, deps, oldtileref);
            oldtile.id = newtileref;
            numbers_del_oref(tmaroot, oldtileref);
            numbers_add_oref(tmaroot, newtileref);
            CFB.utils.cfb_add(cfb, "/Index/Tables/Tile-".concat(newtileref, ".iwa"), compress_iwa_file(write_iwa_file([oldtile])));
            numbers_iwa_doit(cfb, deps, 2, function(ai) {
              var mlist = parse_shallow(ai.messages[0].data);
              mlist[3].push({ type: 2, data: write_shallow([
                [],
                [{ type: 0, data: write_varint49(newtileref) }],
                [{ type: 2, data: stru8("Tables/Tile") }],
                [{ type: 2, data: stru8("Tables/Tile-".concat(newtileref)) }],
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
                [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
                [],
                [],
                [],
                [],
                [{ type: 0, data: write_varint49(0) }],
                [],
                [{ type: 0, data: write_varint49(0) }]
              ]) });
              mlist[1] = [{ type: 0, data: write_varint49(Math.max(newtileref + 1, varint_to_i32(mlist[1][0].data))) }];
              var parentidx = mlist[3].findIndex(function(m) {
                var _a22, _b22;
                var mm = parse_shallow(m.data);
                if ((_a22 = mm[3]) == null ? void 0 : _a22[0])
                  return u8str(mm[3][0].data) == loc;
                if (((_b22 = mm[2]) == null ? void 0 : _b22[0]) && u8str(mm[2][0].data) == loc)
                  return true;
                return false;
              });
              var parent = parse_shallow(mlist[3][parentidx].data);
              if (!parent[6])
                parent[6] = [];
              parent[6].push({
                type: 2,
                data: write_shallow([
                  [],
                  [{ type: 0, data: write_varint49(newtileref) }]
                ])
              });
              mlist[3][parentidx].data = write_shallow(parent);
              ai.messages[0].data = write_shallow(mlist);
            });
          }
          tst[2][0].data = write_TSP_Reference(newtileref);
          t.data = write_shallow(tst);
        });
      }
      store[3][0].data = write_shallow(tiles);
    }
    tma[4][0].data = write_shallow(store);
    tmaroot.messages[0].data = write_shallow(tma);
  });
}
function write_numbers_ws(cfb, deps, ws, wsname, sheetidx, rootref) {
  var drawables = [];
  numbers_iwa_doit(cfb, deps, rootref, function(docroot) {
    var sheetref = parse_shallow(docroot.messages[0].data);
    {
      sheetref[1] = [{ type: 2, data: stru8(wsname) }];
      drawables = mappa(sheetref[2], parse_TSP_Reference);
    }
    docroot.messages[0].data = write_shallow(sheetref);
  });
  var tia = numbers_iwa_find(cfb, deps, drawables[0]);
  var tmaref = parse_TSP_Reference(parse_shallow(tia.messages[0].data)[2][0].data);
  numbers_iwa_doit(cfb, deps, tmaref, function(docroot, x) {
    return write_numbers_tma(cfb, deps, ws, docroot, x, tmaref);
  });
}
var USE_WIDE_ROWS = true;
function write_numbers_tma(cfb, deps, ws, tmaroot, tmafile, tmaref) {
  var range = decode_range(ws["!ref"]);
  range.s.r = range.s.c = 0;
  var trunc = false;
  if (range.e.c > 999) {
    trunc = true;
    range.e.c = 999;
  }
  if (range.e.r > 999999) {
    trunc = true;
    range.e.r = 999999;
  }
  if (trunc)
    console.error("Truncating to ".concat(encode_range(range)));
  var data = sheet_to_json(ws, { range, header: 1 });
  var SST = ["~Sh33tJ5~"];
  var loc = deps[tmaref].location;
  loc = loc.replace(/^Root Entry\//, "");
  loc = loc.replace(/^Index\//, "").replace(/\.iwa$/, "");
  var pb = parse_shallow(tmaroot.messages[0].data);
  {
    pb[6][0].data = write_varint49(range.e.r + 1);
    pb[7][0].data = write_varint49(range.e.c + 1);
    delete pb[46];
    var store = parse_shallow(pb[4][0].data);
    {
      var row_header_ref = parse_TSP_Reference(parse_shallow(store[1][0].data)[2][0].data);
      numbers_iwa_doit(cfb, deps, row_header_ref, function(rowhead, _x) {
        var _a2;
        var base_bucket = parse_shallow(rowhead.messages[0].data);
        if ((_a2 = base_bucket == null ? void 0 : base_bucket[2]) == null ? void 0 : _a2[0])
          for (var R2 = 0; R2 < data.length; ++R2) {
            var _bucket = parse_shallow(base_bucket[2][0].data);
            _bucket[1][0].data = write_varint49(R2);
            _bucket[4][0].data = write_varint49(data[R2].length);
            base_bucket[2][R2] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
          }
        rowhead.messages[0].data = write_shallow(base_bucket);
      });
      var col_header_ref = parse_TSP_Reference(store[2][0].data);
      numbers_iwa_doit(cfb, deps, col_header_ref, function(colhead, _x) {
        var base_bucket = parse_shallow(colhead.messages[0].data);
        for (var C = 0; C <= range.e.c; ++C) {
          var _bucket = parse_shallow(base_bucket[2][0].data);
          _bucket[1][0].data = write_varint49(C);
          _bucket[4][0].data = write_varint49(range.e.r + 1);
          base_bucket[2][C] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
        }
        colhead.messages[0].data = write_shallow(base_bucket);
      });
      var rbtree = parse_shallow(store[9][0].data);
      rbtree[1] = [];
      var tilestore = parse_shallow(store[3][0].data);
      {
        var tstride = 256;
        tilestore[2] = [{ type: 0, data: write_varint49(tstride) }];
        var tileref = parse_TSP_Reference(parse_shallow(tilestore[1][0].data)[2][0].data);
        var save_token = function() {
          var metadata = numbers_iwa_find(cfb, deps, 2);
          var mlist = parse_shallow(metadata.messages[0].data);
          var mlst = mlist[3].filter(function(m) {
            return varint_to_i32(parse_shallow(m.data)[1][0].data) == tileref;
          });
          return (mlst == null ? void 0 : mlst.length) ? varint_to_i32(parse_shallow(mlst[0].data)[12][0].data) : 0;
        }();
        {
          CFB.utils.cfb_del(cfb, deps[tileref].location);
          numbers_iwa_doit(cfb, deps, 2, function(ai) {
            var mlist = parse_shallow(ai.messages[0].data);
            mlist[3] = mlist[3].filter(function(m) {
              return varint_to_i32(parse_shallow(m.data)[1][0].data) != tileref;
            });
            var parentidx = mlist[3].findIndex(function(m) {
              var _a2, _b2;
              var mm = parse_shallow(m.data);
              if ((_a2 = mm[3]) == null ? void 0 : _a2[0])
                return u8str(mm[3][0].data) == loc;
              if (((_b2 = mm[2]) == null ? void 0 : _b2[0]) && u8str(mm[2][0].data) == loc)
                return true;
              return false;
            });
            var parent = parse_shallow(mlist[3][parentidx].data);
            if (!parent[6])
              parent[6] = [];
            parent[6] = parent[6].filter(function(m) {
              return varint_to_i32(parse_shallow(m.data)[1][0].data) != tileref;
            });
            mlist[3][parentidx].data = write_shallow(parent);
            ai.messages[0].data = write_shallow(mlist);
          });
          numbers_del_oref(tmaroot, tileref);
        }
        tilestore[1] = [];
        var ntiles = Math.ceil((range.e.r + 1) / tstride);
        for (var tidx = 0; tidx < ntiles; ++tidx) {
          var newtileid = get_unique_msgid({
            deps: [],
            location: "",
            type: 6002
          }, deps);
          deps[newtileid].location = "Root Entry/Index/Tables/Tile-".concat(newtileid, ".iwa");
          var tiledata = [
            [],
            [{ type: 0, data: write_varint49(0) }],
            [{ type: 0, data: write_varint49(Math.min(range.e.r + 1, (tidx + 1) * tstride)) }],
            [{ type: 0, data: write_varint49(0) }],
            [{ type: 0, data: write_varint49(Math.min((tidx + 1) * tstride, range.e.r + 1) - tidx * tstride) }],
            [],
            [{ type: 0, data: write_varint49(5) }],
            [{ type: 0, data: write_varint49(1) }],
            [{ type: 0, data: write_varint49(1) }]
          ];
          for (var R = tidx * tstride; R <= Math.min(range.e.r, (tidx + 1) * tstride - 1); ++R) {
            var tilerow = write_TST_TileRowInfo(data[R], SST, USE_WIDE_ROWS);
            tilerow[1][0].data = write_varint49(R - tidx * tstride);
            tiledata[5].push({ data: write_shallow(tilerow), type: 2 });
          }
          tilestore[1].push({ type: 2, data: write_shallow([
            [],
            [{ type: 0, data: write_varint49(tidx) }],
            [{ type: 2, data: write_TSP_Reference(newtileid) }]
          ]) });
          var newtile = {
            id: newtileid,
            messages: [write_iwam(6002, write_shallow(tiledata))]
          };
          var tilecontent = compress_iwa_file(write_iwa_file([newtile]));
          CFB.utils.cfb_add(cfb, "/Index/Tables/Tile-".concat(newtileid, ".iwa"), tilecontent);
          numbers_iwa_doit(cfb, deps, 2, function(ai) {
            var mlist = parse_shallow(ai.messages[0].data);
            mlist[3].push({ type: 2, data: write_shallow([
              [],
              [{ type: 0, data: write_varint49(newtileid) }],
              [{ type: 2, data: stru8("Tables/Tile") }],
              [{ type: 2, data: stru8("Tables/Tile-".concat(newtileid)) }],
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
              [{ type: 2, data: new Uint8Array([2, 0, 0]) }],
              [],
              [],
              [],
              [],
              [{ type: 0, data: write_varint49(0) }],
              [],
              [{ type: 0, data: write_varint49(save_token) }]
            ]) });
            mlist[1] = [{ type: 0, data: write_varint49(Math.max(newtileid + 1, varint_to_i32(mlist[1][0].data))) }];
            var parentidx = mlist[3].findIndex(function(m) {
              var _a2, _b2;
              var mm = parse_shallow(m.data);
              if ((_a2 = mm[3]) == null ? void 0 : _a2[0])
                return u8str(mm[3][0].data) == loc;
              if (((_b2 = mm[2]) == null ? void 0 : _b2[0]) && u8str(mm[2][0].data) == loc)
                return true;
              return false;
            });
            var parent = parse_shallow(mlist[3][parentidx].data);
            if (!parent[6])
              parent[6] = [];
            parent[6].push({
              type: 2,
              data: write_shallow([
                [],
                [{ type: 0, data: write_varint49(newtileid) }]
              ])
            });
            mlist[3][parentidx].data = write_shallow(parent);
            ai.messages[0].data = write_shallow(mlist);
          });
          numbers_add_oref(tmaroot, newtileid);
          rbtree[1].push({ type: 2, data: write_shallow([
            [],
            [{ type: 0, data: write_varint49(tidx * tstride) }],
            [{ type: 0, data: write_varint49(tidx) }]
          ]) });
        }
      }
      store[3][0].data = write_shallow(tilestore);
      store[9][0].data = write_shallow(rbtree);
      store[10] = [{ type: 2, data: new Uint8Array([]) }];
      if (ws["!merges"]) {
        var mergeid = get_unique_msgid({
          type: 6144,
          deps: [tmaref],
          location: deps[tmaref].location
        }, deps);
        tmafile.push({
          id: mergeid,
          messages: [write_iwam(6144, write_shallow([
            [],
            ws["!merges"].map(function(m) {
              return { type: 2, data: write_shallow([
                [],
                [{ type: 2, data: write_shallow([
                  [],
                  [{ type: 5, data: new Uint8Array(new Uint16Array([m.s.r, m.s.c]).buffer) }]
                ]) }],
                [{ type: 2, data: write_shallow([
                  [],
                  [{ type: 5, data: new Uint8Array(new Uint16Array([m.e.r - m.s.r + 1, m.e.c - m.s.c + 1]).buffer) }]
                ]) }]
              ]) };
            })
          ]))]
        });
        store[13] = [{ type: 2, data: write_TSP_Reference(mergeid) }];
        numbers_iwa_doit(cfb, deps, 2, function(ai) {
          var mlist = parse_shallow(ai.messages[0].data);
          var parentidx = mlist[3].findIndex(function(m) {
            var _a2, _b2;
            var mm = parse_shallow(m.data);
            if ((_a2 = mm[3]) == null ? void 0 : _a2[0])
              return u8str(mm[3][0].data) == loc;
            if (((_b2 = mm[2]) == null ? void 0 : _b2[0]) && u8str(mm[2][0].data) == loc)
              return true;
            return false;
          });
          var parent = parse_shallow(mlist[3][parentidx].data);
          if (!parent[6])
            parent[6] = [];
          parent[6].push({
            type: 2,
            data: write_shallow([
              [],
              [{ type: 0, data: write_varint49(mergeid) }]
            ])
          });
          mlist[3][parentidx].data = write_shallow(parent);
          ai.messages[0].data = write_shallow(mlist);
        });
        numbers_add_oref(tmaroot, mergeid);
      } else
        delete store[13];
      var sstref = parse_TSP_Reference(store[4][0].data);
      numbers_iwa_doit(cfb, deps, sstref, function(sstroot) {
        var sstdata = parse_shallow(sstroot.messages[0].data);
        {
          sstdata[3] = [];
          SST.forEach(function(str, i) {
            if (i == 0)
              return;
            sstdata[3].push({ type: 2, data: write_shallow([
              [],
              [{ type: 0, data: write_varint49(i) }],
              [{ type: 0, data: write_varint49(1) }],
              [{ type: 2, data: stru8(str) }]
            ]) });
          });
        }
        sstroot.messages[0].data = write_shallow(sstdata);
      });
    }
    pb[4][0].data = write_shallow(store);
  }
  tmaroot.messages[0].data = write_shallow(pb);
}
function fix_opts_func(defaults) {
  return function fix_opts(opts) {
    for (var i = 0; i != defaults.length; ++i) {
      var d = defaults[i];
      if (opts[d[0]] === void 0)
        opts[d[0]] = d[1];
      if (d[2] === "n")
        opts[d[0]] = Number(opts[d[0]]);
    }
  };
}
function fix_read_opts(opts) {
  fix_opts_func([
    ["cellNF", false],
    /* emit cell number format string as .z */
    ["cellHTML", true],
    /* emit html string as .h */
    ["cellFormula", true],
    /* emit formulae as .f */
    ["cellStyles", false],
    /* emits style/theme as .s */
    ["cellText", true],
    /* emit formatted text as .w */
    ["cellDates", false],
    /* emit date cells with type `d` */
    ["sheetStubs", false],
    /* emit empty cells */
    ["sheetRows", 0, "n"],
    /* read n rows (0 = read all rows) */
    ["bookDeps", false],
    /* parse calculation chains */
    ["bookSheets", false],
    /* only try to get sheet names (no Sheets) */
    ["bookProps", false],
    /* only try to get properties (no Sheets) */
    ["bookFiles", false],
    /* include raw file structure (keys, files, cfb) */
    ["bookVBA", false],
    /* include vba raw data (vbaraw) */
    ["password", ""],
    /* password */
    ["WTF", false]
    /* WTF mode (throws errors) */
  ])(opts);
}
function fix_write_opts(opts) {
  fix_opts_func([
    ["cellDates", false],
    /* write date cells with type `d` */
    ["bookSST", false],
    /* Generate Shared String Table */
    ["bookType", "xlsx"],
    /* Type of workbook (xlsx/m/b) */
    ["compression", false],
    /* Use file compression */
    ["WTF", false]
    /* WTF mode (throws errors) */
  ])(opts);
}
function get_sheet_type(n) {
  if (RELS.WS.indexOf(n) > -1)
    return "sheet";
  if (n == RELS.CS)
    return "chart";
  if (n == RELS.DS)
    return "dialog";
  if (n == RELS.MS)
    return "macro";
  return n && n.length ? n : "sheet";
}
function safe_parse_wbrels(wbrels, sheets) {
  if (!wbrels)
    return 0;
  try {
    wbrels = sheets.map(function pwbr(w2) {
      if (!w2.id)
        w2.id = w2.strRelID;
      return [w2.name, wbrels["!id"][w2.id].Target, get_sheet_type(wbrels["!id"][w2.id].Type)];
    });
  } catch (e) {
    return null;
  }
  return !wbrels || wbrels.length === 0 ? null : wbrels;
}
function safe_parse_sheet(zip, path, relsPath, sheet, idx, sheetRels, sheets, stype, opts, wb, themes, styles2) {
  try {
    sheetRels[sheet] = parse_rels(getzipstr(zip, relsPath, true), path);
    var data = getzipdata(zip, path);
    var _ws;
    switch (stype) {
      case "sheet":
        _ws = parse_ws(data, path, idx, opts, sheetRels[sheet], wb, themes, styles2);
        break;
      case "chart":
        _ws = parse_cs(data, path, idx, opts, sheetRels[sheet], wb, themes, styles2);
        if (!_ws || !_ws["!drawel"])
          break;
        var dfile = resolve_path(_ws["!drawel"].Target, path);
        var drelsp = get_rels_path(dfile);
        var draw = parse_drawing(getzipstr(zip, dfile, true), parse_rels(getzipstr(zip, drelsp, true), dfile));
        var chartp = resolve_path(draw, dfile);
        var crelsp = get_rels_path(chartp);
        _ws = parse_chart(getzipstr(zip, chartp, true), chartp, opts, parse_rels(getzipstr(zip, crelsp, true), chartp), wb, _ws);
        break;
      case "macro":
        _ws = parse_ms(data, path, idx, opts, sheetRels[sheet], wb, themes, styles2);
        break;
      case "dialog":
        _ws = parse_ds(data, path, idx, opts, sheetRels[sheet], wb, themes, styles2);
        break;
      default:
        throw new Error("Unrecognized sheet type " + stype);
    }
    sheets[sheet] = _ws;
    var comments = [], tcomments = [];
    if (sheetRels && sheetRels[sheet])
      keys(sheetRels[sheet]).forEach(function(n) {
        var dfile2 = "";
        if (sheetRels[sheet][n].Type == RELS.CMNT) {
          dfile2 = resolve_path(sheetRels[sheet][n].Target, path);
          comments = parse_cmnt(getzipdata(zip, dfile2, true), dfile2, opts);
          if (!comments || !comments.length)
            return;
          sheet_insert_comments(_ws, comments, false);
        }
        if (sheetRels[sheet][n].Type == RELS.TCMNT) {
          dfile2 = resolve_path(sheetRels[sheet][n].Target, path);
          tcomments = tcomments.concat(parse_tcmnt_xml(getzipdata(zip, dfile2, true), opts));
        }
      });
    if (tcomments && tcomments.length)
      sheet_insert_comments(_ws, tcomments, true, opts.people || []);
  } catch (e) {
    if (opts.WTF)
      throw e;
  }
}
function strip_front_slash(x) {
  return x.charAt(0) == "/" ? x.slice(1) : x;
}
function parse_zip(zip, opts) {
  make_ssf();
  opts = opts || {};
  fix_read_opts(opts);
  if (safegetzipfile(zip, "META-INF/manifest.xml"))
    return parse_ods(zip, opts);
  if (safegetzipfile(zip, "objectdata.xml"))
    return parse_ods(zip, opts);
  if (safegetzipfile(zip, "Index/Document.iwa")) {
    if (typeof Uint8Array == "undefined")
      throw new Error("NUMBERS file parsing requires Uint8Array support");
    if (typeof parse_numbers_iwa != "undefined") {
      if (zip.FileIndex)
        return parse_numbers_iwa(zip, opts);
      var _zip = CFB.utils.cfb_new();
      zipentries(zip).forEach(function(e) {
        zip_add_file(_zip, e, getzipbin(zip, e));
      });
      return parse_numbers_iwa(_zip, opts);
    }
    throw new Error("Unsupported NUMBERS file");
  }
  if (!safegetzipfile(zip, "[Content_Types].xml")) {
    if (safegetzipfile(zip, "index.xml.gz"))
      throw new Error("Unsupported NUMBERS 08 file");
    if (safegetzipfile(zip, "index.xml"))
      throw new Error("Unsupported NUMBERS 09 file");
    var index_zip = CFB.find(zip, "Index.zip");
    if (index_zip) {
      opts = dup(opts);
      delete opts.type;
      if (typeof index_zip.content == "string")
        opts.type = "binary";
      if (typeof Bun !== "undefined" && Buffer.isBuffer(index_zip.content))
        return readSync(new Uint8Array(index_zip.content), opts);
      return readSync(index_zip.content, opts);
    }
    throw new Error("Unsupported ZIP file");
  }
  var entries = zipentries(zip);
  var dir = parse_ct(getzipstr(zip, "[Content_Types].xml"));
  var xlsb = false;
  var sheets, binname;
  if (dir.workbooks.length === 0) {
    binname = "xl/workbook.xml";
    if (getzipdata(zip, binname, true))
      dir.workbooks.push(binname);
  }
  if (dir.workbooks.length === 0) {
    binname = "xl/workbook.bin";
    if (!getzipdata(zip, binname, true))
      throw new Error("Could not find workbook");
    dir.workbooks.push(binname);
    xlsb = true;
  }
  if (dir.workbooks[0].slice(-3) == "bin")
    xlsb = true;
  var themes = {};
  var styles2 = {};
  if (!opts.bookSheets && !opts.bookProps) {
    strs = [];
    if (dir.sst)
      try {
        strs = parse_sst(getzipdata(zip, strip_front_slash(dir.sst)), dir.sst, opts);
      } catch (e) {
        if (opts.WTF)
          throw e;
      }
    if (opts.cellStyles && dir.themes.length)
      themes = parse_theme_xml(getzipstr(zip, dir.themes[0].replace(/^\//, ""), true) || "", opts);
    if (dir.style)
      styles2 = parse_sty(getzipdata(zip, strip_front_slash(dir.style)), dir.style, themes, opts);
  }
  dir.links.map(function(link) {
    try {
      var rels = parse_rels(getzipstr(zip, get_rels_path(strip_front_slash(link))), link);
      return parse_xlink(getzipdata(zip, strip_front_slash(link)), rels, link, opts);
    } catch (e) {
    }
  });
  var wb = parse_wb(getzipdata(zip, strip_front_slash(dir.workbooks[0])), dir.workbooks[0], opts);
  var props = {}, propdata = "";
  if (dir.coreprops.length) {
    propdata = getzipdata(zip, strip_front_slash(dir.coreprops[0]), true);
    if (propdata)
      props = parse_core_props(propdata);
    if (dir.extprops.length !== 0) {
      propdata = getzipdata(zip, strip_front_slash(dir.extprops[0]), true);
      if (propdata)
        parse_ext_props(propdata, props, opts);
    }
  }
  var custprops = {};
  if (!opts.bookSheets || opts.bookProps) {
    if (dir.custprops.length !== 0) {
      propdata = getzipstr(zip, strip_front_slash(dir.custprops[0]), true);
      if (propdata)
        custprops = parse_cust_props(propdata, opts);
    }
  }
  var out = {};
  if (opts.bookSheets || opts.bookProps) {
    if (wb.Sheets)
      sheets = wb.Sheets.map(function pluck(x) {
        return x.name;
      });
    else if (props.Worksheets && props.SheetNames.length > 0)
      sheets = props.SheetNames;
    if (opts.bookProps) {
      out.Props = props;
      out.Custprops = custprops;
    }
    if (opts.bookSheets && typeof sheets !== "undefined")
      out.SheetNames = sheets;
    if (opts.bookSheets ? out.SheetNames : opts.bookProps)
      return out;
  }
  sheets = {};
  var deps = {};
  if (opts.bookDeps && dir.calcchain)
    deps = parse_cc(getzipdata(zip, strip_front_slash(dir.calcchain)), dir.calcchain);
  var i = 0;
  var sheetRels = {};
  var path, relsPath;
  {
    var wbsheets = wb.Sheets;
    props.Worksheets = wbsheets.length;
    props.SheetNames = [];
    for (var j = 0; j != wbsheets.length; ++j) {
      props.SheetNames[j] = wbsheets[j].name;
    }
  }
  var wbext = xlsb ? "bin" : "xml";
  var wbrelsi = dir.workbooks[0].lastIndexOf("/");
  var wbrelsfile = (dir.workbooks[0].slice(0, wbrelsi + 1) + "_rels/" + dir.workbooks[0].slice(wbrelsi + 1) + ".rels").replace(/^\//, "");
  if (!safegetzipfile(zip, wbrelsfile))
    wbrelsfile = "xl/_rels/workbook." + wbext + ".rels";
  var wbrels = parse_rels(getzipstr(zip, wbrelsfile, true), wbrelsfile.replace(/_rels.*/, "s5s"));
  if ((dir.metadata || []).length >= 1) {
    opts.xlmeta = parse_xlmeta(getzipdata(zip, strip_front_slash(dir.metadata[0])), dir.metadata[0], opts);
  }
  if ((dir.people || []).length >= 1) {
    opts.people = parse_people_xml(getzipdata(zip, strip_front_slash(dir.people[0])), opts);
  }
  if (wbrels)
    wbrels = safe_parse_wbrels(wbrels, wb.Sheets);
  var nmode = getzipdata(zip, "xl/worksheets/sheet.xml", true) ? 1 : 0;
  wsloop:
    for (i = 0; i != props.Worksheets; ++i) {
      var stype = "sheet";
      if (wbrels && wbrels[i]) {
        path = "xl/" + wbrels[i][1].replace(/[\/]?xl\//, "");
        if (!safegetzipfile(zip, path))
          path = wbrels[i][1];
        if (!safegetzipfile(zip, path))
          path = wbrelsfile.replace(/_rels\/.*$/, "") + wbrels[i][1];
        stype = wbrels[i][2];
      } else {
        path = "xl/worksheets/sheet" + (i + 1 - nmode) + "." + wbext;
        path = path.replace(/sheet0\./, "sheet.");
      }
      relsPath = path.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels");
      if (opts && opts.sheets != null)
        switch (typeof opts.sheets) {
          case "number":
            if (i != opts.sheets)
              continue wsloop;
            break;
          case "string":
            if (props.SheetNames[i].toLowerCase() != opts.sheets.toLowerCase())
              continue wsloop;
            break;
          default:
            if (Array.isArray && Array.isArray(opts.sheets)) {
              var snjseen = false;
              for (var snj = 0; snj != opts.sheets.length; ++snj) {
                if (typeof opts.sheets[snj] == "number" && opts.sheets[snj] == i)
                  snjseen = 1;
                if (typeof opts.sheets[snj] == "string" && opts.sheets[snj].toLowerCase() == props.SheetNames[i].toLowerCase())
                  snjseen = 1;
              }
              if (!snjseen)
                continue wsloop;
            }
        }
      safe_parse_sheet(zip, path, relsPath, props.SheetNames[i], i, sheetRels, sheets, stype, opts, wb, themes, styles2);
    }
  out = {
    Directory: dir,
    Workbook: wb,
    Props: props,
    Custprops: custprops,
    Deps: deps,
    Sheets: sheets,
    SheetNames: props.SheetNames,
    Strings: strs,
    Styles: styles2,
    Themes: themes,
    SSF: dup(table_fmt)
  };
  if (opts && opts.bookFiles) {
    if (zip.files) {
      out.keys = entries;
      out.files = zip.files;
    } else {
      out.keys = [];
      out.files = {};
      zip.FullPaths.forEach(function(p, idx) {
        p = p.replace(/^Root Entry[\/]/, "");
        out.keys.push(p);
        out.files[p] = zip.FileIndex[idx];
      });
    }
  }
  if (opts && opts.bookVBA) {
    if (dir.vba.length > 0)
      out.vbaraw = getzipdata(zip, strip_front_slash(dir.vba[0]), true);
    else if (dir.defaults && dir.defaults.bin === CT_VBA)
      out.vbaraw = getzipdata(zip, "xl/vbaProject.bin", true);
  }
  out.bookType = xlsb ? "xlsb" : "xlsx";
  return out;
}
function parse_xlsxcfb(cfb, _opts) {
  var opts = _opts || {};
  var f = "Workbook", data = CFB.find(cfb, f);
  try {
    f = "/!DataSpaces/Version";
    data = CFB.find(cfb, f);
    if (!data || !data.content)
      throw new Error("ECMA-376 Encrypted file missing " + f);
    parse_DataSpaceVersionInfo(data.content);
    f = "/!DataSpaces/DataSpaceMap";
    data = CFB.find(cfb, f);
    if (!data || !data.content)
      throw new Error("ECMA-376 Encrypted file missing " + f);
    var dsm = parse_DataSpaceMap(data.content);
    if (dsm.length !== 1 || dsm[0].comps.length !== 1 || dsm[0].comps[0].t !== 0 || dsm[0].name !== "StrongEncryptionDataSpace" || dsm[0].comps[0].v !== "EncryptedPackage")
      throw new Error("ECMA-376 Encrypted file bad " + f);
    f = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace";
    data = CFB.find(cfb, f);
    if (!data || !data.content)
      throw new Error("ECMA-376 Encrypted file missing " + f);
    var seds = parse_DataSpaceDefinition(data.content);
    if (seds.length != 1 || seds[0] != "StrongEncryptionTransform")
      throw new Error("ECMA-376 Encrypted file bad " + f);
    f = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary";
    data = CFB.find(cfb, f);
    if (!data || !data.content)
      throw new Error("ECMA-376 Encrypted file missing " + f);
    parse_Primary(data.content);
  } catch (e) {
  }
  f = "/EncryptionInfo";
  data = CFB.find(cfb, f);
  if (!data || !data.content)
    throw new Error("ECMA-376 Encrypted file missing " + f);
  var einfo = parse_EncryptionInfo(data.content);
  f = "/EncryptedPackage";
  data = CFB.find(cfb, f);
  if (!data || !data.content)
    throw new Error("ECMA-376 Encrypted file missing " + f);
  if (einfo[0] == 4 && typeof decrypt_agile !== "undefined")
    return decrypt_agile(einfo[1], data.content, opts.password || "", opts);
  if (einfo[0] == 2 && typeof decrypt_std76 !== "undefined")
    return decrypt_std76(einfo[1], data.content, opts.password || "", opts);
  throw new Error("File is password-protected");
}
function write_zip_xlsb(wb, opts) {
  if (wb && !wb.SSF) {
    wb.SSF = dup(table_fmt);
  }
  if (wb && wb.SSF) {
    make_ssf();
    SSF_load_table(wb.SSF);
    opts.revssf = evert_num(wb.SSF);
    opts.revssf[wb.SSF[65535]] = 0;
    opts.ssf = wb.SSF;
  }
  opts.rels = {};
  opts.wbrels = {};
  opts.Strings = /*::((*/
  [];
  opts.Strings.Count = 0;
  opts.Strings.Unique = 0;
  if (browser_has_Map)
    opts.revStrings = /* @__PURE__ */ new Map();
  else {
    opts.revStrings = {};
    opts.revStrings.foo = [];
    delete opts.revStrings.foo;
  }
  var wbext = "bin";
  var vbafmt = true;
  var ct = new_ct();
  fix_write_opts(opts = opts || {});
  var zip = zip_new();
  var f = "", rId = 0;
  opts.cellXfs = [];
  get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
  if (!wb.Props)
    wb.Props = {};
  f = "docProps/core.xml";
  zip_add_file(zip, f, write_core_props(wb.Props, opts));
  ct.coreprops.push(f);
  add_rels(opts.rels, 2, f, RELS.CORE_PROPS);
  f = "docProps/app.xml";
  if (wb.Props && wb.Props.SheetNames)
    ;
  else if (!wb.Workbook || !wb.Workbook.Sheets)
    wb.Props.SheetNames = wb.SheetNames;
  else {
    var _sn = [];
    for (var _i = 0; _i < wb.SheetNames.length; ++_i)
      if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2)
        _sn.push(wb.SheetNames[_i]);
    wb.Props.SheetNames = _sn;
  }
  wb.Props.Worksheets = wb.Props.SheetNames.length;
  zip_add_file(zip, f, write_ext_props(wb.Props));
  ct.extprops.push(f);
  add_rels(opts.rels, 3, f, RELS.EXT_PROPS);
  if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
    f = "docProps/custom.xml";
    zip_add_file(zip, f, write_cust_props(wb.Custprops));
    ct.custprops.push(f);
    add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
  }
  for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
    var wsrels = { "!id": {} };
    var ws = wb.Sheets[wb.SheetNames[rId - 1]];
    var _type = (ws || {})["!type"] || "sheet";
    switch (_type) {
      case "chart":
      default:
        f = "xl/worksheets/sheet" + rId + "." + wbext;
        zip_add_file(zip, f, write_ws_bin(rId - 1, opts, wb, wsrels));
        ct.sheets.push(f);
        add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
    }
    if (ws) {
      var comments = ws["!comments"];
      var need_vml = false;
      var cf = "";
      if (comments && comments.length > 0) {
        cf = "xl/comments" + rId + "." + wbext;
        zip_add_file(zip, cf, write_comments_bin(comments));
        ct.comments.push(cf);
        add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
        need_vml = true;
      }
      if (ws["!legacy"]) {
        if (need_vml)
          zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_vml(rId, ws["!comments"]));
      }
      delete ws["!comments"];
      delete ws["!legacy"];
    }
    if (wsrels["!id"].rId1)
      zip_add_file(zip, get_rels_path(f), write_rels(wsrels));
  }
  if (opts.Strings != null && opts.Strings.length > 0) {
    f = "xl/sharedStrings." + wbext;
    zip_add_file(zip, f, write_sst_bin(opts.Strings));
    ct.strs.push(f);
    add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
  }
  f = "xl/workbook." + wbext;
  zip_add_file(zip, f, write_wb_bin(wb));
  ct.workbooks.push(f);
  add_rels(opts.rels, 1, f, RELS.WB);
  f = "xl/theme/theme1.xml";
  var ww = write_theme(wb.Themes, opts);
  zip_add_file(zip, f, ww);
  ct.themes.push(f);
  add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
  f = "xl/styles." + wbext;
  zip_add_file(zip, f, write_sty_bin(wb, opts));
  ct.styles.push(f);
  add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
  if (wb.vbaraw && vbafmt) {
    f = "xl/vbaProject.bin";
    zip_add_file(zip, f, wb.vbaraw);
    ct.vba.push(f);
    add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
  }
  f = "xl/metadata." + wbext;
  zip_add_file(zip, f, write_xlmeta_bin());
  ct.metadata.push(f);
  add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
  zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
  zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
  zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
  delete opts.revssf;
  delete opts.ssf;
  return zip;
}
function write_zip_xlsx(wb, opts) {
  if (wb && !wb.SSF) {
    wb.SSF = dup(table_fmt);
  }
  if (wb && wb.SSF) {
    make_ssf();
    SSF_load_table(wb.SSF);
    opts.revssf = evert_num(wb.SSF);
    opts.revssf[wb.SSF[65535]] = 0;
    opts.ssf = wb.SSF;
  }
  opts.rels = {};
  opts.wbrels = {};
  opts.Strings = /*::((*/
  [];
  opts.Strings.Count = 0;
  opts.Strings.Unique = 0;
  if (browser_has_Map)
    opts.revStrings = /* @__PURE__ */ new Map();
  else {
    opts.revStrings = {};
    opts.revStrings.foo = [];
    delete opts.revStrings.foo;
  }
  var wbext = "xml";
  var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
  var ct = new_ct();
  fix_write_opts(opts = opts || {});
  var zip = zip_new();
  var f = "", rId = 0;
  opts.cellXfs = [];
  get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
  if (!wb.Props)
    wb.Props = {};
  f = "docProps/core.xml";
  zip_add_file(zip, f, write_core_props(wb.Props, opts));
  ct.coreprops.push(f);
  add_rels(opts.rels, 2, f, RELS.CORE_PROPS);
  f = "docProps/app.xml";
  if (wb.Props && wb.Props.SheetNames)
    ;
  else if (!wb.Workbook || !wb.Workbook.Sheets)
    wb.Props.SheetNames = wb.SheetNames;
  else {
    var _sn = [];
    for (var _i = 0; _i < wb.SheetNames.length; ++_i)
      if ((wb.Workbook.Sheets[_i] || {}).Hidden != 2)
        _sn.push(wb.SheetNames[_i]);
    wb.Props.SheetNames = _sn;
  }
  wb.Props.Worksheets = wb.Props.SheetNames.length;
  zip_add_file(zip, f, write_ext_props(wb.Props));
  ct.extprops.push(f);
  add_rels(opts.rels, 3, f, RELS.EXT_PROPS);
  if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
    f = "docProps/custom.xml";
    zip_add_file(zip, f, write_cust_props(wb.Custprops));
    ct.custprops.push(f);
    add_rels(opts.rels, 4, f, RELS.CUST_PROPS);
  }
  var people = ["SheetJ5"];
  opts.tcid = 0;
  for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
    var wsrels = { "!id": {} };
    var ws = wb.Sheets[wb.SheetNames[rId - 1]];
    var _type = (ws || {})["!type"] || "sheet";
    switch (_type) {
      case "chart":
      default:
        f = "xl/worksheets/sheet" + rId + "." + wbext;
        zip_add_file(zip, f, write_ws_xml(rId - 1, opts, wb, wsrels));
        ct.sheets.push(f);
        add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
    }
    if (ws) {
      var comments = ws["!comments"];
      var need_vml = false;
      var cf = "";
      if (comments && comments.length > 0) {
        var needtc = false;
        comments.forEach(function(carr) {
          carr[1].forEach(function(c) {
            if (c.T == true)
              needtc = true;
          });
        });
        if (needtc) {
          cf = "xl/threadedComments/threadedComment" + rId + ".xml";
          zip_add_file(zip, cf, write_tcmnt_xml(comments, people, opts));
          ct.threadedcomments.push(cf);
          add_rels(wsrels, -1, "../threadedComments/threadedComment" + rId + ".xml", RELS.TCMNT);
        }
        cf = "xl/comments" + rId + "." + wbext;
        zip_add_file(zip, cf, write_comments_xml(comments));
        ct.comments.push(cf);
        add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
        need_vml = true;
      }
      if (ws["!legacy"]) {
        if (need_vml)
          zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_vml(rId, ws["!comments"]));
      }
      delete ws["!comments"];
      delete ws["!legacy"];
    }
    if (wsrels["!id"].rId1)
      zip_add_file(zip, get_rels_path(f), write_rels(wsrels));
  }
  if (opts.Strings != null && opts.Strings.length > 0) {
    f = "xl/sharedStrings." + wbext;
    zip_add_file(zip, f, write_sst_xml(opts.Strings, opts));
    ct.strs.push(f);
    add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
  }
  f = "xl/workbook." + wbext;
  zip_add_file(zip, f, write_wb_xml(wb));
  ct.workbooks.push(f);
  add_rels(opts.rels, 1, f, RELS.WB);
  f = "xl/theme/theme1.xml";
  zip_add_file(zip, f, write_theme(wb.Themes, opts));
  ct.themes.push(f);
  add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
  f = "xl/styles." + wbext;
  zip_add_file(zip, f, write_sty_xml(wb, opts));
  ct.styles.push(f);
  add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
  if (wb.vbaraw && vbafmt) {
    f = "xl/vbaProject.bin";
    zip_add_file(zip, f, wb.vbaraw);
    ct.vba.push(f);
    add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
  }
  f = "xl/metadata." + wbext;
  zip_add_file(zip, f, write_xlmeta_xml());
  ct.metadata.push(f);
  add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
  if (people.length > 1) {
    f = "xl/persons/person.xml";
    zip_add_file(zip, f, write_people_xml(people));
    ct.people.push(f);
    add_rels(opts.wbrels, -1, "persons/person.xml", RELS.PEOPLE);
  }
  zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
  zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
  zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
  delete opts.revssf;
  delete opts.ssf;
  return zip;
}
function firstbyte(f, o) {
  var x = "";
  switch ((o || {}).type || "base64") {
    case "buffer":
      return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
    case "base64":
      x = Base64_decode(f.slice(0, 12));
      break;
    case "binary":
      x = f;
      break;
    case "array":
      return [f[0], f[1], f[2], f[3], f[4], f[5], f[6], f[7]];
    default:
      throw new Error("Unrecognized type " + (o && o.type || "undefined"));
  }
  return [x.charCodeAt(0), x.charCodeAt(1), x.charCodeAt(2), x.charCodeAt(3), x.charCodeAt(4), x.charCodeAt(5), x.charCodeAt(6), x.charCodeAt(7)];
}
function read_cfb(cfb, opts) {
  if (CFB.find(cfb, "EncryptedPackage"))
    return parse_xlsxcfb(cfb, opts);
  return parse_xlscfb(cfb, opts);
}
function read_zip(data, opts) {
  var zip, d = data;
  var o = opts || {};
  if (!o.type)
    o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
  zip = zip_read(d, o);
  return parse_zip(zip, o);
}
function read_plaintext(data, o) {
  var i = 0;
  main:
    while (i < data.length)
      switch (data.charCodeAt(i)) {
        case 10:
        case 13:
        case 32:
          ++i;
          break;
        case 60:
          return parse_xlml(data.slice(i), o);
        default:
          break main;
      }
  return PRN.to_workbook(data, o);
}
function read_plaintext_raw(data, o) {
  var str = "", bytes = firstbyte(data, o);
  switch (o.type) {
    case "base64":
      str = Base64_decode(data);
      break;
    case "binary":
      str = data;
      break;
    case "buffer":
      str = data.toString("binary");
      break;
    case "array":
      str = cc2str(data);
      break;
    default:
      throw new Error("Unrecognized type " + o.type);
  }
  if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191)
    str = utf8read(str);
  o.type = "binary";
  return read_plaintext(str, o);
}
function read_utf16(data, o) {
  var d = data;
  if (o.type == "base64")
    d = Base64_decode(d);
  if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer)
    d = new Uint8Array(data);
  d = has_buf && Buffer.isBuffer(data) ? data.slice(2).toString("utf16le") : typeof Uint8Array !== "undefined" && d instanceof Uint8Array ? typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le").decode(d.slice(2)) : utf16lereadu(d.slice(2)) : utf16leread(d.slice(2));
  o.type = "binary";
  return read_plaintext(d, o);
}
function bstrify(data) {
  return !data.match(/[^\x00-\x7F]/) ? data : utf8write(data);
}
function read_prn(data, d, o, str) {
  if (str) {
    o.type = "string";
    return PRN.to_workbook(data, o);
  }
  return PRN.to_workbook(d, o);
}
function readSync(data, opts) {
  reset_cp();
  var o = opts || {};
  if (o.codepage && typeof $cptable === "undefined")
    console.error("Codepage tables are not loaded.  Non-ASCII characters may not give expected results");
  if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer)
    return readSync(new Uint8Array(data), (o = dup(o), o.type = "array", o));
  if (typeof Uint8Array !== "undefined" && data instanceof Uint8Array && !o.type)
    o.type = typeof Deno !== "undefined" ? "buffer" : "array";
  var d = data, n = [0, 0, 0, 0], str = false;
  if (o.cellStyles) {
    o.cellNF = true;
    o.sheetStubs = true;
  }
  _ssfopts = {};
  if (o.dateNF)
    _ssfopts.dateNF = o.dateNF;
  if (!o.type)
    o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
  if (o.type == "file") {
    o.type = has_buf ? "buffer" : "binary";
    d = read_binary(data);
    if (typeof Uint8Array !== "undefined" && !has_buf)
      o.type = "array";
  }
  if (o.type == "string") {
    str = true;
    o.type = "binary";
    o.codepage = 65001;
    d = bstrify(data);
  }
  if (o.type == "array" && typeof Uint8Array !== "undefined" && data instanceof Uint8Array && typeof ArrayBuffer !== "undefined") {
    var ab = new ArrayBuffer(3), vu = new Uint8Array(ab);
    vu.foo = "bar";
    if (!vu.foo) {
      o = dup(o);
      o.type = "array";
      return readSync(ab2a(d), o);
    }
  }
  switch ((n = firstbyte(d, o))[0]) {
    case 208:
      if (n[1] === 207 && n[2] === 17 && n[3] === 224 && n[4] === 161 && n[5] === 177 && n[6] === 26 && n[7] === 225)
        return read_cfb(CFB.read(d, o), o);
      break;
    case 9:
      if (n[1] <= 8)
        return parse_xlscfb(d, o);
      break;
    case 60:
      return parse_xlml(d, o);
    case 73:
      if (n[1] === 73 && n[2] === 42 && n[3] === 0)
        throw new Error("TIFF Image File is not a spreadsheet");
      if (n[1] === 68)
        return read_wb_ID(d, o);
      break;
    case 84:
      if (n[1] === 65 && n[2] === 66 && n[3] === 76)
        return DIF.to_workbook(d, o);
      break;
    case 80:
      return n[1] === 75 && n[2] < 9 && n[3] < 9 ? read_zip(d, o) : read_prn(data, d, o, str);
    case 239:
      return n[3] === 60 ? parse_xlml(d, o) : read_prn(data, d, o, str);
    case 255:
      if (n[1] === 254) {
        return read_utf16(d, o);
      } else if (n[1] === 0 && n[2] === 2 && n[3] === 0)
        return WK_.to_workbook(d, o);
      break;
    case 0:
      if (n[1] === 0) {
        if (n[2] >= 2 && n[3] === 0)
          return WK_.to_workbook(d, o);
        if (n[2] === 0 && (n[3] === 8 || n[3] === 9))
          return WK_.to_workbook(d, o);
      }
      break;
    case 3:
    case 131:
    case 139:
    case 140:
      return DBF.to_workbook(d, o);
    case 123:
      if (n[1] === 92 && n[2] === 114 && n[3] === 116)
        return rtf_to_workbook(d, o);
      break;
    case 10:
    case 13:
    case 32:
      return read_plaintext_raw(d, o);
    case 137:
      if (n[1] === 80 && n[2] === 78 && n[3] === 71)
        throw new Error("PNG Image File is not a spreadsheet");
      break;
    case 8:
      if (n[1] === 231)
        throw new Error("Unsupported Multiplan 1.x file!");
      break;
    case 12:
      if (n[1] === 236)
        throw new Error("Unsupported Multiplan 2.x file!");
      if (n[1] === 237)
        throw new Error("Unsupported Multiplan 3.x file!");
      break;
  }
  if (DBF_SUPPORTED_VERSIONS.indexOf(n[0]) > -1 && n[2] <= 12 && n[3] <= 31)
    return DBF.to_workbook(d, o);
  return read_prn(data, d, o, str);
}
function write_cfb_ctr(cfb, o) {
  switch (o.type) {
    case "base64":
    case "binary":
      break;
    case "buffer":
    case "array":
      o.type = "";
      break;
    case "file":
      return write_dl(o.file, CFB.write(cfb, { type: has_buf ? "buffer" : "" }));
    case "string":
      throw new Error("'string' output type invalid for '" + o.bookType + "' files");
    default:
      throw new Error("Unrecognized type " + o.type);
  }
  return CFB.write(cfb, o);
}
function write_zip(wb, opts) {
  switch (opts.bookType) {
    case "ods":
      return write_ods(wb, opts);
    case "numbers":
      return write_numbers_iwa(wb, opts);
    case "xlsb":
      return write_zip_xlsb(wb, opts);
    default:
      return write_zip_xlsx(wb, opts);
  }
}
function write_zip_type(wb, opts) {
  var o = dup(opts || {});
  var z = write_zip(wb, o);
  return write_zip_denouement(z, o);
}
function write_zip_denouement(z, o) {
  var oopts = {};
  var ftype = has_buf ? "nodebuffer" : typeof Uint8Array !== "undefined" ? "array" : "string";
  if (o.compression)
    oopts.compression = "DEFLATE";
  if (o.password)
    oopts.type = ftype;
  else
    switch (o.type) {
      case "base64":
        oopts.type = "base64";
        break;
      case "binary":
        oopts.type = "string";
        break;
      case "string":
        throw new Error("'string' output type invalid for '" + o.bookType + "' files");
      case "buffer":
      case "file":
        oopts.type = ftype;
        break;
      default:
        throw new Error("Unrecognized type " + o.type);
    }
  var out = z.FullPaths ? CFB.write(z, { fileType: "zip", type: (
    /*::(*/
    { "nodebuffer": "buffer", "string": "binary" }[oopts.type] || oopts.type
  ), compression: !!o.compression }) : z.generate(oopts);
  if (typeof Deno !== "undefined") {
    if (typeof out == "string") {
      if (o.type == "binary" || o.type == "base64")
        return out;
      out = new Uint8Array(s2ab(out));
    }
  }
  if (o.password && typeof encrypt_agile !== "undefined")
    return write_cfb_ctr(encrypt_agile(out, o.password), o);
  if (o.type === "file")
    return write_dl(o.file, out);
  return o.type == "string" ? utf8read(
    /*::(*/
    out
    /*:: :any)*/
  ) : out;
}
function write_cfb_type(wb, opts) {
  var o = opts || {};
  var cfb = write_xlscfb(wb, o);
  return write_cfb_ctr(cfb, o);
}
function write_string_type(out, opts, bom) {
  if (!bom)
    bom = "";
  var o = bom + out;
  switch (opts.type) {
    case "base64":
      return Base64_encode(utf8write(o));
    case "binary":
      return utf8write(o);
    case "string":
      return out;
    case "file":
      return write_dl(opts.file, o, "utf8");
    case "buffer": {
      if (has_buf)
        return Buffer_from(o, "utf8");
      else if (typeof TextEncoder !== "undefined")
        return new TextEncoder().encode(o);
      else
        return write_string_type(o, { type: "binary" }).split("").map(function(c) {
          return c.charCodeAt(0);
        });
    }
  }
  throw new Error("Unrecognized type " + opts.type);
}
function write_stxt_type(out, opts) {
  switch (opts.type) {
    case "base64":
      return Base64_encode_pass(out);
    case "binary":
      return out;
    case "string":
      return out;
    case "file":
      return write_dl(opts.file, out, "binary");
    case "buffer": {
      if (has_buf)
        return Buffer_from(out, "binary");
      else
        return out.split("").map(function(c) {
          return c.charCodeAt(0);
        });
    }
  }
  throw new Error("Unrecognized type " + opts.type);
}
function write_binary_type(out, opts) {
  switch (opts.type) {
    case "string":
    case "base64":
    case "binary":
      var bstr = "";
      for (var i = 0; i < out.length; ++i)
        bstr += String.fromCharCode(out[i]);
      return opts.type == "base64" ? Base64_encode(bstr) : opts.type == "string" ? utf8read(bstr) : bstr;
    case "file":
      return write_dl(opts.file, out);
    case "buffer":
      return out;
    default:
      throw new Error("Unrecognized type " + opts.type);
  }
}
function writeSync(wb, opts) {
  reset_cp();
  check_wb(wb);
  var o = dup(opts || {});
  if (o.cellStyles) {
    o.cellNF = true;
    o.sheetStubs = true;
  }
  if (o.type == "array") {
    o.type = "binary";
    var out = writeSync(wb, o);
    o.type = "array";
    return s2ab(out);
  }
  var idx = 0;
  if (o.sheet) {
    if (typeof o.sheet == "number")
      idx = o.sheet;
    else
      idx = wb.SheetNames.indexOf(o.sheet);
    if (!wb.SheetNames[idx])
      throw new Error("Sheet not found: " + o.sheet + " : " + typeof o.sheet);
  }
  switch (o.bookType || "xlsb") {
    case "xml":
    case "xlml":
      return write_string_type(write_xlml(wb, o), o);
    case "slk":
    case "sylk":
      return write_string_type(SYLK.from_sheet(wb.Sheets[wb.SheetNames[idx]], o, wb), o);
    case "htm":
    case "html":
      return write_string_type(sheet_to_html(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "txt":
      return write_stxt_type(sheet_to_txt(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "csv":
      return write_string_type(sheet_to_csv(wb.Sheets[wb.SheetNames[idx]], o), o, "\uFEFF");
    case "dif":
      return write_string_type(DIF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "dbf":
      return write_binary_type(DBF.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "prn":
      return write_string_type(PRN.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "rtf":
      return write_string_type(sheet_to_rtf(wb.Sheets[wb.SheetNames[idx]]), o);
    case "eth":
      return write_string_type(ETH.from_sheet(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "fods":
      return write_string_type(write_ods(wb, o), o);
    case "wk1":
      return write_binary_type(WK_.sheet_to_wk1(wb.Sheets[wb.SheetNames[idx]], o), o);
    case "wk3":
      return write_binary_type(WK_.book_to_wk3(wb, o), o);
    case "biff2":
      if (!o.biff)
        o.biff = 2;
    case "biff3":
      if (!o.biff)
        o.biff = 3;
    case "biff4":
      if (!o.biff)
        o.biff = 4;
      return write_binary_type(write_biff_buf(wb, o), o);
    case "biff5":
      if (!o.biff)
        o.biff = 5;
    case "biff8":
    case "xla":
    case "xls":
      if (!o.biff)
        o.biff = 8;
      return write_cfb_type(wb, o);
    case "xlsx":
    case "xlsm":
    case "xlam":
    case "xlsb":
    case "numbers":
    case "ods":
      return write_zip_type(wb, o);
    default:
      throw new Error("Unrecognized bookType |" + o.bookType + "|");
  }
}
function make_json_row(sheet, r, R, cols, header, hdr, o) {
  var rr = encode_row(R);
  var defval = o.defval, raw = o.raw || !Object.prototype.hasOwnProperty.call(o, "raw");
  var isempty = true, dense = sheet["!data"] != null;
  var row = header === 1 ? [] : {};
  if (header !== 1) {
    if (Object.defineProperty)
      try {
        Object.defineProperty(row, "__rowNum__", { value: R, enumerable: false });
      } catch (e) {
        row.__rowNum__ = R;
      }
    else
      row.__rowNum__ = R;
  }
  if (!dense || sheet["!data"][R])
    for (var C = r.s.c; C <= r.e.c; ++C) {
      var val = dense ? (sheet["!data"][R] || [])[C] : sheet[cols[C] + rr];
      if (val === void 0 || val.t === void 0) {
        if (defval === void 0)
          continue;
        if (hdr[C] != null) {
          row[hdr[C]] = defval;
        }
        continue;
      }
      var v = val.v;
      switch (val.t) {
        case "z":
          if (v == null)
            break;
          continue;
        case "e":
          v = v == 0 ? null : void 0;
          break;
        case "s":
        case "d":
        case "b":
        case "n":
          break;
        default:
          throw new Error("unrecognized type " + val.t);
      }
      if (hdr[C] != null) {
        if (v == null) {
          if (val.t == "e" && v === null)
            row[hdr[C]] = null;
          else if (defval !== void 0)
            row[hdr[C]] = defval;
          else if (raw && v === null)
            row[hdr[C]] = null;
          else
            continue;
        } else {
          row[hdr[C]] = raw && (val.t !== "n" || val.t === "n" && o.rawNumbers !== false) ? v : format_cell(val, v, o);
        }
        if (v != null)
          isempty = false;
      }
    }
  return { row, isempty };
}
function sheet_to_json(sheet, opts) {
  if (sheet == null || sheet["!ref"] == null)
    return [];
  var val = { t: "n", v: 0 }, header = 0, offset = 1, hdr = [], v = 0, vv = "";
  var r = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  var o = opts || {};
  var range = o.range != null ? o.range : sheet["!ref"];
  if (o.header === 1)
    header = 1;
  else if (o.header === "A")
    header = 2;
  else if (Array.isArray(o.header))
    header = 3;
  else if (o.header == null)
    header = 0;
  switch (typeof range) {
    case "string":
      r = safe_decode_range(range);
      break;
    case "number":
      r = safe_decode_range(sheet["!ref"]);
      r.s.r = range;
      break;
    default:
      r = range;
  }
  if (header > 0)
    offset = 0;
  var rr = encode_row(r.s.r);
  var cols = [];
  var out = [];
  var outi = 0, counter = 0;
  var dense = sheet["!data"] != null;
  var R = r.s.r, C = 0;
  var header_cnt = {};
  if (dense && !sheet["!data"][R])
    sheet["!data"][R] = [];
  var colinfo = o.skipHidden && sheet["!cols"] || [];
  var rowinfo = o.skipHidden && sheet["!rows"] || [];
  for (C = r.s.c; C <= r.e.c; ++C) {
    if ((colinfo[C] || {}).hidden)
      continue;
    cols[C] = encode_col(C);
    val = dense ? sheet["!data"][R][C] : sheet[cols[C] + rr];
    switch (header) {
      case 1:
        hdr[C] = C - r.s.c;
        break;
      case 2:
        hdr[C] = cols[C];
        break;
      case 3:
        hdr[C] = o.header[C - r.s.c];
        break;
      default:
        if (val == null)
          val = { w: "__EMPTY", t: "s" };
        vv = v = format_cell(val, null, o);
        counter = header_cnt[v] || 0;
        if (!counter)
          header_cnt[v] = 1;
        else {
          do {
            vv = v + "_" + counter++;
          } while (header_cnt[vv]);
          header_cnt[v] = counter;
          header_cnt[vv] = 1;
        }
        hdr[C] = vv;
    }
  }
  for (R = r.s.r + offset; R <= r.e.r; ++R) {
    if ((rowinfo[R] || {}).hidden)
      continue;
    var row = make_json_row(sheet, r, R, cols, header, hdr, o);
    if (row.isempty === false || (header === 1 ? o.blankrows !== false : !!o.blankrows))
      out[outi++] = row.row;
  }
  out.length = outi;
  return out;
}
var qreg = /"/g;
function make_csv_row(sheet, r, R, cols, fs, rs, FS, o) {
  var isempty = true;
  var row = [], txt = "", rr = encode_row(R);
  var dense = sheet["!data"] != null;
  var datarow = dense && sheet["!data"][R] || [];
  for (var C = r.s.c; C <= r.e.c; ++C) {
    if (!cols[C])
      continue;
    var val = dense ? datarow[C] : sheet[cols[C] + rr];
    if (val == null)
      txt = "";
    else if (val.v != null) {
      isempty = false;
      txt = "" + (o.rawNumbers && val.t == "n" ? val.v : format_cell(val, null, o));
      for (var i = 0, cc = 0; i !== txt.length; ++i)
        if ((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34 || o.forceQuotes) {
          txt = '"' + txt.replace(qreg, '""') + '"';
          break;
        }
      if (txt == "ID")
        txt = '"ID"';
    } else if (val.f != null && !val.F) {
      isempty = false;
      txt = "=" + val.f;
      if (txt.indexOf(",") >= 0)
        txt = '"' + txt.replace(qreg, '""') + '"';
    } else
      txt = "";
    row.push(txt);
  }
  if (o.blankrows === false && isempty)
    return null;
  return row.join(FS);
}
function sheet_to_csv(sheet, opts) {
  var out = [];
  var o = opts == null ? {} : opts;
  if (sheet == null || sheet["!ref"] == null)
    return "";
  var r = safe_decode_range(sheet["!ref"]);
  var FS = o.FS !== void 0 ? o.FS : ",", fs = FS.charCodeAt(0);
  var RS = o.RS !== void 0 ? o.RS : "\n", rs = RS.charCodeAt(0);
  var endregex = new RegExp((FS == "|" ? "\\|" : FS) + "+$");
  var row = "", cols = [];
  var colinfo = o.skipHidden && sheet["!cols"] || [];
  var rowinfo = o.skipHidden && sheet["!rows"] || [];
  for (var C = r.s.c; C <= r.e.c; ++C)
    if (!(colinfo[C] || {}).hidden)
      cols[C] = encode_col(C);
  var w2 = 0;
  for (var R = r.s.r; R <= r.e.r; ++R) {
    if ((rowinfo[R] || {}).hidden)
      continue;
    row = make_csv_row(sheet, r, R, cols, fs, rs, FS, o);
    if (row == null) {
      continue;
    }
    if (o.strip)
      row = row.replace(endregex, "");
    if (row || o.blankrows !== false)
      out.push((w2++ ? RS : "") + row);
  }
  return out.join("");
}
function sheet_to_txt(sheet, opts) {
  if (!opts)
    opts = {};
  opts.FS = "	";
  opts.RS = "\n";
  var s = sheet_to_csv(sheet, opts);
  return s;
}
function sheet_to_formulae(sheet) {
  var y = "", x, val = "";
  if (sheet == null || sheet["!ref"] == null)
    return [];
  var r = safe_decode_range(sheet["!ref"]), rr = "", cols = [], C;
  var cmds = [];
  var dense = sheet["!data"] != null;
  for (C = r.s.c; C <= r.e.c; ++C)
    cols[C] = encode_col(C);
  for (var R = r.s.r; R <= r.e.r; ++R) {
    rr = encode_row(R);
    for (C = r.s.c; C <= r.e.c; ++C) {
      y = cols[C] + rr;
      x = dense ? (sheet["!data"][R] || [])[C] : sheet[y];
      val = "";
      if (x === void 0)
        continue;
      else if (x.F != null) {
        y = x.F;
        if (!x.f)
          continue;
        val = x.f;
        if (y.indexOf(":") == -1)
          y = y + ":" + y;
      }
      if (x.f != null)
        val = x.f;
      else if (x.t == "z")
        continue;
      else if (x.t == "n" && x.v != null)
        val = "" + x.v;
      else if (x.t == "b")
        val = x.v ? "TRUE" : "FALSE";
      else if (x.w !== void 0)
        val = "'" + x.w;
      else if (x.v === void 0)
        continue;
      else if (x.t == "s")
        val = "'" + x.v;
      else
        val = "" + x.v;
      cmds[cmds.length] = y + "=" + val;
    }
  }
  return cmds;
}
function sheet_add_json(_ws, js, opts) {
  var o = opts || {};
  var dense = _ws ? _ws["!data"] != null : o.dense;
  var offset = +!o.skipHeader;
  var ws = _ws || {};
  if (!_ws && dense)
    ws["!data"] = [];
  var _R = 0, _C = 0;
  if (ws && o.origin != null) {
    if (typeof o.origin == "number")
      _R = o.origin;
    else {
      var _origin = typeof o.origin == "string" ? decode_cell(o.origin) : o.origin;
      _R = _origin.r;
      _C = _origin.c;
    }
  }
  var range = { s: { c: 0, r: 0 }, e: { c: _C, r: _R + js.length - 1 + offset } };
  if (ws["!ref"]) {
    var _range = safe_decode_range(ws["!ref"]);
    range.e.c = Math.max(range.e.c, _range.e.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    if (_R == -1) {
      _R = _range.e.r + 1;
      range.e.r = _R + js.length - 1 + offset;
    }
  } else {
    if (_R == -1) {
      _R = 0;
      range.e.r = js.length - 1 + offset;
    }
  }
  var hdr = o.header || [], C = 0;
  var ROW = [];
  js.forEach(function(JS, R) {
    if (dense && !ws["!data"][_R + R + offset])
      ws["!data"][_R + R + offset] = [];
    if (dense)
      ROW = ws["!data"][_R + R + offset];
    keys(JS).forEach(function(k) {
      if ((C = hdr.indexOf(k)) == -1)
        hdr[C = hdr.length] = k;
      var v = JS[k];
      var t = "z";
      var z = "";
      var ref = dense ? "" : encode_col(_C + C) + encode_row(_R + R + offset);
      var cell = dense ? ROW[_C + C] : ws[ref];
      if (v && typeof v === "object" && !(v instanceof Date)) {
        if (dense)
          ROW[_C + C] = v;
        else
          ws[ref] = v;
      } else {
        if (typeof v == "number")
          t = "n";
        else if (typeof v == "boolean")
          t = "b";
        else if (typeof v == "string")
          t = "s";
        else if (v instanceof Date) {
          t = "d";
          if (!o.cellDates) {
            t = "n";
            v = datenum(v);
          }
          z = cell != null && cell.z && fmt_is_date(cell.z) ? cell.z : o.dateNF || table_fmt[14];
        } else if (v === null && o.nullError) {
          t = "e";
          v = 0;
        }
        if (!cell) {
          if (!dense)
            ws[ref] = cell = { t, v };
          else
            ROW[_C + C] = cell = { t, v };
        } else {
          cell.t = t;
          cell.v = v;
          delete cell.w;
          delete cell.R;
          if (z)
            cell.z = z;
        }
        if (z)
          cell.z = z;
      }
    });
  });
  range.e.c = Math.max(range.e.c, _C + hdr.length - 1);
  var __R = encode_row(_R);
  if (dense && !ws["!data"][_R])
    ws["!data"][_R] = [];
  if (offset)
    for (C = 0; C < hdr.length; ++C) {
      if (dense)
        ws["!data"][_R][C + _C] = { t: "s", v: hdr[C] };
      else
        ws[encode_col(C + _C) + __R] = { t: "s", v: hdr[C] };
    }
  ws["!ref"] = encode_range(range);
  return ws;
}
function json_to_sheet(js, opts) {
  return sheet_add_json(null, js, opts);
}
function ws_get_cell_stub(ws, R, C) {
  if (typeof R == "string") {
    if (ws["!data"] != null) {
      var RC = decode_cell(R);
      if (!ws["!data"][RC.r])
        ws["!data"][RC.r] = [];
      return ws["!data"][RC.r][RC.c] || (ws["!data"][RC.r][RC.c] = { t: "z" });
    }
    return ws[R] || (ws[R] = { t: "z" });
  }
  if (typeof R != "number")
    return ws_get_cell_stub(ws, encode_cell(R));
  return ws_get_cell_stub(ws, encode_col(C || 0) + encode_row(R));
}
function wb_sheet_idx(wb, sh) {
  if (typeof sh == "number") {
    if (sh >= 0 && wb.SheetNames.length > sh)
      return sh;
    throw new Error("Cannot find sheet # " + sh);
  } else if (typeof sh == "string") {
    var idx = wb.SheetNames.indexOf(sh);
    if (idx > -1)
      return idx;
    throw new Error("Cannot find sheet name |" + sh + "|");
  } else
    throw new Error("Cannot find sheet |" + sh + "|");
}
function book_new() {
  return { SheetNames: [], Sheets: {} };
}
function book_append_sheet(wb, ws, name, roll) {
  var i = 1;
  if (!name) {
    for (; i <= 65535; ++i, name = void 0)
      if (wb.SheetNames.indexOf(name = "Sheet" + i) == -1)
        break;
  }
  if (!name || wb.SheetNames.length >= 65535)
    throw new Error("Too many worksheets");
  if (roll && wb.SheetNames.indexOf(name) >= 0) {
    var m = name.match(/(^.*?)(\d+)$/);
    i = m && +m[2] || 0;
    var root2 = m && m[1] || name;
    for (++i; i <= 65535; ++i)
      if (wb.SheetNames.indexOf(name = root2 + i) == -1)
        break;
  }
  check_ws_name(name);
  if (wb.SheetNames.indexOf(name) >= 0)
    throw new Error("Worksheet with name |" + name + "| already exists!");
  wb.SheetNames.push(name);
  wb.Sheets[name] = ws;
  return name;
}
function book_set_sheet_visibility(wb, sh, vis) {
  if (!wb.Workbook)
    wb.Workbook = {};
  if (!wb.Workbook.Sheets)
    wb.Workbook.Sheets = [];
  var idx = wb_sheet_idx(wb, sh);
  if (!wb.Workbook.Sheets[idx])
    wb.Workbook.Sheets[idx] = {};
  switch (vis) {
    case 0:
    case 1:
    case 2:
      break;
    default:
      throw new Error("Bad sheet visibility setting " + vis);
  }
  wb.Workbook.Sheets[idx].Hidden = vis;
}
function cell_set_number_format(cell, fmt) {
  cell.z = fmt;
  return cell;
}
function cell_set_hyperlink(cell, target, tooltip) {
  if (!target) {
    delete cell.l;
  } else {
    cell.l = { Target: target };
    if (tooltip)
      cell.l.Tooltip = tooltip;
  }
  return cell;
}
function cell_set_internal_link(cell, range, tooltip) {
  return cell_set_hyperlink(cell, "#" + range, tooltip);
}
function cell_add_comment(cell, text, author) {
  if (!cell.c)
    cell.c = [];
  cell.c.push({ t: text, a: author || "SheetJS" });
}
function sheet_set_array_formula(ws, range, formula, dynamic) {
  var rng2 = typeof range != "string" ? range : safe_decode_range(range);
  var rngstr = typeof range == "string" ? range : encode_range(range);
  for (var R = rng2.s.r; R <= rng2.e.r; ++R)
    for (var C = rng2.s.c; C <= rng2.e.c; ++C) {
      var cell = ws_get_cell_stub(ws, R, C);
      cell.t = "n";
      cell.F = rngstr;
      delete cell.v;
      if (R == rng2.s.r && C == rng2.s.c) {
        cell.f = formula;
        if (dynamic)
          cell.D = true;
      }
    }
  var wsr = decode_range(ws["!ref"]);
  if (wsr.s.r > rng2.s.r)
    wsr.s.r = rng2.s.r;
  if (wsr.s.c > rng2.s.c)
    wsr.s.c = rng2.s.c;
  if (wsr.e.r < rng2.e.r)
    wsr.e.r = rng2.e.r;
  if (wsr.e.c < rng2.e.c)
    wsr.e.c = rng2.e.c;
  ws["!ref"] = encode_range(wsr);
  return ws;
}
var utils = {
  encode_col,
  encode_row,
  encode_cell,
  encode_range,
  decode_col,
  decode_row,
  split_cell,
  decode_cell,
  decode_range,
  format_cell,
  sheet_add_aoa,
  sheet_add_json,
  sheet_add_dom,
  aoa_to_sheet,
  json_to_sheet,
  table_to_sheet: parse_dom_table,
  table_to_book,
  sheet_to_csv,
  sheet_to_txt,
  sheet_to_json,
  sheet_to_html,
  sheet_to_formulae,
  sheet_to_row_object_array: sheet_to_json,
  sheet_get_cell: ws_get_cell_stub,
  book_new,
  book_append_sheet,
  book_set_sheet_visibility,
  cell_set_number_format,
  cell_set_hyperlink,
  cell_set_internal_link,
  cell_add_comment,
  sheet_set_array_formula,
  consts: {
    SHEET_VISIBLE: 0,
    SHEET_HIDDEN: 1,
    SHEET_VERY_HIDDEN: 2
  }
};
const encodedJs = "KGZ1bmN0aW9uKCkgewogICJ1c2Ugc3RyaWN0IjsKICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7CiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7CiAgICBjb25zdCB7CiAgICAgIG1lc3NhZ2VzLAogICAgICBkZWZhdWx0R3JpZERhdGFUbXAsCiAgICAgIGluZGVudGlmZXJDb2x1bW4sCiAgICAgIHByb3BzLAogICAgICBpZ25vcmVkQ29sUHJvcGVydGllcywKICAgICAgTWVzc2FnZUJhclR5cGUsCiAgICAgIERlcENvbFR5cGVzCiAgICB9ID0gZXZlbnQuZGF0YTsKICAgIGxldCBsb2NhbEVycm9yID0gZmFsc2U7CiAgICBjb25zdCBtc2dNYXAgPSBuZXcgTWFwKG1lc3NhZ2VzKTsKICAgIGNvbnN0IHRtcEluc2VydFRvTWVzc2FnZU1hcCA9IChrZXksIHZhbHVlKSA9PiB7CiAgICAgIG1zZ01hcC5zZXQoa2V5LCB2YWx1ZSk7CiAgICB9OwogICAgZnVuY3Rpb24gZmluZER1cGxpY2F0ZXMoYXJyYXkpIHsKICAgICAgY29uc3QgZHVwbGljYXRlczIgPSBbXTsKICAgICAgY29uc3Qgc2VlbiA9IHt9OwogICAgICBjb25zdCBtYWtlRXZlcnl0aGluZ0FTdHJpbmcgPSBhcnJheS5tYXAoKG9iaikgPT4gewogICAgICAgIGNvbnN0IGNvbnZlcnRlZE9iaiA9IHt9OwogICAgICAgIGZvciAoY29uc3Qga2V5MiBpbiBvYmopIHsKICAgICAgICAgIGlmIChvYmpba2V5Ml0gPT0gbnVsbCB8fCBvYmpba2V5Ml0gPT0gdm9pZCAwKQogICAgICAgICAgICBjb252ZXJ0ZWRPYmpba2V5Ml0gPSAiIjsKICAgICAgICAgIGVsc2UgewogICAgICAgICAgICBjb252ZXJ0ZWRPYmpba2V5Ml0gPSBTdHJpbmcob2JqW2tleTJdKS50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gY29udmVydGVkT2JqOwogICAgICB9KTsKICAgICAgY29uc3QgaWdub3JlZFByb3BlcnRpZXMgPSBbLi4uaWdub3JlZENvbFByb3BlcnRpZXNdOwogICAgICBpZiAoaW5kZW50aWZlckNvbHVtbiAhPT0gbnVsbCAmJiBpbmRlbnRpZmVyQ29sdW1uICE9PSB2b2lkIDApIHsKICAgICAgICBpZ25vcmVkUHJvcGVydGllcy5wdXNoKGluZGVudGlmZXJDb2x1bW4pOwogICAgICB9CiAgICAgIGlmIChwcm9wcy5jdXN0b21PcGVyYXRpb25zS2V5KSB7CiAgICAgICAgaWdub3JlZFByb3BlcnRpZXMucHVzaChwcm9wcy5jdXN0b21PcGVyYXRpb25zS2V5LmNvbEtleSk7CiAgICAgIH0KICAgICAgaWYgKHByb3BzLmN1c3RvbUtleXNUb0FkZE9uTmV3Um93KSB7CiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHByb3BzLmN1c3RvbUtleXNUb0FkZE9uTmV3Um93Lmxlbmd0aDsgaW5kZXgrKykgewogICAgICAgICAgY29uc3QgZWxlbWVudCA9IHByb3BzLmN1c3RvbUtleXNUb0FkZE9uTmV3Um93W2luZGV4XTsKICAgICAgICAgIGlmICgoZWxlbWVudC51c2VLZXlXaGVuRGV0ZXJtaW5pbmdEdXBsaWNhdGVkUm93cyA/PyBmYWxzZSkgPT0gdHJ1ZSkKICAgICAgICAgICAgaWdub3JlZFByb3BlcnRpZXMucHVzaChlbGVtZW50LmtleSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGxldCBrZXkgPSAiIjsKICAgICAgbWFrZUV2ZXJ5dGhpbmdBU3RyaW5nLmZvckVhY2goKHJvdywgaW5kZXgpID0+IHsKICAgICAgICBpZiAoZGVmYXVsdEdyaWREYXRhVG1wID09IG51bGwgPyB2b2lkIDAgOiBkZWZhdWx0R3JpZERhdGFUbXBbMF0pIHsKICAgICAgICAgIGtleSA9IEpTT04uc3RyaW5naWZ5KAogICAgICAgICAgICBPYmplY3QuZW50cmllcyhyb3cpLmZpbHRlcigoW3Byb3BdKSA9PiBPYmplY3Qua2V5cyhkZWZhdWx0R3JpZERhdGFUbXBbMF0pLmluY2x1ZGVzKHByb3ApKS5maWx0ZXIoCiAgICAgICAgICAgICAgKFtwcm9wXSkgPT4gcHJvcHMuY29sdW1ucy5tYXAoKG9iaikgPT4gb2JqLmtleSkuaW5jbHVkZXMocHJvcCkKICAgICAgICAgICAgKS5maWx0ZXIoKFtwcm9wXSkgPT4gIWlnbm9yZWRQcm9wZXJ0aWVzLmluY2x1ZGVzKHByb3ApKS5zb3J0KCkKICAgICAgICAgICk7CiAgICAgICAgICBpZiAoc2VlbltrZXldKSB7CiAgICAgICAgICAgIGluZGVudGlmZXJDb2x1bW4gIT09IG51bGwgJiYgaW5kZW50aWZlckNvbHVtbiAhPT0gdm9pZCAwID8gc2VlbltrZXldLmlkcy5wdXNoKHJvd1tpbmRlbnRpZmVyQ29sdW1uXSkgOiBzZWVuW2tleV0uaWRzLnB1c2goaW5kZXgpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaWYgKGluZGVudGlmZXJDb2x1bW4gIT09IG51bGwgJiYgaW5kZW50aWZlckNvbHVtbiAhPT0gdm9pZCAwKSB7CiAgICAgICAgICAgICAgc2VlbltrZXldID0gewogICAgICAgICAgICAgICAgaW5kZXg6IGR1cGxpY2F0ZXMyLmxlbmd0aCwKICAgICAgICAgICAgICAgIGlkczogW3Jvd1tpbmRlbnRpZmVyQ29sdW1uXV0KICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIGR1cGxpY2F0ZXMyLnB1c2goc2VlbltrZXldLmlkcyk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgc2VlbltrZXldID0geyBpbmRleDogZHVwbGljYXRlczIubGVuZ3RoLCBpZHM6IFtpbmRleF0gfTsKICAgICAgICAgICAgICBkdXBsaWNhdGVzMi5wdXNoKHNlZW5ba2V5XS5pZHMpOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9KTsKICAgICAgcmV0dXJuIGR1cGxpY2F0ZXMyLmZpbHRlcigoaWRzKSA9PiBpZHMubGVuZ3RoID4gMSkubWFwKChpZHMpID0+IGlkcy5zb3J0KChhLCBiKSA9PiBhIC0gYikpOwogICAgfQogICAgY29uc3QgZHVwbGljYXRlcyA9IGZpbmREdXBsaWNhdGVzKGRlZmF1bHRHcmlkRGF0YVRtcCk7CiAgICBpZiAoZHVwbGljYXRlcy5sZW5ndGggPiAwKSB7CiAgICAgIGR1cGxpY2F0ZXMuZm9yRWFjaCgoZHVwcywgaW5kZXgpID0+IHsKICAgICAgICB2YXIgbXNnMiA9IGluZGVudGlmZXJDb2x1bW4gIT09IG51bGwgJiYgaW5kZW50aWZlckNvbHVtbiAhPT0gdm9pZCAwID8gYFJvd3MgTG9jYXRlZCBBdCBJRHM6ICR7ZHVwc30gYXJlIGR1cGxpY2F0ZWRgIDogYFJvd3MgTG9jYXRlZCBBdCBJbmRleGVzICR7ZHVwc30gYXJlIGR1cGxpY2F0ZWRgOwogICAgICAgIHRtcEluc2VydFRvTWVzc2FnZU1hcCgiZHVwcyIgKyBpbmRleCwgewogICAgICAgICAgbXNnOiBtc2cyLAogICAgICAgICAgdHlwZTogTWVzc2FnZUJhclR5cGUuZXJyb3IKICAgICAgICB9KTsKICAgICAgfSk7CiAgICAgIGxvY2FsRXJyb3IgPSB0cnVlOwogICAgfQogICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgZGVmYXVsdEdyaWREYXRhVG1wLmxlbmd0aDsgcm93KyspIHsKICAgICAgY29uc3QgZ3JpZERhdGEgPSBkZWZhdWx0R3JpZERhdGFUbXBbcm93XTsKICAgICAgdmFyIGVsZW1lbnRDb2xOYW1lcyA9IE9iamVjdC5rZXlzKGdyaWREYXRhKTsKICAgICAgbGV0IGVtcHR5Q29sID0gW107CiAgICAgIGxldCBlbXB0eVJlcUNvbCA9IFtdOwogICAgICBmb3IgKGxldCBpbmRleElubmVyID0gMDsgaW5kZXhJbm5lciA8IGVsZW1lbnRDb2xOYW1lcy5sZW5ndGg7IGluZGV4SW5uZXIrKykgewogICAgICAgIGNvbnN0IGNvbE5hbWVzID0gZWxlbWVudENvbE5hbWVzW2luZGV4SW5uZXJdOwogICAgICAgIGdyaWREYXRhW2NvbE5hbWVzXTsKICAgICAgICBjb25zdCBjdXJyZW50Q29sID0gcHJvcHMuY29sdW1ucy5maWx0ZXIoKHgpID0+IHgua2V5ID09PSBjb2xOYW1lcyk7CiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyZW50Q29sLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gY3VycmVudENvbFtqXTsKICAgICAgICAgIGNvbnN0IHJvd0NvbCA9IGdyaWREYXRhW2VsZW1lbnQua2V5XTsKICAgICAgICAgIGlmIChlbGVtZW50LnJlcXVpcmVkICYmIHR5cGVvZiBlbGVtZW50LnJlcXVpcmVkID09ICJib29sZWFuIiAmJiAocm93Q29sID09IG51bGwgfHwgcm93Q29sID09IHZvaWQgMCB8fCAocm93Q29sID09IG51bGwgPyB2b2lkIDAgOiByb3dDb2wudG9TdHJpbmcoKS5sZW5ndGgpIDw9IDAgfHwgcm93Q29sID09ICIiICYmIGVsZW1lbnQuZGF0YVR5cGUgIT0gIm51bWJlciIpKSB7CiAgICAgICAgICAgIGlmICghZW1wdHlDb2wuaW5jbHVkZXMoIiAiICsgZWxlbWVudC5uYW1lKSkKICAgICAgICAgICAgICBlbXB0eUNvbC5wdXNoKCIgIiArIGVsZW1lbnQubmFtZSk7CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnJlcXVpcmVkICE9PSAiYm9vbGVhbiIgJiYgIWVsZW1lbnQucmVxdWlyZWQucmVxdWlyZWRPbmx5SWZUaGVzZUNvbHVtbnNBcmVFbXB0eSAmJiBlbGVtZW50LnJlcXVpcmVkLmVycm9yTWVzc2FnZSAmJiAocm93Q29sID09IG51bGwgfHwgcm93Q29sID09IHZvaWQgMCB8fCAocm93Q29sID09IG51bGwgPyB2b2lkIDAgOiByb3dDb2wudG9TdHJpbmcoKS5sZW5ndGgpIDw9IDAgfHwgcm93Q29sID09ICIiICYmIGVsZW1lbnQuZGF0YVR5cGUgIT0gIm51bWJlciIpKSB7CiAgICAgICAgICAgIHZhciBtc2cgPSBgUm93ICR7aW5kZW50aWZlckNvbHVtbiA/ICJXaXRoIElEOiAiICsgZ3JpZERhdGFbaW5kZW50aWZlckNvbHVtbl0gOiAiV2l0aCBJbmRleDoiICsgcm93ICsgMX0gLSAke2VsZW1lbnQucmVxdWlyZWQuZXJyb3JNZXNzYWdlfScuYDsKICAgICAgICAgICAgdG1wSW5zZXJ0VG9NZXNzYWdlTWFwKGVsZW1lbnQua2V5ICsgcm93ICsgImVtcHR5IiwgewogICAgICAgICAgICAgIG1zZywKICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlQmFyVHlwZS5lcnJvcgogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQucmVxdWlyZWQgIT09ICJib29sZWFuIiAmJiBlbGVtZW50LnJlcXVpcmVkLnJlcXVpcmVkT25seUlmVGhlc2VDb2x1bW5zQXJlRW1wdHkgJiYgKHJvd0NvbCA9PSBudWxsIHx8IHJvd0NvbCA9PSB2b2lkIDAgfHwgKHJvd0NvbCA9PSBudWxsID8gdm9pZCAwIDogcm93Q29sLnRvU3RyaW5nKCkubGVuZ3RoKSA8PSAwIHx8IHJvd0NvbCA9PSAiIiAmJiBlbGVtZW50LmRhdGFUeXBlICE9ICJudW1iZXIiKSkgewogICAgICAgICAgICBjb25zdCBjaGVja0tleXMgPSBlbGVtZW50LnJlcXVpcmVkLnJlcXVpcmVkT25seUlmVGhlc2VDb2x1bW5zQXJlRW1wdHkuY29sS2V5czsKICAgICAgICAgICAgbGV0IHNraXBwYWJsZSA9IGZhbHNlOwogICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY2hlY2tLZXlzLmxlbmd0aDsgaW5kZXgrKykgewogICAgICAgICAgICAgIGNvbnN0IGNvbHVtbktleSA9IGNoZWNrS2V5c1tpbmRleF07CiAgICAgICAgICAgICAgY29uc3Qgc3RyID0gZ3JpZERhdGFbY29sdW1uS2V5XTsKICAgICAgICAgICAgICBpZiAoZWxlbWVudC5yZXF1aXJlZC5hbHdheXNSZXF1aXJlZCkgewogICAgICAgICAgICAgICAgaWYgKHN0ciA9PSBudWxsIHx8IHN0ciA9PSB2b2lkIDAgfHwgKHN0ciA9PSBudWxsID8gdm9pZCAwIDogc3RyLnRvU3RyaW5nKCkubGVuZ3RoKSA8PSAwIHx8IHN0ciA9PSAiIiAmJiBlbGVtZW50LmRhdGFUeXBlICE9ICJudW1iZXIiKSB7CiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnJlcXVpcmVkLmVycm9yTWVzc2FnZSkgewogICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBgUm93ICR7aW5kZW50aWZlckNvbHVtbiA/ICJXaXRoIElEOiAiICsgZ3JpZERhdGFbaW5kZW50aWZlckNvbHVtbl0gOiAiV2l0aCBJbmRleDoiICsgcm93ICsgMX0gLSAke2VsZW1lbnQucmVxdWlyZWQuZXJyb3JNZXNzYWdlfScuYDsKICAgICAgICAgICAgICAgICAgICB0bXBJbnNlcnRUb01lc3NhZ2VNYXAoZWxlbWVudC5rZXkgKyByb3cgKyAiZW1wdHkiLCB7CiAgICAgICAgICAgICAgICAgICAgICBtc2csCiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlQmFyVHlwZS5lcnJvcgogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFlbXB0eVJlcUNvbC5pbmNsdWRlcygiICIgKyBlbGVtZW50Lm5hbWUpKSB7CiAgICAgICAgICAgICAgICAgICAgZW1wdHlSZXFDb2wucHVzaCgiICIgKyBlbGVtZW50Lm5hbWUpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmICgoc3RyIHx8ICgoX2EgPSBzdHIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ci50b1N0cmluZygpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudHJpbSgpKSA9PSAiMCIpICYmIChzdHIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ci50b1N0cmluZygpLmxlbmd0aCkgPiAwKSB7CiAgICAgICAgICAgICAgICAgIHNraXBwYWJsZSA9IHRydWU7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIWVtcHR5UmVxQ29sLmluY2x1ZGVzKCIgIiArIGVsZW1lbnQubmFtZSkgJiYgc2tpcHBhYmxlID09IGZhbHNlKSB7CiAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LnJlcXVpcmVkLmVycm9yTWVzc2FnZSkKICAgICAgICAgICAgICAgIGVtcHR5UmVxQ29sLnB1c2goIiAiICsgZWxlbWVudC5uYW1lKTsKICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHZhciBtc2cgPSBgUm93ICR7aW5kZW50aWZlckNvbHVtbiA/ICJXaXRoIElEOiAiICsgZ3JpZERhdGFbaW5kZW50aWZlckNvbHVtbl0gOiAiV2l0aCBJbmRleDoiICsgcm93ICsgMX0gLSAke2VsZW1lbnQucmVxdWlyZWQuZXJyb3JNZXNzYWdlfScuYDsKICAgICAgICAgICAgICAgIHRtcEluc2VydFRvTWVzc2FnZU1hcChlbGVtZW50LmtleSArIHJvdyArICJlbXB0eSIsIHsKICAgICAgICAgICAgICAgICAgbXNnLAogICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlQmFyVHlwZS5lcnJvcgogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocm93Q29sICE9PSBudWxsICYmICh0eXBlb2Ygcm93Q29sICE9PSBlbGVtZW50LmRhdGFUeXBlIHx8IHR5cGVvZiByb3dDb2wgPT09ICJudW1iZXIiKSkgewogICAgICAgICAgICBpZiAoZWxlbWVudC5kYXRhVHlwZSA9PT0gIm51bWJlciIpIHsKICAgICAgICAgICAgICBpZiAocm93Q29sICYmIGlzTmFOKHBhcnNlSW50KHJvd0NvbCkpICYmIHJvd0NvbCAhPT0gIiIpIHsKICAgICAgICAgICAgICAgIHZhciBtc2cgPSBgUm93ICR7aW5kZW50aWZlckNvbHVtbiA/ICJXaXRoIElEOiAiICsgZ3JpZERhdGFbaW5kZW50aWZlckNvbHVtbl0gOiAiV2l0aCBJbmRleDoiICsgcm93ICsgMX0gQ29sOiAke2VsZW1lbnQubmFtZX0gLSBWYWx1ZSBpcyBub3QgYSAnJHtlbGVtZW50LmRhdGFUeXBlfScuYDsKICAgICAgICAgICAgICAgIHRtcEluc2VydFRvTWVzc2FnZU1hcChlbGVtZW50LmtleSArIHJvdywgewogICAgICAgICAgICAgICAgICBtc2csCiAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VCYXJUeXBlLmVycm9yCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIGxvY2FsRXJyb3IgPSB0cnVlOwogICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC52YWxpZGF0aW9ucyAmJiBlbGVtZW50LnZhbGlkYXRpb25zLm51bWJlckJvdW5kYXJpZXMgJiYgZWxlbWVudC52YWxpZGF0aW9ucy5udW1iZXJCb3VuZGFyaWVzLnZhbGlkYXRlT25QYXN0aW5nT25seSA9PSBmYWxzZSkgewogICAgICAgICAgICAgICAgY29uc3QgbWluID0gZWxlbWVudC52YWxpZGF0aW9ucy5udW1iZXJCb3VuZGFyaWVzLm1pblJhbmdlOwogICAgICAgICAgICAgICAgY29uc3QgbWF4ID0gZWxlbWVudC52YWxpZGF0aW9ucy5udW1iZXJCb3VuZGFyaWVzLm1heFJhbmdlOwogICAgICAgICAgICAgICAgaWYgKG1pbiAmJiBtYXgpIHsKICAgICAgICAgICAgICAgICAgaWYgKCEobWluIDw9IHBhcnNlSW50KHJvd0NvbCkgJiYgbWF4ID49IHBhcnNlSW50KHJvd0NvbCkpKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IGBSb3cgJHtpbmRlbnRpZmVyQ29sdW1uID8gIldpdGggSUQ6ICIgKyBncmlkRGF0YVtpbmRlbnRpZmVyQ29sdW1uXSA6ICJXaXRoIEluZGV4OiIgKyByb3cgKyAxfSBDb2w6ICR7ZWxlbWVudC5uYW1lfSAtIFZhbHVlIG91dHNpZGUgb2YgcmFuZ2UgJyR7bWlufSAtICR7bWF4fScuIEVudGVyZWQgdmFsdWUgJHtyb3dDb2x9YDsKICAgICAgICAgICAgICAgICAgICB0bXBJbnNlcnRUb01lc3NhZ2VNYXAoZWxlbWVudC5rZXkgKyByb3csIHsKICAgICAgICAgICAgICAgICAgICAgIG1zZywKICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VCYXJUeXBlLmVycm9yCiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgbG9jYWxFcnJvciA9IHRydWU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWluKSB7CiAgICAgICAgICAgICAgICAgIGlmICghKG1pbiA8PSBwYXJzZUludChyb3dDb2wpKSkgewogICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBgUm93ICR7aW5kZW50aWZlckNvbHVtbiA/ICJXaXRoIElEOiAiICsgZ3JpZERhdGFbaW5kZW50aWZlckNvbHVtbl0gOiAiV2l0aCBJbmRleDoiICsgcm93ICsgMX0gQ29sOiAke2VsZW1lbnQubmFtZX0gLSBWYWx1ZSBpcyBsb3dlciB0aGFuIHJlcXVpcmVkIHJhbmdlOiAnJHttaW59Jy4gRW50ZXJlZCB2YWx1ZSAke3Jvd0NvbH1gOwogICAgICAgICAgICAgICAgICAgIHRtcEluc2VydFRvTWVzc2FnZU1hcChlbGVtZW50LmtleSArIHJvdywgewogICAgICAgICAgICAgICAgICAgICAgbXNnLAogICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZUJhclR5cGUuZXJyb3IKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICBsb2NhbEVycm9yID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXgpIHsKICAgICAgICAgICAgICAgICAgaWYgKCEobWF4ID49IHBhcnNlSW50KHJvd0NvbCkpKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IGBSb3cgJHtpbmRlbnRpZmVyQ29sdW1uID8gIldpdGggSUQ6ICIgKyBncmlkRGF0YVtpbmRlbnRpZmVyQ29sdW1uXSA6ICJXaXRoIEluZGV4OiIgKyByb3cgKyAxfSBDb2w6ICR7ZWxlbWVudC5uYW1lfSAtIFZhbHVlIGlzIGdyZWF0ZXIgdGhhbiByZXF1aXJlZCByYW5nZTogJyR7bWF4fScuIEVudGVyZWQgdmFsdWUgJHtyb3dDb2x9YDsKICAgICAgICAgICAgICAgICAgICB0bXBJbnNlcnRUb01lc3NhZ2VNYXAoZWxlbWVudC5rZXkgKyByb3csIHsKICAgICAgICAgICAgICAgICAgICAgIG1zZywKICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VCYXJUeXBlLmVycm9yCiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgbG9jYWxFcnJvciA9IHRydWU7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5kYXRhVHlwZSA9PT0gImJvb2xlYW4iKSB7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIEJvb2xlYW4ocm93Q29sKTsKICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgICAgdmFyIG1zZyA9IGBSb3cgJHtpbmRlbnRpZmVyQ29sdW1uID8gIldpdGggSUQ6ICIgKyBncmlkRGF0YVtpbmRlbnRpZmVyQ29sdW1uXSA6ICJXaXRoIEluZGV4OiIgKyByb3cgKyAxfSBDb2w6ICR7ZWxlbWVudC5uYW1lfSAtIFZhbHVlIGlzIG5vdCBhICcke2VsZW1lbnQuZGF0YVR5cGV9Jy5gOwogICAgICAgICAgICAgICAgdG1wSW5zZXJ0VG9NZXNzYWdlTWFwKGVsZW1lbnQua2V5ICsgcm93LCB7CiAgICAgICAgICAgICAgICAgIG1zZywKICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZUJhclR5cGUuZXJyb3IKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgbG9jYWxFcnJvciA9IHRydWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuZGF0YVR5cGUgPT09ICJkYXRlIikgewogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWREYXRlKHJvd0NvbCkpIHsKICAgICAgICAgICAgICAgICAgdGhyb3cge307CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICAgICAgICAgICAgdmFyIG1zZyA9IGBSb3cgJHtpbmRlbnRpZmVyQ29sdW1uID8gIldpdGggSUQ6ICIgKyBncmlkRGF0YVtpbmRlbnRpZmVyQ29sdW1uXSA6ICJXaXRoIEluZGV4OiIgKyByb3cgKyAxfSBDb2w6ICR7ZWxlbWVudC5uYW1lfSAtIFZhbHVlIGlzIG5vdCBhICcke2VsZW1lbnQuZGF0YVR5cGV9Jy5gOwogICAgICAgICAgICAgICAgdG1wSW5zZXJ0VG9NZXNzYWdlTWFwKGVsZW1lbnQua2V5ICsgcm93LCB7CiAgICAgICAgICAgICAgICAgIG1zZywKICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZUJhclR5cGUuZXJyb3IKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgbG9jYWxFcnJvciA9IHRydWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZWxlbWVudC52YWxpZGF0aW9ucyAmJiBlbGVtZW50LnZhbGlkYXRpb25zLmNvbHVtbkRlcGVuZGVudCkgewogICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZWxlbWVudC52YWxpZGF0aW9ucy5jb2x1bW5EZXBlbmRlbnQubGVuZ3RoOyBpbmRleCsrKSB7CiAgICAgICAgICAgICAgY29uc3QgY29sRGVwID0gZWxlbWVudC52YWxpZGF0aW9ucy5jb2x1bW5EZXBlbmRlbnRbaW5kZXhdOwogICAgICAgICAgICAgIGlmIChncmlkRGF0YVtjb2xEZXAuZGVwZW5kZW50Q29sdW1uS2V5XSB8fCBncmlkRGF0YVtjb2xEZXAuZGVwZW5kZW50Q29sdW1uS2V5XSAhPT0gdm9pZCAwKSB7CiAgICAgICAgICAgICAgICBjb25zdCBzdHIgPSBncmlkRGF0YVtjb2xEZXAuZGVwZW5kZW50Q29sdW1uS2V5XTsKICAgICAgICAgICAgICAgIGxldCBza2lwID0gZmFsc2U7CiAgICAgICAgICAgICAgICBpZiAoY29sRGVwLnNraXBDaGVja0lmVGhlc2VDb2x1bW5zSGF2ZURhdGEgJiYgY29sRGVwLnNraXBDaGVja0lmVGhlc2VDb2x1bW5zSGF2ZURhdGEuY29sS2V5cykgewogICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNraXBGb3JLZXkgb2YgY29sRGVwLnNraXBDaGVja0lmVGhlc2VDb2x1bW5zSGF2ZURhdGEuY29sS2V5cykgewogICAgICAgICAgICAgICAgICAgIGlmICgoX2IgPSBjb2xEZXAuc2tpcENoZWNrSWZUaGVzZUNvbHVtbnNIYXZlRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnBhcnRpYWwpIHsKICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cjIgPSBncmlkRGF0YVtza2lwRm9yS2V5XTsKICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHIyICYmIHN0cjIgIT09IG51bGwgJiYgc3RyMiAhPT0gdm9pZCAwICYmIChzdHIyID09IG51bGwgPyB2b2lkIDAgOiBzdHIyLnRvU3RyaW5nKCkubGVuZ3RoKSA+IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgc2tpcCA9IHRydWU7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHIyID0gZ3JpZERhdGFbc2tpcEZvcktleV07CiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyMiAmJiBzdHIyICE9PSBudWxsICYmIHN0cjIgIT09IHZvaWQgMCAmJiAoc3RyMiA9PSBudWxsID8gdm9pZCAwIDogc3RyMi50b1N0cmluZygpLmxlbmd0aCkgPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNraXAgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgc2tpcCA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICghc2tpcCkgewogICAgICAgICAgICAgICAgICBpZiAoc3RyICE9PSB2b2lkIDAgJiYgc3RyICE9PSBudWxsKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKChzdHIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ci50b1N0cmluZygpLmxlbmd0aCkgPiAwICYmIGNvbERlcC50eXBlID09PSBEZXBDb2xUeXBlcy5NdXN0QmVFbXB0eSkgewogICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0NvbCAhPT0gbnVsbCAmJiAocm93Q29sID09IG51bGwgPyB2b2lkIDAgOiByb3dDb2wudG9TdHJpbmcoKS5sZW5ndGgpID4gMCkgewogICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gYFJvdyAke2luZGVudGlmZXJDb2x1bW4gPyAiV2l0aCBJRDogIiArIGdyaWREYXRhW2luZGVudGlmZXJDb2x1bW5dIDogIldpdGggSW5kZXg6IiArIHJvdyArIDF9IC0gYCArIChjb2xEZXAuZXJyb3JNZXNzYWdlID8/IGBEYXRhIGNhbm5vdCBiZSBlbnRlcmVkIGluICR7ZWxlbWVudC5uYW1lfSBhbmQgaW4gJHtjb2xEZXAuZGVwZW5kZW50Q29sdW1uTmFtZX0gQ29sdW1uLiBSZW1vdmUgZGF0YSBpbiAke2NvbERlcC5kZXBlbmRlbnRDb2x1bW5OYW1lfSBDb2x1bW4gdG8gZW50ZXIgZGF0YSBoZXJlLmApOwogICAgICAgICAgICAgICAgICAgICAgICB0bXBJbnNlcnRUb01lc3NhZ2VNYXAocm93ICsgIkNvbERlcCIsIHsKICAgICAgICAgICAgICAgICAgICAgICAgICBtc2csCiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZUJhclR5cGUuZXJyb3IKICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRXJyb3IgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoKHN0ciA9PSB2b2lkIDAgfHwgc3RyID09IG51bGwgfHwgc3RyID09ICIiICYmIGVsZW1lbnQuZGF0YVR5cGUgIT0gIm51bWJlciIgfHwgc3RyICYmIChzdHIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ci50b1N0cmluZygpLmxlbmd0aCkgPD0gMCkgJiYgY29sRGVwLnR5cGUgPT09IERlcENvbFR5cGVzLk11c3RIYXZlRGF0YSkgewogICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBgUm93ICR7aW5kZW50aWZlckNvbHVtbiA/ICJXaXRoIElEOiAiICsgZ3JpZERhdGFbaW5kZW50aWZlckNvbHVtbl0gOiAiV2l0aCBJbmRleDoiICsgcm93ICsgMX0gLSBgICsgKGNvbERlcC5lcnJvck1lc3NhZ2UgPz8gYCBEYXRhIG5lZWRzIHRvIGVudGVyZWQgaW4gJHtjb2xEZXAuZGVwZW5kZW50Q29sdW1uTmFtZX0gYW5kIGluICR7ZWxlbWVudC5uYW1lfSBDb2x1bW4uYCk7CiAgICAgICAgICAgICAgICAgICAgdG1wSW5zZXJ0VG9NZXNzYWdlTWFwKHJvdyArICJDb2xEZXAiLCB7CiAgICAgICAgICAgICAgICAgICAgICBtc2csCiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlQmFyVHlwZS5lcnJvcgogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIGxvY2FsRXJyb3IgPSB0cnVlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZWxlbWVudC52YWxpZGF0aW9ucyAmJiBlbGVtZW50LnZhbGlkYXRpb25zLnJlZ2V4VmFsaWRhdGlvbikgewogICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZWxlbWVudC52YWxpZGF0aW9ucy5yZWdleFZhbGlkYXRpb24ubGVuZ3RoOyBpbmRleCsrKSB7CiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGVsZW1lbnQudmFsaWRhdGlvbnMucmVnZXhWYWxpZGF0aW9uW2luZGV4XTsKICAgICAgICAgICAgICBpZiAoIWRhdGEucmVnZXgudGVzdChyb3dDb2wpKSB7CiAgICAgICAgICAgICAgICB2YXIgbXNnID0gYFJvdyAke2luZGVudGlmZXJDb2x1bW4gPyAiV2l0aCBJRDogIiArIGdyaWREYXRhW2luZGVudGlmZXJDb2x1bW5dIDogIldpdGggSW5kZXg6IiArIHJvdyArIDF9IC0gJHtkYXRhLmVycm9yTWVzc2FnZX1gOwogICAgICAgICAgICAgICAgdG1wSW5zZXJ0VG9NZXNzYWdlTWFwKGVsZW1lbnQua2V5ICsgcm93LCB7CiAgICAgICAgICAgICAgICAgIG1zZywKICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZUJhclR5cGUuZXJyb3IKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgbG9jYWxFcnJvciA9IHRydWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoZWxlbWVudC52YWxpZGF0aW9ucyAmJiBlbGVtZW50LnZhbGlkYXRpb25zLnN0cmluZ1ZhbGlkYXRpb25zKSB7CiAgICAgICAgICAgIGNvbnN0IGNhc2VJbnNlbnNpdGl2ZSA9IGVsZW1lbnQudmFsaWRhdGlvbnMuc3RyaW5nVmFsaWRhdGlvbnMuY2FzZUluc2Vuc2l0aXZlOwogICAgICAgICAgICBpZiAoY2FzZUluc2Vuc2l0aXZlKSB7CiAgICAgICAgICAgICAgaWYgKHJvd0NvbCAhPT0gbnVsbCAmJiAoKF9kID0gKF9jID0gZWxlbWVudC52YWxpZGF0aW9ucy5zdHJpbmdWYWxpZGF0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNvbmRpdGlvbkNhbnRFcXVhbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnRvTG93ZXJDYXNlKCkpID09PSAocm93Q29sID09IG51bGwgPyB2b2lkIDAgOiByb3dDb2wudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpKSkgewogICAgICAgICAgICAgICAgdmFyIG1zZyA9IGBSb3cgJHtpbmRlbnRpZmVyQ29sdW1uID8gIldpdGggSUQ6ICIgKyBncmlkRGF0YVtpbmRlbnRpZmVyQ29sdW1uXSA6ICJXaXRoIEluZGV4OiIgKyByb3cgKyAxfSAtICR7KF9lID0gZWxlbWVudC52YWxpZGF0aW9ucy5zdHJpbmdWYWxpZGF0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmVyck1zZ31gOwogICAgICAgICAgICAgICAgdG1wSW5zZXJ0VG9NZXNzYWdlTWFwKGVsZW1lbnQua2V5ICsgcm93LCB7CiAgICAgICAgICAgICAgICAgIG1zZywKICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZUJhclR5cGUuZXJyb3IKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgbG9jYWxFcnJvciA9IHRydWU7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmIChyb3dDb2wgIT09IG51bGwgJiYgKChfZiA9IGVsZW1lbnQudmFsaWRhdGlvbnMuc3RyaW5nVmFsaWRhdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZi5jb25kaXRpb25DYW50RXF1YWwpID09PSAocm93Q29sID09IG51bGwgPyB2b2lkIDAgOiByb3dDb2wudG9TdHJpbmcoKSkpIHsKICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IGBSb3cgJHtpbmRlbnRpZmVyQ29sdW1uID8gIldpdGggSUQ6ICIgKyBncmlkRGF0YVtpbmRlbnRpZmVyQ29sdW1uXSA6ICJXaXRoIEluZGV4OiIgKyByb3cgKyAxfSAtICR7KF9nID0gZWxlbWVudC52YWxpZGF0aW9ucy5zdHJpbmdWYWxpZGF0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmVyck1zZ31gOwogICAgICAgICAgICAgICAgICB0bXBJbnNlcnRUb01lc3NhZ2VNYXAoZWxlbWVudC5rZXkgKyByb3csIHsKICAgICAgICAgICAgICAgICAgICBtc2csCiAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZUJhclR5cGUuZXJyb3IKICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIGxvY2FsRXJyb3IgPSB0cnVlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoZW1wdHlSZXFDb2wubGVuZ3RoID4gMSkgewogICAgICAgIHZhciBtc2cgPSBgUm93ICR7aW5kZW50aWZlckNvbHVtbiA/ICJXaXRoIElEOiAiICsgZ3JpZERhdGFbaW5kZW50aWZlckNvbHVtbl0gOiAiV2l0aCBJbmRleDoiICsgcm93ICsgMX0gLSAke2VtcHR5UmVxQ29sfSBjYW5ub3QgYWxsIGJlIGVtcHR5YDsKICAgICAgICB0bXBJbnNlcnRUb01lc3NhZ2VNYXAocm93ICsgImVyYyIsIHsKICAgICAgICAgIG1zZywKICAgICAgICAgIHR5cGU6IE1lc3NhZ2VCYXJUeXBlLmVycm9yCiAgICAgICAgfSk7CiAgICAgICAgbG9jYWxFcnJvciA9IHRydWU7CiAgICAgIH0gZWxzZSBpZiAoZW1wdHlSZXFDb2wubGVuZ3RoID09IDEpIHsKICAgICAgICB2YXIgbXNnID0gYFJvdzogJHtpbmRlbnRpZmVyQ29sdW1uID8gIldpdGggSUQ6ICIgKyBncmlkRGF0YVtpbmRlbnRpZmVyQ29sdW1uXSA6IHJvdyArIDF9IC0gJHtlbXB0eVJlcUNvbH0gY2Fubm90IGJlIGVtcHR5YDsKICAgICAgICB0bXBJbnNlcnRUb01lc3NhZ2VNYXAocm93ICsgImVyYyIsIHsKICAgICAgICAgIG1zZywKICAgICAgICAgIHR5cGU6IE1lc3NhZ2VCYXJUeXBlLmVycm9yCiAgICAgICAgfSk7CiAgICAgICAgbG9jYWxFcnJvciA9IHRydWU7CiAgICAgIH0KICAgICAgaWYgKGVtcHR5Q29sLmxlbmd0aCA+IDEpIHsKICAgICAgICB2YXIgbXNnID0gYFJvdyAke2luZGVudGlmZXJDb2x1bW4gPyAiV2l0aCBJRDogIiArIGdyaWREYXRhW2luZGVudGlmZXJDb2x1bW5dIDogIldpdGggSW5kZXg6ICIgKyByb3cgKyAxfSAtICR7ZW1wdHlDb2wgPT0gbnVsbCA/IHZvaWQgMCA6IGVtcHR5Q29sLnRvU3RyaW5nKCl9IGNhbm5vdCBiZSBlbXB0eSBhdCBhbGxgOwogICAgICAgIHRtcEluc2VydFRvTWVzc2FnZU1hcChyb3cgKyAiZWMiLCB7CiAgICAgICAgICBtc2csCiAgICAgICAgICB0eXBlOiBNZXNzYWdlQmFyVHlwZS5lcnJvcgogICAgICAgIH0pOwogICAgICAgIGxvY2FsRXJyb3IgPSB0cnVlOwogICAgICB9IGVsc2UgaWYgKGVtcHR5Q29sLmxlbmd0aCA9PSAxKSB7CiAgICAgICAgdmFyIG1zZyA9IGBSb3cgJHtpbmRlbnRpZmVyQ29sdW1uID8gIldpdGggSUQ6ICIgKyBncmlkRGF0YVtpbmRlbnRpZmVyQ29sdW1uXSA6ICJXaXRoIEluZGV4OiAiICsgcm93ICsgMX0gLSAke2VtcHR5Q29sID09IG51bGwgPyB2b2lkIDAgOiBlbXB0eUNvbC50b1N0cmluZygpfSBjYW5ub3QgYmUgZW1wdHlgOwogICAgICAgIHRtcEluc2VydFRvTWVzc2FnZU1hcChyb3cgKyAiZWMiLCB7CiAgICAgICAgICBtc2csCiAgICAgICAgICB0eXBlOiBNZXNzYWdlQmFyVHlwZS5lcnJvcgogICAgICAgIH0pOwogICAgICAgIGxvY2FsRXJyb3IgPSB0cnVlOwogICAgICB9CiAgICB9CiAgICBzZWxmLnBvc3RNZXNzYWdlKHsgaXNFcnJvcjogbG9jYWxFcnJvciwgbWVzc2FnZXM6IG1zZ01hcCB9KTsKICAgIHNlbGYuY2xvc2UoKTsKICB9Owp9KSgpOwovLyMgc291cmNlTWFwcGluZ1VSTD1ydW5HcmlkVmFsaWRhdGlvbnMud29ya2VyLTQzZjJlMGFlLmpzLm1hcAo=";
const blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper() {
  let objURL;
  try {
    objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
    if (!objURL)
      throw "";
    return new Worker(objURL);
  } catch (e) {
    return new Worker("data:application/javascript;base64," + encodedJs);
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
var packagesCache = {};
var _win = void 0;
try {
  _win = window;
} catch (e) {
}
function setVersion(packageName, packageVersion) {
  if (typeof _win !== "undefined") {
    var packages = _win.__packages__ = _win.__packages__ || {};
    if (!packages[packageName] || !packagesCache[packageName]) {
      packagesCache[packageName] = packageVersion;
      var versions = packages[packageName] = packages[packageName] || [];
      versions.push(packageVersion);
    }
  }
}
setVersion("@fluentui/set-version", "6.0.0");
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
function __rest$1(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
var InjectionMode = {
  /**
   * Avoids style injection, use getRules() to read the styles.
   */
  none: 0,
  /**
   * Inserts rules using the insertRule api.
   */
  insertNode: 1,
  /**
   * Appends rules using appendChild.
   */
  appendChild: 2
};
var STYLESHEET_SETTING = "__stylesheet__";
var REUSE_STYLE_NODE = typeof navigator !== "undefined" && /rv:11.0/.test(navigator.userAgent);
var _global$1 = {};
try {
  _global$1 = window || {};
} catch (_a2) {
}
var _stylesheet;
var Stylesheet = (
  /** @class */
  function() {
    function Stylesheet2(config, serializedStylesheet) {
      var _a2, _b2, _c2, _d2, _e2, _f;
      this._rules = [];
      this._preservedRules = [];
      this._counter = 0;
      this._keyToClassName = {};
      this._onInsertRuleCallbacks = [];
      this._onResetCallbacks = [];
      this._classNameToArgs = {};
      this._config = __assign$1({
        // If there is no document we won't have an element to inject into.
        injectionMode: typeof document === "undefined" ? InjectionMode.none : InjectionMode.insertNode,
        defaultPrefix: "css",
        namespace: void 0,
        cspSettings: void 0
      }, config);
      this._classNameToArgs = (_a2 = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.classNameToArgs) !== null && _a2 !== void 0 ? _a2 : this._classNameToArgs;
      this._counter = (_b2 = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.counter) !== null && _b2 !== void 0 ? _b2 : this._counter;
      this._keyToClassName = (_d2 = (_c2 = this._config.classNameCache) !== null && _c2 !== void 0 ? _c2 : serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.keyToClassName) !== null && _d2 !== void 0 ? _d2 : this._keyToClassName;
      this._preservedRules = (_e2 = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.preservedRules) !== null && _e2 !== void 0 ? _e2 : this._preservedRules;
      this._rules = (_f = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.rules) !== null && _f !== void 0 ? _f : this._rules;
    }
    Stylesheet2.getInstance = function() {
      _stylesheet = _global$1[STYLESHEET_SETTING];
      if (!_stylesheet || _stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document) {
        var fabricConfig = (_global$1 === null || _global$1 === void 0 ? void 0 : _global$1.FabricConfig) || {};
        var stylesheet2 = new Stylesheet2(fabricConfig.mergeStyles, fabricConfig.serializedStylesheet);
        _stylesheet = stylesheet2;
        _global$1[STYLESHEET_SETTING] = stylesheet2;
      }
      return _stylesheet;
    };
    Stylesheet2.prototype.serialize = function() {
      return JSON.stringify({
        classNameToArgs: this._classNameToArgs,
        counter: this._counter,
        keyToClassName: this._keyToClassName,
        preservedRules: this._preservedRules,
        rules: this._rules
      });
    };
    Stylesheet2.prototype.setConfig = function(config) {
      this._config = __assign$1(__assign$1({}, this._config), config);
    };
    Stylesheet2.prototype.onReset = function(callback) {
      var _this = this;
      this._onResetCallbacks.push(callback);
      return function() {
        _this._onResetCallbacks = _this._onResetCallbacks.filter(function(cb) {
          return cb !== callback;
        });
      };
    };
    Stylesheet2.prototype.onInsertRule = function(callback) {
      var _this = this;
      this._onInsertRuleCallbacks.push(callback);
      return function() {
        _this._onInsertRuleCallbacks = _this._onInsertRuleCallbacks.filter(function(cb) {
          return cb !== callback;
        });
      };
    };
    Stylesheet2.prototype.getClassName = function(displayName) {
      var namespace = this._config.namespace;
      var prefix2 = displayName || this._config.defaultPrefix;
      return (namespace ? namespace + "-" : "") + prefix2 + "-" + this._counter++;
    };
    Stylesheet2.prototype.cacheClassName = function(className, key, args, rules2) {
      this._keyToClassName[key] = className;
      this._classNameToArgs[className] = {
        args,
        rules: rules2
      };
    };
    Stylesheet2.prototype.classNameFromKey = function(key) {
      return this._keyToClassName[key];
    };
    Stylesheet2.prototype.getClassNameCache = function() {
      return this._keyToClassName;
    };
    Stylesheet2.prototype.argsFromClassName = function(className) {
      var entry = this._classNameToArgs[className];
      return entry && entry.args;
    };
    Stylesheet2.prototype.insertedRulesFromClassName = function(className) {
      var entry = this._classNameToArgs[className];
      return entry && entry.rules;
    };
    Stylesheet2.prototype.insertRule = function(rule, preserve) {
      var injectionMode = this._config.injectionMode;
      var element = injectionMode !== InjectionMode.none ? this._getStyleElement() : void 0;
      if (preserve) {
        this._preservedRules.push(rule);
      }
      if (element) {
        switch (injectionMode) {
          case InjectionMode.insertNode:
            var sheet = element.sheet;
            try {
              sheet.insertRule(rule, sheet.cssRules.length);
            } catch (e) {
            }
            break;
          case InjectionMode.appendChild:
            element.appendChild(document.createTextNode(rule));
            break;
        }
      } else {
        this._rules.push(rule);
      }
      if (this._config.onInsertRule) {
        this._config.onInsertRule(rule);
      }
      this._onInsertRuleCallbacks.forEach(function(callback) {
        return callback();
      });
    };
    Stylesheet2.prototype.getRules = function(includePreservedRules) {
      return (includePreservedRules ? this._preservedRules.join("") : "") + this._rules.join("");
    };
    Stylesheet2.prototype.reset = function() {
      this._rules = [];
      this._counter = 0;
      this._classNameToArgs = {};
      this._keyToClassName = {};
      this._onResetCallbacks.forEach(function(callback) {
        return callback();
      });
    };
    Stylesheet2.prototype.resetKeys = function() {
      this._keyToClassName = {};
    };
    Stylesheet2.prototype._getStyleElement = function() {
      var _this = this;
      if (!this._styleElement && typeof document !== "undefined") {
        this._styleElement = this._createStyleElement();
        if (!REUSE_STYLE_NODE) {
          window.requestAnimationFrame(function() {
            _this._styleElement = void 0;
          });
        }
      }
      return this._styleElement;
    };
    Stylesheet2.prototype._createStyleElement = function() {
      var head = document.head;
      var styleElement = document.createElement("style");
      var nodeToInsertBefore = null;
      styleElement.setAttribute("data-merge-styles", "true");
      var cspSettings = this._config.cspSettings;
      if (cspSettings) {
        if (cspSettings.nonce) {
          styleElement.setAttribute("nonce", cspSettings.nonce);
        }
      }
      if (this._lastStyleElement) {
        nodeToInsertBefore = this._lastStyleElement.nextElementSibling;
      } else {
        var placeholderStyleTag = this._findPlaceholderStyleTag();
        if (placeholderStyleTag) {
          nodeToInsertBefore = placeholderStyleTag.nextElementSibling;
        } else {
          nodeToInsertBefore = head.childNodes[0];
        }
      }
      head.insertBefore(styleElement, head.contains(nodeToInsertBefore) ? nodeToInsertBefore : null);
      this._lastStyleElement = styleElement;
      return styleElement;
    };
    Stylesheet2.prototype._findPlaceholderStyleTag = function() {
      var head = document.head;
      if (head) {
        return head.querySelector("style[data-merge-styles]");
      }
      return null;
    };
    return Stylesheet2;
  }()
);
function extractStyleParts() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var classes = [];
  var objects = [];
  var stylesheet2 = Stylesheet.getInstance();
  function _processArgs(argsList) {
    for (var _i2 = 0, argsList_1 = argsList; _i2 < argsList_1.length; _i2++) {
      var arg = argsList_1[_i2];
      if (arg) {
        if (typeof arg === "string") {
          if (arg.indexOf(" ") >= 0) {
            _processArgs(arg.split(" "));
          } else {
            var translatedArgs = stylesheet2.argsFromClassName(arg);
            if (translatedArgs) {
              _processArgs(translatedArgs);
            } else {
              if (classes.indexOf(arg) === -1) {
                classes.push(arg);
              }
            }
          }
        } else if (Array.isArray(arg)) {
          _processArgs(arg);
        } else if (typeof arg === "object") {
          objects.push(arg);
        }
      }
    }
  }
  _processArgs(args);
  return {
    classes,
    objects
  };
}
function setRTL$1(isRTL) {
  if (_rtl !== isRTL) {
    _rtl = isRTL;
  }
}
function getRTL$1() {
  if (_rtl === void 0) {
    _rtl = typeof document !== "undefined" && !!document.documentElement && document.documentElement.getAttribute("dir") === "rtl";
  }
  return _rtl;
}
var _rtl;
_rtl = getRTL$1();
function getStyleOptions() {
  return {
    rtl: getRTL$1()
  };
}
var rules = {};
function kebabRules(rulePairs, index2) {
  var rule = rulePairs[index2];
  if (rule.charAt(0) !== "-") {
    rulePairs[index2] = rules[rule] = rules[rule] || rule.replace(/([A-Z])/g, "-$1").toLowerCase();
  }
}
var _vendorSettings;
function getVendorSettings() {
  var _a2;
  if (!_vendorSettings) {
    var doc = typeof document !== "undefined" ? document : void 0;
    var nav = typeof navigator !== "undefined" ? navigator : void 0;
    var userAgent = (_a2 = nav === null || nav === void 0 ? void 0 : nav.userAgent) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase();
    if (!doc) {
      _vendorSettings = {
        isWebkit: true,
        isMoz: true,
        isOpera: true,
        isMs: true
      };
    } else {
      _vendorSettings = {
        isWebkit: !!(doc && "WebkitAppearance" in doc.documentElement.style),
        isMoz: !!(userAgent && userAgent.indexOf("firefox") > -1),
        isOpera: !!(userAgent && userAgent.indexOf("opera") > -1),
        isMs: !!(nav && (/rv:11.0/i.test(nav.userAgent) || /Edge\/\d./i.test(navigator.userAgent)))
      };
    }
  }
  return _vendorSettings;
}
var autoPrefixNames = {
  "user-select": 1
};
function prefixRules(rulePairs, index2) {
  var vendorSettings = getVendorSettings();
  var name = rulePairs[index2];
  if (autoPrefixNames[name]) {
    var value = rulePairs[index2 + 1];
    if (autoPrefixNames[name]) {
      if (vendorSettings.isWebkit) {
        rulePairs.push("-webkit-" + name, value);
      }
      if (vendorSettings.isMoz) {
        rulePairs.push("-moz-" + name, value);
      }
      if (vendorSettings.isMs) {
        rulePairs.push("-ms-" + name, value);
      }
      if (vendorSettings.isOpera) {
        rulePairs.push("-o-" + name, value);
      }
    }
  }
}
var NON_PIXEL_NUMBER_PROPS = [
  "column-count",
  "font-weight",
  "flex",
  "flex-grow",
  "flex-shrink",
  "fill-opacity",
  "opacity",
  "order",
  "z-index",
  "zoom"
];
function provideUnits(rulePairs, index2) {
  var name = rulePairs[index2];
  var value = rulePairs[index2 + 1];
  if (typeof value === "number") {
    var isNonPixelProp = NON_PIXEL_NUMBER_PROPS.indexOf(name) > -1;
    var isVariableOrPrefixed = name.indexOf("--") > -1;
    var unit = isNonPixelProp || isVariableOrPrefixed ? "" : "px";
    rulePairs[index2 + 1] = "" + value + unit;
  }
}
var _a$8;
var LEFT = "left";
var RIGHT = "right";
var NO_FLIP = "@noflip";
var NAME_REPLACEMENTS = (_a$8 = {}, _a$8[LEFT] = RIGHT, _a$8[RIGHT] = LEFT, _a$8);
var VALUE_REPLACEMENTS = {
  "w-resize": "e-resize",
  "sw-resize": "se-resize",
  "nw-resize": "ne-resize"
};
function rtlifyRules(options2, rulePairs, index2) {
  if (options2.rtl) {
    var name_1 = rulePairs[index2];
    if (!name_1) {
      return;
    }
    var value = rulePairs[index2 + 1];
    if (typeof value === "string" && value.indexOf(NO_FLIP) >= 0) {
      rulePairs[index2 + 1] = value.replace(/\s*(?:\/\*\s*)?\@noflip\b(?:\s*\*\/)?\s*?/g, "");
    } else if (name_1.indexOf(LEFT) >= 0) {
      rulePairs[index2] = name_1.replace(LEFT, RIGHT);
    } else if (name_1.indexOf(RIGHT) >= 0) {
      rulePairs[index2] = name_1.replace(RIGHT, LEFT);
    } else if (String(value).indexOf(LEFT) >= 0) {
      rulePairs[index2 + 1] = value.replace(LEFT, RIGHT);
    } else if (String(value).indexOf(RIGHT) >= 0) {
      rulePairs[index2 + 1] = value.replace(RIGHT, LEFT);
    } else if (NAME_REPLACEMENTS[name_1]) {
      rulePairs[index2] = NAME_REPLACEMENTS[name_1];
    } else if (VALUE_REPLACEMENTS[value]) {
      rulePairs[index2 + 1] = VALUE_REPLACEMENTS[value];
    } else {
      switch (name_1) {
        case "margin":
        case "padding":
          rulePairs[index2 + 1] = flipQuad(value);
          break;
        case "box-shadow":
          rulePairs[index2 + 1] = negateNum(value, 0);
          break;
      }
    }
  }
}
function negateNum(value, partIndex) {
  var parts = value.split(" ");
  var numberVal = parseInt(parts[partIndex], 10);
  parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));
  return parts.join(" ");
}
function flipQuad(value) {
  if (typeof value === "string") {
    var parts = value.split(" ");
    if (parts.length === 4) {
      return parts[0] + " " + parts[3] + " " + parts[2] + " " + parts[1];
    }
  }
  return value;
}
function tokenizeWithParentheses(value) {
  var parts = [];
  var partStart = 0;
  var parens = 0;
  for (var i = 0; i < value.length; i++) {
    switch (value[i]) {
      case "(":
        parens++;
        break;
      case ")":
        if (parens) {
          parens--;
        }
        break;
      case "	":
      case " ":
        if (!parens) {
          if (i > partStart) {
            parts.push(value.substring(partStart, i));
          }
          partStart = i + 1;
        }
        break;
    }
  }
  if (partStart < value.length) {
    parts.push(value.substring(partStart));
  }
  return parts;
}
var DISPLAY_NAME = "displayName";
function getDisplayName(rules2) {
  var rootStyle = rules2 && rules2["&"];
  return rootStyle ? rootStyle.displayName : void 0;
}
var globalSelectorRegExp = /\:global\((.+?)\)/g;
function expandCommaSeparatedGlobals(selectorWithGlobals) {
  if (!globalSelectorRegExp.test(selectorWithGlobals)) {
    return selectorWithGlobals;
  }
  var replacementInfo = [];
  var findGlobal = /\:global\((.+?)\)/g;
  var match2 = null;
  while (match2 = findGlobal.exec(selectorWithGlobals)) {
    if (match2[1].indexOf(",") > -1) {
      replacementInfo.push([
        match2.index,
        match2.index + match2[0].length,
        // Wrap each of the found selectors in :global()
        match2[1].split(",").map(function(v) {
          return ":global(" + v.trim() + ")";
        }).join(", ")
      ]);
    }
  }
  return replacementInfo.reverse().reduce(function(selector, _a2) {
    var matchIndex = _a2[0], matchEndIndex = _a2[1], replacement = _a2[2];
    var prefix2 = selector.slice(0, matchIndex);
    var suffix = selector.slice(matchEndIndex);
    return prefix2 + replacement + suffix;
  }, selectorWithGlobals);
}
function expandSelector(newSelector, currentSelector) {
  if (newSelector.indexOf(":global(") >= 0) {
    return newSelector.replace(globalSelectorRegExp, "$1");
  } else if (newSelector.indexOf(":") === 0) {
    return currentSelector + newSelector;
  } else if (newSelector.indexOf("&") < 0) {
    return currentSelector + " " + newSelector;
  }
  return newSelector;
}
function extractSelector(currentSelector, rules2, selector, value) {
  if (rules2 === void 0) {
    rules2 = { __order: [] };
  }
  if (selector.indexOf("@") === 0) {
    selector = selector + "{" + currentSelector;
    extractRules([value], rules2, selector);
  } else if (selector.indexOf(",") > -1) {
    expandCommaSeparatedGlobals(selector).split(",").map(function(s) {
      return s.trim();
    }).forEach(function(separatedSelector) {
      return extractRules([value], rules2, expandSelector(separatedSelector, currentSelector));
    });
  } else {
    extractRules([value], rules2, expandSelector(selector, currentSelector));
  }
}
function extractRules(args, rules2, currentSelector) {
  if (rules2 === void 0) {
    rules2 = { __order: [] };
  }
  if (currentSelector === void 0) {
    currentSelector = "&";
  }
  var stylesheet2 = Stylesheet.getInstance();
  var currentRules = rules2[currentSelector];
  if (!currentRules) {
    currentRules = {};
    rules2[currentSelector] = currentRules;
    rules2.__order.push(currentSelector);
  }
  for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
    var arg = args_1[_i];
    if (typeof arg === "string") {
      var expandedRules = stylesheet2.argsFromClassName(arg);
      if (expandedRules) {
        extractRules(expandedRules, rules2, currentSelector);
      }
    } else if (Array.isArray(arg)) {
      extractRules(arg, rules2, currentSelector);
    } else {
      for (var prop in arg) {
        if (arg.hasOwnProperty(prop)) {
          var propValue = arg[prop];
          if (prop === "selectors") {
            var selectors = arg.selectors;
            for (var newSelector in selectors) {
              if (selectors.hasOwnProperty(newSelector)) {
                extractSelector(currentSelector, rules2, newSelector, selectors[newSelector]);
              }
            }
          } else if (typeof propValue === "object") {
            if (propValue !== null) {
              extractSelector(currentSelector, rules2, prop, propValue);
            }
          } else {
            if (propValue !== void 0) {
              if (prop === "margin" || prop === "padding") {
                expandQuads(currentRules, prop, propValue);
              } else {
                currentRules[prop] = propValue;
              }
            }
          }
        }
      }
    }
  }
  return rules2;
}
function expandQuads(currentRules, name, value) {
  var parts = typeof value === "string" ? tokenizeWithParentheses(value) : [value];
  if (parts.length === 0) {
    parts.push(value);
  }
  if (parts[parts.length - 1] === "!important") {
    parts = parts.slice(0, -1).map(function(p) {
      return p + " !important";
    });
  }
  currentRules[name + "Top"] = parts[0];
  currentRules[name + "Right"] = parts[1] || parts[0];
  currentRules[name + "Bottom"] = parts[2] || parts[0];
  currentRules[name + "Left"] = parts[3] || parts[1] || parts[0];
}
function getKeyForRules(options2, rules2) {
  var serialized = [options2.rtl ? "rtl" : "ltr"];
  var hasProps = false;
  for (var _i = 0, _a2 = rules2.__order; _i < _a2.length; _i++) {
    var selector = _a2[_i];
    serialized.push(selector);
    var rulesForSelector = rules2[selector];
    for (var propName in rulesForSelector) {
      if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== void 0) {
        hasProps = true;
        serialized.push(propName, rulesForSelector[propName]);
      }
    }
  }
  return hasProps ? serialized.join("") : void 0;
}
function repeatString(target, count) {
  if (count <= 0) {
    return "";
  }
  if (count === 1) {
    return target;
  }
  return target + repeatString(target, count - 1);
}
function serializeRuleEntries(options2, ruleEntries) {
  if (!ruleEntries) {
    return "";
  }
  var allEntries = [];
  for (var entry in ruleEntries) {
    if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== void 0) {
      allEntries.push(entry, ruleEntries[entry]);
    }
  }
  for (var i = 0; i < allEntries.length; i += 2) {
    kebabRules(allEntries, i);
    provideUnits(allEntries, i);
    rtlifyRules(options2, allEntries, i);
    prefixRules(allEntries, i);
  }
  for (var i = 1; i < allEntries.length; i += 4) {
    allEntries.splice(i, 1, ":", allEntries[i], ";");
  }
  return allEntries.join("");
}
function styleToRegistration(options2) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var rules2 = extractRules(args);
  var key = getKeyForRules(options2, rules2);
  if (key) {
    var stylesheet2 = Stylesheet.getInstance();
    var registration = {
      className: stylesheet2.classNameFromKey(key),
      key,
      args
    };
    if (!registration.className) {
      registration.className = stylesheet2.getClassName(getDisplayName(rules2));
      var rulesToInsert = [];
      for (var _a2 = 0, _b2 = rules2.__order; _a2 < _b2.length; _a2++) {
        var selector = _b2[_a2];
        rulesToInsert.push(selector, serializeRuleEntries(options2, rules2[selector]));
      }
      registration.rulesToInsert = rulesToInsert;
    }
    return registration;
  }
  return void 0;
}
function applyRegistration(registration, specificityMultiplier) {
  if (specificityMultiplier === void 0) {
    specificityMultiplier = 1;
  }
  var stylesheet2 = Stylesheet.getInstance();
  var className = registration.className, key = registration.key, args = registration.args, rulesToInsert = registration.rulesToInsert;
  if (rulesToInsert) {
    for (var i = 0; i < rulesToInsert.length; i += 2) {
      var rules2 = rulesToInsert[i + 1];
      if (rules2) {
        var selector = rulesToInsert[i];
        selector = selector.replace(/&/g, repeatString("." + registration.className, specificityMultiplier));
        var processedRule = selector + "{" + rules2 + "}" + (selector.indexOf("@") === 0 ? "}" : "");
        stylesheet2.insertRule(processedRule);
      }
    }
    stylesheet2.cacheClassName(className, key, args, rulesToInsert);
  }
}
function styleToClassName(options2) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var registration = styleToRegistration.apply(void 0, __spreadArray([options2], args));
  if (registration) {
    applyRegistration(registration, options2.specificityMultiplier);
    return registration.className;
  }
  return "";
}
function mergeStyles() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return mergeCss(args, getStyleOptions());
}
function mergeCss(args, options2) {
  var styleArgs = args instanceof Array ? args : [args];
  var _a2 = extractStyleParts(styleArgs), classes = _a2.classes, objects = _a2.objects;
  if (objects.length) {
    classes.push(styleToClassName(options2 || {}, objects));
  }
  return classes.join(" ");
}
function concatStyleSets() {
  var styleSets = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    styleSets[_i] = arguments[_i];
  }
  if (styleSets && styleSets.length === 1 && styleSets[0] && !styleSets[0].subComponentStyles) {
    return styleSets[0];
  }
  var mergedSet = {};
  var workingSubcomponentStyles = {};
  for (var _a2 = 0, styleSets_1 = styleSets; _a2 < styleSets_1.length; _a2++) {
    var currentSet = styleSets_1[_a2];
    if (currentSet) {
      for (var prop in currentSet) {
        if (currentSet.hasOwnProperty(prop)) {
          if (prop === "subComponentStyles" && currentSet.subComponentStyles !== void 0) {
            var currentComponentStyles = currentSet.subComponentStyles;
            for (var subCompProp in currentComponentStyles) {
              if (currentComponentStyles.hasOwnProperty(subCompProp)) {
                if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {
                  workingSubcomponentStyles[subCompProp].push(currentComponentStyles[subCompProp]);
                } else {
                  workingSubcomponentStyles[subCompProp] = [currentComponentStyles[subCompProp]];
                }
              }
            }
            continue;
          }
          var mergedValue = mergedSet[prop];
          var currentValue = currentSet[prop];
          if (mergedValue === void 0) {
            mergedSet[prop] = currentValue;
          } else {
            mergedSet[prop] = __spreadArray(__spreadArray([], Array.isArray(mergedValue) ? mergedValue : [mergedValue]), Array.isArray(currentValue) ? currentValue : [currentValue]);
          }
        }
      }
    }
  }
  if (Object.keys(workingSubcomponentStyles).length > 0) {
    mergedSet.subComponentStyles = {};
    var mergedSubStyles = mergedSet.subComponentStyles;
    var _loop_1 = function(subCompProp2) {
      if (workingSubcomponentStyles.hasOwnProperty(subCompProp2)) {
        var workingSet_1 = workingSubcomponentStyles[subCompProp2];
        mergedSubStyles[subCompProp2] = function(styleProps) {
          return concatStyleSets.apply(void 0, workingSet_1.map(function(styleFunctionOrObject) {
            return typeof styleFunctionOrObject === "function" ? styleFunctionOrObject(styleProps) : styleFunctionOrObject;
          }));
        };
      }
    };
    for (var subCompProp in workingSubcomponentStyles) {
      _loop_1(subCompProp);
    }
  }
  return mergedSet;
}
function mergeStyleSets() {
  var styleSets = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    styleSets[_i] = arguments[_i];
  }
  return mergeCssSets(styleSets, getStyleOptions());
}
function mergeCssSets(styleSets, options2) {
  var classNameSet = { subComponentStyles: {} };
  var styleSet = styleSets[0];
  if (!styleSet && styleSets.length <= 1) {
    return { subComponentStyles: {} };
  }
  var concatenatedStyleSet = concatStyleSets.apply(void 0, styleSets);
  var registrations = [];
  for (var styleSetArea in concatenatedStyleSet) {
    if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {
      if (styleSetArea === "subComponentStyles") {
        classNameSet.subComponentStyles = concatenatedStyleSet.subComponentStyles || {};
        continue;
      }
      var styles2 = concatenatedStyleSet[styleSetArea];
      var _a2 = extractStyleParts(styles2), classes = _a2.classes, objects = _a2.objects;
      if (objects === null || objects === void 0 ? void 0 : objects.length) {
        var registration = styleToRegistration(options2 || {}, { displayName: styleSetArea }, objects);
        if (registration) {
          registrations.push(registration);
          classNameSet[styleSetArea] = classes.concat([registration.className]).join(" ");
        }
      } else {
        classNameSet[styleSetArea] = classes.join(" ");
      }
    }
  }
  for (var _i = 0, registrations_1 = registrations; _i < registrations_1.length; _i++) {
    var registration = registrations_1[_i];
    if (registration) {
      applyRegistration(registration, options2 === null || options2 === void 0 ? void 0 : options2.specificityMultiplier);
    }
  }
  return classNameSet;
}
function concatStyleSetsWithProps(styleProps) {
  var allStyles = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    allStyles[_i - 1] = arguments[_i];
  }
  var result = [];
  for (var _a2 = 0, allStyles_1 = allStyles; _a2 < allStyles_1.length; _a2++) {
    var styles2 = allStyles_1[_a2];
    if (styles2) {
      result.push(typeof styles2 === "function" ? styles2(styleProps) : styles2);
    }
  }
  if (result.length === 1) {
    return result[0];
  } else if (result.length) {
    return concatStyleSets.apply(void 0, result);
  }
  return {};
}
function fontFace(font) {
  var stylesheet2 = Stylesheet.getInstance();
  var rule = serializeRuleEntries(getStyleOptions(), font);
  var className = stylesheet2.classNameFromKey(rule);
  if (className) {
    return;
  }
  var name = stylesheet2.getClassName();
  stylesheet2.insertRule("@font-face{" + rule + "}", true);
  stylesheet2.cacheClassName(name, rule, [], ["font-face", rule]);
}
function keyframes$1(timeline) {
  var stylesheet2 = Stylesheet.getInstance();
  var rulesArray = [];
  for (var prop in timeline) {
    if (timeline.hasOwnProperty(prop)) {
      rulesArray.push(prop, "{", serializeRuleEntries(getStyleOptions(), timeline[prop]), "}");
    }
  }
  var rules2 = rulesArray.join("");
  var className = stylesheet2.classNameFromKey(rules2);
  if (className) {
    return className;
  }
  var name = stylesheet2.getClassName();
  stylesheet2.insertRule("@keyframes " + name + "{" + rules2 + "}", true);
  stylesheet2.cacheClassName(name, rules2, [], ["keyframes", rules2]);
  return name;
}
function buildClassMap(styles2) {
  var classes = {};
  var _loop_1 = function(styleName2) {
    if (styles2.hasOwnProperty(styleName2)) {
      var className_1;
      Object.defineProperty(classes, styleName2, {
        get: function() {
          if (className_1 === void 0) {
            className_1 = mergeStyles(styles2[styleName2]).toString();
          }
          return className_1;
        },
        enumerable: true,
        configurable: true
      });
    }
  };
  for (var styleName in styles2) {
    _loop_1(styleName);
  }
  return classes;
}
function canUseDOM$1() {
  return typeof window !== "undefined" && !!(window.document && // eslint-disable-next-line deprecation/deprecation
  window.document.createElement);
}
var _window = void 0;
try {
  _window = window;
} catch (e) {
}
function getWindow$1(rootElement) {
  if (!canUseDOM$1() || typeof _window === "undefined") {
    return void 0;
  } else {
    var el = rootElement;
    return el && el.ownerDocument && el.ownerDocument.defaultView ? el.ownerDocument.defaultView : _window;
  }
}
var Async = (
  /** @class */
  function() {
    function Async2(parent, onError) {
      this._timeoutIds = null;
      this._immediateIds = null;
      this._intervalIds = null;
      this._animationFrameIds = null;
      this._isDisposed = false;
      this._parent = parent || null;
      this._onErrorHandler = onError;
      this._noop = function() {
      };
    }
    Async2.prototype.dispose = function() {
      var id;
      this._isDisposed = true;
      this._parent = null;
      if (this._timeoutIds) {
        for (id in this._timeoutIds) {
          if (this._timeoutIds.hasOwnProperty(id)) {
            this.clearTimeout(parseInt(id, 10));
          }
        }
        this._timeoutIds = null;
      }
      if (this._immediateIds) {
        for (id in this._immediateIds) {
          if (this._immediateIds.hasOwnProperty(id)) {
            this.clearImmediate(parseInt(id, 10));
          }
        }
        this._immediateIds = null;
      }
      if (this._intervalIds) {
        for (id in this._intervalIds) {
          if (this._intervalIds.hasOwnProperty(id)) {
            this.clearInterval(parseInt(id, 10));
          }
        }
        this._intervalIds = null;
      }
      if (this._animationFrameIds) {
        for (id in this._animationFrameIds) {
          if (this._animationFrameIds.hasOwnProperty(id)) {
            this.cancelAnimationFrame(parseInt(id, 10));
          }
        }
        this._animationFrameIds = null;
      }
    };
    Async2.prototype.setTimeout = function(callback, duration) {
      var _this = this;
      var timeoutId = 0;
      if (!this._isDisposed) {
        if (!this._timeoutIds) {
          this._timeoutIds = {};
        }
        timeoutId = setTimeout(function() {
          try {
            if (_this._timeoutIds) {
              delete _this._timeoutIds[timeoutId];
            }
            callback.apply(_this._parent);
          } catch (e) {
            _this._logError(e);
          }
        }, duration);
        this._timeoutIds[timeoutId] = true;
      }
      return timeoutId;
    };
    Async2.prototype.clearTimeout = function(id) {
      if (this._timeoutIds && this._timeoutIds[id]) {
        clearTimeout(id);
        delete this._timeoutIds[id];
      }
    };
    Async2.prototype.setImmediate = function(callback, targetElement) {
      var _this = this;
      var immediateId = 0;
      var win2 = getWindow$1(targetElement);
      if (!this._isDisposed) {
        if (!this._immediateIds) {
          this._immediateIds = {};
        }
        var setImmediateCallback = function() {
          try {
            if (_this._immediateIds) {
              delete _this._immediateIds[immediateId];
            }
            callback.apply(_this._parent);
          } catch (e) {
            _this._logError(e);
          }
        };
        immediateId = win2.setTimeout(setImmediateCallback, 0);
        this._immediateIds[immediateId] = true;
      }
      return immediateId;
    };
    Async2.prototype.clearImmediate = function(id, targetElement) {
      var win2 = getWindow$1(targetElement);
      if (this._immediateIds && this._immediateIds[id]) {
        win2.clearTimeout(id);
        delete this._immediateIds[id];
      }
    };
    Async2.prototype.setInterval = function(callback, duration) {
      var _this = this;
      var intervalId = 0;
      if (!this._isDisposed) {
        if (!this._intervalIds) {
          this._intervalIds = {};
        }
        intervalId = setInterval(function() {
          try {
            callback.apply(_this._parent);
          } catch (e) {
            _this._logError(e);
          }
        }, duration);
        this._intervalIds[intervalId] = true;
      }
      return intervalId;
    };
    Async2.prototype.clearInterval = function(id) {
      if (this._intervalIds && this._intervalIds[id]) {
        clearInterval(id);
        delete this._intervalIds[id];
      }
    };
    Async2.prototype.throttle = function(func, wait, options2) {
      var _this = this;
      if (this._isDisposed) {
        return this._noop;
      }
      var waitMS = wait || 0;
      var leading = true;
      var trailing = true;
      var lastExecuteTime = 0;
      var lastResult;
      var lastArgs;
      var timeoutId = null;
      if (options2 && typeof options2.leading === "boolean") {
        leading = options2.leading;
      }
      if (options2 && typeof options2.trailing === "boolean") {
        trailing = options2.trailing;
      }
      var callback = function(userCall) {
        var now2 = Date.now();
        var delta = now2 - lastExecuteTime;
        var waitLength = leading ? waitMS - delta : waitMS;
        if (delta >= waitMS && (!userCall || leading)) {
          lastExecuteTime = now2;
          if (timeoutId) {
            _this.clearTimeout(timeoutId);
            timeoutId = null;
          }
          lastResult = func.apply(_this._parent, lastArgs);
        } else if (timeoutId === null && trailing) {
          timeoutId = _this.setTimeout(callback, waitLength);
        }
        return lastResult;
      };
      var resultFunction = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        lastArgs = args;
        return callback(true);
      };
      return resultFunction;
    };
    Async2.prototype.debounce = function(func, wait, options2) {
      var _this = this;
      if (this._isDisposed) {
        var noOpFunction = function() {
        };
        noOpFunction.cancel = function() {
          return;
        };
        noOpFunction.flush = function() {
          return null;
        };
        noOpFunction.pending = function() {
          return false;
        };
        return noOpFunction;
      }
      var waitMS = wait || 0;
      var leading = false;
      var trailing = true;
      var maxWait = null;
      var lastCallTime = 0;
      var lastExecuteTime = Date.now();
      var lastResult;
      var lastArgs;
      var timeoutId = null;
      if (options2 && typeof options2.leading === "boolean") {
        leading = options2.leading;
      }
      if (options2 && typeof options2.trailing === "boolean") {
        trailing = options2.trailing;
      }
      if (options2 && typeof options2.maxWait === "number" && !isNaN(options2.maxWait)) {
        maxWait = options2.maxWait;
      }
      var markExecuted = function(time) {
        if (timeoutId) {
          _this.clearTimeout(timeoutId);
          timeoutId = null;
        }
        lastExecuteTime = time;
      };
      var invokeFunction = function(time) {
        markExecuted(time);
        lastResult = func.apply(_this._parent, lastArgs);
      };
      var callback = function(userCall) {
        var now2 = Date.now();
        var executeImmediately = false;
        if (userCall) {
          if (leading && now2 - lastCallTime >= waitMS) {
            executeImmediately = true;
          }
          lastCallTime = now2;
        }
        var delta = now2 - lastCallTime;
        var waitLength = waitMS - delta;
        var maxWaitDelta = now2 - lastExecuteTime;
        var maxWaitExpired = false;
        if (maxWait !== null) {
          if (maxWaitDelta >= maxWait && timeoutId) {
            maxWaitExpired = true;
          } else {
            waitLength = Math.min(waitLength, maxWait - maxWaitDelta);
          }
        }
        if (delta >= waitMS || maxWaitExpired || executeImmediately) {
          invokeFunction(now2);
        } else if ((timeoutId === null || !userCall) && trailing) {
          timeoutId = _this.setTimeout(callback, waitLength);
        }
        return lastResult;
      };
      var pending = function() {
        return !!timeoutId;
      };
      var cancel = function() {
        if (pending()) {
          markExecuted(Date.now());
        }
      };
      var flush2 = function() {
        if (pending()) {
          invokeFunction(Date.now());
        }
        return lastResult;
      };
      var resultFunction = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        lastArgs = args;
        return callback(true);
      };
      resultFunction.cancel = cancel;
      resultFunction.flush = flush2;
      resultFunction.pending = pending;
      return resultFunction;
    };
    Async2.prototype.requestAnimationFrame = function(callback, targetElement) {
      var _this = this;
      var animationFrameId = 0;
      var win2 = getWindow$1(targetElement);
      if (!this._isDisposed) {
        if (!this._animationFrameIds) {
          this._animationFrameIds = {};
        }
        var animationFrameCallback = function() {
          try {
            if (_this._animationFrameIds) {
              delete _this._animationFrameIds[animationFrameId];
            }
            callback.apply(_this._parent);
          } catch (e) {
            _this._logError(e);
          }
        };
        animationFrameId = win2.requestAnimationFrame ? win2.requestAnimationFrame(animationFrameCallback) : win2.setTimeout(animationFrameCallback, 0);
        this._animationFrameIds[animationFrameId] = true;
      }
      return animationFrameId;
    };
    Async2.prototype.cancelAnimationFrame = function(id, targetElement) {
      var win2 = getWindow$1(targetElement);
      if (this._animationFrameIds && this._animationFrameIds[id]) {
        win2.cancelAnimationFrame ? win2.cancelAnimationFrame(id) : win2.clearTimeout(id);
        delete this._animationFrameIds[id];
      }
    };
    Async2.prototype._logError = function(e) {
      if (this._onErrorHandler) {
        this._onErrorHandler(e);
      }
    };
    return Async2;
  }()
);
function shallowCompare(a, b) {
  if (!a || !b) {
    return !a && !b;
  }
  for (var propName in a) {
    if (a.hasOwnProperty(propName)) {
      if (!b.hasOwnProperty(propName) || b[propName] !== a[propName]) {
        return false;
      }
    }
  }
  for (var propName in b) {
    if (b.hasOwnProperty(propName)) {
      if (!a.hasOwnProperty(propName)) {
        return false;
      }
    }
  }
  return true;
}
function assign$2(target) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return filteredAssign.apply(this, [null, target].concat(args));
}
function filteredAssign(isAllowed, target) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  target = target || {};
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var sourceObject = args_1[_a2];
    if (sourceObject) {
      for (var propName in sourceObject) {
        if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {
          target[propName] = sourceObject[propName];
        }
      }
    }
  }
  return target;
}
var EventGroup = (
  /** @class */
  function() {
    function EventGroup2(parent) {
      this._id = EventGroup2._uniqueId++;
      this._parent = parent;
      this._eventRecords = [];
    }
    EventGroup2.raise = function(target, eventName, eventArgs, bubbleEvent) {
      var retVal2;
      if (EventGroup2._isElement(target)) {
        if (typeof document !== "undefined" && document.createEvent) {
          var ev = document.createEvent("HTMLEvents");
          ev.initEvent(eventName, bubbleEvent || false, true);
          assign$2(ev, eventArgs);
          retVal2 = target.dispatchEvent(ev);
        } else if (typeof document !== "undefined" && document.createEventObject) {
          var evObj = document.createEventObject(eventArgs);
          target.fireEvent("on" + eventName, evObj);
        }
      } else {
        while (target && retVal2 !== false) {
          var events = target.__events__;
          var eventRecords = events ? events[eventName] : null;
          if (eventRecords) {
            for (var id in eventRecords) {
              if (eventRecords.hasOwnProperty(id)) {
                var eventRecordList = eventRecords[id];
                for (var listIndex = 0; retVal2 !== false && listIndex < eventRecordList.length; listIndex++) {
                  var record = eventRecordList[listIndex];
                  if (record.objectCallback) {
                    retVal2 = record.objectCallback.call(record.parent, eventArgs);
                  }
                }
              }
            }
          }
          target = bubbleEvent ? target.parent : null;
        }
      }
      return retVal2;
    };
    EventGroup2.isObserved = function(target, eventName) {
      var events = target && target.__events__;
      return !!events && !!events[eventName];
    };
    EventGroup2.isDeclared = function(target, eventName) {
      var declaredEvents = target && target.__declaredEvents;
      return !!declaredEvents && !!declaredEvents[eventName];
    };
    EventGroup2.stopPropagation = function(event) {
      if (event.stopPropagation) {
        event.stopPropagation();
      } else {
        event.cancelBubble = true;
      }
    };
    EventGroup2._isElement = function(target) {
      return !!target && (!!target.addEventListener || typeof HTMLElement !== "undefined" && target instanceof HTMLElement);
    };
    EventGroup2.prototype.dispose = function() {
      if (!this._isDisposed) {
        this._isDisposed = true;
        this.off();
        this._parent = null;
      }
    };
    EventGroup2.prototype.onAll = function(target, events, useCapture) {
      for (var eventName in events) {
        if (events.hasOwnProperty(eventName)) {
          this.on(target, eventName, events[eventName], useCapture);
        }
      }
    };
    EventGroup2.prototype.on = function(target, eventName, callback, options2) {
      var _this = this;
      if (eventName.indexOf(",") > -1) {
        var events = eventName.split(/[ ,]+/);
        for (var i = 0; i < events.length; i++) {
          this.on(target, events[i], callback, options2);
        }
      } else {
        var parent_1 = this._parent;
        var eventRecord = {
          target,
          eventName,
          parent: parent_1,
          callback,
          options: options2
        };
        var events = target.__events__ = target.__events__ || {};
        events[eventName] = events[eventName] || {
          count: 0
        };
        events[eventName][this._id] = events[eventName][this._id] || [];
        events[eventName][this._id].push(eventRecord);
        events[eventName].count++;
        if (EventGroup2._isElement(target)) {
          var processElementEvent = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (_this._isDisposed) {
              return;
            }
            var result;
            try {
              result = callback.apply(parent_1, args);
              if (result === false && args[0]) {
                var e = args[0];
                if (e.preventDefault) {
                  e.preventDefault();
                }
                if (e.stopPropagation) {
                  e.stopPropagation();
                }
                e.cancelBubble = true;
              }
            } catch (e2) {
            }
            return result;
          };
          eventRecord.elementCallback = processElementEvent;
          if (target.addEventListener) {
            target.addEventListener(eventName, processElementEvent, options2);
          } else if (target.attachEvent) {
            target.attachEvent("on" + eventName, processElementEvent);
          }
        } else {
          var processObjectEvent = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (_this._isDisposed) {
              return;
            }
            return callback.apply(parent_1, args);
          };
          eventRecord.objectCallback = processObjectEvent;
        }
        this._eventRecords.push(eventRecord);
      }
    };
    EventGroup2.prototype.off = function(target, eventName, callback, options2) {
      for (var i = 0; i < this._eventRecords.length; i++) {
        var eventRecord = this._eventRecords[i];
        if ((!target || target === eventRecord.target) && (!eventName || eventName === eventRecord.eventName) && (!callback || callback === eventRecord.callback) && (typeof options2 !== "boolean" || options2 === eventRecord.options)) {
          var events = eventRecord.target.__events__;
          var targetArrayLookup = events[eventRecord.eventName];
          var targetArray = targetArrayLookup ? targetArrayLookup[this._id] : null;
          if (targetArray) {
            if (targetArray.length === 1 || !callback) {
              targetArrayLookup.count -= targetArray.length;
              delete events[eventRecord.eventName][this._id];
            } else {
              targetArrayLookup.count--;
              targetArray.splice(targetArray.indexOf(eventRecord), 1);
            }
            if (!targetArrayLookup.count) {
              delete events[eventRecord.eventName];
            }
          }
          if (eventRecord.elementCallback) {
            if (eventRecord.target.removeEventListener) {
              eventRecord.target.removeEventListener(eventRecord.eventName, eventRecord.elementCallback, eventRecord.options);
            } else if (eventRecord.target.detachEvent) {
              eventRecord.target.detachEvent("on" + eventRecord.eventName, eventRecord.elementCallback);
            }
          }
          this._eventRecords.splice(i--, 1);
        }
      }
    };
    EventGroup2.prototype.raise = function(eventName, eventArgs, bubbleEvent) {
      return EventGroup2.raise(this._parent, eventName, eventArgs, bubbleEvent);
    };
    EventGroup2.prototype.declare = function(event) {
      var declaredEvents = this._parent.__declaredEvents = this._parent.__declaredEvents || {};
      if (typeof event === "string") {
        declaredEvents[event] = true;
      } else {
        for (var i = 0; i < event.length; i++) {
          declaredEvents[event[i]] = true;
        }
      }
    };
    EventGroup2._uniqueId = 0;
    return EventGroup2;
  }()
);
function getDocument(rootElement) {
  if (!canUseDOM$1() || typeof document === "undefined") {
    return void 0;
  } else {
    var el = rootElement;
    return el && el.ownerDocument ? el.ownerDocument : document;
  }
}
var _scrollbarWidth;
var _bodyScrollDisabledCount = 0;
var DisabledScrollClassName = mergeStyles({
  overflow: "hidden !important"
});
var DATA_IS_SCROLLABLE_ATTRIBUTE = "data-is-scrollable";
var allowScrollOnElement = function(element, events) {
  if (!element) {
    return;
  }
  var _previousClientY = 0;
  var _element = null;
  var _saveClientY = function(event) {
    if (event.targetTouches.length === 1) {
      _previousClientY = event.targetTouches[0].clientY;
    }
  };
  var _preventOverscrolling = function(event) {
    if (event.targetTouches.length !== 1) {
      return;
    }
    event.stopPropagation();
    if (!_element) {
      return;
    }
    var clientY = event.targetTouches[0].clientY - _previousClientY;
    var scrollableParent = findScrollableParent(event.target);
    if (scrollableParent) {
      _element = scrollableParent;
    }
    if (_element.scrollTop === 0 && clientY > 0) {
      event.preventDefault();
    }
    if (_element.scrollHeight - Math.ceil(_element.scrollTop) <= _element.clientHeight && clientY < 0) {
      event.preventDefault();
    }
  };
  events.on(element, "touchstart", _saveClientY, { passive: false });
  events.on(element, "touchmove", _preventOverscrolling, { passive: false });
  _element = element;
};
var allowOverscrollOnElement = function(element, events) {
  if (!element) {
    return;
  }
  var _allowElementScroll = function(event) {
    event.stopPropagation();
  };
  events.on(element, "touchmove", _allowElementScroll, { passive: false });
};
var _disableIosBodyScroll = function(event) {
  event.preventDefault();
};
function disableBodyScroll() {
  var doc = getDocument();
  if (doc && doc.body && !_bodyScrollDisabledCount) {
    doc.body.classList.add(DisabledScrollClassName);
    doc.body.addEventListener("touchmove", _disableIosBodyScroll, { passive: false, capture: false });
  }
  _bodyScrollDisabledCount++;
}
function enableBodyScroll() {
  if (_bodyScrollDisabledCount > 0) {
    var doc = getDocument();
    if (doc && doc.body && _bodyScrollDisabledCount === 1) {
      doc.body.classList.remove(DisabledScrollClassName);
      doc.body.removeEventListener("touchmove", _disableIosBodyScroll);
    }
    _bodyScrollDisabledCount--;
  }
}
function getScrollbarWidth() {
  if (_scrollbarWidth === void 0) {
    var scrollDiv = document.createElement("div");
    scrollDiv.style.setProperty("width", "100px");
    scrollDiv.style.setProperty("height", "100px");
    scrollDiv.style.setProperty("overflow", "scroll");
    scrollDiv.style.setProperty("position", "absolute");
    scrollDiv.style.setProperty("top", "-9999px");
    document.body.appendChild(scrollDiv);
    _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
  }
  return _scrollbarWidth;
}
function findScrollableParent(startingElement) {
  var el = startingElement;
  var doc = getDocument(startingElement);
  while (el && el !== doc.body) {
    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === "true") {
      return el;
    }
    el = el.parentElement;
  }
  el = startingElement;
  while (el && el !== doc.body) {
    if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== "false") {
      var computedStyles = getComputedStyle(el);
      var overflowY = computedStyles ? computedStyles.getPropertyValue("overflow-y") : "";
      if (overflowY && (overflowY === "scroll" || overflowY === "auto")) {
        return el;
      }
    }
    el = el.parentElement;
  }
  if (!el || el === doc.body) {
    el = getWindow$1(startingElement);
  }
  return el;
}
function getRect(element) {
  var rect;
  if (element) {
    if (element === window) {
      rect = {
        left: 0,
        top: 0,
        width: window.innerWidth,
        height: window.innerHeight,
        right: window.innerWidth,
        bottom: window.innerHeight
      };
    } else if (element.getBoundingClientRect) {
      rect = element.getBoundingClientRect();
    }
  }
  return rect;
}
var SCROLL_ITERATION_DELAY = 16;
var SCROLL_GUTTER = 100;
var MAX_SCROLL_VELOCITY = 15;
var AutoScroll = (
  /** @class */
  function() {
    function AutoScroll2(element) {
      this._events = new EventGroup(this);
      this._scrollableParent = findScrollableParent(element);
      this._incrementScroll = this._incrementScroll.bind(this);
      this._scrollRect = getRect(this._scrollableParent);
      if (this._scrollableParent === window) {
        this._scrollableParent = document.body;
      }
      if (this._scrollableParent) {
        this._events.on(window, "mousemove", this._onMouseMove, true);
        this._events.on(window, "touchmove", this._onTouchMove, true);
      }
    }
    AutoScroll2.prototype.dispose = function() {
      this._events.dispose();
      this._stopScroll();
    };
    AutoScroll2.prototype._onMouseMove = function(ev) {
      this._computeScrollVelocity(ev);
    };
    AutoScroll2.prototype._onTouchMove = function(ev) {
      if (ev.touches.length > 0) {
        this._computeScrollVelocity(ev);
      }
    };
    AutoScroll2.prototype._computeScrollVelocity = function(ev) {
      if (!this._scrollRect) {
        return;
      }
      var clientX;
      var clientY;
      if ("clientX" in ev) {
        clientX = ev.clientX;
        clientY = ev.clientY;
      } else {
        clientX = ev.touches[0].clientX;
        clientY = ev.touches[0].clientY;
      }
      var scrollRectTop = this._scrollRect.top;
      var scrollRectLeft = this._scrollRect.left;
      var scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER;
      var scrollClientRight = scrollRectLeft + this._scrollRect.width - SCROLL_GUTTER;
      var scrollRect;
      var clientDirection;
      var scrollClient;
      if (clientY < scrollRectTop + SCROLL_GUTTER || clientY > scrollClientBottom) {
        clientDirection = clientY;
        scrollRect = scrollRectTop;
        scrollClient = scrollClientBottom;
        this._isVerticalScroll = true;
      } else {
        clientDirection = clientX;
        scrollRect = scrollRectLeft;
        scrollClient = scrollClientRight;
        this._isVerticalScroll = false;
      }
      if (clientDirection < scrollRect + SCROLL_GUTTER) {
        this._scrollVelocity = Math.max(-MAX_SCROLL_VELOCITY, -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER - (clientDirection - scrollRect)) / SCROLL_GUTTER));
      } else if (clientDirection > scrollClient) {
        this._scrollVelocity = Math.min(MAX_SCROLL_VELOCITY, MAX_SCROLL_VELOCITY * ((clientDirection - scrollClient) / SCROLL_GUTTER));
      } else {
        this._scrollVelocity = 0;
      }
      if (this._scrollVelocity) {
        this._startScroll();
      } else {
        this._stopScroll();
      }
    };
    AutoScroll2.prototype._startScroll = function() {
      if (!this._timeoutId) {
        this._incrementScroll();
      }
    };
    AutoScroll2.prototype._incrementScroll = function() {
      if (this._scrollableParent) {
        if (this._isVerticalScroll) {
          this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);
        } else {
          this._scrollableParent.scrollLeft += Math.round(this._scrollVelocity);
        }
      }
      this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);
    };
    AutoScroll2.prototype._stopScroll = function() {
      if (this._timeoutId) {
        clearTimeout(this._timeoutId);
        delete this._timeoutId;
      }
    };
    return AutoScroll2;
  }()
);
var _warningCallback = void 0;
function warn(message) {
  if (_warningCallback && process.env.NODE_ENV !== "production") {
    _warningCallback(message);
  } else if (console && console.warn) {
    console.warn(message);
  }
}
function warnConditionallyRequiredProps(componentName, props, requiredProps, conditionalPropName, condition) {
  if (condition === true && process.env.NODE_ENV !== "production") {
    for (var _i = 0, requiredProps_1 = requiredProps; _i < requiredProps_1.length; _i++) {
      var requiredPropName = requiredProps_1[_i];
      if (!(requiredPropName in props)) {
        warn(componentName + " property '" + requiredPropName + "' is required when '" + conditionalPropName + "' is used.'");
      }
    }
  }
}
function warnMutuallyExclusive(componentName, props, exclusiveMap) {
  if (process.env.NODE_ENV !== "production") {
    for (var propName in exclusiveMap) {
      if (props && props[propName] !== void 0) {
        var propInExclusiveMapValue = exclusiveMap[propName];
        if (propInExclusiveMapValue && props[propInExclusiveMapValue] !== void 0) {
          warn(componentName + " property '" + propName + "' is mutually exclusive with '" + exclusiveMap[propName] + "'. Use one or the other.");
        }
      }
    }
  }
}
function warnDeprecations(componentName, props, deprecationMap) {
  if (process.env.NODE_ENV !== "production") {
    for (var propName in deprecationMap) {
      if (props && propName in props) {
        var deprecationMessage = componentName + " property '" + propName + "' was used but has been deprecated.";
        var replacementPropName = deprecationMap[propName];
        if (replacementPropName) {
          deprecationMessage += " Use '" + replacementPropName + "' instead.";
        }
        warn(deprecationMessage);
      }
    }
  }
}
(function(_super) {
  __extends(BaseComponent, _super);
  function BaseComponent(props, context) {
    var _this = _super.call(this, props, context) || this;
    _makeAllSafe(_this, BaseComponent.prototype, [
      "componentDidMount",
      "shouldComponentUpdate",
      "getSnapshotBeforeUpdate",
      "render",
      "componentDidUpdate",
      "componentWillUnmount"
    ]);
    return _this;
  }
  BaseComponent.prototype.componentDidUpdate = function(prevProps, prevState) {
    this._updateComponentRef(prevProps, this.props);
  };
  BaseComponent.prototype.componentDidMount = function() {
    this._setComponentRef(this.props.componentRef, this);
  };
  BaseComponent.prototype.componentWillUnmount = function() {
    this._setComponentRef(this.props.componentRef, null);
    if (this.__disposables) {
      for (var i = 0, len = this._disposables.length; i < len; i++) {
        var disposable = this.__disposables[i];
        if (disposable.dispose) {
          disposable.dispose();
        }
      }
      this.__disposables = null;
    }
  };
  Object.defineProperty(BaseComponent.prototype, "className", {
    /**
     * Gets the object's class name.
     */
    get: function() {
      if (!this.__className) {
        var funcNameRegex = /function (.{1,})\(/;
        var results = funcNameRegex.exec(this.constructor.toString());
        this.__className = results && results.length > 1 ? results[1] : "";
      }
      return this.__className;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseComponent.prototype, "_disposables", {
    /**
     * Allows subclasses to push things to this._disposables to be auto disposed.
     */
    get: function() {
      if (!this.__disposables) {
        this.__disposables = [];
      }
      return this.__disposables;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseComponent.prototype, "_async", {
    /**
     * Gets the async instance associated with the component, created on demand. The async instance gives
     * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks
     * will be cleared/ignored automatically after unmounting. The helpers within the async object also
     * preserve the this pointer so that you don't need to "bind" the callbacks.
     */
    get: function() {
      if (!this.__async) {
        this.__async = new Async(this);
        this._disposables.push(this.__async);
      }
      return this.__async;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseComponent.prototype, "_events", {
    /**
     * Gets the event group instance assocaited with the component, created on demand. The event instance
     * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks
     * will be automatically disconnected after unmounting. The helpers within the events object also
     * preserve the this reference so that you don't need to "bind" the callbacks.
     */
    get: function() {
      if (!this.__events) {
        this.__events = new EventGroup(this);
        this._disposables.push(this.__events);
      }
      return this.__events;
    },
    enumerable: false,
    configurable: true
  });
  BaseComponent.prototype._resolveRef = function(refName) {
    var _this = this;
    if (!this.__resolves) {
      this.__resolves = {};
    }
    if (!this.__resolves[refName]) {
      this.__resolves[refName] = function(ref) {
        return _this[refName] = ref;
      };
    }
    return this.__resolves[refName];
  };
  BaseComponent.prototype._updateComponentRef = function(currentProps, newProps) {
    if (newProps === void 0) {
      newProps = {};
    }
    if (currentProps && newProps && currentProps.componentRef !== newProps.componentRef) {
      this._setComponentRef(currentProps.componentRef, null);
      this._setComponentRef(newProps.componentRef, this);
    }
  };
  BaseComponent.prototype._warnDeprecations = function(deprecationMap) {
    warnDeprecations(this.className, this.props, deprecationMap);
  };
  BaseComponent.prototype._warnMutuallyExclusive = function(mutuallyExclusiveMap) {
    warnMutuallyExclusive(this.className, this.props, mutuallyExclusiveMap);
  };
  BaseComponent.prototype._warnConditionallyRequiredProps = function(requiredProps, conditionalPropName, condition) {
    warnConditionallyRequiredProps(this.className, this.props, requiredProps, conditionalPropName, condition);
  };
  BaseComponent.prototype._setComponentRef = function(ref, value) {
    if (!this._skipComponentRefResolution && ref) {
      if (typeof ref === "function") {
        ref(value);
      }
      if (typeof ref === "object") {
        ref.current = value;
      }
    }
  };
  return BaseComponent;
})(React__namespace.Component);
function _makeAllSafe(obj, prototype, methodNames) {
  for (var i = 0, len = methodNames.length; i < len; i++) {
    _makeSafe(obj, prototype, methodNames[i]);
  }
}
function _makeSafe(obj, prototype, methodName) {
  var classMethod = obj[methodName];
  var prototypeMethod = prototype[methodName];
  if (classMethod || prototypeMethod) {
    obj[methodName] = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var retVal2;
      if (prototypeMethod) {
        retVal2 = prototypeMethod.apply(this, args);
      }
      if (classMethod !== prototypeMethod) {
        retVal2 = classMethod.apply(this, args);
      }
      return retVal2;
    };
  }
}
function nullRender() {
  return null;
}
var DelayedRender = (
  /** @class */
  function(_super) {
    __extends(DelayedRender2, _super);
    function DelayedRender2(props) {
      var _this = _super.call(this, props) || this;
      _this.state = {
        isRendered: getWindow$1() === void 0
      };
      return _this;
    }
    DelayedRender2.prototype.componentDidMount = function() {
      var _this = this;
      var delay = this.props.delay;
      this._timeoutId = window.setTimeout(function() {
        _this.setState({
          isRendered: true
        });
      }, delay);
    };
    DelayedRender2.prototype.componentWillUnmount = function() {
      if (this._timeoutId) {
        clearTimeout(this._timeoutId);
      }
    };
    DelayedRender2.prototype.render = function() {
      return this.state.isRendered ? React__namespace.Children.only(this.props.children) : null;
    };
    DelayedRender2.defaultProps = {
      delay: 0
    };
    return DelayedRender2;
  }(React__namespace.Component)
);
var GLOBAL_SETTINGS_PROP_NAME = "__globalSettings__";
var CALLBACK_STATE_PROP_NAME = "__callbacks__";
var _counter = 0;
var GlobalSettings = (
  /** @class */
  function() {
    function GlobalSettings2() {
    }
    GlobalSettings2.getValue = function(key, defaultValue) {
      var globalSettings = _getGlobalSettings();
      if (globalSettings[key] === void 0) {
        globalSettings[key] = typeof defaultValue === "function" ? defaultValue() : defaultValue;
      }
      return globalSettings[key];
    };
    GlobalSettings2.setValue = function(key, value) {
      var globalSettings = _getGlobalSettings();
      var callbacks = globalSettings[CALLBACK_STATE_PROP_NAME];
      var oldValue = globalSettings[key];
      if (value !== oldValue) {
        globalSettings[key] = value;
        var changeDescription = {
          oldValue,
          value,
          key
        };
        for (var id in callbacks) {
          if (callbacks.hasOwnProperty(id)) {
            callbacks[id](changeDescription);
          }
        }
      }
      return value;
    };
    GlobalSettings2.addChangeListener = function(cb) {
      var id = cb.__id__;
      var callbacks = _getCallbacks();
      if (!id) {
        id = cb.__id__ = String(_counter++);
      }
      callbacks[id] = cb;
    };
    GlobalSettings2.removeChangeListener = function(cb) {
      var callbacks = _getCallbacks();
      delete callbacks[cb.__id__];
    };
    return GlobalSettings2;
  }()
);
function _getGlobalSettings() {
  var _a2;
  var win2 = getWindow$1();
  var globalObj = win2 || {};
  if (!globalObj[GLOBAL_SETTINGS_PROP_NAME]) {
    globalObj[GLOBAL_SETTINGS_PROP_NAME] = (_a2 = {}, _a2[CALLBACK_STATE_PROP_NAME] = {}, _a2);
  }
  return globalObj[GLOBAL_SETTINGS_PROP_NAME];
}
function _getCallbacks() {
  var globalSettings = _getGlobalSettings();
  return globalSettings[CALLBACK_STATE_PROP_NAME];
}
var KeyCodes = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  ctrl: 17,
  alt: 18,
  pauseBreak: 19,
  capslock: 20,
  escape: 27,
  space: 32,
  pageUp: 33,
  pageDown: 34,
  end: 35,
  home: 36,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  insert: 45,
  del: 46,
  zero: 48,
  one: 49,
  two: 50,
  three: 51,
  four: 52,
  five: 53,
  six: 54,
  seven: 55,
  eight: 56,
  nine: 57,
  colon: 58,
  a: 65,
  b: 66,
  c: 67,
  d: 68,
  e: 69,
  f: 70,
  g: 71,
  h: 72,
  i: 73,
  j: 74,
  k: 75,
  l: 76,
  m: 77,
  n: 78,
  o: 79,
  p: 80,
  q: 81,
  r: 82,
  s: 83,
  t: 84,
  u: 85,
  v: 86,
  w: 87,
  x: 88,
  y: 89,
  z: 90,
  leftWindow: 91,
  rightWindow: 92,
  select: 93,
  /* eslint-disable @typescript-eslint/naming-convention */
  zero_numpad: 96,
  one_numpad: 97,
  two_numpad: 98,
  three_numpad: 99,
  four_numpad: 100,
  five_numpad: 101,
  six_numpad: 102,
  seven_numpad: 103,
  eight_numpad: 104,
  nine_numpad: 105,
  /* eslint-enable @typescript-eslint/naming-convention */
  multiply: 106,
  add: 107,
  subtract: 109,
  decimalPoint: 110,
  divide: 111,
  f1: 112,
  f2: 113,
  f3: 114,
  f4: 115,
  f5: 116,
  f6: 117,
  f7: 118,
  f8: 119,
  f9: 120,
  f10: 121,
  f11: 122,
  f12: 123,
  numlock: 144,
  scrollLock: 145,
  semicolon: 186,
  equalSign: 187,
  comma: 188,
  dash: 189,
  period: 190,
  forwardSlash: 191,
  graveAccent: 192,
  openBracket: 219,
  backSlash: 220,
  closeBracket: 221,
  singleQuote: 222
};
var Rectangle = (
  /** @class */
  function() {
    function Rectangle2(left, right, top, bottom) {
      if (left === void 0) {
        left = 0;
      }
      if (right === void 0) {
        right = 0;
      }
      if (top === void 0) {
        top = 0;
      }
      if (bottom === void 0) {
        bottom = 0;
      }
      this.top = top;
      this.bottom = bottom;
      this.left = left;
      this.right = right;
    }
    Object.defineProperty(Rectangle2.prototype, "width", {
      /**
       * Calculated automatically by subtracting the right from left
       */
      get: function() {
        return this.right - this.left;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Rectangle2.prototype, "height", {
      /**
       * Calculated automatically by subtracting the bottom from top.
       */
      get: function() {
        return this.bottom - this.top;
      },
      enumerable: false,
      configurable: true
    });
    Rectangle2.prototype.equals = function(rect) {
      return parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) && parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) && parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) && parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4));
    };
    return Rectangle2;
  }()
);
function appendFunction(parent) {
  var functions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    functions[_i - 1] = arguments[_i];
  }
  if (functions.length < 2) {
    return functions[0];
  }
  return function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    functions.forEach(function(f) {
      return f && f.apply(parent, args);
    });
  };
}
function mergeAriaAttributeValues() {
  var ariaAttributes = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    ariaAttributes[_i] = arguments[_i];
  }
  var mergedAttribute = ariaAttributes.filter(function(arg) {
    return arg;
  }).join(" ").trim();
  return mergedAttribute === "" ? void 0 : mergedAttribute;
}
function findIndex(array, cb, fromIndex) {
  if (fromIndex === void 0) {
    fromIndex = 0;
  }
  var index2 = -1;
  for (var i = fromIndex; array && i < array.length; i++) {
    if (cb(array[i], i)) {
      index2 = i;
      break;
    }
  }
  return index2;
}
function addElementAtIndex(array, index2, itemToAdd) {
  var copy2 = array.slice();
  copy2.splice(index2, 0, itemToAdd);
  return copy2;
}
function arraysEqual(array1, array2) {
  if (array1.length !== array2.length) {
    return false;
  }
  for (var i = 0; i < array1.length; i++) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function getItem$1(key) {
  var result = null;
  try {
    var win2 = getWindow$1();
    result = win2 ? win2.sessionStorage.getItem(key) : null;
  } catch (e) {
  }
  return result;
}
function setItem(key, data) {
  var _a2;
  try {
    (_a2 = getWindow$1()) === null || _a2 === void 0 ? void 0 : _a2.sessionStorage.setItem(key, data);
  } catch (e) {
  }
}
var RTL_LOCAL_STORAGE_KEY = "isRTL";
var _isRTL;
function getRTL(theme) {
  if (theme === void 0) {
    theme = {};
  }
  if (theme.rtl !== void 0) {
    return theme.rtl;
  }
  if (_isRTL === void 0) {
    var savedRTL = getItem$1(RTL_LOCAL_STORAGE_KEY);
    if (savedRTL !== null) {
      _isRTL = savedRTL === "1";
      setRTL(_isRTL);
    }
    var doc = getDocument();
    if (_isRTL === void 0 && doc) {
      _isRTL = (doc.body && doc.body.getAttribute("dir") || doc.documentElement.getAttribute("dir")) === "rtl";
      setRTL$1(_isRTL);
    }
  }
  return !!_isRTL;
}
function setRTL(isRTL, persistSetting) {
  if (persistSetting === void 0) {
    persistSetting = false;
  }
  var doc = getDocument();
  if (doc) {
    doc.documentElement.setAttribute("dir", isRTL ? "rtl" : "ltr");
  }
  if (persistSetting) {
    setItem(RTL_LOCAL_STORAGE_KEY, isRTL ? "1" : "0");
  }
  _isRTL = isRTL;
  setRTL$1(_isRTL);
}
function getRTLSafeKeyCode(key, theme) {
  if (theme === void 0) {
    theme = {};
  }
  if (getRTL(theme)) {
    if (key === KeyCodes.left) {
      key = KeyCodes.right;
    } else if (key === KeyCodes.right) {
      key = KeyCodes.left;
    }
  }
  return key;
}
function isVirtualElement(element) {
  return element && !!element._virtual;
}
function getVirtualParent(child) {
  var parent;
  if (child && isVirtualElement(child)) {
    parent = child._virtual.parent;
  }
  return parent;
}
function getParent(child, allowVirtualParents) {
  if (allowVirtualParents === void 0) {
    allowVirtualParents = true;
  }
  return child && (allowVirtualParents && getVirtualParent(child) || child.parentNode && child.parentNode);
}
function elementContains(parent, child, allowVirtualParents) {
  if (allowVirtualParents === void 0) {
    allowVirtualParents = true;
  }
  var isContained = false;
  if (parent && child) {
    if (allowVirtualParents) {
      if (parent === child) {
        isContained = true;
      } else {
        isContained = false;
        while (child) {
          var nextParent = getParent(child);
          if (nextParent === parent) {
            isContained = true;
            break;
          }
          child = nextParent;
        }
      }
    } else if (parent.contains) {
      isContained = parent.contains(child);
    }
  }
  return isContained;
}
function findElementRecursive(element, matchFunction) {
  if (!element || element === document.body) {
    return null;
  }
  return matchFunction(element) ? element : findElementRecursive(getParent(element), matchFunction);
}
function elementContainsAttribute(element, attribute) {
  var elementMatch = findElementRecursive(element, function(testElement) {
    return testElement.hasAttribute(attribute);
  });
  return elementMatch && elementMatch.getAttribute(attribute);
}
function getChildren(parent, allowVirtualChildren) {
  if (allowVirtualChildren === void 0) {
    allowVirtualChildren = true;
  }
  var children = [];
  if (parent) {
    for (var i = 0; i < parent.children.length; i++) {
      children.push(parent.children.item(i));
    }
    if (allowVirtualChildren && isVirtualElement(parent)) {
      children.push.apply(children, parent._virtual.children);
    }
  }
  return children;
}
var DATA_PORTAL_ATTRIBUTE = "data-portal-element";
function setPortalAttribute(element) {
  element.setAttribute(DATA_PORTAL_ATTRIBUTE, "true");
}
function portalContainsElement(target, parent) {
  var elementMatch = findElementRecursive(target, function(testElement) {
    return parent === testElement || testElement.hasAttribute(DATA_PORTAL_ATTRIBUTE);
  });
  return elementMatch !== null && elementMatch.hasAttribute(DATA_PORTAL_ATTRIBUTE);
}
function setVirtualParent(child, parent) {
  var virtualChild = child;
  var virtualParent = parent;
  if (!virtualChild._virtual) {
    virtualChild._virtual = {
      children: []
    };
  }
  var oldParent = virtualChild._virtual.parent;
  if (oldParent && oldParent !== parent) {
    var index2 = oldParent._virtual.children.indexOf(virtualChild);
    if (index2 > -1) {
      oldParent._virtual.children.splice(index2, 1);
    }
  }
  virtualChild._virtual.parent = virtualParent || void 0;
  if (virtualParent) {
    if (!virtualParent._virtual) {
      virtualParent._virtual = {
        children: []
      };
    }
    virtualParent._virtual.children.push(virtualChild);
  }
}
var IS_FOCUSABLE_ATTRIBUTE$1 = "data-is-focusable";
var IS_VISIBLE_ATTRIBUTE = "data-is-visible";
var FOCUSZONE_ID_ATTRIBUTE$1 = "data-focuszone-id";
var FOCUSZONE_SUB_ATTRIBUTE = "data-is-sub-focuszone";
function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones) {
  return getNextElement(rootElement, currentElement, true, false, false, includeElementsInFocusZones);
}
function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones) {
  return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones);
}
function getFirstTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode) {
  if (checkNode === void 0) {
    checkNode = true;
  }
  return getNextElement(
    rootElement,
    currentElement,
    checkNode,
    false,
    false,
    includeElementsInFocusZones,
    false,
    true
    /*tabbable*/
  );
}
function getLastTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode) {
  if (checkNode === void 0) {
    checkNode = true;
  }
  return getPreviousElement(
    rootElement,
    currentElement,
    checkNode,
    false,
    true,
    includeElementsInFocusZones,
    false,
    true
    /*tabbable*/
  );
}
function focusFirstChild(rootElement, bypassHiddenElements) {
  var element = getNextElement(rootElement, rootElement, true, false, false, true, void 0, void 0, bypassHiddenElements);
  if (element) {
    focusAsync(element);
    return true;
  }
  return false;
}
function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, allowFocusRoot, tabbable) {
  if (!currentElement || !allowFocusRoot && currentElement === rootElement) {
    return null;
  }
  var isCurrentElementVisible = isElementVisible(currentElement);
  if (traverseChildren && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
    var childMatch = getPreviousElement(rootElement, currentElement.lastElementChild, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
    if (childMatch) {
      if (tabbable && isElementTabbable(childMatch, true) || !tabbable) {
        return childMatch;
      }
      var childMatchSiblingMatch = getPreviousElement(rootElement, childMatch.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
      if (childMatchSiblingMatch) {
        return childMatchSiblingMatch;
      }
      var childMatchParent = childMatch.parentElement;
      while (childMatchParent && childMatchParent !== currentElement) {
        var childMatchParentMatch = getPreviousElement(rootElement, childMatchParent.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
        if (childMatchParentMatch) {
          return childMatchParentMatch;
        }
        childMatchParent = childMatchParent.parentElement;
      }
    }
  }
  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {
    return currentElement;
  }
  var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
  if (siblingMatch) {
    return siblingMatch;
  }
  if (!suppressParentTraversal) {
    return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, allowFocusRoot, tabbable);
  }
  return null;
}
function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements) {
  if (!currentElement || currentElement === rootElement && suppressChildTraversal && !allowFocusRoot) {
    return null;
  }
  var checkElementVisibility = bypassHiddenElements ? isElementVisibleAndNotHidden : isElementVisible;
  var isCurrentElementVisible = checkElementVisibility(currentElement);
  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {
    return currentElement;
  }
  if (!suppressChildTraversal && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
    var childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements);
    if (childMatch) {
      return childMatch;
    }
  }
  if (currentElement === rootElement) {
    return null;
  }
  var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements);
  if (siblingMatch) {
    return siblingMatch;
  }
  if (!suppressParentTraversal) {
    return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, allowFocusRoot, tabbable, bypassHiddenElements);
  }
  return null;
}
function isElementVisible(element) {
  if (!element || !element.getAttribute) {
    return false;
  }
  var visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);
  if (visibilityAttribute !== null && visibilityAttribute !== void 0) {
    return visibilityAttribute === "true";
  }
  return element.offsetHeight !== 0 || element.offsetParent !== null || // eslint-disable-next-line @typescript-eslint/no-explicit-any
  element.isVisible === true;
}
function isElementVisibleAndNotHidden(element) {
  return !!element && isElementVisible(element) && !element.hidden && window.getComputedStyle(element).visibility !== "hidden";
}
function isElementTabbable(element, checkTabIndex) {
  if (!element || element.disabled) {
    return false;
  }
  var tabIndex = 0;
  var tabIndexAttributeValue = null;
  if (element && element.getAttribute) {
    tabIndexAttributeValue = element.getAttribute("tabIndex");
    if (tabIndexAttributeValue) {
      tabIndex = parseInt(tabIndexAttributeValue, 10);
    }
  }
  var isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE$1) : null;
  var isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;
  var result = !!element && isFocusableAttribute !== "false" && (element.tagName === "A" || element.tagName === "BUTTON" || element.tagName === "INPUT" || element.tagName === "TEXTAREA" || element.tagName === "SELECT" || isFocusableAttribute === "true" || isTabIndexSet);
  return checkTabIndex ? tabIndex !== -1 && result : result;
}
function isElementFocusZone(element) {
  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE$1));
}
function isElementFocusSubZone(element) {
  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === "true");
}
function doesElementContainFocus(element) {
  var document2 = getDocument(element);
  var currentActiveElement = document2 && document2.activeElement;
  if (currentActiveElement && elementContains(element, currentActiveElement)) {
    return true;
  }
  return false;
}
function shouldWrapFocus(element, noWrapDataAttribute) {
  return elementContainsAttribute(element, noWrapDataAttribute) === "true" ? false : true;
}
var targetToFocusOnNextRepaint = void 0;
function focusAsync(element) {
  if (element) {
    if (targetToFocusOnNextRepaint) {
      targetToFocusOnNextRepaint = element;
      return;
    }
    targetToFocusOnNextRepaint = element;
    var win2 = getWindow$1(element);
    if (win2) {
      win2.requestAnimationFrame(function() {
        targetToFocusOnNextRepaint && targetToFocusOnNextRepaint.focus();
        targetToFocusOnNextRepaint = void 0;
      });
    }
  }
}
function getFocusableByIndexPath(parent, path) {
  var element = parent;
  for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
    var index2 = path_1[_i];
    var nextChild = element.children[Math.min(index2, element.children.length - 1)];
    if (!nextChild) {
      break;
    }
    element = nextChild;
  }
  element = isElementTabbable(element) && isElementVisible(element) ? element : getNextElement(parent, element, true) || getPreviousElement(parent, element);
  return element;
}
function getElementIndexPath(fromElement, toElement) {
  var path = [];
  while (toElement && fromElement && toElement !== fromElement) {
    var parent_1 = getParent(toElement, true);
    if (parent_1 === null) {
      return [];
    }
    path.unshift(Array.prototype.indexOf.call(parent_1.children, toElement));
    toElement = parent_1;
  }
  return path;
}
function on(element, eventName, callback, options2) {
  element.addEventListener(eventName, callback, options2);
  return function() {
    return element.removeEventListener(eventName, callback, options2);
  };
}
var MAX_CACHE_COUNT = 50;
var DEFAULT_SPECIFICITY_MULTIPLIER = 5;
var _memoizedClassNames = 0;
var stylesheet$1 = Stylesheet.getInstance();
if (stylesheet$1 && stylesheet$1.onReset) {
  stylesheet$1.onReset(function() {
    return _memoizedClassNames++;
  });
}
var retVal = "__retval__";
function classNamesFunction(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var map = /* @__PURE__ */ new Map();
  var styleCalcCount = 0;
  var getClassNamesCount = 0;
  var currentMemoizedClassNames = _memoizedClassNames;
  var getClassNames2 = function(styleFunctionOrObject, styleProps) {
    var _a2;
    if (styleProps === void 0) {
      styleProps = {};
    }
    if (options2.useStaticStyles && typeof styleFunctionOrObject === "function" && styleFunctionOrObject.__noStyleOverride__) {
      return styleFunctionOrObject(styleProps);
    }
    getClassNamesCount++;
    var current = map;
    var theme = styleProps.theme;
    var rtl = theme && theme.rtl !== void 0 ? theme.rtl : getRTL();
    var disableCaching = options2.disableCaching;
    if (currentMemoizedClassNames !== _memoizedClassNames) {
      currentMemoizedClassNames = _memoizedClassNames;
      map = /* @__PURE__ */ new Map();
      styleCalcCount = 0;
    }
    if (!options2.disableCaching) {
      current = _traverseMap(map, styleFunctionOrObject);
      current = _traverseMap(current, styleProps);
    }
    if (disableCaching || !current[retVal]) {
      if (styleFunctionOrObject === void 0) {
        current[retVal] = {};
      } else {
        current[retVal] = mergeCssSets([
          typeof styleFunctionOrObject === "function" ? styleFunctionOrObject(styleProps) : styleFunctionOrObject
        ], { rtl: !!rtl, specificityMultiplier: options2.useStaticStyles ? DEFAULT_SPECIFICITY_MULTIPLIER : void 0 });
      }
      if (!disableCaching) {
        styleCalcCount++;
      }
    }
    if (styleCalcCount > (options2.cacheSize || MAX_CACHE_COUNT)) {
      var win2 = getWindow$1();
      if ((_a2 = win2 === null || win2 === void 0 ? void 0 : win2.FabricConfig) === null || _a2 === void 0 ? void 0 : _a2.enableClassNameCacheFullWarning) {
        console.warn("Styles are being recalculated too frequently. Cache miss rate is " + styleCalcCount + "/" + getClassNamesCount + ".");
        console.trace();
      }
      map.clear();
      styleCalcCount = 0;
      options2.disableCaching = true;
    }
    return current[retVal];
  };
  return getClassNames2;
}
function _traverseEdge(current, value) {
  value = _normalizeValue(value);
  if (!current.has(value)) {
    current.set(value, /* @__PURE__ */ new Map());
  }
  return current.get(value);
}
function _traverseMap(current, inputs) {
  if (typeof inputs === "function") {
    var cachedInputsFromStyled = inputs.__cachedInputs__;
    if (cachedInputsFromStyled) {
      for (var _i = 0, _a2 = inputs.__cachedInputs__; _i < _a2.length; _i++) {
        var input = _a2[_i];
        current = _traverseEdge(current, input);
      }
    } else {
      current = _traverseEdge(current, inputs);
    }
  } else if (typeof inputs === "object") {
    for (var propName in inputs) {
      if (inputs.hasOwnProperty(propName)) {
        current = _traverseEdge(current, inputs[propName]);
      }
    }
  }
  return current;
}
function _normalizeValue(value) {
  switch (value) {
    case void 0:
      return "__undefined__";
    case null:
      return "__null__";
    default:
      return value;
  }
}
var _initializedStylesheetResets$1 = false;
var _resetCounter = 0;
var _emptyObject = { empty: true };
var _dictionary = {};
var _weakMap = typeof WeakMap === "undefined" ? null : WeakMap;
function resetMemoizations() {
  _resetCounter++;
}
function memoizeFunction(cb, maxCacheSize, ignoreNullOrUndefinedResult) {
  if (maxCacheSize === void 0) {
    maxCacheSize = 100;
  }
  if (ignoreNullOrUndefinedResult === void 0) {
    ignoreNullOrUndefinedResult = false;
  }
  if (!_weakMap) {
    return cb;
  }
  if (!_initializedStylesheetResets$1) {
    var stylesheet2 = Stylesheet.getInstance();
    if (stylesheet2 && stylesheet2.onReset) {
      Stylesheet.getInstance().onReset(resetMemoizations);
    }
    _initializedStylesheetResets$1 = true;
  }
  var rootNode;
  var cacheSize = 0;
  var localResetCounter = _resetCounter;
  return function memoizedFunction() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var currentNode = rootNode;
    if (rootNode === void 0 || localResetCounter !== _resetCounter || maxCacheSize > 0 && cacheSize > maxCacheSize) {
      rootNode = _createNode();
      cacheSize = 0;
      localResetCounter = _resetCounter;
    }
    currentNode = rootNode;
    for (var i = 0; i < args.length; i++) {
      var arg = _normalizeArg(args[i]);
      if (!currentNode.map.has(arg)) {
        currentNode.map.set(arg, _createNode());
      }
      currentNode = currentNode.map.get(arg);
    }
    if (!currentNode.hasOwnProperty("value")) {
      currentNode.value = cb.apply(void 0, args);
      cacheSize++;
    }
    if (ignoreNullOrUndefinedResult && (currentNode.value === null || currentNode.value === void 0)) {
      currentNode.value = cb.apply(void 0, args);
    }
    return currentNode.value;
  };
}
function createMemoizer(getValue) {
  if (!_weakMap) {
    return getValue;
  }
  var cache = new _weakMap();
  function memoizedGetValue(input) {
    if (!input || typeof input !== "function" && typeof input !== "object") {
      return getValue(input);
    }
    if (cache.has(input)) {
      return cache.get(input);
    }
    var value = getValue(input);
    cache.set(input, value);
    return value;
  }
  return memoizedGetValue;
}
function _normalizeArg(val) {
  if (!val) {
    return _emptyObject;
  } else if (typeof val === "object" || typeof val === "function") {
    return val;
  } else if (!_dictionary[val]) {
    _dictionary[val] = { val };
  }
  return _dictionary[val];
}
function _createNode() {
  return {
    map: _weakMap ? new _weakMap() : null
  };
}
function createComposedComponent(outer) {
  var Outer = outer;
  var outerMemoizer = createMemoizer(function(inner) {
    if (outer === inner) {
      throw new Error("Attempted to compose a component with itself.");
    }
    var Inner = inner;
    var innerMemoizer = createMemoizer(function(defaultRender) {
      var InnerWithDefaultRender = function(innerProps) {
        return React__namespace.createElement(Inner, __assign$1({}, innerProps, { defaultRender }));
      };
      return InnerWithDefaultRender;
    });
    var OuterWithDefaultRender = function(outerProps) {
      var defaultRender = outerProps.defaultRender;
      return React__namespace.createElement(Outer, __assign$1({}, outerProps, { defaultRender: defaultRender ? innerMemoizer(defaultRender) : Inner }));
    };
    return OuterWithDefaultRender;
  });
  return outerMemoizer;
}
var componentAsMemoizer = createMemoizer(createComposedComponent);
function composeComponentAs(outer, inner) {
  return componentAsMemoizer(outer)(inner);
}
function isControlled(props, valueProp) {
  return props[valueProp] !== void 0 && props[valueProp] !== null;
}
function css$3() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var classes = [];
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var arg = args_1[_a2];
    if (arg) {
      if (typeof arg === "string") {
        classes.push(arg);
      } else if (arg.hasOwnProperty("toString") && typeof arg.toString === "function") {
        classes.push(arg.toString());
      } else {
        for (var key in arg) {
          if (arg[key]) {
            classes.push(key);
          }
        }
      }
    }
  }
  return classes.join(" ");
}
var CustomizationsGlobalKey = "customizations";
var NO_CUSTOMIZATIONS = { settings: {}, scopedSettings: {}, inCustomizerContext: false };
var _allSettings = GlobalSettings.getValue(CustomizationsGlobalKey, {
  settings: {},
  scopedSettings: {},
  inCustomizerContext: false
});
var _events = [];
var Customizations = (
  /** @class */
  function() {
    function Customizations2() {
    }
    Customizations2.reset = function() {
      _allSettings.settings = {};
      _allSettings.scopedSettings = {};
    };
    Customizations2.applySettings = function(settings) {
      _allSettings.settings = __assign$1(__assign$1({}, _allSettings.settings), settings);
      Customizations2._raiseChange();
    };
    Customizations2.applyScopedSettings = function(scopeName, settings) {
      _allSettings.scopedSettings[scopeName] = __assign$1(__assign$1({}, _allSettings.scopedSettings[scopeName]), settings);
      Customizations2._raiseChange();
    };
    Customizations2.getSettings = function(properties, scopeName, localSettings) {
      if (localSettings === void 0) {
        localSettings = NO_CUSTOMIZATIONS;
      }
      var settings = {};
      var localScopedSettings = scopeName && localSettings.scopedSettings[scopeName] || {};
      var globalScopedSettings = scopeName && _allSettings.scopedSettings[scopeName] || {};
      for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
        var property = properties_1[_i];
        settings[property] = localScopedSettings[property] || localSettings.settings[property] || globalScopedSettings[property] || _allSettings.settings[property];
      }
      return settings;
    };
    Customizations2.applyBatchedUpdates = function(code, suppressUpdate) {
      Customizations2._suppressUpdates = true;
      try {
        code();
      } catch (_a2) {
      }
      Customizations2._suppressUpdates = false;
      if (!suppressUpdate) {
        Customizations2._raiseChange();
      }
    };
    Customizations2.observe = function(onChange2) {
      _events.push(onChange2);
    };
    Customizations2.unobserve = function(onChange2) {
      _events = _events.filter(function(cb) {
        return cb !== onChange2;
      });
    };
    Customizations2._raiseChange = function() {
      if (!Customizations2._suppressUpdates) {
        _events.forEach(function(cb) {
          return cb();
        });
      }
    };
    return Customizations2;
  }()
);
var CustomizerContext = React__namespace.createContext({
  customizations: {
    inCustomizerContext: false,
    settings: {},
    scopedSettings: {}
  }
});
function mergeSettings(oldSettings, newSettings) {
  if (oldSettings === void 0) {
    oldSettings = {};
  }
  var mergeSettingsWith = _isSettingsFunction(newSettings) ? newSettings : _settingsMergeWith(newSettings);
  return mergeSettingsWith(oldSettings);
}
function mergeScopedSettings(oldSettings, newSettings) {
  if (oldSettings === void 0) {
    oldSettings = {};
  }
  var mergeSettingsWith = _isSettingsFunction(newSettings) ? newSettings : _scopedSettingsMergeWith(newSettings);
  return mergeSettingsWith(oldSettings);
}
function _isSettingsFunction(settings) {
  return typeof settings === "function";
}
function _settingsMergeWith(newSettings) {
  return function(settings) {
    return newSettings ? __assign$1(__assign$1({}, settings), newSettings) : settings;
  };
}
function _scopedSettingsMergeWith(scopedSettingsFromProps) {
  if (scopedSettingsFromProps === void 0) {
    scopedSettingsFromProps = {};
  }
  return function(oldScopedSettings) {
    var newScopedSettings = __assign$1({}, oldScopedSettings);
    for (var scopeName in scopedSettingsFromProps) {
      if (scopedSettingsFromProps.hasOwnProperty(scopeName)) {
        newScopedSettings[scopeName] = __assign$1(__assign$1({}, oldScopedSettings[scopeName]), scopedSettingsFromProps[scopeName]);
      }
    }
    return newScopedSettings;
  };
}
function mergeCustomizations(props, parentContext) {
  var _a2 = (parentContext || {}).customizations, customizations = _a2 === void 0 ? { settings: {}, scopedSettings: {} } : _a2;
  return {
    customizations: {
      settings: mergeSettings(customizations.settings, props.settings),
      scopedSettings: mergeScopedSettings(customizations.scopedSettings, props.scopedSettings),
      inCustomizerContext: true
    }
  };
}
var Customizer = (
  /** @class */
  function(_super) {
    __extends(Customizer2, _super);
    function Customizer2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._onCustomizationChange = function() {
        return _this.forceUpdate();
      };
      return _this;
    }
    Customizer2.prototype.componentDidMount = function() {
      Customizations.observe(this._onCustomizationChange);
    };
    Customizer2.prototype.componentWillUnmount = function() {
      Customizations.unobserve(this._onCustomizationChange);
    };
    Customizer2.prototype.render = function() {
      var _this = this;
      var contextTransform = this.props.contextTransform;
      return React__namespace.createElement(CustomizerContext.Consumer, null, function(parentContext) {
        var newContext = mergeCustomizations(_this.props, parentContext);
        if (contextTransform) {
          newContext = contextTransform(newContext);
        }
        return React__namespace.createElement(CustomizerContext.Provider, { value: newContext }, _this.props.children);
      });
    };
    return Customizer2;
  }(React__namespace.Component)
);
function hoistStatics(source, dest) {
  for (var name_1 in source) {
    if (source.hasOwnProperty(name_1)) {
      dest[name_1] = source[name_1];
    }
  }
  return dest;
}
function customizable(scope, fields, concatStyles) {
  return function customizableFactory(ComposedComponent) {
    var _a2;
    var resultClass = (_a2 = /** @class */
    function(_super) {
      __extends(ComponentWithInjectedProps, _super);
      function ComponentWithInjectedProps(props) {
        var _this = _super.call(this, props) || this;
        _this._styleCache = {};
        _this._onSettingChanged = _this._onSettingChanged.bind(_this);
        return _this;
      }
      ComponentWithInjectedProps.prototype.componentDidMount = function() {
        Customizations.observe(this._onSettingChanged);
      };
      ComponentWithInjectedProps.prototype.componentWillUnmount = function() {
        Customizations.unobserve(this._onSettingChanged);
      };
      ComponentWithInjectedProps.prototype.render = function() {
        var _this = this;
        return React__namespace.createElement(CustomizerContext.Consumer, null, function(context) {
          var defaultProps2 = Customizations.getSettings(fields, scope, context.customizations);
          var componentProps = _this.props;
          if (defaultProps2.styles && typeof defaultProps2.styles === "function") {
            defaultProps2.styles = defaultProps2.styles(__assign$1(__assign$1({}, defaultProps2), componentProps));
          }
          if (concatStyles && defaultProps2.styles) {
            if (_this._styleCache.default !== defaultProps2.styles || _this._styleCache.component !== componentProps.styles) {
              var mergedStyles = concatStyleSets(defaultProps2.styles, componentProps.styles);
              _this._styleCache.default = defaultProps2.styles;
              _this._styleCache.component = componentProps.styles;
              _this._styleCache.merged = mergedStyles;
            }
            return React__namespace.createElement(ComposedComponent, __assign$1({}, defaultProps2, componentProps, { styles: _this._styleCache.merged }));
          }
          return React__namespace.createElement(ComposedComponent, __assign$1({}, defaultProps2, componentProps));
        });
      };
      ComponentWithInjectedProps.prototype._onSettingChanged = function() {
        this.forceUpdate();
      };
      return ComponentWithInjectedProps;
    }(React__namespace.Component), _a2.displayName = "Customized" + scope, _a2);
    return hoistStatics(ComposedComponent, resultClass);
  };
}
function useCustomizationSettings(properties, scopeName) {
  var forceUpdate = useForceUpdate();
  var customizations = React__namespace.useContext(CustomizerContext).customizations;
  var inCustomizerContext = customizations.inCustomizerContext;
  React__namespace.useEffect(function() {
    if (!inCustomizerContext) {
      Customizations.observe(forceUpdate);
    }
    return function() {
      if (!inCustomizerContext) {
        Customizations.unobserve(forceUpdate);
      }
    };
  }, [inCustomizerContext]);
  return Customizations.getSettings(properties, scopeName, customizations);
}
function useForceUpdate() {
  var _a2 = React__namespace.useState(0), setValue = _a2[1];
  return function() {
    return setValue(function(value) {
      return ++value;
    });
  };
}
function extendComponent(parent, methods) {
  for (var name_1 in methods) {
    if (methods.hasOwnProperty(name_1)) {
      parent[name_1] = appendFunction(parent, parent[name_1], methods[name_1]);
    }
  }
}
var CURRENT_ID_PROPERTY = "__currentId__";
var DEFAULT_ID_STRING = "id__";
var _global = getWindow$1() || {};
if (_global[CURRENT_ID_PROPERTY] === void 0) {
  _global[CURRENT_ID_PROPERTY] = 0;
}
var _initializedStylesheetResets = false;
function getId(prefix2) {
  if (!_initializedStylesheetResets) {
    var stylesheet2 = Stylesheet.getInstance();
    if (stylesheet2 && stylesheet2.onReset) {
      stylesheet2.onReset(resetIds);
    }
    _initializedStylesheetResets = true;
  }
  var index2 = _global[CURRENT_ID_PROPERTY]++;
  return (prefix2 === void 0 ? DEFAULT_ID_STRING : prefix2) + index2;
}
function resetIds(counter) {
  if (counter === void 0) {
    counter = 0;
  }
  _global[CURRENT_ID_PROPERTY] = counter;
}
var toObjectMap = function() {
  var items = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    items[_i] = arguments[_i];
  }
  var result = {};
  for (var _a2 = 0, items_1 = items; _a2 < items_1.length; _a2++) {
    var item = items_1[_a2];
    var keys2 = Array.isArray(item) ? item : Object.keys(item);
    for (var _b2 = 0, keys_1 = keys2; _b2 < keys_1.length; _b2++) {
      var key = keys_1[_b2];
      result[key] = 1;
    }
  }
  return result;
};
var baseElementEvents = toObjectMap([
  "onCopy",
  "onCut",
  "onPaste",
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate",
  "onFocus",
  "onFocusCapture",
  "onBlur",
  "onBlurCapture",
  "onChange",
  "onInput",
  "onSubmit",
  "onLoad",
  "onError",
  "onKeyDown",
  "onKeyDownCapture",
  "onKeyPress",
  "onKeyUp",
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting",
  "onClick",
  "onClickCapture",
  "onContextMenu",
  "onDoubleClick",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseDownCapture",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  "onMouseUpCapture",
  "onSelect",
  "onTouchCancel",
  "onTouchEnd",
  "onTouchMove",
  "onTouchStart",
  "onScroll",
  "onWheel",
  "onPointerCancel",
  "onPointerDown",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerMove",
  "onPointerOut",
  "onPointerOver",
  "onPointerUp",
  "onGotPointerCapture",
  "onLostPointerCapture"
]);
var baseElementProperties = toObjectMap([
  "accessKey",
  "children",
  "className",
  "contentEditable",
  "dir",
  "draggable",
  "hidden",
  "htmlFor",
  "id",
  "lang",
  "ref",
  "role",
  "style",
  "tabIndex",
  "title",
  "translate",
  "spellCheck",
  "name"
  // global
]);
var htmlElementProperties = toObjectMap(baseElementProperties, baseElementEvents);
var labelProperties = toObjectMap(htmlElementProperties, [
  "form"
  // button, fieldset, input, label, meter, object, output, select, textarea
]);
var audioProperties = toObjectMap(htmlElementProperties, [
  "height",
  "loop",
  "muted",
  "preload",
  "src",
  "width"
  // canvas, embed, iframe, img, input, object, video
]);
var videoProperties = toObjectMap(audioProperties, [
  "poster"
  // video
]);
var olProperties = toObjectMap(htmlElementProperties, [
  "start"
  // ol
]);
var liProperties = toObjectMap(htmlElementProperties, [
  "value"
  // button, input, li, option, meter, progress, param
]);
var anchorProperties = toObjectMap(htmlElementProperties, [
  "download",
  "href",
  "hrefLang",
  "media",
  "rel",
  "target",
  "type"
  // a, button, input, link, menu, object, script, source, style
]);
var buttonProperties = toObjectMap(htmlElementProperties, [
  "autoFocus",
  "disabled",
  "form",
  "formAction",
  "formEncType",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "type",
  "value"
  // button, input, li, option, meter, progress, param,
]);
var inputProperties = toObjectMap(buttonProperties, [
  "accept",
  "alt",
  "autoCapitalize",
  "autoComplete",
  "checked",
  "dirname",
  "form",
  "height",
  "inputMode",
  "list",
  "max",
  "maxLength",
  "min",
  "minLength",
  "multiple",
  "pattern",
  "placeholder",
  "readOnly",
  "required",
  "src",
  "step",
  "size",
  "type",
  "value",
  "width"
  // canvas, embed, iframe, img, input, object, video
]);
var textAreaProperties = toObjectMap(buttonProperties, [
  "autoCapitalize",
  "cols",
  "dirname",
  "form",
  "maxLength",
  "minLength",
  "placeholder",
  "readOnly",
  "required",
  "rows",
  "wrap"
  // textarea
]);
var selectProperties = toObjectMap(buttonProperties, [
  "form",
  "multiple",
  "required"
  // input, select, textarea
]);
var optionProperties = toObjectMap(htmlElementProperties, [
  "selected",
  "value"
  // button, input, li, option, meter, progress, param
]);
var tableProperties = toObjectMap(htmlElementProperties, [
  "cellPadding",
  "cellSpacing"
  // table
]);
var trProperties = htmlElementProperties;
var thProperties = toObjectMap(htmlElementProperties, [
  "rowSpan",
  "scope"
  // th
]);
var tdProperties = toObjectMap(htmlElementProperties, [
  "colSpan",
  "headers",
  "rowSpan",
  "scope"
  // th
]);
var colGroupProperties = toObjectMap(htmlElementProperties, [
  "span"
  // col, colgroup
]);
var colProperties = toObjectMap(htmlElementProperties, [
  "span"
  // col, colgroup
]);
var formProperties = toObjectMap(htmlElementProperties, [
  "acceptCharset",
  "action",
  "encType",
  "encType",
  "method",
  "noValidate",
  "target"
  // form
]);
var iframeProperties = toObjectMap(htmlElementProperties, [
  "allow",
  "allowFullScreen",
  "allowPaymentRequest",
  "allowTransparency",
  "csp",
  "height",
  "importance",
  "referrerPolicy",
  "sandbox",
  "src",
  "srcDoc",
  "width"
  // canvas, embed, iframe, img, input, object, video,
]);
var imgProperties = toObjectMap(htmlElementProperties, [
  "alt",
  "crossOrigin",
  "height",
  "src",
  "srcSet",
  "useMap",
  "width"
  // canvas, embed, iframe, img, input, object, video
]);
var divProperties = htmlElementProperties;
function getNativeProps(props, allowedPropNames, excludedPropNames) {
  var isArray2 = Array.isArray(allowedPropNames);
  var result = {};
  var keys2 = Object.keys(props);
  for (var _i = 0, keys_2 = keys2; _i < keys_2.length; _i++) {
    var key = keys_2[_i];
    var isNativeProp = !isArray2 && allowedPropNames[key] || isArray2 && allowedPropNames.indexOf(key) >= 0 || key.indexOf("data-") === 0 || key.indexOf("aria-") === 0;
    if (isNativeProp && (!excludedPropNames || (excludedPropNames === null || excludedPropNames === void 0 ? void 0 : excludedPropNames.indexOf(key)) === -1)) {
      result[key] = props[key];
    }
  }
  return result;
}
var nativeElementMap = {
  label: labelProperties,
  audio: audioProperties,
  video: videoProperties,
  ol: olProperties,
  li: liProperties,
  a: anchorProperties,
  button: buttonProperties,
  input: inputProperties,
  textarea: textAreaProperties,
  select: selectProperties,
  option: optionProperties,
  table: tableProperties,
  tr: trProperties,
  th: thProperties,
  td: tdProperties,
  colGroup: colGroupProperties,
  col: colProperties,
  form: formProperties,
  iframe: iframeProperties,
  img: imgProperties
};
function getNativeElementProps(tagName, props, excludedPropNames) {
  var allowedPropNames = tagName && nativeElementMap[tagName] || htmlElementProperties;
  return getNativeProps(props, allowedPropNames, excludedPropNames);
}
var REACT_LIFECYCLE_EXCLUSIONS = [
  "setState",
  "render",
  "componentWillMount",
  "UNSAFE_componentWillMount",
  "componentDidMount",
  "componentWillReceiveProps",
  "UNSAFE_componentWillReceiveProps",
  "shouldComponentUpdate",
  "componentWillUpdate",
  "getSnapshotBeforeUpdate",
  "UNSAFE_componentWillUpdate",
  "componentDidUpdate",
  "componentWillUnmount"
];
function hoistMethods(destination, source, exclusions) {
  if (exclusions === void 0) {
    exclusions = REACT_LIFECYCLE_EXCLUSIONS;
  }
  var hoisted = [];
  var _loop_1 = function(methodName2) {
    if (typeof source[methodName2] === "function" && destination[methodName2] === void 0 && (!exclusions || exclusions.indexOf(methodName2) === -1)) {
      hoisted.push(methodName2);
      destination[methodName2] = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        source[methodName2].apply(source, args);
      };
    }
  };
  for (var methodName in source) {
    _loop_1(methodName);
  }
  return hoisted;
}
function unhoistMethods(source, methodNames) {
  methodNames.forEach(function(methodName) {
    return delete source[methodName];
  });
}
function initializeComponentRef(obj) {
  extendComponent(obj, {
    componentDidMount: _onMount,
    componentDidUpdate: _onUpdate,
    componentWillUnmount: _onUnmount
  });
}
function _onMount() {
  _setComponentRef(this.props.componentRef, this);
}
function _onUpdate(prevProps) {
  if (prevProps.componentRef !== this.props.componentRef) {
    _setComponentRef(prevProps.componentRef, null);
    _setComponentRef(this.props.componentRef, this);
  }
}
function _onUnmount() {
  _setComponentRef(this.props.componentRef, null);
}
function _setComponentRef(componentRef, value) {
  if (componentRef) {
    if (typeof componentRef === "object") {
      componentRef.current = value;
    } else if (typeof componentRef === "function") {
      componentRef(value);
    }
  }
}
var _a$7;
var DirectionalKeyCodes = (_a$7 = {}, _a$7[KeyCodes.up] = 1, _a$7[KeyCodes.down] = 1, _a$7[KeyCodes.left] = 1, _a$7[KeyCodes.right] = 1, _a$7[KeyCodes.home] = 1, _a$7[KeyCodes.end] = 1, _a$7[KeyCodes.tab] = 1, _a$7[KeyCodes.pageUp] = 1, _a$7[KeyCodes.pageDown] = 1, _a$7);
function isDirectionalKeyCode(which) {
  return !!DirectionalKeyCodes[which];
}
var IsFocusVisibleClassName = "ms-Fabric--isFocusVisible";
var IsFocusHiddenClassName = "ms-Fabric--isFocusHidden";
function updateClassList(el, enabled) {
  if (el) {
    el.classList.add(enabled ? IsFocusVisibleClassName : IsFocusHiddenClassName);
    el.classList.remove(enabled ? IsFocusHiddenClassName : IsFocusVisibleClassName);
  }
}
function setFocusVisibility(enabled, target, registeredProviders) {
  var _a2;
  if (registeredProviders) {
    registeredProviders.forEach(function(ref) {
      return updateClassList(ref.current, enabled);
    });
  } else {
    updateClassList((_a2 = getWindow$1(target)) === null || _a2 === void 0 ? void 0 : _a2.document.body, enabled);
  }
}
var mountCounters = /* @__PURE__ */ new WeakMap();
var callbackMap = /* @__PURE__ */ new WeakMap();
function setMountCounters(key, delta) {
  var newValue;
  var currValue = mountCounters.get(key);
  if (currValue) {
    newValue = currValue + delta;
  } else {
    newValue = 1;
  }
  mountCounters.set(key, newValue);
  return newValue;
}
function setCallbackMap(context) {
  var callbacks = callbackMap.get(context);
  if (callbacks) {
    return callbacks;
  }
  var onMouseDown = function(ev) {
    return _onMouseDown(ev, context.registeredProviders);
  };
  var onPointerDown = function(ev) {
    return _onPointerDown(ev, context.registeredProviders);
  };
  var onKeyDown = function(ev) {
    return _onKeyDown(ev, context.registeredProviders);
  };
  var onKeyUp = function(ev) {
    return _onKeyUp(ev, context.registeredProviders);
  };
  callbacks = { onMouseDown, onPointerDown, onKeyDown, onKeyUp };
  callbackMap.set(context, callbacks);
  return callbacks;
}
var FocusRectsContext = React__namespace.createContext(void 0);
function useFocusRects(rootRef) {
  var context = React__namespace.useContext(FocusRectsContext);
  React__namespace.useEffect(function() {
    var _a2, _b2;
    var win2 = getWindow$1(rootRef === null || rootRef === void 0 ? void 0 : rootRef.current);
    if (!win2 || ((_a2 = win2.FabricConfig) === null || _a2 === void 0 ? void 0 : _a2.disableFocusRects) === true) {
      return void 0;
    }
    var el = win2;
    var onMouseDown;
    var onPointerDown;
    var onKeyDown;
    var onKeyUp;
    if ((_b2 = context === null || context === void 0 ? void 0 : context.providerRef) === null || _b2 === void 0 ? void 0 : _b2.current) {
      el = context.providerRef.current;
      var callbacks = setCallbackMap(context);
      onMouseDown = callbacks.onMouseDown;
      onPointerDown = callbacks.onPointerDown;
      onKeyDown = callbacks.onKeyDown;
      onKeyUp = callbacks.onKeyUp;
    } else {
      onMouseDown = _onMouseDown;
      onPointerDown = _onPointerDown;
      onKeyDown = _onKeyDown;
      onKeyUp = _onKeyUp;
    }
    var count = setMountCounters(el, 1);
    if (count <= 1) {
      el.addEventListener("mousedown", onMouseDown, true);
      el.addEventListener("pointerdown", onPointerDown, true);
      el.addEventListener("keydown", onKeyDown, true);
      el.addEventListener("keyup", onKeyUp, true);
    }
    return function() {
      var _a3;
      if (!win2 || ((_a3 = win2.FabricConfig) === null || _a3 === void 0 ? void 0 : _a3.disableFocusRects) === true) {
        return;
      }
      count = setMountCounters(el, -1);
      if (count === 0) {
        el.removeEventListener("mousedown", onMouseDown, true);
        el.removeEventListener("pointerdown", onPointerDown, true);
        el.removeEventListener("keydown", onKeyDown, true);
        el.removeEventListener("keyup", onKeyUp, true);
      }
    };
  }, [context, rootRef]);
}
var FocusRects = function(props) {
  useFocusRects(props.rootRef);
  return null;
};
function _onMouseDown(ev, registeredProviders) {
  setFocusVisibility(false, ev.target, registeredProviders);
}
function _onPointerDown(ev, registeredProviders) {
  if (ev.pointerType !== "mouse") {
    setFocusVisibility(false, ev.target, registeredProviders);
  }
}
function _onKeyDown(ev, registeredProviders) {
  if (isDirectionalKeyCode(ev.which)) {
    setFocusVisibility(true, ev.target, registeredProviders);
  }
}
function _onKeyUp(ev, registeredProviders) {
  if (isDirectionalKeyCode(ev.which)) {
    setFocusVisibility(true, ev.target, registeredProviders);
  }
}
var FocusRectsProvider = function(props) {
  var providerRef = props.providerRef, layerRoot = props.layerRoot;
  var registeredProviders = React__namespace.useState([])[0];
  var parentContext = React__namespace.useContext(FocusRectsContext);
  var inheritParentContext = parentContext !== void 0 && !layerRoot;
  var context = React__namespace.useMemo(function() {
    return inheritParentContext ? void 0 : {
      providerRef,
      registeredProviders,
      registerProvider: function(ref) {
        registeredProviders.push(ref);
        parentContext === null || parentContext === void 0 ? void 0 : parentContext.registerProvider(ref);
      },
      unregisterProvider: function(ref) {
        parentContext === null || parentContext === void 0 ? void 0 : parentContext.unregisterProvider(ref);
        var i = registeredProviders.indexOf(ref);
        if (i >= 0) {
          registeredProviders.splice(i, 1);
        }
      }
    };
  }, [providerRef, registeredProviders, parentContext, inheritParentContext]);
  React__namespace.useEffect(function() {
    if (context) {
      context.registerProvider(context.providerRef);
      return function() {
        return context.unregisterProvider(context.providerRef);
      };
    }
  }, [context]);
  if (context) {
    return React__namespace.createElement(FocusRectsContext.Provider, { value: context }, props.children);
  } else {
    return React__namespace.createElement(React__namespace.Fragment, null, props.children);
  }
};
function getItem(key) {
  var result = null;
  try {
    var win2 = getWindow$1();
    result = win2 ? win2.localStorage.getItem(key) : null;
  } catch (e) {
  }
  return result;
}
var _language;
var STORAGE_KEY = "language";
function getLanguage(persistenceType) {
  if (persistenceType === void 0) {
    persistenceType = "sessionStorage";
  }
  if (_language === void 0) {
    var doc = getDocument();
    var savedLanguage = persistenceType === "localStorage" ? getItem(STORAGE_KEY) : persistenceType === "sessionStorage" ? getItem$1(STORAGE_KEY) : void 0;
    if (savedLanguage) {
      _language = savedLanguage;
    }
    if (_language === void 0 && doc) {
      _language = doc.documentElement.getAttribute("lang");
    }
    if (_language === void 0) {
      _language = "en";
    }
  }
  return _language;
}
function getDistanceBetweenPoints(point1, point2) {
  var left1 = point1.left || point1.x || 0;
  var top1 = point1.top || point1.y || 0;
  var left2 = point2.left || point2.x || 0;
  var top2 = point2.top || point2.y || 0;
  var distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));
  return distance;
}
function calculatePrecision(value) {
  var groups = /[1-9]([0]+$)|\.([0-9]*)/.exec(String(value));
  if (!groups) {
    return 0;
  }
  if (groups[1]) {
    return -groups[1].length;
  }
  if (groups[2]) {
    return groups[2].length;
  }
  return 0;
}
function precisionRound(value, precision, base) {
  if (base === void 0) {
    base = 10;
  }
  var exp = Math.pow(base, precision);
  return Math.round(value * exp) / exp;
}
function merge$1(target) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var arg = args_1[_a2];
    _merge(target || {}, arg);
  }
  return target;
}
function _merge(target, source, circularReferences) {
  if (circularReferences === void 0) {
    circularReferences = [];
  }
  circularReferences.push(source);
  for (var name_1 in source) {
    if (source.hasOwnProperty(name_1)) {
      if (name_1 !== "__proto__" && name_1 !== "constructor" && name_1 !== "prototype") {
        var value = source[name_1];
        if (typeof value === "object" && value !== null && !Array.isArray(value)) {
          var isCircularReference = circularReferences.indexOf(value) > -1;
          target[name_1] = isCircularReference ? value : _merge(target[name_1] || {}, value, circularReferences);
        } else {
          target[name_1] = value;
        }
      }
    }
  }
  circularReferences.pop();
  return target;
}
var isIOS = function() {
  if (!window || !window.navigator || !window.navigator.userAgent) {
    return false;
  }
  return /iPad|iPhone|iPod/i.test(window.navigator.userAgent);
};
var tagsToIgnore = ["TEMPLATE", "STYLE", "SCRIPT"];
function modalize(target) {
  var targetDocument = getDocument(target);
  if (!targetDocument) {
    return function() {
      return void 0;
    };
  }
  var affectedNodes = [];
  while (target !== targetDocument.body && target.parentElement) {
    for (var _i = 0, _a2 = target.parentElement.children; _i < _a2.length; _i++) {
      var sibling = _a2[_i];
      var ariaHidden = sibling.getAttribute("aria-hidden");
      if (sibling !== target && (ariaHidden === null || ariaHidden === void 0 ? void 0 : ariaHidden.toLowerCase()) !== "true" && tagsToIgnore.indexOf(sibling.tagName) === -1) {
        affectedNodes.push([sibling, ariaHidden]);
      }
    }
    target = target.parentElement;
  }
  affectedNodes.forEach(function(_a3) {
    var node2 = _a3[0];
    node2.setAttribute("aria-hidden", "true");
  });
  return function() {
    unmodalize(affectedNodes);
    affectedNodes = [];
  };
}
function unmodalize(affectedNodes) {
  affectedNodes.forEach(function(_a2) {
    var node2 = _a2[0], originalValue = _a2[1];
    if (originalValue) {
      node2.setAttribute("aria-hidden", originalValue);
    } else {
      node2.removeAttribute("aria-hidden");
    }
  });
}
var isMacResult;
function isMac(reset) {
  var _a2;
  if (typeof isMacResult === "undefined" || reset) {
    var win2 = getWindow$1();
    var userAgent = (_a2 = win2 === null || win2 === void 0 ? void 0 : win2.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent;
    isMacResult = !!userAgent && userAgent.indexOf("Macintosh") !== -1;
  }
  return !!isMacResult;
}
function hasHorizontalOverflow(element) {
  return element.clientWidth < element.scrollWidth;
}
function hasVerticalOverflow(element) {
  return element.clientHeight < element.scrollHeight;
}
function hasOverflow(element) {
  return hasHorizontalOverflow(element) || hasVerticalOverflow(element);
}
function createComposedRenderFunction(outer) {
  var outerMemoizer = createMemoizer(function(inner) {
    var innerMemoizer = createMemoizer(function(defaultRender) {
      return function(innerProps) {
        return inner(innerProps, defaultRender);
      };
    });
    return function(outerProps, defaultRender) {
      return outer(outerProps, defaultRender ? innerMemoizer(defaultRender) : inner);
    };
  });
  return outerMemoizer;
}
var memoizer = createMemoizer(createComposedRenderFunction);
function composeRenderFunction(outer, inner) {
  return memoizer(outer)(inner);
}
var safeRequestAnimationFrame = function(component) {
  var activeTimeouts;
  return function(cb) {
    if (!activeTimeouts) {
      activeTimeouts = /* @__PURE__ */ new Set();
      extendComponent(component, {
        componentWillUnmount: function() {
          activeTimeouts.forEach(function(id) {
            return cancelAnimationFrame(id);
          });
        }
      });
    }
    var timeoutId = requestAnimationFrame(function() {
      activeTimeouts.delete(timeoutId);
      cb();
    });
    activeTimeouts.add(timeoutId);
  };
};
var SELECTION_CHANGE = "change";
var SELECTION_ITEMS_CHANGE = "items-change";
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2[SelectionMode2["none"] = 0] = "none";
  SelectionMode2[SelectionMode2["single"] = 1] = "single";
  SelectionMode2[SelectionMode2["multiple"] = 2] = "multiple";
})(SelectionMode || (SelectionMode = {}));
var SelectionDirection;
(function(SelectionDirection2) {
  SelectionDirection2[SelectionDirection2["horizontal"] = 0] = "horizontal";
  SelectionDirection2[SelectionDirection2["vertical"] = 1] = "vertical";
})(SelectionDirection || (SelectionDirection = {}));
var Selection = (
  /** @class */
  function() {
    function Selection2() {
      var options2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        options2[_i] = arguments[_i];
      }
      var _a2 = options2[0] || {}, onSelectionChanged = _a2.onSelectionChanged, onItemsChanged = _a2.onItemsChanged, getKey = _a2.getKey, _b2 = _a2.canSelectItem, canSelectItem = _b2 === void 0 ? function() {
        return true;
      } : _b2, items = _a2.items, _c2 = _a2.selectionMode, selectionMode = _c2 === void 0 ? SelectionMode.multiple : _c2;
      this.mode = selectionMode;
      this._getKey = getKey || defaultGetKey;
      this._changeEventSuppressionCount = 0;
      this._exemptedCount = 0;
      this._anchoredIndex = 0;
      this._unselectableCount = 0;
      this._onSelectionChanged = onSelectionChanged;
      this._onItemsChanged = onItemsChanged;
      this._canSelectItem = canSelectItem;
      this._keyToIndexMap = {};
      this._isModal = false;
      this.setItems(items || [], true);
      this.count = this.getSelectedCount();
    }
    Selection2.prototype.canSelectItem = function(item, index2) {
      if (typeof index2 === "number" && index2 < 0) {
        return false;
      }
      return this._canSelectItem(item, index2);
    };
    Selection2.prototype.getKey = function(item, index2) {
      var key = this._getKey(item, index2);
      return typeof key === "number" || key ? "" + key : "";
    };
    Selection2.prototype.setChangeEvents = function(isEnabled, suppressChange) {
      this._changeEventSuppressionCount += isEnabled ? -1 : 1;
      if (this._changeEventSuppressionCount === 0 && this._hasChanged) {
        this._hasChanged = false;
        if (!suppressChange) {
          this._change();
        }
      }
    };
    Selection2.prototype.isModal = function() {
      return this._isModal;
    };
    Selection2.prototype.setModal = function(isModal) {
      if (this._isModal !== isModal) {
        this.setChangeEvents(false);
        this._isModal = isModal;
        if (!isModal) {
          this.setAllSelected(false);
        }
        this._change();
        this.setChangeEvents(true);
      }
    };
    Selection2.prototype.setItems = function(items, shouldClear) {
      if (shouldClear === void 0) {
        shouldClear = true;
      }
      var newKeyToIndexMap = {};
      var newUnselectableIndices = {};
      var hasSelectionChanged = false;
      this.setChangeEvents(false);
      this._unselectableCount = 0;
      var haveItemsChanged = false;
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        if (item) {
          var key = this.getKey(item, i);
          if (key) {
            if (!haveItemsChanged && (!(key in this._keyToIndexMap) || this._keyToIndexMap[key] !== i)) {
              haveItemsChanged = true;
            }
            newKeyToIndexMap[key] = i;
          }
        }
        newUnselectableIndices[i] = item && !this.canSelectItem(item);
        if (newUnselectableIndices[i]) {
          this._unselectableCount++;
        }
      }
      if (shouldClear || items.length === 0) {
        this._setAllSelected(false, true);
      }
      var newExemptedIndicies = {};
      var newExemptedCount = 0;
      for (var indexProperty in this._exemptedIndices) {
        if (this._exemptedIndices.hasOwnProperty(indexProperty)) {
          var index2 = Number(indexProperty);
          var item = this._items[index2];
          var exemptKey = item ? this.getKey(item, Number(index2)) : void 0;
          var newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index2;
          if (newIndex === void 0) {
            hasSelectionChanged = true;
          } else {
            newExemptedIndicies[newIndex] = true;
            newExemptedCount++;
            hasSelectionChanged = hasSelectionChanged || newIndex !== index2;
          }
        }
      }
      if (this._items && this._exemptedCount === 0 && items.length !== this._items.length && this._isAllSelected) {
        hasSelectionChanged = true;
      }
      if (!haveItemsChanged) {
        for (var _i = 0, _a2 = Object.keys(this._keyToIndexMap); _i < _a2.length; _i++) {
          var key = _a2[_i];
          if (!(key in newKeyToIndexMap)) {
            haveItemsChanged = true;
            break;
          }
        }
      }
      this._exemptedIndices = newExemptedIndicies;
      this._exemptedCount = newExemptedCount;
      this._keyToIndexMap = newKeyToIndexMap;
      this._unselectableIndices = newUnselectableIndices;
      this._items = items;
      this._selectedItems = null;
      if (hasSelectionChanged) {
        this._updateCount();
      }
      if (haveItemsChanged) {
        EventGroup.raise(this, SELECTION_ITEMS_CHANGE);
        if (this._onItemsChanged) {
          this._onItemsChanged();
        }
      }
      if (hasSelectionChanged) {
        this._change();
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype.getItems = function() {
      return this._items;
    };
    Selection2.prototype.getSelection = function() {
      if (!this._selectedItems) {
        this._selectedItems = [];
        var items = this._items;
        if (items) {
          for (var i = 0; i < items.length; i++) {
            if (this.isIndexSelected(i)) {
              this._selectedItems.push(items[i]);
            }
          }
        }
      }
      return this._selectedItems;
    };
    Selection2.prototype.getSelectedCount = function() {
      return this._isAllSelected ? this._items.length - this._exemptedCount - this._unselectableCount : this._exemptedCount;
    };
    Selection2.prototype.getSelectedIndices = function() {
      if (!this._selectedIndices) {
        this._selectedIndices = [];
        var items = this._items;
        if (items) {
          for (var i = 0; i < items.length; i++) {
            if (this.isIndexSelected(i)) {
              this._selectedIndices.push(i);
            }
          }
        }
      }
      return this._selectedIndices;
    };
    Selection2.prototype.getItemIndex = function(key) {
      var index2 = this._keyToIndexMap[key];
      return index2 !== null && index2 !== void 0 ? index2 : -1;
    };
    Selection2.prototype.isRangeSelected = function(fromIndex, count) {
      if (count === 0) {
        return false;
      }
      var endIndex = fromIndex + count;
      for (var i = fromIndex; i < endIndex; i++) {
        if (!this.isIndexSelected(i)) {
          return false;
        }
      }
      return true;
    };
    Selection2.prototype.isAllSelected = function() {
      var selectableCount = this._items.length - this._unselectableCount;
      if (this.mode === SelectionMode.single) {
        selectableCount = Math.min(selectableCount, 1);
      }
      return this.count > 0 && this._isAllSelected && this._exemptedCount === 0 || !this._isAllSelected && this._exemptedCount === selectableCount && selectableCount > 0;
    };
    Selection2.prototype.isKeySelected = function(key) {
      var index2 = this._keyToIndexMap[key];
      return this.isIndexSelected(index2);
    };
    Selection2.prototype.isIndexSelected = function(index2) {
      return !!(this.count > 0 && this._isAllSelected && !this._exemptedIndices[index2] && !this._unselectableIndices[index2] || !this._isAllSelected && this._exemptedIndices[index2]);
    };
    Selection2.prototype.setAllSelected = function(isAllSelected) {
      if (isAllSelected && this.mode !== SelectionMode.multiple) {
        return;
      }
      var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;
      this.setChangeEvents(false);
      if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {
        this._exemptedIndices = {};
        if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {
          this._exemptedCount = 0;
          this._isAllSelected = isAllSelected;
          this._change();
        }
        this._updateCount();
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype.setKeySelected = function(key, isSelected, shouldAnchor) {
      var index2 = this._keyToIndexMap[key];
      if (index2 >= 0) {
        this.setIndexSelected(index2, isSelected, shouldAnchor);
      }
    };
    Selection2.prototype.setIndexSelected = function(index2, isSelected, shouldAnchor) {
      if (this.mode === SelectionMode.none) {
        return;
      }
      index2 = Math.min(Math.max(0, index2), this._items.length - 1);
      if (index2 < 0 || index2 >= this._items.length) {
        return;
      }
      this.setChangeEvents(false);
      var isExempt = this._exemptedIndices[index2];
      var canSelect = !this._unselectableIndices[index2];
      if (canSelect) {
        if (isSelected && this.mode === SelectionMode.single) {
          this._setAllSelected(false, true);
        }
        if (isExempt && (isSelected && this._isAllSelected || !isSelected && !this._isAllSelected)) {
          delete this._exemptedIndices[index2];
          this._exemptedCount--;
        }
        if (!isExempt && (isSelected && !this._isAllSelected || !isSelected && this._isAllSelected)) {
          this._exemptedIndices[index2] = true;
          this._exemptedCount++;
        }
        if (shouldAnchor) {
          this._anchoredIndex = index2;
        }
      }
      this._updateCount();
      this.setChangeEvents(true);
    };
    Selection2.prototype.setRangeSelected = function(fromIndex, count, isSelected, shouldAnchor) {
      if (this.mode === SelectionMode.none) {
        return;
      }
      fromIndex = Math.min(Math.max(0, fromIndex), this._items.length - 1);
      count = Math.min(Math.max(0, count), this._items.length - fromIndex);
      if (fromIndex < 0 || fromIndex >= this._items.length || count === 0) {
        return;
      }
      this.setChangeEvents(false);
      var anchorIndex = this._anchoredIndex || 0;
      var startIndex = fromIndex;
      var endIndex = fromIndex + count - 1;
      var newAnchorIndex = anchorIndex >= endIndex ? startIndex : endIndex;
      for (; startIndex <= endIndex; startIndex++) {
        this.setIndexSelected(startIndex, isSelected, shouldAnchor ? startIndex === newAnchorIndex : false);
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype.selectToKey = function(key, clearSelection) {
      this.selectToIndex(this._keyToIndexMap[key], clearSelection);
    };
    Selection2.prototype.selectToRange = function(fromIndex, count, clearSelection) {
      if (this.mode === SelectionMode.none) {
        return;
      }
      if (this.mode === SelectionMode.single) {
        if (count === 1) {
          this.setIndexSelected(fromIndex, true, true);
        }
        return;
      }
      var anchorIndex = this._anchoredIndex || 0;
      var startIndex = Math.min(fromIndex, anchorIndex);
      var endIndex = Math.max(fromIndex + count - 1, anchorIndex);
      this.setChangeEvents(false);
      if (clearSelection) {
        this._setAllSelected(false, true);
      }
      for (; startIndex <= endIndex; startIndex++) {
        this.setIndexSelected(startIndex, true, false);
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype.selectToIndex = function(index2, clearSelection) {
      if (this.mode === SelectionMode.none) {
        return;
      }
      if (this.mode === SelectionMode.single) {
        this.setIndexSelected(index2, true, true);
        return;
      }
      var anchorIndex = this._anchoredIndex || 0;
      var startIndex = Math.min(index2, anchorIndex);
      var endIndex = Math.max(index2, anchorIndex);
      this.setChangeEvents(false);
      if (clearSelection) {
        this._setAllSelected(false, true);
      }
      for (; startIndex <= endIndex; startIndex++) {
        this.setIndexSelected(startIndex, true, false);
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype.toggleAllSelected = function() {
      this.setAllSelected(!this.isAllSelected());
    };
    Selection2.prototype.toggleKeySelected = function(key) {
      this.setKeySelected(key, !this.isKeySelected(key), true);
    };
    Selection2.prototype.toggleIndexSelected = function(index2) {
      this.setIndexSelected(index2, !this.isIndexSelected(index2), true);
    };
    Selection2.prototype.toggleRangeSelected = function(fromIndex, count) {
      if (this.mode === SelectionMode.none) {
        return;
      }
      var isRangeSelected = this.isRangeSelected(fromIndex, count);
      var endIndex = fromIndex + count;
      if (this.mode === SelectionMode.single && count > 1) {
        return;
      }
      this.setChangeEvents(false);
      for (var i = fromIndex; i < endIndex; i++) {
        this.setIndexSelected(i, !isRangeSelected, false);
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype._updateCount = function(preserveModalState) {
      if (preserveModalState === void 0) {
        preserveModalState = false;
      }
      var count = this.getSelectedCount();
      if (count !== this.count) {
        this.count = count;
        this._change();
      }
      if (!this.count && !preserveModalState) {
        this.setModal(false);
      }
    };
    Selection2.prototype._setAllSelected = function(isAllSelected, preserveModalState) {
      if (preserveModalState === void 0) {
        preserveModalState = false;
      }
      if (isAllSelected && this.mode !== SelectionMode.multiple) {
        return;
      }
      var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;
      this.setChangeEvents(false);
      if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {
        this._exemptedIndices = {};
        if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {
          this._exemptedCount = 0;
          this._isAllSelected = isAllSelected;
          this._change();
        }
        this._updateCount(preserveModalState);
      }
      this.setChangeEvents(true);
    };
    Selection2.prototype._change = function() {
      if (this._changeEventSuppressionCount === 0) {
        this._selectedItems = null;
        this._selectedIndices = void 0;
        EventGroup.raise(this, SELECTION_CHANGE);
        if (this._onSelectionChanged) {
          this._onSelectionChanged();
        }
      } else {
        this._hasChanged = true;
      }
    };
    return Selection2;
  }()
);
function defaultGetKey(item, index2) {
  var _a2 = (item || {}).key, key = _a2 === void 0 ? "" + index2 : _a2;
  return key;
}
var FORMAT_ARGS_REGEX = /[\{\}]/g;
var FORMAT_REGEX = /\{\d+\}/g;
function format$1(s) {
  var values2 = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    values2[_i - 1] = arguments[_i];
  }
  var args = values2;
  function replaceFunc(match2) {
    var replacement = args[match2.replace(FORMAT_ARGS_REGEX, "")];
    if (replacement === null || replacement === void 0) {
      replacement = "";
    }
    return replacement;
  }
  return s.replace(FORMAT_REGEX, replaceFunc);
}
var DefaultFields = ["theme", "styles"];
function styled(Component, baseStyles, getProps, customizable2, pure) {
  customizable2 = customizable2 || { scope: "", fields: void 0 };
  var scope = customizable2.scope, _a2 = customizable2.fields, fields = _a2 === void 0 ? DefaultFields : _a2;
  var Wrapped = React__namespace.forwardRef(function(props, forwardedRef) {
    var styles2 = React__namespace.useRef();
    var settings = useCustomizationSettings(fields, scope);
    var customizedStyles = settings.styles;
    settings.dir;
    var rest = __rest$1(settings, ["styles", "dir"]);
    var additionalProps = getProps ? getProps(props) : void 0;
    var cache = styles2.current && styles2.current.__cachedInputs__ || [];
    var propStyles = props.styles;
    if (!styles2.current || customizedStyles !== cache[1] || propStyles !== cache[2]) {
      var concatenatedStyles = function(styleProps) {
        return concatStyleSetsWithProps(styleProps, baseStyles, customizedStyles, propStyles);
      };
      concatenatedStyles.__cachedInputs__ = [
        baseStyles,
        customizedStyles,
        propStyles
      ];
      concatenatedStyles.__noStyleOverride__ = !customizedStyles && !propStyles;
      styles2.current = concatenatedStyles;
    }
    return React__namespace.createElement(Component, __assign$1({ ref: forwardedRef }, rest, additionalProps, props, { styles: styles2.current }));
  });
  Wrapped.displayName = "Styled" + (Component.displayName || Component.name);
  var pureComponent = pure ? React__namespace.memo(Wrapped) : Wrapped;
  if (Wrapped.displayName) {
    pureComponent.displayName = Wrapped.displayName;
  }
  return pureComponent;
}
var warningsMap;
if (process.env.NODE_ENV !== "production") {
  warningsMap = {
    valueOnChange: {},
    valueDefaultValue: {},
    controlledToUncontrolled: {},
    uncontrolledToControlled: {}
  };
}
function warnControlledUsage(params) {
  if (process.env.NODE_ENV !== "production") {
    var componentId = params.componentId, componentName = params.componentName, defaultValueProp = params.defaultValueProp, props = params.props, oldProps = params.oldProps, onChangeProp = params.onChangeProp, readOnlyProp = params.readOnlyProp, valueProp = params.valueProp;
    var oldIsControlled = oldProps ? isControlled(oldProps, valueProp) : void 0;
    var newIsControlled = isControlled(props, valueProp);
    if (newIsControlled) {
      var hasOnChange = !!props[onChangeProp];
      var isReadOnly = !!(readOnlyProp && props[readOnlyProp]);
      if (!(hasOnChange || isReadOnly) && !warningsMap.valueOnChange[componentId]) {
        warningsMap.valueOnChange[componentId] = true;
        warn("Warning: You provided a '" + valueProp + "' prop to a " + componentName + " without an '" + onChangeProp + "' handler. " + ("This will render a read-only field. If the field should be mutable use '" + defaultValueProp + "'. ") + ("Otherwise, set '" + onChangeProp + "'" + (readOnlyProp ? " or '" + readOnlyProp + "'" : "") + "."));
      }
      var defaultValue = props[defaultValueProp];
      if (defaultValue !== void 0 && defaultValue !== null && !warningsMap.valueDefaultValue[componentId]) {
        warningsMap.valueDefaultValue[componentId] = true;
        warn("Warning: You provided both '" + valueProp + "' and '" + defaultValueProp + "' to a " + componentName + ". " + ("Form fields must be either controlled or uncontrolled (specify either the '" + valueProp + "' prop, ") + ("or the '" + defaultValueProp + "' prop, but not both). Decide between using a controlled or uncontrolled ") + (componentName + " and remove one of these props. More info: https://fb.me/react-controlled-components"));
      }
    }
    if (oldProps && newIsControlled !== oldIsControlled) {
      var oldType = oldIsControlled ? "a controlled" : "an uncontrolled";
      var newType = oldIsControlled ? "uncontrolled" : "controlled";
      var warnMap = oldIsControlled ? warningsMap.controlledToUncontrolled : warningsMap.uncontrolledToControlled;
      if (!warnMap[componentId]) {
        warnMap[componentId] = true;
        warn("Warning: A component is changing " + oldType + " " + componentName + " to be " + newType + ". " + (componentName + "s should not switch from controlled to uncontrolled (or vice versa). ") + "Decide between using controlled or uncontrolled for the lifetime of the component. More info: https://fb.me/react-controlled-components");
      }
    }
  }
}
var isIE11 = function() {
  var _a2;
  var win2 = getWindow$1();
  if (!((_a2 = win2 === null || win2 === void 0 ? void 0 : win2.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent)) {
    return false;
  }
  return win2.navigator.userAgent.indexOf("rv:11.0") > -1;
};
function getPropsWithDefaults(defaultProps2, propsWithoutDefaults) {
  var props = __assign$1({}, propsWithoutDefaults);
  for (var _i = 0, _a2 = Object.keys(defaultProps2); _i < _a2.length; _i++) {
    var key = _a2[_i];
    if (props[key] === void 0) {
      props[key] = defaultProps2[key];
    }
  }
  return props;
}
var createResolver = function(local) {
  return function(newValue) {
    for (var _i = 0, _a2 = local.refs; _i < _a2.length; _i++) {
      var ref = _a2[_i];
      if (typeof ref === "function") {
        ref(newValue);
      } else if (ref) {
        ref.current = newValue;
      }
    }
  };
};
var createMergedRef = function(value) {
  var local = {
    refs: []
  };
  return function() {
    var newRefs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newRefs[_i] = arguments[_i];
    }
    if (!local.resolver || !arraysEqual(local.refs, newRefs)) {
      local.resolver = createResolver(local);
    }
    local.refs = newRefs;
    return local.resolver;
  };
};
var useIsomorphicLayoutEffect = canUseDOM$1() ? React__namespace.useLayoutEffect : React__namespace.useEffect;
var ICON_SETTING_NAME = "icons";
var _iconSettings = GlobalSettings.getValue(ICON_SETTING_NAME, {
  __options: {
    disableWarnings: false,
    warnOnMissingIcons: true
  },
  __remapped: {}
});
var stylesheet = Stylesheet.getInstance();
if (stylesheet && stylesheet.onReset) {
  stylesheet.onReset(function() {
    for (var name_1 in _iconSettings) {
      if (_iconSettings.hasOwnProperty(name_1) && !!_iconSettings[name_1].subset) {
        _iconSettings[name_1].subset.className = void 0;
      }
    }
  });
}
var normalizeIconName = function(name) {
  return name.toLowerCase();
};
function registerIcons(iconSubset, options2) {
  var subset = __assign$1(__assign$1({}, iconSubset), { isRegistered: false, className: void 0 });
  var icons = iconSubset.icons;
  options2 = options2 ? __assign$1(__assign$1({}, _iconSettings.__options), options2) : _iconSettings.__options;
  for (var iconName in icons) {
    if (icons.hasOwnProperty(iconName)) {
      var code = icons[iconName];
      var normalizedIconName = normalizeIconName(iconName);
      if (_iconSettings[normalizedIconName]) {
        _warnDuplicateIcon(iconName);
      } else {
        _iconSettings[normalizedIconName] = {
          code,
          subset
        };
      }
    }
  }
}
function registerIconAlias(iconName, mappedToName) {
  _iconSettings.__remapped[normalizeIconName(iconName)] = normalizeIconName(mappedToName);
}
function getIcon(name) {
  var icon = void 0;
  var options2 = _iconSettings.__options;
  name = name ? normalizeIconName(name) : "";
  name = _iconSettings.__remapped[name] || name;
  if (name) {
    icon = _iconSettings[name];
    if (icon) {
      var subset = icon.subset;
      if (subset && subset.fontFace) {
        if (!subset.isRegistered) {
          fontFace(subset.fontFace);
          subset.isRegistered = true;
        }
        if (!subset.className) {
          subset.className = mergeStyles(subset.style, {
            fontFamily: subset.fontFace.fontFamily,
            fontWeight: subset.fontFace.fontWeight || "normal",
            fontStyle: subset.fontFace.fontStyle || "normal"
          });
        }
      }
    } else {
      if (!options2.disableWarnings && options2.warnOnMissingIcons) {
        warn('The icon "' + name + '" was used but not registered. See https://github.com/microsoft/fluentui/wiki/Using-icons for more information.');
      }
    }
  }
  return icon;
}
var _missingIcons = [];
var _missingIconsTimer = void 0;
function _warnDuplicateIcon(iconName) {
  var options2 = _iconSettings.__options;
  var warningDelay = 2e3;
  var maxIconsInMessage = 10;
  if (!options2.disableWarnings) {
    _missingIcons.push(iconName);
    if (_missingIconsTimer === void 0) {
      _missingIconsTimer = setTimeout(function() {
        warn("Some icons were re-registered. Applications should only call registerIcons for any given icon once. Redefining what an icon is may have unintended consequences. Duplicates include: \n" + _missingIcons.slice(0, maxIconsInMessage).join(", ") + (_missingIcons.length > maxIconsInMessage ? " (+ " + (_missingIcons.length - maxIconsInMessage) + " more)" : ""));
        _missingIconsTimer = void 0;
        _missingIcons = [];
      }, warningDelay);
    }
  }
}
function makeSemanticColors(p, e, s, isInverted, depComments) {
  if (depComments === void 0) {
    depComments = false;
  }
  var semanticColors = __assign$1({
    primaryButtonBorder: "transparent",
    errorText: !isInverted ? "#a4262c" : "#F1707B",
    messageText: !isInverted ? "#323130" : "#F3F2F1",
    messageLink: !isInverted ? "#005A9E" : "#6CB8F6",
    messageLinkHovered: !isInverted ? "#004578" : "#82C7FF",
    infoIcon: !isInverted ? "#605e5c" : "#C8C6C4",
    errorIcon: !isInverted ? "#A80000" : "#F1707B",
    blockingIcon: !isInverted ? "#FDE7E9" : "#442726",
    warningIcon: !isInverted ? "#797775" : "#C8C6C4",
    severeWarningIcon: !isInverted ? "#D83B01" : "#FCE100",
    successIcon: !isInverted ? "#107C10" : "#92C353",
    infoBackground: !isInverted ? "#f3f2f1" : "#323130",
    errorBackground: !isInverted ? "#FDE7E9" : "#442726",
    blockingBackground: !isInverted ? "#FDE7E9" : "#442726",
    warningBackground: !isInverted ? "#FFF4CE" : "#433519",
    severeWarningBackground: !isInverted ? "#FED9CC" : "#4F2A0F",
    successBackground: !isInverted ? "#DFF6DD" : "#393D1B",
    // deprecated
    warningHighlight: !isInverted ? "#ffb900" : "#fff100",
    successText: !isInverted ? "#107C10" : "#92c353"
  }, s);
  var fullSemanticColors = getSemanticColors(p, e, semanticColors, isInverted);
  return _fixDeprecatedSlots(fullSemanticColors, depComments);
}
function getSemanticColors(p, e, s, isInverted, depComments) {
  var result = {};
  var _a2 = p || {}, white = _a2.white, black = _a2.black, themePrimary = _a2.themePrimary, themeDark = _a2.themeDark, themeDarker = _a2.themeDarker, themeDarkAlt = _a2.themeDarkAlt, themeLighter = _a2.themeLighter, neutralLight = _a2.neutralLight, neutralLighter = _a2.neutralLighter, neutralDark = _a2.neutralDark, neutralQuaternary = _a2.neutralQuaternary, neutralQuaternaryAlt = _a2.neutralQuaternaryAlt, neutralPrimary = _a2.neutralPrimary, neutralSecondary = _a2.neutralSecondary, neutralSecondaryAlt = _a2.neutralSecondaryAlt, neutralTertiary = _a2.neutralTertiary, neutralTertiaryAlt = _a2.neutralTertiaryAlt, neutralLighterAlt = _a2.neutralLighterAlt, accent = _a2.accent;
  if (white) {
    result.bodyBackground = white;
    result.bodyFrameBackground = white;
    result.accentButtonText = white;
    result.buttonBackground = white;
    result.primaryButtonText = white;
    result.primaryButtonTextHovered = white;
    result.primaryButtonTextPressed = white;
    result.inputBackground = white;
    result.inputForegroundChecked = white;
    result.listBackground = white;
    result.menuBackground = white;
    result.cardStandoutBackground = white;
  }
  if (black) {
    result.bodyTextChecked = black;
    result.buttonTextCheckedHovered = black;
  }
  if (themePrimary) {
    result.link = themePrimary;
    result.primaryButtonBackground = themePrimary;
    result.inputBackgroundChecked = themePrimary;
    result.inputIcon = themePrimary;
    result.inputFocusBorderAlt = themePrimary;
    result.menuIcon = themePrimary;
    result.menuHeader = themePrimary;
    result.accentButtonBackground = themePrimary;
  }
  if (themeDark) {
    result.primaryButtonBackgroundPressed = themeDark;
    result.inputBackgroundCheckedHovered = themeDark;
    result.inputIconHovered = themeDark;
  }
  if (themeDarker) {
    result.linkHovered = themeDarker;
  }
  if (themeDarkAlt) {
    result.primaryButtonBackgroundHovered = themeDarkAlt;
  }
  if (themeLighter) {
    result.inputPlaceholderBackgroundChecked = themeLighter;
  }
  if (neutralLight) {
    result.bodyBackgroundChecked = neutralLight;
    result.bodyFrameDivider = neutralLight;
    result.bodyDivider = neutralLight;
    result.variantBorder = neutralLight;
    result.buttonBackgroundCheckedHovered = neutralLight;
    result.buttonBackgroundPressed = neutralLight;
    result.listItemBackgroundChecked = neutralLight;
    result.listHeaderBackgroundPressed = neutralLight;
    result.menuItemBackgroundPressed = neutralLight;
    result.menuItemBackgroundChecked = neutralLight;
  }
  if (neutralLighter) {
    result.bodyBackgroundHovered = neutralLighter;
    result.buttonBackgroundHovered = neutralLighter;
    result.buttonBackgroundDisabled = neutralLighter;
    result.buttonBorderDisabled = neutralLighter;
    result.primaryButtonBackgroundDisabled = neutralLighter;
    result.disabledBackground = neutralLighter;
    result.listItemBackgroundHovered = neutralLighter;
    result.listHeaderBackgroundHovered = neutralLighter;
    result.menuItemBackgroundHovered = neutralLighter;
  }
  if (neutralQuaternary) {
    result.primaryButtonTextDisabled = neutralQuaternary;
    result.disabledSubtext = neutralQuaternary;
  }
  if (neutralQuaternaryAlt) {
    result.listItemBackgroundCheckedHovered = neutralQuaternaryAlt;
  }
  if (neutralTertiary) {
    result.disabledBodyText = neutralTertiary;
    result.variantBorderHovered = (s === null || s === void 0 ? void 0 : s.variantBorderHovered) || neutralTertiary;
    result.buttonTextDisabled = neutralTertiary;
    result.inputIconDisabled = neutralTertiary;
    result.disabledText = neutralTertiary;
  }
  if (neutralPrimary) {
    result.bodyText = neutralPrimary;
    result.actionLink = neutralPrimary;
    result.buttonText = neutralPrimary;
    result.inputBorderHovered = neutralPrimary;
    result.inputText = neutralPrimary;
    result.listText = neutralPrimary;
    result.menuItemText = neutralPrimary;
  }
  if (neutralLighterAlt) {
    result.bodyStandoutBackground = neutralLighterAlt;
    result.defaultStateBackground = neutralLighterAlt;
  }
  if (neutralDark) {
    result.actionLinkHovered = neutralDark;
    result.buttonTextHovered = neutralDark;
    result.buttonTextChecked = neutralDark;
    result.buttonTextPressed = neutralDark;
    result.inputTextHovered = neutralDark;
    result.menuItemTextHovered = neutralDark;
  }
  if (neutralSecondary) {
    result.bodySubtext = neutralSecondary;
    result.focusBorder = neutralSecondary;
    result.inputBorder = neutralSecondary;
    result.smallInputBorder = neutralSecondary;
    result.inputPlaceholderText = neutralSecondary;
  }
  if (neutralSecondaryAlt) {
    result.buttonBorder = neutralSecondaryAlt;
  }
  if (neutralTertiaryAlt) {
    result.disabledBodySubtext = neutralTertiaryAlt;
    result.disabledBorder = neutralTertiaryAlt;
    result.buttonBackgroundChecked = neutralTertiaryAlt;
    result.menuDivider = neutralTertiaryAlt;
  }
  if (accent) {
    result.accentButtonBackground = accent;
  }
  if (e === null || e === void 0 ? void 0 : e.elevation4) {
    result.cardShadow = e.elevation4;
  }
  if (!isInverted && (e === null || e === void 0 ? void 0 : e.elevation8)) {
    result.cardShadowHovered = e.elevation8;
  } else if (result.variantBorderHovered) {
    result.cardShadowHovered = "0 0 1px " + result.variantBorderHovered;
  }
  result = __assign$1(__assign$1({}, result), s);
  return result;
}
function _fixDeprecatedSlots(s, depComments) {
  var dep = "";
  if (depComments === true) {
    dep = " /* @deprecated */";
  }
  s.listTextColor = s.listText + dep;
  s.menuItemBackgroundChecked += dep;
  s.warningHighlight += dep;
  s.warningText = s.messageText + dep;
  s.successText += dep;
  return s;
}
function mergeThemes(theme, partialTheme) {
  var _a2, _b2, _c2;
  if (partialTheme === void 0) {
    partialTheme = {};
  }
  var mergedTheme = merge$1({}, theme, partialTheme, {
    semanticColors: getSemanticColors(partialTheme.palette, partialTheme.effects, partialTheme.semanticColors, partialTheme.isInverted === void 0 ? theme.isInverted : partialTheme.isInverted)
  });
  if (((_a2 = partialTheme.palette) === null || _a2 === void 0 ? void 0 : _a2.themePrimary) && !((_b2 = partialTheme.palette) === null || _b2 === void 0 ? void 0 : _b2.accent)) {
    mergedTheme.palette.accent = partialTheme.palette.themePrimary;
  }
  if (partialTheme.defaultFontStyle) {
    for (var _i = 0, _d2 = Object.keys(mergedTheme.fonts); _i < _d2.length; _i++) {
      var fontStyle = _d2[_i];
      mergedTheme.fonts[fontStyle] = merge$1(mergedTheme.fonts[fontStyle], partialTheme.defaultFontStyle, (_c2 = partialTheme === null || partialTheme === void 0 ? void 0 : partialTheme.fonts) === null || _c2 === void 0 ? void 0 : _c2[fontStyle]);
    }
  }
  return mergedTheme;
}
var DefaultPalette = {
  themeDarker: "#004578",
  themeDark: "#005a9e",
  themeDarkAlt: "#106ebe",
  themePrimary: "#0078d4",
  themeSecondary: "#2b88d8",
  themeTertiary: "#71afe5",
  themeLight: "#c7e0f4",
  themeLighter: "#deecf9",
  themeLighterAlt: "#eff6fc",
  black: "#000000",
  blackTranslucent40: "rgba(0,0,0,.4)",
  neutralDark: "#201f1e",
  neutralPrimary: "#323130",
  neutralPrimaryAlt: "#3b3a39",
  neutralSecondary: "#605e5c",
  neutralSecondaryAlt: "#8a8886",
  neutralTertiary: "#a19f9d",
  neutralTertiaryAlt: "#c8c6c4",
  neutralQuaternary: "#d2d0ce",
  neutralQuaternaryAlt: "#e1dfdd",
  neutralLight: "#edebe9",
  neutralLighter: "#f3f2f1",
  neutralLighterAlt: "#faf9f8",
  accent: "#0078d4",
  white: "#ffffff",
  whiteTranslucent40: "rgba(255,255,255,.4)",
  yellowDark: "#d29200",
  yellow: "#ffb900",
  yellowLight: "#fff100",
  orange: "#d83b01",
  orangeLight: "#ea4300",
  orangeLighter: "#ff8c00",
  redDark: "#a4262c",
  red: "#e81123",
  magentaDark: "#5c005c",
  magenta: "#b4009e",
  magentaLight: "#e3008c",
  purpleDark: "#32145a",
  purple: "#5c2d91",
  purpleLight: "#b4a0ff",
  blueDark: "#002050",
  blueMid: "#00188f",
  blue: "#0078d4",
  blueLight: "#00bcf2",
  tealDark: "#004b50",
  teal: "#008272",
  tealLight: "#00b294",
  greenDark: "#004b1c",
  green: "#107c10",
  greenLight: "#bad80a"
};
var Depths;
(function(Depths2) {
  Depths2.depth0 = "0 0 0 0 transparent";
  Depths2.depth4 = "0 1.6px 3.6px 0 rgba(0, 0, 0, 0.132), 0 0.3px 0.9px 0 rgba(0, 0, 0, 0.108)";
  Depths2.depth8 = "0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132), 0 0.6px 1.8px 0 rgba(0, 0, 0, 0.108)";
  Depths2.depth16 = "0 6.4px 14.4px 0 rgba(0, 0, 0, 0.132), 0 1.2px 3.6px 0 rgba(0, 0, 0, 0.108)";
  Depths2.depth64 = "0 25.6px 57.6px 0 rgba(0, 0, 0, 0.22), 0 4.8px 14.4px 0 rgba(0, 0, 0, 0.18)";
})(Depths || (Depths = {}));
var DefaultEffects = {
  elevation4: Depths.depth4,
  elevation8: Depths.depth8,
  elevation16: Depths.depth16,
  elevation64: Depths.depth64,
  roundedCorner2: "2px",
  roundedCorner4: "4px",
  roundedCorner6: "6px"
};
var DefaultSpacing = {
  s2: "4px",
  s1: "8px",
  m: "16px",
  l1: "20px",
  l2: "32px"
};
var EASING_FUNCTION_1 = "cubic-bezier(.1,.9,.2,1)";
var EASING_FUNCTION_2 = "cubic-bezier(.1,.25,.75,.9)";
var DURATION_1 = "0.167s";
var DURATION_2 = "0.267s";
var DURATION_3 = "0.367s";
var DURATION_4 = "0.467s";
var FADE_IN = keyframes$1({
  from: { opacity: 0 },
  to: { opacity: 1 }
});
var FADE_OUT = keyframes$1({
  from: { opacity: 1 },
  to: { opacity: 0, visibility: "hidden" }
});
var SLIDE_RIGHT_IN10 = _createSlideInX(-10);
var SLIDE_RIGHT_IN20 = _createSlideInX(-20);
var SLIDE_RIGHT_IN40 = _createSlideInX(-40);
var SLIDE_RIGHT_IN400 = _createSlideInX(-400);
var SLIDE_LEFT_IN10 = _createSlideInX(10);
var SLIDE_LEFT_IN20 = _createSlideInX(20);
var SLIDE_LEFT_IN40 = _createSlideInX(40);
var SLIDE_LEFT_IN400 = _createSlideInX(400);
var SLIDE_UP_IN10 = _createSlideInY(10);
var SLIDE_UP_IN20 = _createSlideInY(20);
var SLIDE_DOWN_IN10 = _createSlideInY(-10);
var SLIDE_DOWN_IN20 = _createSlideInY(-20);
var SLIDE_RIGHT_OUT10 = _createSlideOutX(10);
var SLIDE_RIGHT_OUT20 = _createSlideOutX(20);
var SLIDE_RIGHT_OUT40 = _createSlideOutX(40);
var SLIDE_RIGHT_OUT400 = _createSlideOutX(400);
var SLIDE_LEFT_OUT10 = _createSlideOutX(-10);
var SLIDE_LEFT_OUT20 = _createSlideOutX(-20);
var SLIDE_LEFT_OUT40 = _createSlideOutX(-40);
var SLIDE_LEFT_OUT400 = _createSlideOutX(-400);
var SLIDE_UP_OUT10 = _createSlideOutY(-10);
var SLIDE_UP_OUT20 = _createSlideOutY(-20);
var SLIDE_DOWN_OUT10 = _createSlideOutY(10);
var SLIDE_DOWN_OUT20 = _createSlideOutY(20);
var SCALE_UP100 = keyframes$1({
  from: { transform: "scale3d(.98,.98,1)" },
  to: { transform: "scale3d(1,1,1)" }
});
var SCALE_DOWN98 = keyframes$1({
  from: { transform: "scale3d(1,1,1)" },
  to: { transform: "scale3d(.98,.98,1)" }
});
var SCALE_DOWN100 = keyframes$1({
  from: { transform: "scale3d(1.03,1.03,1)" },
  to: { transform: "scale3d(1,1,1)" }
});
var SCALE_UP103 = keyframes$1({
  from: { transform: "scale3d(1,1,1)" },
  to: { transform: "scale3d(1.03,1.03,1)" }
});
var ROTATE90 = keyframes$1({
  from: { transform: "rotateZ(0deg)" },
  to: { transform: "rotateZ(90deg)" }
});
var ROTATE_N90 = keyframes$1({
  from: { transform: "rotateZ(0deg)" },
  to: { transform: "rotateZ(-90deg)" }
});
var AnimationVariables = {
  easeFunction1: EASING_FUNCTION_1,
  easeFunction2: EASING_FUNCTION_2,
  durationValue1: DURATION_1,
  durationValue2: DURATION_2,
  durationValue3: DURATION_3,
  durationValue4: DURATION_4
};
var AnimationStyles = {
  slideRightIn10: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN10, DURATION_3, EASING_FUNCTION_1),
  slideRightIn20: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN20, DURATION_3, EASING_FUNCTION_1),
  slideRightIn40: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN40, DURATION_3, EASING_FUNCTION_1),
  slideRightIn400: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN400, DURATION_3, EASING_FUNCTION_1),
  slideLeftIn10: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN10, DURATION_3, EASING_FUNCTION_1),
  slideLeftIn20: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN20, DURATION_3, EASING_FUNCTION_1),
  slideLeftIn40: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN40, DURATION_3, EASING_FUNCTION_1),
  slideLeftIn400: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN400, DURATION_3, EASING_FUNCTION_1),
  slideUpIn10: _createAnimation(FADE_IN + "," + SLIDE_UP_IN10, DURATION_3, EASING_FUNCTION_1),
  slideUpIn20: _createAnimation(FADE_IN + "," + SLIDE_UP_IN20, DURATION_3, EASING_FUNCTION_1),
  slideDownIn10: _createAnimation(FADE_IN + "," + SLIDE_DOWN_IN10, DURATION_3, EASING_FUNCTION_1),
  slideDownIn20: _createAnimation(FADE_IN + "," + SLIDE_DOWN_IN20, DURATION_3, EASING_FUNCTION_1),
  slideRightOut10: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT10, DURATION_3, EASING_FUNCTION_1),
  slideRightOut20: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT20, DURATION_3, EASING_FUNCTION_1),
  slideRightOut40: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT40, DURATION_3, EASING_FUNCTION_1),
  slideRightOut400: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT400, DURATION_3, EASING_FUNCTION_1),
  slideLeftOut10: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT10, DURATION_3, EASING_FUNCTION_1),
  slideLeftOut20: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT20, DURATION_3, EASING_FUNCTION_1),
  slideLeftOut40: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT40, DURATION_3, EASING_FUNCTION_1),
  slideLeftOut400: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT400, DURATION_3, EASING_FUNCTION_1),
  slideUpOut10: _createAnimation(FADE_OUT + "," + SLIDE_UP_OUT10, DURATION_3, EASING_FUNCTION_1),
  slideUpOut20: _createAnimation(FADE_OUT + "," + SLIDE_UP_OUT20, DURATION_3, EASING_FUNCTION_1),
  slideDownOut10: _createAnimation(FADE_OUT + "," + SLIDE_DOWN_OUT10, DURATION_3, EASING_FUNCTION_1),
  slideDownOut20: _createAnimation(FADE_OUT + "," + SLIDE_DOWN_OUT20, DURATION_3, EASING_FUNCTION_1),
  scaleUpIn100: _createAnimation(FADE_IN + "," + SCALE_UP100, DURATION_3, EASING_FUNCTION_1),
  scaleDownIn100: _createAnimation(FADE_IN + "," + SCALE_DOWN100, DURATION_3, EASING_FUNCTION_1),
  scaleUpOut103: _createAnimation(FADE_OUT + "," + SCALE_UP103, DURATION_1, EASING_FUNCTION_2),
  scaleDownOut98: _createAnimation(FADE_OUT + "," + SCALE_DOWN98, DURATION_1, EASING_FUNCTION_2),
  fadeIn100: _createAnimation(FADE_IN, DURATION_1, EASING_FUNCTION_2),
  fadeIn200: _createAnimation(FADE_IN, DURATION_2, EASING_FUNCTION_2),
  fadeIn400: _createAnimation(FADE_IN, DURATION_3, EASING_FUNCTION_2),
  fadeIn500: _createAnimation(FADE_IN, DURATION_4, EASING_FUNCTION_2),
  fadeOut100: _createAnimation(FADE_OUT, DURATION_1, EASING_FUNCTION_2),
  fadeOut200: _createAnimation(FADE_OUT, DURATION_2, EASING_FUNCTION_2),
  fadeOut400: _createAnimation(FADE_OUT, DURATION_3, EASING_FUNCTION_2),
  fadeOut500: _createAnimation(FADE_OUT, DURATION_4, EASING_FUNCTION_2),
  rotate90deg: _createAnimation(ROTATE90, "0.1s", EASING_FUNCTION_2),
  rotateN90deg: _createAnimation(ROTATE_N90, "0.1s", EASING_FUNCTION_2)
  // expandCollapse 100/200/400, delay 100/200
};
function _createAnimation(animationName, animationDuration2, animationTimingFunction) {
  return {
    animationName,
    animationDuration: animationDuration2,
    animationTimingFunction,
    animationFillMode: "both"
  };
}
function _createSlideInX(fromX) {
  return keyframes$1({
    from: { transform: "translate3d(" + fromX + "px,0,0)", pointerEvents: "none" },
    to: { transform: "translate3d(0,0,0)", pointerEvents: "auto" }
  });
}
function _createSlideInY(fromY) {
  return keyframes$1({
    from: { transform: "translate3d(0," + fromY + "px,0)", pointerEvents: "none" },
    to: { transform: "translate3d(0,0,0)", pointerEvents: "auto" }
  });
}
function _createSlideOutX(toX) {
  return keyframes$1({
    from: { transform: "translate3d(0,0,0)" },
    to: { transform: "translate3d(" + toX + "px,0,0)" }
  });
}
function _createSlideOutY(toY) {
  return keyframes$1({
    from: { transform: "translate3d(0,0,0)" },
    to: { transform: "translate3d(0," + toY + "px,0)" }
  });
}
var LocalizedFontNames;
(function(LocalizedFontNames2) {
  LocalizedFontNames2.Arabic = "Segoe UI Web (Arabic)";
  LocalizedFontNames2.Cyrillic = "Segoe UI Web (Cyrillic)";
  LocalizedFontNames2.EastEuropean = "Segoe UI Web (East European)";
  LocalizedFontNames2.Greek = "Segoe UI Web (Greek)";
  LocalizedFontNames2.Hebrew = "Segoe UI Web (Hebrew)";
  LocalizedFontNames2.Thai = "Leelawadee UI Web";
  LocalizedFontNames2.Vietnamese = "Segoe UI Web (Vietnamese)";
  LocalizedFontNames2.WestEuropean = "Segoe UI Web (West European)";
  LocalizedFontNames2.Selawik = "Selawik Web";
  LocalizedFontNames2.Armenian = "Segoe UI Web (Armenian)";
  LocalizedFontNames2.Georgian = "Segoe UI Web (Georgian)";
})(LocalizedFontNames || (LocalizedFontNames = {}));
var LocalizedFontFamilies;
(function(LocalizedFontFamilies2) {
  LocalizedFontFamilies2.Arabic = "'" + LocalizedFontNames.Arabic + "'";
  LocalizedFontFamilies2.ChineseSimplified = "'Microsoft Yahei UI', Verdana, Simsun";
  LocalizedFontFamilies2.ChineseTraditional = "'Microsoft Jhenghei UI', Pmingliu";
  LocalizedFontFamilies2.Cyrillic = "'" + LocalizedFontNames.Cyrillic + "'";
  LocalizedFontFamilies2.EastEuropean = "'" + LocalizedFontNames.EastEuropean + "'";
  LocalizedFontFamilies2.Greek = "'" + LocalizedFontNames.Greek + "'";
  LocalizedFontFamilies2.Hebrew = "'" + LocalizedFontNames.Hebrew + "'";
  LocalizedFontFamilies2.Hindi = "'Nirmala UI'";
  LocalizedFontFamilies2.Japanese = "'Yu Gothic UI', 'Meiryo UI', Meiryo, 'MS Pgothic', Osaka";
  LocalizedFontFamilies2.Korean = "'Malgun Gothic', Gulim";
  LocalizedFontFamilies2.Selawik = "'" + LocalizedFontNames.Selawik + "'";
  LocalizedFontFamilies2.Thai = "'Leelawadee UI Web', 'Kmer UI'";
  LocalizedFontFamilies2.Vietnamese = "'" + LocalizedFontNames.Vietnamese + "'";
  LocalizedFontFamilies2.WestEuropean = "'" + LocalizedFontNames.WestEuropean + "'";
  LocalizedFontFamilies2.Armenian = "'" + LocalizedFontNames.Armenian + "'";
  LocalizedFontFamilies2.Georgian = "'" + LocalizedFontNames.Georgian + "'";
})(LocalizedFontFamilies || (LocalizedFontFamilies = {}));
var FontSizes;
(function(FontSizes2) {
  FontSizes2.size10 = "10px";
  FontSizes2.size12 = "12px";
  FontSizes2.size14 = "14px";
  FontSizes2.size16 = "16px";
  FontSizes2.size18 = "18px";
  FontSizes2.size20 = "20px";
  FontSizes2.size24 = "24px";
  FontSizes2.size28 = "28px";
  FontSizes2.size32 = "32px";
  FontSizes2.size42 = "42px";
  FontSizes2.size68 = "68px";
  FontSizes2.mini = "10px";
  FontSizes2.xSmall = "10px";
  FontSizes2.small = "12px";
  FontSizes2.smallPlus = "12px";
  FontSizes2.medium = "14px";
  FontSizes2.mediumPlus = "16px";
  FontSizes2.icon = "16px";
  FontSizes2.large = "18px";
  FontSizes2.xLarge = "20px";
  FontSizes2.xLargePlus = "24px";
  FontSizes2.xxLarge = "28px";
  FontSizes2.xxLargePlus = "32px";
  FontSizes2.superLarge = "42px";
  FontSizes2.mega = "68px";
})(FontSizes || (FontSizes = {}));
var FontWeights;
(function(FontWeights2) {
  FontWeights2.light = 100;
  FontWeights2.semilight = 300;
  FontWeights2.regular = 400;
  FontWeights2.semibold = 600;
  FontWeights2.bold = 700;
})(FontWeights || (FontWeights = {}));
var IconFontSizes;
(function(IconFontSizes2) {
  IconFontSizes2.xSmall = "10px";
  IconFontSizes2.small = "12px";
  IconFontSizes2.medium = "16px";
  IconFontSizes2.large = "20px";
})(IconFontSizes || (IconFontSizes = {}));
var FontFamilyFallbacks = "'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', sans-serif";
var defaultFontFamily = "'Segoe UI', '" + LocalizedFontNames.WestEuropean + "'";
var LanguageToFontMap = {
  ar: LocalizedFontFamilies.Arabic,
  bg: LocalizedFontFamilies.Cyrillic,
  cs: LocalizedFontFamilies.EastEuropean,
  el: LocalizedFontFamilies.Greek,
  et: LocalizedFontFamilies.EastEuropean,
  he: LocalizedFontFamilies.Hebrew,
  hi: LocalizedFontFamilies.Hindi,
  hr: LocalizedFontFamilies.EastEuropean,
  hu: LocalizedFontFamilies.EastEuropean,
  ja: LocalizedFontFamilies.Japanese,
  kk: LocalizedFontFamilies.EastEuropean,
  ko: LocalizedFontFamilies.Korean,
  lt: LocalizedFontFamilies.EastEuropean,
  lv: LocalizedFontFamilies.EastEuropean,
  pl: LocalizedFontFamilies.EastEuropean,
  ru: LocalizedFontFamilies.Cyrillic,
  sk: LocalizedFontFamilies.EastEuropean,
  "sr-latn": LocalizedFontFamilies.EastEuropean,
  th: LocalizedFontFamilies.Thai,
  tr: LocalizedFontFamilies.EastEuropean,
  uk: LocalizedFontFamilies.Cyrillic,
  vi: LocalizedFontFamilies.Vietnamese,
  "zh-hans": LocalizedFontFamilies.ChineseSimplified,
  "zh-hant": LocalizedFontFamilies.ChineseTraditional,
  hy: LocalizedFontFamilies.Armenian,
  ka: LocalizedFontFamilies.Georgian
};
function _fontFamilyWithFallbacks(fontFamily) {
  return fontFamily + ", " + FontFamilyFallbacks;
}
function _getLocalizedFontFamily(language) {
  for (var lang in LanguageToFontMap) {
    if (LanguageToFontMap.hasOwnProperty(lang) && language && lang.indexOf(language) === 0) {
      return LanguageToFontMap[lang];
    }
  }
  return defaultFontFamily;
}
function _createFont(size, weight, fontFamily) {
  return {
    fontFamily,
    MozOsxFontSmoothing: "grayscale",
    WebkitFontSmoothing: "antialiased",
    fontSize: size,
    fontWeight: weight
  };
}
function createFontStyles(localeCode) {
  var localizedFont = _getLocalizedFontFamily(localeCode);
  var fontFamilyWithFallback = _fontFamilyWithFallbacks(localizedFont);
  var fontStyles = {
    tiny: _createFont(FontSizes.mini, FontWeights.regular, fontFamilyWithFallback),
    xSmall: _createFont(FontSizes.xSmall, FontWeights.regular, fontFamilyWithFallback),
    small: _createFont(FontSizes.small, FontWeights.regular, fontFamilyWithFallback),
    smallPlus: _createFont(FontSizes.smallPlus, FontWeights.regular, fontFamilyWithFallback),
    medium: _createFont(FontSizes.medium, FontWeights.regular, fontFamilyWithFallback),
    mediumPlus: _createFont(FontSizes.mediumPlus, FontWeights.regular, fontFamilyWithFallback),
    large: _createFont(FontSizes.large, FontWeights.regular, fontFamilyWithFallback),
    xLarge: _createFont(FontSizes.xLarge, FontWeights.semibold, fontFamilyWithFallback),
    xLargePlus: _createFont(FontSizes.xLargePlus, FontWeights.semibold, fontFamilyWithFallback),
    xxLarge: _createFont(FontSizes.xxLarge, FontWeights.semibold, fontFamilyWithFallback),
    xxLargePlus: _createFont(FontSizes.xxLargePlus, FontWeights.semibold, fontFamilyWithFallback),
    superLarge: _createFont(FontSizes.superLarge, FontWeights.semibold, fontFamilyWithFallback),
    mega: _createFont(FontSizes.mega, FontWeights.semibold, fontFamilyWithFallback)
  };
  return fontStyles;
}
var DefaultBaseUrl = "https://res-1.cdn.office.net/files/fabric-cdn-prod_20221209.001/assets";
var DefaultFontStyles = createFontStyles(getLanguage());
function _registerFontFace(fontFamily, url, fontWeight, localFontName) {
  fontFamily = "'" + fontFamily + "'";
  var localFontSrc = localFontName !== void 0 ? "local('" + localFontName + "')," : "";
  fontFace({
    fontFamily,
    src: localFontSrc + ("url('" + url + ".woff2') format('woff2'),") + ("url('" + url + ".woff') format('woff')"),
    fontWeight,
    fontStyle: "normal",
    fontDisplay: "swap"
  });
}
function _registerFontFaceSet(baseUrl, fontFamily, cdnFolder, cdnFontName, localFontName) {
  if (cdnFontName === void 0) {
    cdnFontName = "segoeui";
  }
  var urlBase = baseUrl + "/" + cdnFolder + "/" + cdnFontName;
  _registerFontFace(fontFamily, urlBase + "-light", FontWeights.light, localFontName && localFontName + " Light");
  _registerFontFace(fontFamily, urlBase + "-semilight", FontWeights.semilight, localFontName && localFontName + " SemiLight");
  _registerFontFace(fontFamily, urlBase + "-regular", FontWeights.regular, localFontName);
  _registerFontFace(fontFamily, urlBase + "-semibold", FontWeights.semibold, localFontName && localFontName + " SemiBold");
  _registerFontFace(fontFamily, urlBase + "-bold", FontWeights.bold, localFontName && localFontName + " Bold");
}
function registerDefaultFontFaces(baseUrl) {
  if (baseUrl) {
    var fontUrl = baseUrl + "/fonts";
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Thai, "leelawadeeui-thai", "leelawadeeui");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Arabic, "segoeui-arabic");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Cyrillic, "segoeui-cyrillic");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.EastEuropean, "segoeui-easteuropean");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Greek, "segoeui-greek");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Hebrew, "segoeui-hebrew");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Vietnamese, "segoeui-vietnamese");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.WestEuropean, "segoeui-westeuropean", "segoeui", "Segoe UI");
    _registerFontFaceSet(fontUrl, LocalizedFontFamilies.Selawik, "selawik", "selawik");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Armenian, "segoeui-armenian");
    _registerFontFaceSet(fontUrl, LocalizedFontNames.Georgian, "segoeui-georgian");
    _registerFontFace("Leelawadee UI Web", fontUrl + "/leelawadeeui-thai/leelawadeeui-semilight", FontWeights.light);
    _registerFontFace("Leelawadee UI Web", fontUrl + "/leelawadeeui-thai/leelawadeeui-bold", FontWeights.semibold);
  }
}
function _getFontBaseUrl() {
  var _a2, _b2;
  var fabricConfig = (_a2 = getWindow$1()) === null || _a2 === void 0 ? void 0 : _a2.FabricConfig;
  return (_b2 = fabricConfig === null || fabricConfig === void 0 ? void 0 : fabricConfig.fontBaseUrl) !== null && _b2 !== void 0 ? _b2 : DefaultBaseUrl;
}
registerDefaultFontFaces(_getFontBaseUrl());
function createTheme(theme, depComments) {
  if (theme === void 0) {
    theme = {};
  }
  if (depComments === void 0) {
    depComments = false;
  }
  var isInverted = !!theme.isInverted;
  var baseTheme = {
    palette: DefaultPalette,
    effects: DefaultEffects,
    fonts: DefaultFontStyles,
    spacing: DefaultSpacing,
    isInverted,
    disableGlobalClassNames: false,
    semanticColors: makeSemanticColors(DefaultPalette, DefaultEffects, void 0, isInverted, depComments),
    rtl: void 0
  };
  return mergeThemes(baseTheme, theme);
}
var HighContrastSelector = "@media screen and (-ms-high-contrast: active), screen and (forced-colors: active)";
var HighContrastSelectorWhite = (
  // eslint-disable-next-line @fluentui/max-len
  "@media screen and (-ms-high-contrast: black-on-white), screen and (forced-colors: active) and (prefers-color-scheme: light)"
);
var ScreenWidthMinSmall = 320;
var ScreenWidthMinMedium = 480;
var ScreenWidthMinLarge = 640;
var ScreenWidthMinXLarge = 1024;
var ScreenWidthMinXXLarge = 1366;
var ScreenWidthMaxSmall = ScreenWidthMinMedium - 1;
var ScreenWidthMaxMedium = ScreenWidthMinLarge - 1;
var ScreenWidthMinUhfMobile = 768;
function getScreenSelector(min2, max2) {
  var minSelector = typeof min2 === "number" ? " and (min-width: " + min2 + "px)" : "";
  var maxSelector = typeof max2 === "number" ? " and (max-width: " + max2 + "px)" : "";
  return "@media only screen" + minSelector + maxSelector;
}
function getHighContrastNoAdjustStyle() {
  return {
    forcedColorAdjust: "none",
    MsHighContrastAdjust: "none"
  };
}
var ZIndexes;
(function(ZIndexes2) {
  ZIndexes2.Nav = 1;
  ZIndexes2.ScrollablePane = 1;
  ZIndexes2.FocusStyle = 1;
  ZIndexes2.Coachmark = 1e3;
  ZIndexes2.Layer = 1e6;
  ZIndexes2.KeytipLayer = 1000001;
})(ZIndexes || (ZIndexes = {}));
function getFocusStyle(theme, insetOrOptions, position2, highContrastStyle, borderColor, outlineColor, isFocusedOnly, borderRadius2) {
  if (typeof insetOrOptions === "number" || !insetOrOptions) {
    return _getFocusStyleInternal(theme, {
      inset: insetOrOptions,
      position: position2,
      highContrastStyle,
      borderColor,
      outlineColor,
      isFocusedOnly,
      borderRadius: borderRadius2
    });
  } else {
    return _getFocusStyleInternal(theme, insetOrOptions);
  }
}
function _getFocusStyleInternal(theme, options2) {
  var _a2, _b2;
  if (options2 === void 0) {
    options2 = {};
  }
  var borderRadius2 = options2.borderRadius, _c2 = options2.inset, inset = _c2 === void 0 ? 0 : _c2, _d2 = options2.width, width = _d2 === void 0 ? 1 : _d2, _e2 = options2.position, position2 = _e2 === void 0 ? "relative" : _e2, highContrastStyle = options2.highContrastStyle, _f = options2.borderColor, borderColor = _f === void 0 ? theme.palette.white : _f, _g = options2.outlineColor, outlineColor = _g === void 0 ? theme.palette.neutralSecondary : _g, _h = options2.isFocusedOnly, isFocusedOnly = _h === void 0 ? true : _h, pointerEvents = options2.pointerEvents;
  return {
    // Clear browser-specific focus styles and use 'transparent' as placeholder for focus style.
    outline: "transparent",
    // Requirement because pseudo-element is absolutely positioned.
    position: position2,
    selectors: (_a2 = {
      // Clear the focus border in Firefox.
      // Reference: http://stackoverflow.com/a/199319/1436671
      "::-moz-focus-inner": {
        border: "0"
      }
    }, // When the element that uses this mixin is in a :focus state, add a pseudo-element to
    // create a border.
    _a2["." + IsFocusVisibleClassName + " &" + (isFocusedOnly ? ":focus" : "") + ":after"] = {
      content: '""',
      position: "absolute",
      pointerEvents,
      left: inset + 1,
      top: inset + 1,
      bottom: inset + 1,
      right: inset + 1,
      border: width + "px solid " + borderColor,
      outline: width + "px solid " + outlineColor,
      zIndex: ZIndexes.FocusStyle,
      borderRadius: borderRadius2,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = highContrastStyle, _b2)
    }, _a2)
  };
}
function focusClear() {
  return {
    selectors: {
      "&::-moz-focus-inner": {
        // Clear the focus border in Firefox. Reference: http://stackoverflow.com/a/199319/1436671
        border: 0
      },
      "&": {
        // Clear browser specific focus styles and use transparent as placeholder for focus style
        outline: "transparent"
      }
    }
  };
}
var getInputFocusStyle = function(borderColor, borderRadius2, borderType, borderPosition) {
  var _a2, _b2, _c2;
  if (borderType === void 0) {
    borderType = "border";
  }
  if (borderPosition === void 0) {
    borderPosition = -1;
  }
  var isBorderBottom = borderType === "borderBottom";
  return {
    borderColor,
    selectors: {
      ":after": (_a2 = {
        pointerEvents: "none",
        content: "''",
        position: "absolute",
        left: isBorderBottom ? 0 : borderPosition,
        top: borderPosition,
        bottom: borderPosition,
        right: isBorderBottom ? 0 : borderPosition
      }, _a2[borderType] = "2px solid " + borderColor, _a2.borderRadius = borderRadius2, _a2.width = borderType === "borderBottom" ? "100%" : void 0, _a2.selectors = (_b2 = {}, _b2[HighContrastSelector] = (_c2 = {}, _c2[borderType === "border" ? "borderColor" : "borderBottomColor"] = "Highlight", _c2), _b2), _a2)
    }
  };
};
var hiddenContentStyle = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  padding: 0,
  border: 0,
  overflow: "hidden",
  whiteSpace: "nowrap"
};
var _getGlobalClassNames = memoizeFunction(function(classNames2, disableGlobalClassNames) {
  var styleSheet = Stylesheet.getInstance();
  if (disableGlobalClassNames) {
    return Object.keys(classNames2).reduce(function(acc, className) {
      acc[className] = styleSheet.getClassName(classNames2[className]);
      return acc;
    }, {});
  }
  return classNames2;
});
function getGlobalClassNames(classNames2, theme, disableGlobalClassNames) {
  return _getGlobalClassNames(classNames2, disableGlobalClassNames !== void 0 ? disableGlobalClassNames : theme.disableGlobalClassNames);
}
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var _root = typeof window === "undefined" ? global : window;
var _styleNonce = _root && _root.CSPSettings && _root.CSPSettings.nonce;
var _themeState = initializeThemeState();
var _themeTokenRegex = /[\'\"]\[theme:\s*(\w+)\s*(?:\,\s*default:\s*([\\"\']?[\.\,\(\)\#\-\s\w]*[\.\,\(\)\#\-\w][\"\']?))?\s*\][\'\"]/g;
var now = function() {
  return typeof performance !== "undefined" && !!performance.now ? performance.now() : Date.now();
};
function measure(func) {
  var start = now();
  func();
  var end = now();
  _themeState.perf.duration += end - start;
}
function initializeThemeState() {
  var state = _root.__themeState__ || {
    theme: void 0,
    lastStyleElement: void 0,
    registeredStyles: []
  };
  if (!state.runState) {
    state = __assign(__assign({}, state), { perf: {
      count: 0,
      duration: 0
    }, runState: {
      flushTimer: 0,
      mode: 0,
      buffer: []
    } });
  }
  if (!state.registeredThemableStyles) {
    state = __assign(__assign({}, state), { registeredThemableStyles: [] });
  }
  _root.__themeState__ = state;
  return state;
}
function loadStyles(styles2, loadAsync) {
  if (loadAsync === void 0) {
    loadAsync = false;
  }
  measure(function() {
    var styleParts = Array.isArray(styles2) ? styles2 : splitStyles(styles2);
    var _a2 = _themeState.runState, mode = _a2.mode, buffer = _a2.buffer, flushTimer = _a2.flushTimer;
    if (loadAsync || mode === 1) {
      buffer.push(styleParts);
      if (!flushTimer) {
        _themeState.runState.flushTimer = asyncLoadStyles();
      }
    } else {
      applyThemableStyles(styleParts);
    }
  });
}
function flush() {
  measure(function() {
    var styleArrays = _themeState.runState.buffer.slice();
    _themeState.runState.buffer = [];
    var mergedStyleArray = [].concat.apply([], styleArrays);
    if (mergedStyleArray.length > 0) {
      applyThemableStyles(mergedStyleArray);
    }
  });
}
function asyncLoadStyles() {
  return setTimeout(function() {
    _themeState.runState.flushTimer = 0;
    flush();
  }, 0);
}
function applyThemableStyles(stylesArray, styleRecord) {
  if (_themeState.loadStyles) {
    _themeState.loadStyles(resolveThemableArray(stylesArray).styleString, stylesArray);
  } else {
    registerStyles$1(stylesArray);
  }
}
function loadTheme$1(theme) {
  _themeState.theme = theme;
  reloadStyles();
}
function clearStyles(option) {
  if (option === void 0) {
    option = 3;
  }
  if (option === 3 || option === 2) {
    clearStylesInternal(_themeState.registeredStyles);
    _themeState.registeredStyles = [];
  }
  if (option === 3 || option === 1) {
    clearStylesInternal(_themeState.registeredThemableStyles);
    _themeState.registeredThemableStyles = [];
  }
}
function clearStylesInternal(records) {
  records.forEach(function(styleRecord) {
    var styleElement = styleRecord && styleRecord.styleElement;
    if (styleElement && styleElement.parentElement) {
      styleElement.parentElement.removeChild(styleElement);
    }
  });
}
function reloadStyles() {
  if (_themeState.theme) {
    var themableStyles = [];
    for (var _i = 0, _a2 = _themeState.registeredThemableStyles; _i < _a2.length; _i++) {
      var styleRecord = _a2[_i];
      themableStyles.push(styleRecord.themableStyle);
    }
    if (themableStyles.length > 0) {
      clearStyles(
        1
        /* ClearStyleOptions.onlyThemable */
      );
      applyThemableStyles([].concat.apply([], themableStyles));
    }
  }
}
function resolveThemableArray(splitStyleArray) {
  var theme = _themeState.theme;
  var themable = false;
  var resolvedArray = (splitStyleArray || []).map(function(currentValue) {
    var themeSlot = currentValue.theme;
    if (themeSlot) {
      themable = true;
      var themedValue = theme ? theme[themeSlot] : void 0;
      var defaultValue = currentValue.defaultValue || "inherit";
      if (theme && !themedValue && console && !(themeSlot in theme) && typeof DEBUG !== "undefined" && DEBUG) {
        console.warn('Theming value not provided for "'.concat(themeSlot, '". Falling back to "').concat(defaultValue, '".'));
      }
      return themedValue || defaultValue;
    } else {
      return currentValue.rawString;
    }
  });
  return {
    styleString: resolvedArray.join(""),
    themable
  };
}
function splitStyles(styles2) {
  var result = [];
  if (styles2) {
    var pos = 0;
    var tokenMatch = void 0;
    while (tokenMatch = _themeTokenRegex.exec(styles2)) {
      var matchIndex = tokenMatch.index;
      if (matchIndex > pos) {
        result.push({
          rawString: styles2.substring(pos, matchIndex)
        });
      }
      result.push({
        theme: tokenMatch[1],
        defaultValue: tokenMatch[2]
        // May be undefined
      });
      pos = _themeTokenRegex.lastIndex;
    }
    result.push({
      rawString: styles2.substring(pos)
    });
  }
  return result;
}
function registerStyles$1(styleArray) {
  if (typeof document === "undefined") {
    return;
  }
  var head = document.getElementsByTagName("head")[0];
  var styleElement = document.createElement("style");
  var _a2 = resolveThemableArray(styleArray), styleString = _a2.styleString, themable = _a2.themable;
  styleElement.setAttribute("data-load-themed-styles", "true");
  if (_styleNonce) {
    styleElement.setAttribute("nonce", _styleNonce);
  }
  styleElement.appendChild(document.createTextNode(styleString));
  _themeState.perf.count++;
  head.appendChild(styleElement);
  var ev = document.createEvent("HTMLEvents");
  ev.initEvent(
    "styleinsert",
    true,
    false
    /* cancelable */
  );
  ev.args = {
    newStyle: styleElement
  };
  document.dispatchEvent(ev);
  var record = {
    styleElement,
    themableStyle: styleArray
  };
  if (themable) {
    _themeState.registeredThemableStyles.push(record);
  } else {
    _themeState.registeredStyles.push(record);
  }
}
var _theme = createTheme({});
var _onThemeChangeCallbacks = [];
var ThemeSettingName = "theme";
function initializeThemeInCustomizations() {
  var _a2;
  var _b2, _c2;
  var win2 = getWindow$1();
  if ((_b2 = win2 === null || win2 === void 0 ? void 0 : win2.FabricConfig) === null || _b2 === void 0 ? void 0 : _b2.legacyTheme) {
    loadTheme(win2.FabricConfig.legacyTheme);
  } else if (!Customizations.getSettings([ThemeSettingName]).theme) {
    if ((_c2 = win2 === null || win2 === void 0 ? void 0 : win2.FabricConfig) === null || _c2 === void 0 ? void 0 : _c2.theme) {
      _theme = createTheme(win2.FabricConfig.theme);
    }
    Customizations.applySettings((_a2 = {}, _a2[ThemeSettingName] = _theme, _a2));
  }
}
initializeThemeInCustomizations();
function getTheme(depComments) {
  if (depComments === void 0) {
    depComments = false;
  }
  if (depComments === true) {
    _theme = createTheme({}, depComments);
  }
  return _theme;
}
function loadTheme(theme, depComments) {
  var _a2;
  if (depComments === void 0) {
    depComments = false;
  }
  _theme = createTheme(theme, depComments);
  loadTheme$1(__assign$1(__assign$1(__assign$1(__assign$1({}, _theme.palette), _theme.semanticColors), _theme.effects), _loadFonts(_theme)));
  Customizations.applySettings((_a2 = {}, _a2[ThemeSettingName] = _theme, _a2));
  _onThemeChangeCallbacks.forEach(function(callback) {
    try {
      callback(_theme);
    } catch (e) {
    }
  });
  return _theme;
}
function _loadFonts(theme) {
  var lines = {};
  for (var _i = 0, _a2 = Object.keys(theme.fonts); _i < _a2.length; _i++) {
    var fontName = _a2[_i];
    var font = theme.fonts[fontName];
    for (var _b2 = 0, _c2 = Object.keys(font); _b2 < _c2.length; _b2++) {
      var propName = _c2[_b2];
      var name_1 = fontName + propName.charAt(0).toUpperCase() + propName.slice(1);
      var value = font[propName];
      if (propName === "fontSize" && typeof value === "number") {
        value = value + "px";
      }
      lines[name_1] = value;
    }
  }
  return lines;
}
var normalize = {
  boxShadow: "none",
  margin: 0,
  padding: 0,
  boxSizing: "border-box"
};
function getPlaceholderStyles(styles2) {
  return {
    selectors: {
      "::placeholder": styles2,
      ":-ms-input-placeholder": styles2,
      "::-ms-input-placeholder": styles2
      // Edge
    }
  };
}
var AnimationClassNames = buildClassMap(AnimationStyles);
var FLUENT_CDN_BASE_URL = "https://res.cdn.office.net/files/fabric-cdn-prod_20230524.001";
setVersion("@fluentui/style-utilities", "8.9.11");
initializeThemeInCustomizations();
var DirectionalHint = {
  /**
   * Appear above the target element, with the left edges of the callout and target aligning.
   */
  topLeftEdge: 0,
  /**
   * Appear above the target element, with the centers of the callout and target aligning.
   */
  topCenter: 1,
  /**
   * Appear above the target element, with the right edges of the callout and target aligning.
   */
  topRightEdge: 2,
  /**
   * Appear above the target element, aligning with the target element such that the callout tends toward
   * the center of the screen.
   */
  topAutoEdge: 3,
  /**
   * Appear below the target element, with the left edges of the callout and target aligning.
   */
  bottomLeftEdge: 4,
  /**
   * Appear below the target element, with the centers of the callout and target aligning.
   */
  bottomCenter: 5,
  /**
   * Appear below the target element, with the right edges of the callout and target aligning.
   */
  bottomRightEdge: 6,
  /**
   * Appear below the target element, aligning with the target element such that the callout tends toward
   * the center of the screen.
   */
  bottomAutoEdge: 7,
  /**
   * Appear to the left of the target element, with the top edges of the callout and target aligning.
   */
  leftTopEdge: 8,
  /**
   * Appear to the left of the target element, with the centers of the callout and target aligning.
   */
  leftCenter: 9,
  /**
   * Appear to the left of the target element, with the bottom edges of the callout and target aligning.
   */
  leftBottomEdge: 10,
  /**
   * Appear to the right of the target element, with the top edges of the callout and target aligning.
   */
  rightTopEdge: 11,
  /**
   * Appear to the right of the target element, with the centers of the callout and target aligning.
   */
  rightCenter: 12,
  /**
   * Appear to the right of the target element, with the bottom edges of the callout and target aligning.
   */
  rightBottomEdge: 13
};
var RectangleEdge;
(function(RectangleEdge2) {
  RectangleEdge2[RectangleEdge2["top"] = 1] = "top";
  RectangleEdge2[RectangleEdge2["bottom"] = -1] = "bottom";
  RectangleEdge2[RectangleEdge2["left"] = 2] = "left";
  RectangleEdge2[RectangleEdge2["right"] = -2] = "right";
})(RectangleEdge || (RectangleEdge = {}));
var Position;
(function(Position2) {
  Position2[Position2["top"] = 0] = "top";
  Position2[Position2["bottom"] = 1] = "bottom";
  Position2[Position2["start"] = 2] = "start";
  Position2[Position2["end"] = 3] = "end";
})(Position || (Position = {}));
var _a$6;
function _createPositionData(targetEdge, alignmentEdge, isAuto) {
  return {
    targetEdge,
    alignmentEdge,
    isAuto
  };
}
var DirectionalDictionary = (_a$6 = {}, _a$6[DirectionalHint.topLeftEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.left), _a$6[DirectionalHint.topCenter] = _createPositionData(RectangleEdge.top), _a$6[DirectionalHint.topRightEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.right), _a$6[DirectionalHint.topAutoEdge] = _createPositionData(RectangleEdge.top, void 0, true), _a$6[DirectionalHint.bottomLeftEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.left), _a$6[DirectionalHint.bottomCenter] = _createPositionData(RectangleEdge.bottom), _a$6[DirectionalHint.bottomRightEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.right), _a$6[DirectionalHint.bottomAutoEdge] = _createPositionData(RectangleEdge.bottom, void 0, true), _a$6[DirectionalHint.leftTopEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.top), _a$6[DirectionalHint.leftCenter] = _createPositionData(RectangleEdge.left), _a$6[DirectionalHint.leftBottomEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.bottom), _a$6[DirectionalHint.rightTopEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.top), _a$6[DirectionalHint.rightCenter] = _createPositionData(RectangleEdge.right), _a$6[DirectionalHint.rightBottomEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.bottom), _a$6);
function _isRectangleWithinBounds(rect, boundingRect) {
  if (rect.top < boundingRect.top) {
    return false;
  }
  if (rect.bottom > boundingRect.bottom) {
    return false;
  }
  if (rect.left < boundingRect.left) {
    return false;
  }
  if (rect.right > boundingRect.right) {
    return false;
  }
  return true;
}
function _getOutOfBoundsEdges(rect, boundingRect) {
  var outOfBounds = [];
  if (rect.top < boundingRect.top) {
    outOfBounds.push(RectangleEdge.top);
  }
  if (rect.bottom > boundingRect.bottom) {
    outOfBounds.push(RectangleEdge.bottom);
  }
  if (rect.left < boundingRect.left) {
    outOfBounds.push(RectangleEdge.left);
  }
  if (rect.right > boundingRect.right) {
    outOfBounds.push(RectangleEdge.right);
  }
  return outOfBounds;
}
function _getEdgeValue(rect, edge) {
  return rect[RectangleEdge[edge]];
}
function _setEdgeValue(rect, edge, value) {
  rect[RectangleEdge[edge]] = value;
  return rect;
}
function _getCenterValue(rect, edge) {
  var edges = _getFlankingEdges(edge);
  return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;
}
function _getRelativeEdgeValue(edge, value) {
  if (edge > 0) {
    return value;
  } else {
    return value * -1;
  }
}
function _getRelativeRectEdgeValue(edge, rect) {
  return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));
}
function _getRelativeEdgeDifference(rect, hostRect, edge) {
  var edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);
  return _getRelativeEdgeValue(edge, edgeDifference);
}
function _moveEdge(rect, edge, newValue, maintainSize) {
  if (maintainSize === void 0) {
    maintainSize = true;
  }
  var difference = _getEdgeValue(rect, edge) - newValue;
  var returnRect = _setEdgeValue(rect, edge, newValue);
  if (maintainSize) {
    returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);
  }
  return returnRect;
}
function _alignEdges(rect, target, edge, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));
}
function _alignOppositeEdges(rect, target, targetEdge, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  var oppositeEdge = targetEdge * -1;
  var adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);
  return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);
}
function _isEdgeInBounds(rect, bounds, edge) {
  var adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);
  return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);
}
function _getOutOfBoundsDegree(rect, bounds) {
  var breakingEdges = _getOutOfBoundsEdges(rect, bounds);
  var total = 0;
  for (var _i = 0, breakingEdges_1 = breakingEdges; _i < breakingEdges_1.length; _i++) {
    var edge = breakingEdges_1[_i];
    total += Math.pow(_getRelativeEdgeDifference(rect, bounds, edge), 2);
  }
  return total;
}
function _flipToFit(rect, target, bounding, positionData, gap) {
  if (gap === void 0) {
    gap = 0;
  }
  var directions = [
    RectangleEdge.left,
    RectangleEdge.right,
    RectangleEdge.bottom,
    RectangleEdge.top
  ];
  if (getRTL()) {
    directions[0] *= -1;
    directions[1] *= -1;
  }
  var currentEstimate = rect;
  var currentEdge = positionData.targetEdge;
  var currentAlignment = positionData.alignmentEdge;
  var oobDegree;
  var bestEdge = currentEdge;
  var bestAlignment = currentAlignment;
  for (var i = 0; i < 4; i++) {
    if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {
      var currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);
      if (!oobDegree || currentOOBDegree < oobDegree) {
        oobDegree = currentOOBDegree;
        bestEdge = currentEdge;
        bestAlignment = currentAlignment;
      }
      directions.splice(directions.indexOf(currentEdge), 1);
      if (directions.length > 0) {
        if (directions.indexOf(currentEdge * -1) > -1) {
          currentEdge = currentEdge * -1;
        } else {
          currentAlignment = currentEdge;
          currentEdge = directions.slice(-1)[0];
        }
        currentEstimate = _estimatePosition(rect, target, { targetEdge: currentEdge, alignmentEdge: currentAlignment }, gap);
      }
    } else {
      return {
        elementRectangle: currentEstimate,
        targetEdge: currentEdge,
        alignmentEdge: currentAlignment
      };
    }
  }
  currentEstimate = _estimatePosition(rect, target, { targetEdge: bestEdge, alignmentEdge: bestAlignment }, gap);
  return {
    elementRectangle: currentEstimate,
    targetEdge: bestEdge,
    alignmentEdge: bestAlignment
  };
}
function _flipAlignmentEdge(elementEstimate, target, gap, coverTarget) {
  var alignmentEdge = elementEstimate.alignmentEdge, targetEdge = elementEstimate.targetEdge, elementRectangle = elementEstimate.elementRectangle;
  var oppositeEdge = alignmentEdge * -1;
  var newEstimate = _estimatePosition(elementRectangle, target, { targetEdge, alignmentEdge: oppositeEdge }, gap, coverTarget);
  return {
    elementRectangle: newEstimate,
    targetEdge,
    alignmentEdge: oppositeEdge
  };
}
function _adjustFitWithinBounds(element, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
  if (gap === void 0) {
    gap = 0;
  }
  var alignmentEdge = positionData.alignmentEdge, alignTargetEdge = positionData.alignTargetEdge;
  var elementEstimate = {
    elementRectangle: element,
    targetEdge: positionData.targetEdge,
    alignmentEdge
  };
  if (!directionalHintFixed && !coverTarget) {
    elementEstimate = _flipToFit(element, target, bounding, positionData, gap);
  }
  var outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);
  var fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : void 0;
  if (outOfBounds.length > 0) {
    if (alignTargetEdge) {
      if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {
        var flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap, coverTarget);
        if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {
          return flippedElementEstimate;
        } else {
          elementEstimate = _alignOutOfBoundsEdges(_getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding), elementEstimate, bounding, fixedEdge);
        }
      } else {
        elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
      }
    } else {
      elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
    }
  }
  return elementEstimate;
}
function _alignOutOfBoundsEdges(outOfBoundsEdges, elementEstimate, bounding, preserveEdge) {
  for (var _i = 0, outOfBoundsEdges_1 = outOfBoundsEdges; _i < outOfBoundsEdges_1.length; _i++) {
    var direction = outOfBoundsEdges_1[_i];
    var edgeAttempt = void 0;
    if (preserveEdge && preserveEdge === direction * -1) {
      edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);
      elementEstimate.forcedInBounds = true;
    } else {
      edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);
      var inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);
      if (!inBounds) {
        edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);
        elementEstimate.forcedInBounds = true;
      }
    }
    elementEstimate.elementRectangle = edgeAttempt;
  }
  return elementEstimate;
}
function _centerEdgeToPoint(rect, edge, point) {
  var positiveEdge = _getFlankingEdges(edge).positiveEdge;
  var elementMiddle = _getCenterValue(rect, edge);
  var distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);
  return _moveEdge(rect, positiveEdge, point - distanceToMiddle);
}
function _estimatePosition(elementToPosition, target, positionData, gap, coverTarget) {
  if (gap === void 0) {
    gap = 0;
  }
  var estimatedElementPosition = new Rectangle(elementToPosition.left, elementToPosition.right, elementToPosition.top, elementToPosition.bottom);
  var alignmentEdge = positionData.alignmentEdge, targetEdge = positionData.targetEdge;
  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
  estimatedElementPosition = coverTarget ? _alignEdges(estimatedElementPosition, target, targetEdge, gap) : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap);
  if (!alignmentEdge) {
    var targetMiddlePoint = _getCenterValue(target, targetEdge);
    estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);
  } else {
    estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);
  }
  return estimatedElementPosition;
}
function _getFlankingEdges(edge) {
  if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {
    return {
      positiveEdge: RectangleEdge.left,
      negativeEdge: RectangleEdge.right
    };
  } else {
    return {
      positiveEdge: RectangleEdge.top,
      negativeEdge: RectangleEdge.bottom
    };
  }
}
function _finalizeReturnEdge(elementRectangle, returnEdge, bounds) {
  if (bounds && Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) > Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))) {
    return returnEdge * -1;
  }
  return returnEdge;
}
function _isEdgeOnBounds(elementRectangle, edge, bounds) {
  return bounds !== void 0 && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);
}
function _finalizeElementPosition(elementRectangle, hostElement, targetEdge, bounds, alignmentEdge, coverTarget, doNotFinalizeReturnEdge, forceWithinBounds) {
  var returnValue = {};
  var hostRect = _getRectangleFromElement(hostElement);
  var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
  var returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;
  if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {
    returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);
  }
  returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);
  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);
  if (forceWithinBounds) {
    returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge * -1);
    returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge * -1);
  }
  return returnValue;
}
function _calculateActualBeakWidthInPixels(beakWidth) {
  return Math.sqrt(beakWidth * beakWidth * 2);
}
function _getPositionData(directionalHint, directionalHintForRTL, previousPositions) {
  if (directionalHint === void 0) {
    directionalHint = DirectionalHint.bottomAutoEdge;
  }
  if (previousPositions) {
    return {
      alignmentEdge: previousPositions.alignmentEdge,
      isAuto: previousPositions.isAuto,
      targetEdge: previousPositions.targetEdge
    };
  }
  var positionInformation = __assign$1({}, DirectionalDictionary[directionalHint]);
  if (getRTL()) {
    if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {
      positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;
    }
    return directionalHintForRTL !== void 0 ? DirectionalDictionary[directionalHintForRTL] : positionInformation;
  }
  return positionInformation;
}
function _getAlignmentData(positionData, target, boundingRect, coverTarget, alignTargetEdge) {
  if (positionData.isAuto) {
    positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);
  }
  positionData.alignTargetEdge = alignTargetEdge;
  return positionData;
}
function getClosestEdge(targetEdge, target, boundingRect) {
  var targetCenter = _getCenterValue(target, targetEdge);
  var boundingCenter = _getCenterValue(boundingRect, targetEdge);
  var _a2 = _getFlankingEdges(targetEdge), positiveEdge = _a2.positiveEdge, negativeEdge = _a2.negativeEdge;
  if (targetCenter <= boundingCenter) {
    return positiveEdge;
  } else {
    return negativeEdge;
  }
}
function _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
  var estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);
  if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {
    return {
      elementRectangle: estimatedElementPosition,
      targetEdge: positionData.targetEdge,
      alignmentEdge: positionData.alignmentEdge
    };
  } else {
    return _adjustFitWithinBounds(estimatedElementPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget);
  }
}
function _finalizeBeakPosition(elementPosition, positionedBeak, bounds) {
  var targetEdge = elementPosition.targetEdge * -1;
  var actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);
  var returnValue = {};
  var returnEdge = _finalizeReturnEdge(elementPosition.elementRectangle, elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge, bounds);
  var beakEdgeDifference = _getRelativeEdgeDifference(elementPosition.elementRectangle, elementPosition.targetRectangle, targetEdge);
  var showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));
  returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);
  returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);
  return {
    elementPosition: __assign$1({}, returnValue),
    closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),
    targetEdge,
    hideBeak: !showBeak
  };
}
function _positionBeak(beakWidth, elementPosition) {
  var target = elementPosition.targetRectangle;
  var _a2 = _getFlankingEdges(elementPosition.targetEdge), positiveEdge = _a2.positiveEdge, negativeEdge = _a2.negativeEdge;
  var beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);
  var elementBounds = new Rectangle(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);
  var beakPosition = new Rectangle(0, beakWidth, 0, beakWidth);
  beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);
  beakPosition = _centerEdgeToPoint(beakPosition, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));
  if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {
    beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);
  } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {
    beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);
  }
  return beakPosition;
}
function _getRectangleFromElement(element) {
  var clientRect = element.getBoundingClientRect();
  return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);
}
function _getRectangleFromIRect(rect) {
  return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);
}
function _getTargetRect(bounds, target) {
  var targetRectangle;
  if (target) {
    if (!!target.preventDefault) {
      var ev = target;
      targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);
    } else if (!!target.getBoundingClientRect) {
      targetRectangle = _getRectangleFromElement(target);
    } else {
      var rectOrPoint = target;
      var left = rectOrPoint.left || rectOrPoint.x;
      var top_1 = rectOrPoint.top || rectOrPoint.y;
      var right = rectOrPoint.right || left;
      var bottom = rectOrPoint.bottom || top_1;
      targetRectangle = new Rectangle(left, right, top_1, bottom);
    }
    if (!_isRectangleWithinBounds(targetRectangle, bounds)) {
      var outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);
      for (var _i = 0, outOfBounds_1 = outOfBounds; _i < outOfBounds_1.length; _i++) {
        var direction = outOfBounds_1[_i];
        targetRectangle[RectangleEdge[direction]] = bounds[RectangleEdge[direction]];
      }
    }
  } else {
    targetRectangle = new Rectangle(0, 0, 0, 0);
  }
  return targetRectangle;
}
function _positionElementRelative(props, elementToPosition, boundingRect, previousPositions) {
  var gap = props.gapSpace ? props.gapSpace : 0;
  var targetRect = _getTargetRect(boundingRect, props.target);
  var positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions), targetRect, boundingRect, props.coverTarget, props.alignTargetEdge);
  var positionedElement = _positionElementWithinBounds(_getRectangleFromElement(elementToPosition), targetRect, boundingRect, positionData, gap, props.directionalHintFixed, props.coverTarget);
  return __assign$1(__assign$1({}, positionedElement), { targetRectangle: targetRect });
}
function _finalizePositionData(positionedElement, hostElement, bounds, coverTarget, doNotFinalizeReturnEdge) {
  var finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, bounds, positionedElement.alignmentEdge, coverTarget, doNotFinalizeReturnEdge, positionedElement.forcedInBounds);
  return {
    elementPosition: finalizedElement,
    targetEdge: positionedElement.targetEdge,
    alignmentEdge: positionedElement.alignmentEdge
  };
}
function _positionCallout(props, hostElement, callout, previousPositions, doNotFinalizeReturnEdge) {
  var beakWidth = props.isBeakVisible ? props.beakWidth || 0 : 0;
  var gap = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);
  var positionProps = props;
  positionProps.gapSpace = gap;
  var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
  var positionedElement = _positionElementRelative(positionProps, callout, boundingRect, previousPositions);
  var beakPositioned = _positionBeak(beakWidth, positionedElement);
  var finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned, boundingRect);
  return __assign$1(__assign$1({}, _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge)), { beakPosition: finalizedBeakPosition });
}
function _positionCard(props, hostElement, callout, previousPositions) {
  return _positionCallout(props, hostElement, callout, previousPositions, true);
}
function positionCallout(props, hostElement, elementToPosition, previousPositions) {
  return _positionCallout(props, hostElement, elementToPosition, previousPositions);
}
function positionCard(props, hostElement, elementToPosition, previousPositions) {
  return _positionCard(props, hostElement, elementToPosition, previousPositions);
}
function getOppositeEdge(edge) {
  return edge * -1;
}
function _getBoundsFromTargetWindow(target, targetWindow) {
  var segments = void 0;
  if (targetWindow.getWindowSegments) {
    segments = targetWindow.getWindowSegments();
  }
  if (segments === void 0 || segments.length <= 1) {
    return {
      top: 0,
      left: 0,
      right: targetWindow.innerWidth,
      bottom: targetWindow.innerHeight,
      width: targetWindow.innerWidth,
      height: targetWindow.innerHeight
    };
  }
  var x = 0;
  var y = 0;
  if (target !== null && !!target.getBoundingClientRect) {
    var clientRect = target.getBoundingClientRect();
    x = (clientRect.left + clientRect.right) / 2;
    y = (clientRect.top + clientRect.bottom) / 2;
  } else if (target !== null) {
    x = target.left || target.x;
    y = target.top || target.y;
  }
  var bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };
  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
    var segment = segments_1[_i];
    if (x && segment.left <= x && segment.right >= x && y && segment.top <= y && segment.bottom >= y) {
      bounds = {
        top: segment.top,
        left: segment.left,
        right: segment.right,
        bottom: segment.bottom,
        width: segment.width,
        height: segment.height
      };
    }
  }
  return bounds;
}
function getBoundsFromTargetWindow(target, targetWindow) {
  return _getBoundsFromTargetWindow(target, targetWindow);
}
function useAsync() {
  var asyncRef = React__namespace.useRef();
  if (!asyncRef.current) {
    asyncRef.current = new Async();
  }
  React__namespace.useEffect(function() {
    return function() {
      var _a2;
      (_a2 = asyncRef.current) === null || _a2 === void 0 ? void 0 : _a2.dispose();
      asyncRef.current = void 0;
    };
  }, []);
  return asyncRef.current;
}
function useConst(initialValue) {
  var ref = React__namespace.useRef();
  if (ref.current === void 0) {
    ref.current = {
      value: typeof initialValue === "function" ? initialValue() : initialValue
    };
  }
  return ref.current.value;
}
function useBoolean(initialState) {
  var _a2 = React__namespace.useState(initialState), value = _a2[0], setValue = _a2[1];
  var setTrue = useConst(function() {
    return function() {
      setValue(true);
    };
  });
  var setFalse = useConst(function() {
    return function() {
      setValue(false);
    };
  });
  var toggle = useConst(function() {
    return function() {
      setValue(function(currentValue) {
        return !currentValue;
      });
    };
  });
  return [value, { setTrue, setFalse, toggle }];
}
function useControllableValue(controlledValue, defaultUncontrolledValue, onChange2) {
  var _a2 = React__namespace.useState(defaultUncontrolledValue), value = _a2[0], setValue = _a2[1];
  var isControlled2 = useConst(controlledValue !== void 0);
  var currentValue = isControlled2 ? controlledValue : value;
  var valueRef = React__namespace.useRef(currentValue);
  var onChangeRef = React__namespace.useRef(onChange2);
  React__namespace.useEffect(function() {
    valueRef.current = currentValue;
    onChangeRef.current = onChange2;
  });
  var setValueOrCallOnChange = useConst(function() {
    return function(update, ev) {
      var newValue = typeof update === "function" ? update(valueRef.current) : update;
      if (onChangeRef.current) {
        onChangeRef.current(ev, newValue);
      }
      if (!isControlled2) {
        setValue(newValue);
      }
    };
  });
  return [currentValue, setValueOrCallOnChange];
}
function useEventCallback(fn) {
  var callbackRef = React__namespace.useRef(function() {
    throw new Error("Cannot call an event handler while rendering");
  });
  useIsomorphicLayoutEffect(function() {
    callbackRef.current = fn;
  }, [fn]);
  return useConst(function() {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var callback = callbackRef.current;
      return callback.apply(void 0, args);
    };
  });
}
function useId(prefix2, providedId) {
  var ref = React__namespace.useRef(providedId);
  if (!ref.current) {
    ref.current = getId(prefix2);
  }
  return ref.current;
}
function useMergedRefs() {
  var refs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    refs[_i] = arguments[_i];
  }
  var mergedCallback = React__namespace.useCallback(function(value) {
    mergedCallback.current = value;
    for (var _i2 = 0, refs_1 = refs; _i2 < refs_1.length; _i2++) {
      var ref = refs_1[_i2];
      if (typeof ref === "function") {
        ref(value);
      } else if (ref) {
        ref.current = value;
      }
    }
  }, __spreadArray([], refs));
  return mergedCallback;
}
function useOnEvent(element, eventName, callback, useCapture) {
  var callbackRef = React__namespace.useRef(callback);
  callbackRef.current = callback;
  React__namespace.useEffect(function() {
    var actualElement = element && "current" in element ? element.current : element;
    if (!actualElement) {
      return;
    }
    var dispose = on(actualElement, eventName, function(ev) {
      return callbackRef.current(ev);
    }, useCapture);
    return dispose;
  }, [element, eventName, useCapture]);
}
function usePrevious(value) {
  var ref = React.useRef();
  React.useEffect(function() {
    ref.current = value;
  });
  return ref.current;
}
var useSetTimeout = function() {
  var timeoutIds = useConst({});
  React__namespace.useEffect(
    function() {
      return function() {
        for (var _i = 0, _a2 = Object.keys(timeoutIds); _i < _a2.length; _i++) {
          var id = _a2[_i];
          clearTimeout(id);
        }
      };
    },
    // useConst ensures this will never change, but react-hooks/exhaustive-deps doesn't know that
    [timeoutIds]
  );
  return useConst({
    setTimeout: function(func, duration) {
      var id = setTimeout(func, duration);
      timeoutIds[id] = 1;
      return id;
    },
    clearTimeout: function(id) {
      delete timeoutIds[id];
      clearTimeout(id);
    }
  });
};
var WindowContext = React__namespace.createContext({
  window: typeof window === "object" ? window : void 0
});
var useWindow = function() {
  return React__namespace.useContext(WindowContext).window;
};
var useDocument = function() {
  var _a2;
  return (_a2 = React__namespace.useContext(WindowContext).window) === null || _a2 === void 0 ? void 0 : _a2.document;
};
function useTarget(target, hostElement) {
  var previousTargetProp = React__namespace.useRef();
  var targetRef = React__namespace.useRef(null);
  var targetWindow = useWindow();
  if (!target || target !== previousTargetProp.current || typeof target === "string") {
    var currentElement = hostElement === null || hostElement === void 0 ? void 0 : hostElement.current;
    if (target) {
      if (typeof target === "string") {
        var currentDoc = getDocument(currentElement);
        targetRef.current = currentDoc ? currentDoc.querySelector(target) : null;
      } else if ("stopPropagation" in target) {
        targetRef.current = target;
      } else if ("getBoundingClientRect" in target) {
        targetRef.current = target;
      } else if ("current" in target) {
        targetRef.current = target.current;
      } else {
        targetRef.current = target;
      }
    }
    previousTargetProp.current = target;
  }
  return [targetRef, targetWindow];
}
var useUnmount = function(callback) {
  var unmountRef = React__namespace.useRef(callback);
  unmountRef.current = callback;
  React__namespace.useEffect(function() {
    return function() {
      var _a2;
      (_a2 = unmountRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unmountRef);
    };
  }, []);
};
var warningId = 0;
function useWarnings(options2) {
  if (process.env.NODE_ENV !== "production") {
    var name_1 = options2.name, props = options2.props, _a2 = options2.other, other = _a2 === void 0 ? [] : _a2, conditionallyRequired = options2.conditionallyRequired, deprecations = options2.deprecations, mutuallyExclusive = options2.mutuallyExclusive, controlledUsage = options2.controlledUsage;
    var hasWarnedRef = React__namespace.useRef(false);
    var componentId = useConst(function() {
      return "useWarnings_" + warningId++;
    });
    var oldProps = usePrevious(props);
    if (!hasWarnedRef.current) {
      hasWarnedRef.current = true;
      for (var _i = 0, other_1 = other; _i < other_1.length; _i++) {
        var warning = other_1[_i];
        warn(warning);
      }
      if (conditionallyRequired) {
        for (var _b2 = 0, conditionallyRequired_1 = conditionallyRequired; _b2 < conditionallyRequired_1.length; _b2++) {
          var req = conditionallyRequired_1[_b2];
          warnConditionallyRequiredProps(name_1, props, req.requiredProps, req.conditionalPropName, req.condition);
        }
      }
      deprecations && warnDeprecations(name_1, props, deprecations);
      mutuallyExclusive && warnMutuallyExclusive(name_1, props, mutuallyExclusive);
    }
    controlledUsage && warnControlledUsage(__assign$1(__assign$1({}, controlledUsage), { componentId, props, componentName: name_1, oldProps }));
  }
}
function useScrollbarAsync(props, root2) {
  var async = useAsync();
  var _a2 = React__namespace.useState(false), needsVerticalScrollBarState = _a2[0], setNeedsVerticalScrollBar = _a2[1];
  React__namespace.useEffect(function() {
    async.requestAnimationFrame(function() {
      var _a3;
      if (props.style && props.style.overflowY) {
        return;
      }
      var needsVerticalScrollBar = false;
      if (root2 && root2.current && ((_a3 = root2.current) === null || _a3 === void 0 ? void 0 : _a3.firstElementChild)) {
        var rootHeight = root2.current.clientHeight;
        var firstChildHeight = root2.current.firstElementChild.clientHeight;
        if (rootHeight > 0 && firstChildHeight > rootHeight) {
          needsVerticalScrollBar = firstChildHeight - rootHeight > 1;
        }
      }
      if (needsVerticalScrollBarState !== needsVerticalScrollBar) {
        setNeedsVerticalScrollBar(needsVerticalScrollBar);
      }
    });
    return function() {
      return async.dispose();
    };
  });
  return needsVerticalScrollBarState;
}
function defaultFocusRestorer(options2) {
  var originalElement = options2.originalElement, containsFocus = options2.containsFocus;
  if (originalElement && containsFocus && originalElement !== getWindow$1()) {
    setTimeout(function() {
      var _a2;
      (_a2 = originalElement.focus) === null || _a2 === void 0 ? void 0 : _a2.call(originalElement);
    }, 0);
  }
}
function useRestoreFocus(props, root2) {
  var _a2 = props.onRestoreFocus, onRestoreFocus = _a2 === void 0 ? defaultFocusRestorer : _a2;
  var originalFocusedElement = React__namespace.useRef();
  var containsFocus = React__namespace.useRef(false);
  React__namespace.useEffect(function() {
    originalFocusedElement.current = getDocument().activeElement;
    if (doesElementContainFocus(root2.current)) {
      containsFocus.current = true;
    }
    return function() {
      var _a3;
      onRestoreFocus === null || onRestoreFocus === void 0 ? void 0 : onRestoreFocus({
        originalElement: originalFocusedElement.current,
        containsFocus: containsFocus.current,
        documentContainsFocus: ((_a3 = getDocument()) === null || _a3 === void 0 ? void 0 : _a3.hasFocus()) || false
      });
      originalFocusedElement.current = void 0;
    };
  }, []);
  useOnEvent(root2, "focus", React__namespace.useCallback(function() {
    containsFocus.current = true;
  }, []), true);
  useOnEvent(root2, "blur", React__namespace.useCallback(function(ev) {
    if (root2.current && ev.relatedTarget && !root2.current.contains(ev.relatedTarget)) {
      containsFocus.current = false;
    }
  }, []), true);
}
function useHideSiblingNodes(props, root2) {
  var shouldHideSiblings = String(props["aria-modal"]).toLowerCase() === "true" && props.enableAriaHiddenSiblings;
  React__namespace.useEffect(function() {
    if (!(shouldHideSiblings && root2.current)) {
      return;
    }
    var unmodalize2 = modalize(root2.current);
    return unmodalize2;
  }, [root2, shouldHideSiblings]);
}
var Popup = React__namespace.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults({ shouldRestoreFocus: true, enableAriaHiddenSiblings: true }, propsWithoutDefaults);
  var root2 = React__namespace.useRef();
  var mergedRootRef = useMergedRefs(root2, forwardedRef);
  useHideSiblingNodes(props, root2);
  useRestoreFocus(props, root2);
  var role = props.role, className = props.className, ariaLabel = props.ariaLabel, ariaLabelledBy = props.ariaLabelledBy, ariaDescribedBy = props.ariaDescribedBy, style = props.style, children = props.children, onDismiss = props.onDismiss;
  var needsVerticalScrollBar = useScrollbarAsync(props, root2);
  var onKeyDown = React__namespace.useCallback(function(ev) {
    switch (ev.which) {
      case KeyCodes.escape:
        if (onDismiss) {
          onDismiss(ev);
          ev.preventDefault();
          ev.stopPropagation();
        }
        break;
    }
  }, [onDismiss]);
  var win2 = useWindow();
  useOnEvent(win2, "keydown", onKeyDown);
  return React__namespace.createElement("div", __assign$1({ ref: mergedRootRef }, getNativeProps(props, divProperties), { className, role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, onKeyDown, style: __assign$1({ overflowY: needsVerticalScrollBar ? "scroll" : void 0, outline: "none" }, style) }), children);
});
Popup.displayName = "Popup";
var _a$5;
var COMPONENT_NAME$d = "CalloutContentBase";
var ANIMATIONS = (_a$5 = {}, _a$5[RectangleEdge.top] = AnimationClassNames.slideUpIn10, _a$5[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10, _a$5[RectangleEdge.left] = AnimationClassNames.slideLeftIn10, _a$5[RectangleEdge.right] = AnimationClassNames.slideRightIn10, _a$5);
var BEAK_ORIGIN_POSITION = { top: 0, left: 0 };
var OFF_SCREEN_STYLE = {
  opacity: 0,
  filter: "opacity(0)",
  pointerEvents: "none"
};
var ARIA_ROLE_ATTRIBUTES = ["role", "aria-roledescription"];
var DEFAULT_PROPS$9 = {
  preventDismissOnLostFocus: false,
  preventDismissOnScroll: false,
  preventDismissOnResize: false,
  isBeakVisible: true,
  beakWidth: 16,
  gapSpace: 0,
  minPagePadding: 8,
  directionalHint: DirectionalHint.bottomAutoEdge
};
var getClassNames$R = classNamesFunction({
  disableCaching: true
  // disabling caching because stylesProp.position mutates often
});
function useBounds(_a2, targetRef, targetWindow) {
  var bounds = _a2.bounds, _b2 = _a2.minPagePadding, minPagePadding = _b2 === void 0 ? DEFAULT_PROPS$9.minPagePadding : _b2, target = _a2.target;
  var _c2 = React__namespace.useState(false), targetWindowResized = _c2[0], setTargetWindowResized = _c2[1];
  var cachedBounds = React__namespace.useRef();
  var getBounds = React__namespace.useCallback(function() {
    if (!cachedBounds.current || targetWindowResized) {
      var currentBounds = typeof bounds === "function" ? targetWindow ? bounds(target, targetWindow) : void 0 : bounds;
      if (!currentBounds && targetWindow) {
        currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);
        currentBounds = {
          top: currentBounds.top + minPagePadding,
          left: currentBounds.left + minPagePadding,
          right: currentBounds.right - minPagePadding,
          bottom: currentBounds.bottom - minPagePadding,
          width: currentBounds.width - minPagePadding * 2,
          height: currentBounds.height - minPagePadding * 2
        };
      }
      cachedBounds.current = currentBounds;
      targetWindowResized && setTargetWindowResized(false);
    }
    return cachedBounds.current;
  }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);
  var async = useAsync();
  useOnEvent(targetWindow, "resize", async.debounce(function() {
    setTargetWindowResized(true);
  }, 500, { leading: true }));
  return getBounds;
}
function useMaxHeight(_a2, getBounds, positions) {
  var _b2;
  var calloutMaxHeight = _a2.calloutMaxHeight, finalHeight = _a2.finalHeight, directionalHint = _a2.directionalHint, directionalHintFixed = _a2.directionalHintFixed, hidden = _a2.hidden;
  var _c2 = React__namespace.useState(), maxHeight = _c2[0], setMaxHeight = _c2[1];
  var _d2 = (_b2 = positions === null || positions === void 0 ? void 0 : positions.elementPosition) !== null && _b2 !== void 0 ? _b2 : {}, top = _d2.top, bottom = _d2.bottom;
  React__namespace.useEffect(function() {
    var _a3;
    var _b3 = (_a3 = getBounds()) !== null && _a3 !== void 0 ? _a3 : {}, topBounds = _b3.top, bottomBounds = _b3.bottom;
    var calculatedHeight;
    if (typeof top === "number" && bottomBounds) {
      calculatedHeight = bottomBounds - top;
    } else if (typeof bottom === "number" && typeof topBounds === "number" && bottomBounds) {
      calculatedHeight = bottomBounds - topBounds - bottom;
    }
    if (!calloutMaxHeight && !hidden || calloutMaxHeight && calculatedHeight && calloutMaxHeight > calculatedHeight) {
      setMaxHeight(calculatedHeight);
    } else if (calloutMaxHeight) {
      setMaxHeight(calloutMaxHeight);
    } else {
      setMaxHeight(void 0);
    }
  }, [bottom, calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, getBounds, hidden, positions, top]);
  return maxHeight;
}
function usePositions(props, hostElement, calloutElement, targetRef, getBounds) {
  var _a2 = React__namespace.useState(), positions = _a2[0], setPositions = _a2[1];
  var positionAttempts = React__namespace.useRef(0);
  var previousTarget = React__namespace.useRef();
  var async = useAsync();
  var hidden = props.hidden, target = props.target, finalHeight = props.finalHeight, calloutMaxHeight = props.calloutMaxHeight, onPositioned = props.onPositioned, directionalHint = props.directionalHint;
  React__namespace.useEffect(function() {
    if (!hidden) {
      var timerId_1 = async.requestAnimationFrame(function() {
        var _a3, _b2;
        if (hostElement.current && calloutElement) {
          var currentProps = __assign$1(__assign$1({}, props), { target: targetRef.current, bounds: getBounds() });
          var dupeCalloutElement = calloutElement.cloneNode(true);
          dupeCalloutElement.style.maxHeight = calloutMaxHeight ? "" + calloutMaxHeight : "";
          dupeCalloutElement.style.visibility = "hidden";
          (_a3 = calloutElement.parentElement) === null || _a3 === void 0 ? void 0 : _a3.appendChild(dupeCalloutElement);
          var previousPositions = previousTarget.current === target ? positions : void 0;
          var newPositions = finalHeight ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions) : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions);
          (_b2 = calloutElement.parentElement) === null || _b2 === void 0 ? void 0 : _b2.removeChild(dupeCalloutElement);
          if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {
            positionAttempts.current++;
            setPositions(newPositions);
          } else if (positionAttempts.current > 0) {
            positionAttempts.current = 0;
            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(positions);
          }
        }
      }, calloutElement);
      previousTarget.current = target;
      return function() {
        async.cancelAnimationFrame(timerId_1);
        previousTarget.current = void 0;
      };
    } else {
      setPositions(void 0);
      positionAttempts.current = 0;
    }
  }, [
    hidden,
    directionalHint,
    async,
    calloutElement,
    calloutMaxHeight,
    hostElement,
    targetRef,
    finalHeight,
    getBounds,
    onPositioned,
    positions,
    props,
    target
  ]);
  return positions;
}
function useAutoFocus(_a2, positions, calloutElement) {
  var hidden = _a2.hidden, setInitialFocus = _a2.setInitialFocus;
  var async = useAsync();
  var hasPositions = !!positions;
  React__namespace.useEffect(function() {
    if (!hidden && setInitialFocus && hasPositions && calloutElement) {
      var timerId_2 = async.requestAnimationFrame(function() {
        return focusFirstChild(calloutElement);
      }, calloutElement);
      return function() {
        return async.cancelAnimationFrame(timerId_2);
      };
    }
  }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);
}
function useDismissHandlers(_a2, positions, hostElement, targetRef, targetWindow) {
  var hidden = _a2.hidden, onDismiss = _a2.onDismiss, preventDismissOnScroll = _a2.preventDismissOnScroll, preventDismissOnResize = _a2.preventDismissOnResize, preventDismissOnLostFocus = _a2.preventDismissOnLostFocus, dismissOnTargetClick = _a2.dismissOnTargetClick, shouldDismissOnWindowFocus = _a2.shouldDismissOnWindowFocus, preventDismissOnEvent = _a2.preventDismissOnEvent;
  var isMouseDownOnPopup = React__namespace.useRef(false);
  var async = useAsync();
  var mouseDownHandlers = useConst([
    function() {
      isMouseDownOnPopup.current = true;
    },
    function() {
      isMouseDownOnPopup.current = false;
    }
  ]);
  var positionsExists = !!positions;
  React__namespace.useEffect(function() {
    var dismissOnScroll = function(ev) {
      if (positionsExists && !preventDismissOnScroll) {
        dismissOnClickOrScroll(ev);
      }
    };
    var dismissOnResize = function(ev) {
      if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var dismissOnLostFocus = function(ev) {
      if (!preventDismissOnLostFocus) {
        dismissOnClickOrScroll(ev);
      }
    };
    var dismissOnClickOrScroll = function(ev) {
      var eventPaths = ev.composedPath ? ev.composedPath() : [];
      var target = eventPaths.length > 0 ? eventPaths[0] : ev.target;
      var isEventTargetOutsideCallout = hostElement.current && !elementContains(hostElement.current, target);
      if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {
        isMouseDownOnPopup.current = false;
        return;
      }
      if (!targetRef.current && isEventTargetOutsideCallout || ev.target !== targetWindow && isEventTargetOutsideCallout && (!targetRef.current || "stopPropagation" in targetRef.current || dismissOnTargetClick || target !== targetRef.current && !elementContains(targetRef.current, target))) {
        if (preventDismissOnEvent && preventDismissOnEvent(ev)) {
          return;
        }
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var dismissOnTargetWindowBlur = function(ev) {
      if (!shouldDismissOnWindowFocus) {
        return;
      }
      if ((preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) && !(targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.hasFocus()) && ev.relatedTarget === null) {
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
      }
    };
    var disposablesPromise = new Promise(function(resolve) {
      async.setTimeout(function() {
        if (!hidden && targetWindow) {
          var disposables_1 = [
            on(targetWindow, "scroll", dismissOnScroll, true),
            on(targetWindow, "resize", dismissOnResize, true),
            on(targetWindow.document.documentElement, "focus", dismissOnLostFocus, true),
            on(targetWindow.document.documentElement, "click", dismissOnLostFocus, true),
            on(targetWindow, "blur", dismissOnTargetWindowBlur, true)
          ];
          resolve(function() {
            disposables_1.forEach(function(dispose) {
              return dispose();
            });
          });
        }
      }, 0);
    });
    return function() {
      disposablesPromise.then(function(dispose) {
        return dispose();
      });
    };
  }, [
    hidden,
    async,
    hostElement,
    targetRef,
    targetWindow,
    onDismiss,
    shouldDismissOnWindowFocus,
    dismissOnTargetClick,
    preventDismissOnLostFocus,
    preventDismissOnResize,
    preventDismissOnScroll,
    positionsExists,
    preventDismissOnEvent
  ]);
  return mouseDownHandlers;
}
var CalloutContentBase = React__namespace.memo(React__namespace.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults(DEFAULT_PROPS$9, propsWithoutDefaults);
  var styles2 = props.styles, style = props.style, ariaLabel = props.ariaLabel, ariaDescribedBy = props.ariaDescribedBy, ariaLabelledBy = props.ariaLabelledBy, className = props.className, isBeakVisible = props.isBeakVisible, children = props.children, beakWidth = props.beakWidth, calloutWidth = props.calloutWidth, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer, finalHeight = props.finalHeight, _a2 = props.hideOverflow, hideOverflow = _a2 === void 0 ? !!finalHeight : _a2, backgroundColor2 = props.backgroundColor, calloutMaxHeight = props.calloutMaxHeight, onScroll = props.onScroll, _b2 = props.shouldRestoreFocus, shouldRestoreFocus = _b2 === void 0 ? true : _b2, target = props.target, hidden = props.hidden, onLayerMounted = props.onLayerMounted, popupProps = props.popupProps;
  var hostElement = React__namespace.useRef(null);
  var _c2 = React__namespace.useState(null), calloutElement = _c2[0], setCalloutElement = _c2[1];
  var calloutCallback = React__namespace.useCallback(function(calloutEl) {
    setCalloutElement(calloutEl);
  }, []);
  var rootRef = useMergedRefs(hostElement, forwardedRef);
  var _d2 = useTarget(props.target, {
    current: calloutElement
  }), targetRef = _d2[0], targetWindow = _d2[1];
  var getBounds = useBounds(props, targetRef, targetWindow);
  var positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds);
  var maxHeight = useMaxHeight(props, getBounds, positions);
  var _e2 = useDismissHandlers(props, positions, hostElement, targetRef, targetWindow), mouseDownOnPopup = _e2[0], mouseUpOnPopup = _e2[1];
  var isForcedInBounds = (positions === null || positions === void 0 ? void 0 : positions.elementPosition.top) && (positions === null || positions === void 0 ? void 0 : positions.elementPosition.bottom);
  var cssPositions = __assign$1(__assign$1({}, positions === null || positions === void 0 ? void 0 : positions.elementPosition), { maxHeight });
  if (isForcedInBounds) {
    cssPositions.bottom = void 0;
  }
  useAutoFocus(props, positions, calloutElement);
  React__namespace.useEffect(function() {
    if (!hidden) {
      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
    }
  }, [hidden]);
  if (!targetWindow) {
    return null;
  }
  var overflowYHidden = hideOverflow;
  var beakVisible = isBeakVisible && !!target;
  var classNames2 = getClassNames$R(styles2, {
    theme: props.theme,
    className,
    overflowYHidden,
    calloutWidth,
    positions,
    beakWidth,
    backgroundColor: backgroundColor2,
    calloutMaxWidth,
    calloutMinWidth,
    doNotLayer
  });
  var overflowStyle = __assign$1(__assign$1({ maxHeight: calloutMaxHeight ? calloutMaxHeight : "100%" }, style), overflowYHidden && { overflowY: "hidden" });
  var visibilityStyle = props.hidden ? { visibility: "hidden" } : void 0;
  return React__namespace.createElement(
    "div",
    { ref: rootRef, className: classNames2.container, style: visibilityStyle },
    React__namespace.createElement(
      "div",
      __assign$1({}, getNativeProps(props, divProperties, ARIA_ROLE_ATTRIBUTES), {
        className: css$3(classNames2.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]),
        style: positions ? __assign$1({}, cssPositions) : OFF_SCREEN_STYLE,
        // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.
        // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
        tabIndex: -1,
        ref: calloutCallback
      }),
      beakVisible && React__namespace.createElement("div", { className: classNames2.beak, style: getBeakPosition(positions) }),
      beakVisible && React__namespace.createElement("div", { className: classNames2.beakCurtain }),
      React__namespace.createElement(
        Popup,
        __assign$1({
          // don't use getNativeElementProps for role and roledescription because it will also
          // pass through data-* props (resulting in them being used in two places)
          role: props.role,
          "aria-roledescription": props["aria-roledescription"],
          ariaDescribedBy,
          ariaLabel,
          ariaLabelledBy,
          className: classNames2.calloutMain,
          onDismiss: props.onDismiss,
          onMouseDown: mouseDownOnPopup,
          onMouseUp: mouseUpOnPopup,
          onRestoreFocus: props.onRestoreFocus,
          onScroll,
          shouldRestoreFocus,
          style: overflowStyle
        }, popupProps),
        children
      )
    )
  );
}), function(previousProps, nextProps) {
  if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {
    return true;
  }
  return shallowCompare(previousProps, nextProps);
});
function getBeakPosition(positions) {
  var _a2, _b2;
  var beakPositionStyle = __assign$1(__assign$1({}, (_a2 = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _a2 === void 0 ? void 0 : _a2.elementPosition), { display: ((_b2 = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _b2 === void 0 ? void 0 : _b2.hideBeak) ? "none" : void 0 });
  if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {
    beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;
    beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;
  }
  return beakPositionStyle;
}
function arePositionsEqual(prevElementPositions, newElementPosition) {
  return comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) && comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition);
}
function comparePositions(prevElementPositions, newElementPositions) {
  for (var key in newElementPositions) {
    if (newElementPositions.hasOwnProperty(key)) {
      var oldPositionEdge = prevElementPositions[key];
      var newPositionEdge = newElementPositions[key];
      if (oldPositionEdge !== void 0 && newPositionEdge !== void 0) {
        if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  return true;
}
CalloutContentBase.displayName = COMPONENT_NAME$d;
function getBeakStyle(beakWidth) {
  return {
    height: beakWidth,
    width: beakWidth
  };
}
var GlobalClassNames$A = {
  container: "ms-Callout-container",
  root: "ms-Callout",
  beak: "ms-Callout-beak",
  beakCurtain: "ms-Callout-beakCurtain",
  calloutMain: "ms-Callout-main"
};
var getStyles$O = function(props) {
  var _a2;
  var theme = props.theme, className = props.className, overflowYHidden = props.overflowYHidden, calloutWidth = props.calloutWidth, beakWidth = props.beakWidth, backgroundColor2 = props.backgroundColor, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer;
  var classNames2 = getGlobalClassNames(GlobalClassNames$A, theme);
  var semanticColors = theme.semanticColors, effects = theme.effects;
  return {
    container: [
      classNames2.container,
      {
        position: "relative"
      }
    ],
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        position: "absolute",
        display: "flex",
        zIndex: doNotLayer ? ZIndexes.Layer : void 0,
        boxSizing: "border-box",
        borderRadius: effects.roundedCorner2,
        boxShadow: effects.elevation16,
        selectors: (_a2 = {}, _a2[HighContrastSelector] = {
          borderWidth: 1,
          borderStyle: "solid",
          borderColor: "WindowText"
        }, _a2)
      },
      focusClear(),
      className,
      !!calloutWidth && { width: calloutWidth },
      !!calloutMaxWidth && { maxWidth: calloutMaxWidth },
      !!calloutMinWidth && { minWidth: calloutMinWidth }
    ],
    beak: [
      classNames2.beak,
      {
        position: "absolute",
        backgroundColor: semanticColors.menuBackground,
        boxShadow: "inherit",
        border: "inherit",
        boxSizing: "border-box",
        transform: "rotate(45deg)"
      },
      getBeakStyle(beakWidth),
      backgroundColor2 && {
        backgroundColor: backgroundColor2
      }
    ],
    beakCurtain: [
      classNames2.beakCurtain,
      {
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        backgroundColor: semanticColors.menuBackground,
        borderRadius: effects.roundedCorner2
      }
    ],
    calloutMain: [
      classNames2.calloutMain,
      {
        backgroundColor: semanticColors.menuBackground,
        overflowX: "hidden",
        overflowY: "auto",
        position: "relative",
        width: "100%",
        borderRadius: effects.roundedCorner2
      },
      overflowYHidden && {
        overflowY: "hidden"
      },
      backgroundColor2 && {
        backgroundColor: backgroundColor2
      }
    ]
  };
};
var CalloutContent = styled(CalloutContentBase, getStyles$O, void 0, {
  scope: "CalloutContent"
});
const PortalCompatContext = /* @__PURE__ */ React__namespace.createContext(void 0);
const portalCompatContextDefaultValue = () => () => void 0;
PortalCompatContext.Provider;
function usePortalCompat() {
  var _React_useContext;
  return (_React_useContext = React__namespace.useContext(PortalCompatContext)) !== null && _React_useContext !== void 0 ? _React_useContext : portalCompatContextDefaultValue;
}
var getClassNames$Q = classNamesFunction();
var getFabricTheme = memoizeFunction(function(theme, isRTL) {
  return createTheme(__assign$1(__assign$1({}, theme), { rtl: isRTL }));
});
var getDir = function(_a2) {
  var theme = _a2.theme, dir = _a2.dir;
  var contextDir = getRTL(theme) ? "rtl" : "ltr";
  var pageDir = getRTL() ? "rtl" : "ltr";
  var componentDir = dir ? dir : contextDir;
  return {
    // If Fabric dir !== contextDir
    // Or If contextDir !== pageDir
    // Then we need to set dir of the Fabric root
    rootDir: componentDir !== contextDir || componentDir !== pageDir ? componentDir : dir,
    // If dir !== contextDir || pageDir
    // then set contextual theme around content
    needsTheme: componentDir !== contextDir
  };
};
var FabricBase = React__namespace.forwardRef(function(props, ref) {
  var className = props.className, theme = props.theme, applyTheme = props.applyTheme, applyThemeToBody = props.applyThemeToBody, styles2 = props.styles;
  var classNames2 = getClassNames$Q(styles2, {
    theme,
    applyTheme,
    className
  });
  var rootElement = React__namespace.useRef(null);
  useApplyThemeToBody(applyThemeToBody, classNames2, rootElement);
  return React__namespace.createElement(React__namespace.Fragment, null, useRenderedContent(props, classNames2, rootElement, ref));
});
FabricBase.displayName = "FabricBase";
function useRenderedContent(props, _a2, rootElement, ref) {
  var root2 = _a2.root;
  var _b2 = props.as, Root = _b2 === void 0 ? "div" : _b2, dir = props.dir, theme = props.theme;
  var divProps = getNativeProps(props, divProperties, ["dir"]);
  var _c2 = getDir(props), rootDir = _c2.rootDir, needsTheme = _c2.needsTheme;
  var renderedContent = React__namespace.createElement(
    FocusRectsProvider,
    { providerRef: rootElement },
    React__namespace.createElement(Root, __assign$1({ dir: rootDir }, divProps, { className: root2, ref: useMergedRefs(rootElement, ref) }))
  );
  if (needsTheme) {
    renderedContent = // eslint-disable-next-line deprecation/deprecation
    React__namespace.createElement(Customizer, { settings: { theme: getFabricTheme(theme, dir === "rtl") } }, renderedContent);
  }
  return renderedContent;
}
function useApplyThemeToBody(applyThemeToBody, _a2, rootElement) {
  var bodyThemed = _a2.bodyThemed;
  React__namespace.useEffect(function() {
    if (applyThemeToBody) {
      var currentDoc_1 = getDocument(rootElement.current);
      if (currentDoc_1) {
        currentDoc_1.body.classList.add(bodyThemed);
        return function() {
          currentDoc_1.body.classList.remove(bodyThemed);
        };
      }
    }
  }, [bodyThemed, applyThemeToBody, rootElement]);
  return rootElement;
}
var inheritFont = { fontFamily: "inherit" };
var GlobalClassNames$z = {
  root: "ms-Fabric",
  bodyThemed: "ms-Fabric-bodyThemed"
};
var getStyles$N = function(props) {
  var applyTheme = props.applyTheme, className = props.className, preventBlanketFontInheritance = props.preventBlanketFontInheritance, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames$z, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        color: theme.palette.neutralPrimary
      },
      !preventBlanketFontInheritance && {
        "& button": inheritFont,
        "& input": inheritFont,
        "& textarea": inheritFont
      },
      // apply theme to only if applyTheme is true
      applyTheme && {
        color: theme.semanticColors.bodyText,
        backgroundColor: theme.semanticColors.bodyBackground
      },
      className
    ],
    bodyThemed: [
      {
        backgroundColor: theme.semanticColors.bodyBackground
      }
    ]
  };
};
var Fabric = styled(FabricBase, getStyles$N, void 0, {
  scope: "Fabric"
});
var _layersByHostId = {};
var _layerHostsById = {};
var defaultHostId = "fluent-default-layer-host";
var _defaultHostSelector = "#" + defaultHostId;
function registerLayer(hostId, callback) {
  if (!_layersByHostId[hostId]) {
    _layersByHostId[hostId] = [];
  }
  _layersByHostId[hostId].push(callback);
  var layerHosts = _layerHostsById[hostId];
  if (layerHosts) {
    for (var _i = 0, layerHosts_1 = layerHosts; _i < layerHosts_1.length; _i++) {
      var layerHost = layerHosts_1[_i];
      layerHost.notifyLayersChanged();
    }
  }
}
function unregisterLayer(hostId, callback) {
  var layers = _layersByHostId[hostId];
  if (layers) {
    var idx = layers.indexOf(callback);
    if (idx >= 0) {
      layers.splice(idx, 1);
      if (layers.length === 0) {
        delete _layersByHostId[hostId];
      }
    }
  }
  var layerHosts = _layerHostsById[hostId];
  if (layerHosts) {
    for (var _i = 0, layerHosts_2 = layerHosts; _i < layerHosts_2.length; _i++) {
      var layerHost = layerHosts_2[_i];
      layerHost.notifyLayersChanged();
    }
  }
}
function getLayerHost(hostId) {
  var layerHosts = _layerHostsById[hostId];
  return layerHosts && layerHosts[0] || void 0;
}
function createDefaultLayerHost(doc) {
  var host = doc.createElement("div");
  host.setAttribute("id", defaultHostId);
  host.style.cssText = "position:fixed;z-index:1000000";
  doc === null || doc === void 0 ? void 0 : doc.body.appendChild(host);
  return host;
}
function getDefaultTarget() {
  return _defaultHostSelector;
}
var getClassNames$P = classNamesFunction();
var LayerBase = React__namespace.forwardRef(function(props, ref) {
  var registerPortalEl = usePortalCompat();
  var rootRef = React__namespace.useRef(null);
  var mergedRef = useMergedRefs(rootRef, ref);
  var layerRef = React__namespace.useRef();
  var fabricElementRef = React__namespace.useRef(null);
  var _a2 = React__namespace.useState(false), needRaiseLayerMount = _a2[0], setNeedRaiseLayerMount = _a2[1];
  var children = props.children, className = props.className, eventBubblingEnabled = props.eventBubblingEnabled, fabricProps = props.fabricProps, hostId = props.hostId, insertFirst = props.insertFirst, _b2 = props.onLayerDidMount, onLayerDidMount = _b2 === void 0 ? function() {
    return void 0;
  } : _b2, _c2 = props.onLayerMounted, onLayerMounted = _c2 === void 0 ? function() {
    return void 0;
  } : _c2, onLayerWillUnmount = props.onLayerWillUnmount, styles2 = props.styles, theme = props.theme;
  var fabricRef = useMergedRefs(fabricElementRef, fabricProps === null || fabricProps === void 0 ? void 0 : fabricProps.ref);
  var classNames2 = getClassNames$P(styles2, {
    theme,
    className,
    isNotHost: !hostId
  });
  var getHost = function(doc) {
    var _a3, _b3;
    if (hostId) {
      var layerHost = getLayerHost(hostId);
      if (layerHost) {
        return (_a3 = layerHost.rootRef.current) !== null && _a3 !== void 0 ? _a3 : null;
      }
      return (_b3 = doc.getElementById(hostId)) !== null && _b3 !== void 0 ? _b3 : null;
    } else {
      var defaultHostSelector = getDefaultTarget();
      var host = defaultHostSelector ? doc.querySelector(defaultHostSelector) : null;
      if (!host) {
        host = createDefaultLayerHost(doc);
      }
      return host;
    }
  };
  var removeLayerElement = function() {
    onLayerWillUnmount === null || onLayerWillUnmount === void 0 ? void 0 : onLayerWillUnmount();
    var elem = layerRef.current;
    layerRef.current = void 0;
    if (elem && elem.parentNode) {
      elem.parentNode.removeChild(elem);
    }
  };
  var createLayerElement = function() {
    var _a3;
    var doc = getDocument(rootRef.current);
    if (!doc) {
      return;
    }
    var host = getHost(doc);
    if (!host) {
      return;
    }
    removeLayerElement();
    var el = ((_a3 = host.ownerDocument) !== null && _a3 !== void 0 ? _a3 : doc).createElement("div");
    el.className = classNames2.root;
    setPortalAttribute(el);
    setVirtualParent(el, rootRef.current);
    insertFirst ? host.insertBefore(el, host.firstChild) : host.appendChild(el);
    layerRef.current = el;
    setNeedRaiseLayerMount(true);
  };
  useIsomorphicLayoutEffect(function() {
    createLayerElement();
    if (hostId) {
      registerLayer(hostId, createLayerElement);
    }
    var unregisterPortalEl = layerRef.current ? registerPortalEl(layerRef.current) : void 0;
    return function() {
      if (unregisterPortalEl) {
        unregisterPortalEl();
      }
      removeLayerElement();
      if (hostId) {
        unregisterLayer(hostId, createLayerElement);
      }
    };
  }, [hostId]);
  React__namespace.useEffect(function() {
    if (layerRef.current && needRaiseLayerMount) {
      onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
      onLayerDidMount === null || onLayerDidMount === void 0 ? void 0 : onLayerDidMount();
      setNeedRaiseLayerMount(false);
    }
  }, [needRaiseLayerMount, onLayerMounted, onLayerDidMount]);
  useDebugWarnings$3(props);
  return React__namespace.createElement("span", { className: "ms-layer", ref: mergedRef }, layerRef.current && ReactDOM__namespace.createPortal(React__namespace.createElement(
    FocusRectsProvider,
    { layerRoot: true, providerRef: fabricRef },
    React__namespace.createElement(Fabric, __assign$1({}, !eventBubblingEnabled && getFilteredEvents(), fabricProps, { className: css$3(classNames2.content, fabricProps === null || fabricProps === void 0 ? void 0 : fabricProps.className), ref: fabricRef }), children)
  ), layerRef.current));
});
LayerBase.displayName = "LayerBase";
var filteredEventProps;
var onFilterEvent = function(ev) {
  if (ev.eventPhase === Event.BUBBLING_PHASE && ev.type !== "mouseenter" && ev.type !== "mouseleave" && ev.type !== "touchstart" && ev.type !== "touchend") {
    ev.stopPropagation();
  }
};
function getFilteredEvents() {
  if (!filteredEventProps) {
    filteredEventProps = {};
    [
      "onClick",
      "onContextMenu",
      "onDoubleClick",
      "onDrag",
      "onDragEnd",
      "onDragEnter",
      "onDragExit",
      "onDragLeave",
      "onDragOver",
      "onDragStart",
      "onDrop",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onMouseMove",
      "onMouseOver",
      "onMouseOut",
      "onMouseUp",
      "onTouchMove",
      "onTouchStart",
      "onTouchCancel",
      "onTouchEnd",
      "onKeyDown",
      "onKeyPress",
      "onKeyUp",
      "onFocus",
      "onBlur",
      "onChange",
      "onInput",
      "onInvalid",
      "onSubmit"
    ].forEach(function(name) {
      return filteredEventProps[name] = onFilterEvent;
    });
  }
  return filteredEventProps;
}
function useDebugWarnings$3(props) {
  if (process.env.NODE_ENV !== "production") {
    useWarnings({
      name: "Layer",
      props,
      deprecations: { onLayerMounted: "onLayerDidMount" }
    });
  }
}
var GlobalClassNames$y = {
  root: "ms-Layer",
  rootNoHost: "ms-Layer--fixed",
  content: "ms-Layer-content"
};
var getStyles$M = function(props) {
  var className = props.className, isNotHost = props.isNotHost, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames$y, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      isNotHost && [
        classNames2.rootNoHost,
        {
          position: "fixed",
          zIndex: ZIndexes.Layer,
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          visibility: "hidden"
        }
      ],
      className
    ],
    content: [
      classNames2.content,
      {
        visibility: "visible"
      }
    ]
  };
};
var Layer = styled(LayerBase, getStyles$M, void 0, {
  scope: "Layer",
  fields: ["hostId", "theme", "styles"]
});
var Callout = React__namespace.forwardRef(function(_a2, forwardedRef) {
  var layerProps = _a2.layerProps, doNotLayer = _a2.doNotLayer, rest = __rest$1(_a2, ["layerProps", "doNotLayer"]);
  var content = React__namespace.createElement(CalloutContent, __assign$1({}, rest, { doNotLayer, ref: forwardedRef }));
  return doNotLayer ? content : React__namespace.createElement(Layer, __assign$1({}, layerProps), content);
});
Callout.displayName = "Callout";
var COMPONENT_NAME$c = "FocusTrapZone";
var DEFAULT_PROPS$8 = {
  disabled: false,
  disableFirstFocus: false,
  forceFocusInsideTrap: true,
  isClickableOutsideFocusTrap: false
};
var useComponentRef$5 = function(componentRef, previouslyFocusedElement, focusFTZ) {
  React__namespace.useImperativeHandle(componentRef, function() {
    return {
      get previouslyFocusedElement() {
        return previouslyFocusedElement;
      },
      focus: focusFTZ
    };
  }, [focusFTZ, previouslyFocusedElement]);
};
var FocusTrapZone = React__namespace.forwardRef(function(propsWithoutDefaults, ref) {
  var _a2;
  var root2 = React__namespace.useRef(null);
  var firstBumper = React__namespace.useRef(null);
  var lastBumper = React__namespace.useRef(null);
  var mergedRootRef = useMergedRefs(root2, ref);
  var doc = useDocument();
  var isFirstRender = (_a2 = usePrevious(false)) !== null && _a2 !== void 0 ? _a2 : true;
  var props = getPropsWithDefaults(DEFAULT_PROPS$8, propsWithoutDefaults);
  var internalState = useConst({
    hasFocus: false,
    focusStackId: useId("ftz-", props.id)
  });
  var children = props.children, componentRef = props.componentRef, disabled = props.disabled, disableFirstFocus = props.disableFirstFocus, forceFocusInsideTrap = props.forceFocusInsideTrap, focusPreviouslyFocusedInnerElement = props.focusPreviouslyFocusedInnerElement, firstFocusableSelector = props.firstFocusableSelector, firstFocusableTarget = props.firstFocusableTarget, _b2 = props.disableRestoreFocus, disableRestoreFocus = _b2 === void 0 ? props.ignoreExternalFocusing : _b2, isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap, enableAriaHiddenSiblings = props.enableAriaHiddenSiblings;
  var bumperProps = {
    "aria-hidden": true,
    style: {
      pointerEvents: "none",
      position: "fixed"
      // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them
    },
    tabIndex: disabled ? -1 : 0,
    "data-is-visible": true,
    "data-is-focus-trap-zone-bumper": true
  };
  var focusElementAsync = React__namespace.useCallback(function(element) {
    if (element !== firstBumper.current && element !== lastBumper.current) {
      focusAsync(element);
    }
  }, []);
  var focusFTZ = useEventCallback(function() {
    if (!root2.current) {
      return;
    }
    var previouslyFocusedElementInTrapZone = internalState.previouslyFocusedElementInTrapZone;
    if (focusPreviouslyFocusedInnerElement && previouslyFocusedElementInTrapZone && elementContains(root2.current, previouslyFocusedElementInTrapZone)) {
      focusElementAsync(previouslyFocusedElementInTrapZone);
      return;
    }
    var firstFocusableChild = null;
    if (typeof firstFocusableTarget === "string") {
      firstFocusableChild = root2.current.querySelector(firstFocusableTarget);
    } else if (firstFocusableTarget) {
      firstFocusableChild = firstFocusableTarget(root2.current);
    } else if (firstFocusableSelector) {
      var focusSelector = typeof firstFocusableSelector === "string" ? firstFocusableSelector : firstFocusableSelector();
      firstFocusableChild = root2.current.querySelector("." + focusSelector);
    }
    if (!firstFocusableChild) {
      firstFocusableChild = getNextElement(root2.current, root2.current.firstChild, false, false, false, true);
    }
    if (firstFocusableChild) {
      focusElementAsync(firstFocusableChild);
    }
  });
  var focusBumper = function(isFirstBumper) {
    if (disabled || !root2.current) {
      return;
    }
    var nextFocusable = isFirstBumper === internalState.hasFocus ? getLastTabbable(root2.current, lastBumper.current, true, false) : getFirstTabbable(root2.current, firstBumper.current, true, false);
    if (nextFocusable) {
      if (nextFocusable === firstBumper.current || nextFocusable === lastBumper.current) {
        focusFTZ();
      } else {
        nextFocusable.focus();
      }
    }
  };
  var onRootBlurCapture = function(ev) {
    var _a3;
    (_a3 = props.onBlurCapture) === null || _a3 === void 0 ? void 0 : _a3.call(props, ev);
    var relatedTarget = ev.relatedTarget;
    if (ev.relatedTarget === null) {
      relatedTarget = doc.activeElement;
    }
    if (!elementContains(root2.current, relatedTarget)) {
      internalState.hasFocus = false;
    }
  };
  var onRootFocusCapture = function(ev) {
    var _a3;
    (_a3 = props.onFocusCapture) === null || _a3 === void 0 ? void 0 : _a3.call(props, ev);
    if (ev.target === firstBumper.current) {
      focusBumper(true);
    } else if (ev.target === lastBumper.current) {
      focusBumper(false);
    }
    internalState.hasFocus = true;
    if (ev.target !== ev.currentTarget && !(ev.target === firstBumper.current || ev.target === lastBumper.current)) {
      internalState.previouslyFocusedElementInTrapZone = ev.target;
    }
  };
  var returnFocusToInitiator = useEventCallback(function(elementToFocusOnDismiss) {
    FocusTrapZone.focusStack = FocusTrapZone.focusStack.filter(function(value) {
      return internalState.focusStackId !== value;
    });
    if (!doc) {
      return;
    }
    var activeElement = doc.activeElement;
    if (!disableRestoreFocus && typeof (elementToFocusOnDismiss === null || elementToFocusOnDismiss === void 0 ? void 0 : elementToFocusOnDismiss.focus) === "function" && // only restore focus if the current focused element is within the FTZ, or if nothing is focused
    (elementContains(root2.current, activeElement) || activeElement === doc.body)) {
      focusElementAsync(elementToFocusOnDismiss);
    }
  });
  var forceFocusOrClickInTrap = useEventCallback(function(ev) {
    if (disabled) {
      return;
    }
    if (internalState.focusStackId === FocusTrapZone.focusStack.slice(-1)[0]) {
      var targetElement = ev.target;
      if (targetElement && !elementContains(root2.current, targetElement)) {
        if (doc && doc.activeElement === doc.body) {
          setTimeout(function() {
            if (doc && doc.activeElement === doc.body) {
              focusFTZ();
              internalState.hasFocus = true;
            }
          }, 0);
        } else {
          focusFTZ();
          internalState.hasFocus = true;
        }
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  });
  React__namespace.useEffect(function() {
    var disposables = [];
    if (forceFocusInsideTrap) {
      disposables.push(on(window, "focus", forceFocusOrClickInTrap, true));
    }
    if (!isClickableOutsideFocusTrap) {
      disposables.push(on(window, "click", forceFocusOrClickInTrap, true));
    }
    return function() {
      disposables.forEach(function(dispose) {
        return dispose();
      });
    };
  }, [forceFocusInsideTrap, isClickableOutsideFocusTrap]);
  React__namespace.useEffect(function() {
    if (disabled || !isFirstRender && !forceFocusInsideTrap || !root2.current) {
      return;
    }
    FocusTrapZone.focusStack.push(internalState.focusStackId);
    var elementToFocusOnDismiss = props.elementToFocusOnDismiss || doc.activeElement;
    if (!disableFirstFocus && !elementContains(root2.current, elementToFocusOnDismiss)) {
      focusFTZ();
    }
    return function() {
      return returnFocusToInitiator(elementToFocusOnDismiss);
    };
  }, [forceFocusInsideTrap, disabled]);
  React__namespace.useEffect(function() {
    if (!disabled && enableAriaHiddenSiblings) {
      var unmodalize2 = modalize(root2.current);
      return unmodalize2;
    }
  }, [disabled, enableAriaHiddenSiblings, root2]);
  useUnmount(function() {
    delete internalState.previouslyFocusedElementInTrapZone;
  });
  useComponentRef$5(componentRef, internalState.previouslyFocusedElementInTrapZone, focusFTZ);
  return React__namespace.createElement(
    "div",
    __assign$1({ "aria-labelledby": props.ariaLabelledBy }, getNativeProps(props, divProperties), { ref: mergedRootRef, onFocusCapture: onRootFocusCapture, onBlurCapture: onRootBlurCapture }),
    React__namespace.createElement("div", __assign$1({}, bumperProps, { ref: firstBumper })),
    children,
    React__namespace.createElement("div", __assign$1({}, bumperProps, { ref: lastBumper }))
  );
});
FocusTrapZone.displayName = COMPONENT_NAME$c;
FocusTrapZone.focusStack = [];
var FocusTrapCallout = function(props) {
  return React__namespace.createElement(
    Callout,
    __assign$1({}, props),
    React__namespace.createElement(FocusTrapZone, __assign$1({ disabled: props.hidden }, props.focusTrapProps), props.children)
  );
};
var getClassNames$O = classNamesFunction();
var TooltipBase = (
  /** @class */
  function(_super) {
    __extends(TooltipBase2, _super);
    function TooltipBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._onRenderContent = function(props) {
        if (typeof props.content === "string") {
          return React__namespace.createElement("p", { className: _this._classNames.subText }, props.content);
        } else {
          return React__namespace.createElement("div", { className: _this._classNames.subText }, props.content);
        }
      };
      return _this;
    }
    TooltipBase2.prototype.render = function() {
      var _a2 = this.props, className = _a2.className, calloutProps = _a2.calloutProps, directionalHint = _a2.directionalHint, directionalHintForRTL = _a2.directionalHintForRTL, styles2 = _a2.styles, id = _a2.id, maxWidth = _a2.maxWidth, _b2 = _a2.onRenderContent, onRenderContent = _b2 === void 0 ? this._onRenderContent : _b2, targetElement = _a2.targetElement, theme = _a2.theme;
      this._classNames = getClassNames$O(styles2, {
        theme,
        className: className || calloutProps && calloutProps.className,
        beakWidth: calloutProps && calloutProps.isBeakVisible ? calloutProps.beakWidth : 0,
        gapSpace: calloutProps && calloutProps.gapSpace,
        maxWidth
      });
      return React__namespace.createElement(
        Callout,
        __assign$1({ target: targetElement, directionalHint, directionalHintForRTL }, calloutProps, getNativeProps(this.props, divProperties, ["id"]), { className: this._classNames.root }),
        React__namespace.createElement("div", { className: this._classNames.content, id, onFocus: this.props.onFocus, onMouseEnter: this.props.onMouseEnter, onMouseLeave: this.props.onMouseLeave }, onRenderContent(this.props, this._onRenderContent))
      );
    };
    TooltipBase2.defaultProps = {
      directionalHint: DirectionalHint.topCenter,
      maxWidth: "364px",
      calloutProps: {
        isBeakVisible: true,
        beakWidth: 16,
        gapSpace: 0,
        setInitialFocus: true,
        doNotLayer: false
      }
    };
    return TooltipBase2;
  }(React__namespace.Component)
);
var getStyles$L = function(props) {
  var className = props.className, _a2 = props.beakWidth, beakWidth = _a2 === void 0 ? 16 : _a2, _b2 = props.gapSpace, gapSpace = _b2 === void 0 ? 0 : _b2, maxWidth = props.maxWidth, theme = props.theme;
  var semanticColors = theme.semanticColors, fonts = theme.fonts, effects = theme.effects;
  var tooltipGapSpace = -(Math.sqrt(beakWidth * beakWidth / 2) + gapSpace) + 1 / window.devicePixelRatio;
  return {
    root: [
      "ms-Tooltip",
      theme.fonts.medium,
      AnimationClassNames.fadeIn200,
      {
        background: semanticColors.menuBackground,
        boxShadow: effects.elevation8,
        padding: "8px",
        maxWidth,
        selectors: {
          ":after": {
            content: "''",
            position: "absolute",
            bottom: tooltipGapSpace,
            left: tooltipGapSpace,
            right: tooltipGapSpace,
            top: tooltipGapSpace,
            zIndex: 0
          }
        }
      },
      className
    ],
    content: [
      "ms-Tooltip-content",
      fonts.small,
      {
        position: "relative",
        zIndex: 1,
        color: semanticColors.menuItemText,
        wordWrap: "break-word",
        overflowWrap: "break-word",
        overflow: "hidden"
      }
    ],
    subText: [
      "ms-Tooltip-subtext",
      {
        // Using inherit here to avoid unintentional global overrides of the <p> tag.
        fontSize: "inherit",
        fontWeight: "inherit",
        color: "inherit",
        margin: 0
      }
    ]
  };
};
var Tooltip = styled(TooltipBase, getStyles$L, void 0, {
  scope: "Tooltip"
});
var TooltipDelay;
(function(TooltipDelay2) {
  TooltipDelay2[TooltipDelay2["zero"] = 0] = "zero";
  TooltipDelay2[TooltipDelay2["medium"] = 1] = "medium";
  TooltipDelay2[TooltipDelay2["long"] = 2] = "long";
})(TooltipDelay || (TooltipDelay = {}));
var TooltipOverflowMode;
(function(TooltipOverflowMode2) {
  TooltipOverflowMode2[TooltipOverflowMode2["Parent"] = 0] = "Parent";
  TooltipOverflowMode2[TooltipOverflowMode2["Self"] = 1] = "Self";
})(TooltipOverflowMode || (TooltipOverflowMode = {}));
var getClassNames$N = classNamesFunction();
var TooltipHostBase = (
  /** @class */
  function(_super) {
    __extends(TooltipHostBase2, _super);
    function TooltipHostBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._tooltipHost = React__namespace.createRef();
      _this._defaultTooltipId = getId("tooltip");
      _this.show = function() {
        _this._toggleTooltip(true);
      };
      _this.dismiss = function() {
        _this._hideTooltip();
      };
      _this._getTargetElement = function() {
        if (!_this._tooltipHost.current) {
          return void 0;
        }
        var overflowMode = _this.props.overflowMode;
        if (overflowMode !== void 0) {
          switch (overflowMode) {
            case TooltipOverflowMode.Parent:
              return _this._tooltipHost.current.parentElement;
            case TooltipOverflowMode.Self:
              return _this._tooltipHost.current;
          }
        }
        return _this._tooltipHost.current;
      };
      _this._onTooltipFocus = function(ev) {
        if (_this._ignoreNextFocusEvent) {
          _this._ignoreNextFocusEvent = false;
          return;
        }
        _this._onTooltipMouseEnter(ev);
      };
      _this._onTooltipContentFocus = function(ev) {
        if (TooltipHostBase2._currentVisibleTooltip && TooltipHostBase2._currentVisibleTooltip !== _this) {
          TooltipHostBase2._currentVisibleTooltip.dismiss();
        }
        TooltipHostBase2._currentVisibleTooltip = _this;
        _this._clearDismissTimer();
        _this._clearOpenTimer();
      };
      _this._onTooltipBlur = function(ev) {
        _this._ignoreNextFocusEvent = (document === null || document === void 0 ? void 0 : document.activeElement) === ev.target;
        _this._dismissTimerId = _this._async.setTimeout(function() {
          _this._hideTooltip();
        }, 0);
      };
      _this._onTooltipMouseEnter = function(ev) {
        var _a2 = _this.props, overflowMode = _a2.overflowMode, delay = _a2.delay;
        if (TooltipHostBase2._currentVisibleTooltip && TooltipHostBase2._currentVisibleTooltip !== _this) {
          TooltipHostBase2._currentVisibleTooltip.dismiss();
        }
        TooltipHostBase2._currentVisibleTooltip = _this;
        if (overflowMode !== void 0) {
          var overflowElement = _this._getTargetElement();
          if (overflowElement && !hasOverflow(overflowElement)) {
            return;
          }
        }
        if (ev.target && portalContainsElement(ev.target, _this._getTargetElement())) {
          return;
        }
        _this._clearDismissTimer();
        _this._clearOpenTimer();
        if (delay !== TooltipDelay.zero) {
          var delayTime = _this._getDelayTime(delay);
          _this._openTimerId = _this._async.setTimeout(function() {
            _this._toggleTooltip(true);
          }, delayTime);
        } else {
          _this._toggleTooltip(true);
        }
      };
      _this._onTooltipMouseLeave = function(ev) {
        var closeDelay = _this.props.closeDelay;
        _this._clearDismissTimer();
        _this._clearOpenTimer();
        if (closeDelay) {
          _this._dismissTimerId = _this._async.setTimeout(function() {
            _this._toggleTooltip(false);
          }, closeDelay);
        } else {
          _this._toggleTooltip(false);
        }
        if (TooltipHostBase2._currentVisibleTooltip === _this) {
          TooltipHostBase2._currentVisibleTooltip = void 0;
        }
      };
      _this._onTooltipKeyDown = function(ev) {
        if ((ev.which === KeyCodes.escape || ev.ctrlKey) && _this.state.isTooltipVisible) {
          _this._hideTooltip();
          ev.stopPropagation();
        }
      };
      _this._clearDismissTimer = function() {
        _this._async.clearTimeout(_this._dismissTimerId);
      };
      _this._clearOpenTimer = function() {
        _this._async.clearTimeout(_this._openTimerId);
      };
      _this._hideTooltip = function() {
        _this._clearOpenTimer();
        _this._clearDismissTimer();
        _this._toggleTooltip(false);
      };
      _this._toggleTooltip = function(isTooltipVisible) {
        if (_this.state.isTooltipVisible !== isTooltipVisible) {
          _this.setState({ isTooltipVisible }, function() {
            return _this.props.onTooltipToggle && _this.props.onTooltipToggle(isTooltipVisible);
          });
        }
      };
      _this._getDelayTime = function(delay) {
        switch (delay) {
          case TooltipDelay.medium:
            return 300;
          case TooltipDelay.long:
            return 500;
          default:
            return 0;
        }
      };
      initializeComponentRef(_this);
      _this.state = {
        isAriaPlaceholderRendered: false,
        isTooltipVisible: false
      };
      _this._async = new Async(_this);
      return _this;
    }
    TooltipHostBase2.prototype.render = function() {
      var _a2 = this.props, calloutProps = _a2.calloutProps, children = _a2.children, content = _a2.content, directionalHint = _a2.directionalHint, directionalHintForRTL = _a2.directionalHintForRTL, className = _a2.hostClassName, id = _a2.id, _b2 = _a2.setAriaDescribedBy, setAriaDescribedBy = _b2 === void 0 ? true : _b2, tooltipProps = _a2.tooltipProps, styles2 = _a2.styles, theme = _a2.theme;
      this._classNames = getClassNames$N(styles2, {
        theme,
        className
      });
      var isTooltipVisible = this.state.isTooltipVisible;
      var tooltipId = id || this._defaultTooltipId;
      var tooltipRenderProps = __assign$1(__assign$1({ id: tooltipId + "--tooltip", content, targetElement: this._getTargetElement(), directionalHint, directionalHintForRTL, calloutProps: assign$2({}, calloutProps, {
        onDismiss: this._hideTooltip,
        onFocus: this._onTooltipContentFocus,
        onMouseEnter: this._onTooltipMouseEnter,
        onMouseLeave: this._onTooltipMouseLeave
      }), onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave }, getNativeProps(this.props, divProperties, ["id"])), tooltipProps);
      var tooltipContent = (tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.onRenderContent) ? tooltipProps.onRenderContent(tooltipRenderProps, function(props) {
        return (props === null || props === void 0 ? void 0 : props.content) ? React__namespace.createElement(React__namespace.Fragment, null, props.content) : null;
      }) : content;
      var showTooltip = isTooltipVisible && !!tooltipContent;
      var ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && !!tooltipContent ? tooltipId : void 0;
      return React__namespace.createElement(
        "div",
        __assign$1({ className: this._classNames.root, ref: this._tooltipHost }, { onFocusCapture: this._onTooltipFocus }, { onBlurCapture: this._onTooltipBlur }, { onMouseEnter: this._onTooltipMouseEnter, onMouseLeave: this._onTooltipMouseLeave, onKeyDown: this._onTooltipKeyDown, role: "none", "aria-describedby": ariaDescribedBy }),
        children,
        showTooltip && React__namespace.createElement(Tooltip, __assign$1({}, tooltipRenderProps)),
        React__namespace.createElement("div", { hidden: true, id: tooltipId, style: hiddenContentStyle }, tooltipContent)
      );
    };
    TooltipHostBase2.prototype.componentWillUnmount = function() {
      if (TooltipHostBase2._currentVisibleTooltip && TooltipHostBase2._currentVisibleTooltip === this) {
        TooltipHostBase2._currentVisibleTooltip = void 0;
      }
      this._async.dispose();
    };
    TooltipHostBase2.defaultProps = {
      delay: TooltipDelay.medium
    };
    return TooltipHostBase2;
  }(React__namespace.Component)
);
var GlobalClassNames$x = {
  root: "ms-TooltipHost",
  ariaPlaceholder: "ms-TooltipHost-aria-placeholder"
};
var getStyles$K = function(props) {
  var className = props.className, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames$x, theme);
  return {
    root: [
      classNames2.root,
      {
        display: "inline"
      },
      className
    ]
  };
};
var TooltipHost = styled(TooltipHostBase, getStyles$K, void 0, {
  scope: "TooltipHost"
});
var IconType;
(function(IconType2) {
  IconType2[IconType2["default"] = 0] = "default";
  IconType2[IconType2["image"] = 1] = "image";
  IconType2[IconType2["Default"] = 1e5] = "Default";
  IconType2[IconType2["Image"] = 100001] = "Image";
})(IconType || (IconType = {}));
var ImageFit;
(function(ImageFit2) {
  ImageFit2[ImageFit2["center"] = 0] = "center";
  ImageFit2[ImageFit2["contain"] = 1] = "contain";
  ImageFit2[ImageFit2["cover"] = 2] = "cover";
  ImageFit2[ImageFit2["none"] = 3] = "none";
  ImageFit2[ImageFit2["centerCover"] = 4] = "centerCover";
  ImageFit2[ImageFit2["centerContain"] = 5] = "centerContain";
})(ImageFit || (ImageFit = {}));
var ImageCoverStyle;
(function(ImageCoverStyle2) {
  ImageCoverStyle2[ImageCoverStyle2["landscape"] = 0] = "landscape";
  ImageCoverStyle2[ImageCoverStyle2["portrait"] = 1] = "portrait";
})(ImageCoverStyle || (ImageCoverStyle = {}));
var ImageLoadState;
(function(ImageLoadState2) {
  ImageLoadState2[ImageLoadState2["notLoaded"] = 0] = "notLoaded";
  ImageLoadState2[ImageLoadState2["loaded"] = 1] = "loaded";
  ImageLoadState2[ImageLoadState2["error"] = 2] = "error";
  ImageLoadState2[ImageLoadState2["errorLoaded"] = 3] = "errorLoaded";
})(ImageLoadState || (ImageLoadState = {}));
var getClassNames$M = classNamesFunction();
var SVG_REGEX = /\.svg$/i;
var KEY_PREFIX = "fabricImage";
function useLoadState(props, imageElement) {
  var onLoadingStateChange = props.onLoadingStateChange, onLoad = props.onLoad, onError = props.onError, src = props.src;
  var _a2 = React__namespace.useState(ImageLoadState.notLoaded), loadState = _a2[0], setLoadState = _a2[1];
  useIsomorphicLayoutEffect(function() {
    setLoadState(ImageLoadState.notLoaded);
  }, [src]);
  React__namespace.useEffect(function() {
    if (loadState === ImageLoadState.notLoaded) {
      var isLoaded = imageElement.current ? src && imageElement.current.naturalWidth > 0 && imageElement.current.naturalHeight > 0 || imageElement.current.complete && SVG_REGEX.test(src) : false;
      if (isLoaded) {
        setLoadState(ImageLoadState.loaded);
      }
    }
  });
  React__namespace.useEffect(function() {
    onLoadingStateChange === null || onLoadingStateChange === void 0 ? void 0 : onLoadingStateChange(loadState);
  }, [loadState]);
  var onImageLoaded = React__namespace.useCallback(function(ev) {
    onLoad === null || onLoad === void 0 ? void 0 : onLoad(ev);
    if (src) {
      setLoadState(ImageLoadState.loaded);
    }
  }, [src, onLoad]);
  var onImageError = React__namespace.useCallback(function(ev) {
    onError === null || onError === void 0 ? void 0 : onError(ev);
    setLoadState(ImageLoadState.error);
  }, [onError]);
  return [loadState, onImageLoaded, onImageError];
}
var ImageBase = React__namespace.forwardRef(function(props, forwardedRef) {
  var frameElement = React__namespace.useRef();
  var imageElement = React__namespace.useRef();
  var _a2 = useLoadState(props, imageElement), loadState = _a2[0], onImageLoaded = _a2[1], onImageError = _a2[2];
  var imageProps = getNativeProps(props, imgProperties, [
    "width",
    "height"
  ]);
  var src = props.src, alt = props.alt, width = props.width, height = props.height, _b2 = props.shouldFadeIn, shouldFadeIn = _b2 === void 0 ? true : _b2, shouldStartVisible = props.shouldStartVisible, className = props.className, imageFit = props.imageFit, role = props.role, maximizeFrame = props.maximizeFrame, styles2 = props.styles, theme = props.theme, loading = props.loading;
  var coverStyle = useCoverStyle(props, loadState, imageElement, frameElement);
  var classNames2 = getClassNames$M(styles2, {
    theme,
    className,
    width,
    height,
    maximizeFrame,
    shouldFadeIn,
    shouldStartVisible,
    isLoaded: loadState === ImageLoadState.loaded || loadState === ImageLoadState.notLoaded && props.shouldStartVisible,
    isLandscape: coverStyle === ImageCoverStyle.landscape,
    isCenter: imageFit === ImageFit.center,
    isCenterContain: imageFit === ImageFit.centerContain,
    isCenterCover: imageFit === ImageFit.centerCover,
    isContain: imageFit === ImageFit.contain,
    isCover: imageFit === ImageFit.cover,
    isNone: imageFit === ImageFit.none,
    isError: loadState === ImageLoadState.error,
    isNotImageFit: imageFit === void 0
  });
  return React__namespace.createElement(
    "div",
    { className: classNames2.root, style: { width, height }, ref: frameElement },
    React__namespace.createElement("img", __assign$1({}, imageProps, { onLoad: onImageLoaded, onError: onImageError, key: KEY_PREFIX + props.src || "", className: classNames2.image, ref: useMergedRefs(imageElement, forwardedRef), src, alt, role, loading }))
  );
});
ImageBase.displayName = "ImageBase";
function useCoverStyle(props, loadState, imageElement, frameElement) {
  var previousLoadState = React__namespace.useRef(loadState);
  var coverStyle = React__namespace.useRef();
  if (coverStyle === void 0 || previousLoadState.current === ImageLoadState.notLoaded && loadState === ImageLoadState.loaded) {
    coverStyle.current = computeCoverStyle(props, loadState, imageElement, frameElement);
  }
  previousLoadState.current = loadState;
  return coverStyle.current;
}
function computeCoverStyle(props, loadState, imageElement, frameElement) {
  var imageFit = props.imageFit, width = props.width, height = props.height;
  if (props.coverStyle !== void 0) {
    return props.coverStyle;
  } else if (loadState === ImageLoadState.loaded && (imageFit === ImageFit.cover || imageFit === ImageFit.contain || imageFit === ImageFit.centerContain || imageFit === ImageFit.centerCover) && imageElement.current && frameElement.current) {
    var desiredRatio = void 0;
    if (typeof width === "number" && typeof height === "number" && imageFit !== ImageFit.centerContain && imageFit !== ImageFit.centerCover) {
      desiredRatio = width / height;
    } else {
      desiredRatio = frameElement.current.clientWidth / frameElement.current.clientHeight;
    }
    var naturalRatio = imageElement.current.naturalWidth / imageElement.current.naturalHeight;
    if (naturalRatio > desiredRatio) {
      return ImageCoverStyle.landscape;
    }
  }
  return ImageCoverStyle.portrait;
}
var GlobalClassNames$w = {
  root: "ms-Image",
  rootMaximizeFrame: "ms-Image--maximizeFrame",
  image: "ms-Image-image",
  imageCenter: "ms-Image-image--center",
  imageContain: "ms-Image-image--contain",
  imageCover: "ms-Image-image--cover",
  imageCenterContain: "ms-Image-image--centerContain",
  imageCenterCover: "ms-Image-image--centerCover",
  imageNone: "ms-Image-image--none",
  imageLandscape: "ms-Image-image--landscape",
  imagePortrait: "ms-Image-image--portrait"
};
var getStyles$J = function(props) {
  var className = props.className, width = props.width, height = props.height, maximizeFrame = props.maximizeFrame, isLoaded = props.isLoaded, shouldFadeIn = props.shouldFadeIn, shouldStartVisible = props.shouldStartVisible, isLandscape = props.isLandscape, isCenter = props.isCenter, isContain = props.isContain, isCover = props.isCover, isCenterContain = props.isCenterContain, isCenterCover = props.isCenterCover, isNone = props.isNone, isError = props.isError, isNotImageFit = props.isNotImageFit, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames$w, theme);
  var ImageFitStyles = {
    position: "absolute",
    left: "50% /* @noflip */",
    top: "50%",
    transform: "translate(-50%,-50%)"
    // @todo test RTL renders transform: translate(50%,-50%);
  };
  var window2 = getWindow$1();
  var supportsObjectFit = window2 !== void 0 && window2.navigator.msMaxTouchPoints === void 0;
  var fallbackObjectFitStyles = isContain && isLandscape || isCover && !isLandscape ? { width: "100%", height: "auto" } : { width: "auto", height: "100%" };
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        overflow: "hidden"
      },
      maximizeFrame && [
        classNames2.rootMaximizeFrame,
        {
          height: "100%",
          width: "100%"
        }
      ],
      isLoaded && shouldFadeIn && !shouldStartVisible && AnimationClassNames.fadeIn400,
      (isCenter || isContain || isCover || isCenterContain || isCenterCover) && {
        position: "relative"
      },
      className
    ],
    image: [
      classNames2.image,
      {
        display: "block",
        opacity: 0
      },
      isLoaded && [
        "is-loaded",
        {
          opacity: 1
        }
      ],
      isCenter && [classNames2.imageCenter, ImageFitStyles],
      isContain && [
        classNames2.imageContain,
        supportsObjectFit && {
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        !supportsObjectFit && fallbackObjectFitStyles,
        !supportsObjectFit && ImageFitStyles
      ],
      isCover && [
        classNames2.imageCover,
        supportsObjectFit && {
          width: "100%",
          height: "100%",
          objectFit: "cover"
        },
        !supportsObjectFit && fallbackObjectFitStyles,
        !supportsObjectFit && ImageFitStyles
      ],
      isCenterContain && [
        classNames2.imageCenterContain,
        isLandscape && {
          maxWidth: "100%"
        },
        !isLandscape && {
          maxHeight: "100%"
        },
        ImageFitStyles
      ],
      isCenterCover && [
        classNames2.imageCenterCover,
        isLandscape && {
          maxHeight: "100%"
        },
        !isLandscape && {
          maxWidth: "100%"
        },
        ImageFitStyles
      ],
      isNone && [
        classNames2.imageNone,
        {
          width: "auto",
          height: "auto"
        }
      ],
      isNotImageFit && [
        !!width && !height && {
          height: "auto",
          width: "100%"
        },
        !width && !!height && {
          height: "100%",
          width: "auto"
        },
        !!width && !!height && {
          height: "100%",
          width: "100%"
        }
      ],
      isLandscape && classNames2.imageLandscape,
      !isLandscape && classNames2.imagePortrait,
      !isLoaded && "is-notLoaded",
      shouldFadeIn && "is-fadeIn",
      isError && "is-error"
    ]
  };
};
var Image = styled(ImageBase, getStyles$J, void 0, {
  scope: "Image"
}, true);
Image.displayName = "Image";
var classNames$2 = mergeStyleSets({
  root: {
    display: "inline-block"
  },
  placeholder: [
    "ms-Icon-placeHolder",
    {
      width: "1em"
    }
  ],
  image: [
    "ms-Icon-imageContainer",
    {
      overflow: "hidden"
    }
  ]
});
var MS_ICON = "ms-Icon";
var getStyles$I = function(props) {
  var className = props.className, iconClassName = props.iconClassName, isPlaceholder = props.isPlaceholder, isImage = props.isImage, styles2 = props.styles;
  return {
    root: [
      isPlaceholder && classNames$2.placeholder,
      classNames$2.root,
      isImage && classNames$2.image,
      iconClassName,
      className,
      styles2 && styles2.root,
      // eslint-disable-next-line deprecation/deprecation
      styles2 && styles2.imageContainer
    ]
  };
};
var getIconContent = memoizeFunction(
  function(iconName) {
    var _a2 = getIcon(iconName) || {
      subset: {},
      code: void 0
    }, code = _a2.code, subset = _a2.subset;
    if (!code) {
      return null;
    }
    return {
      children: code,
      iconClassName: subset.className,
      fontFamily: subset.fontFace && subset.fontFace.fontFamily,
      mergeImageProps: subset.mergeImageProps
    };
  },
  void 0,
  true
  /*ignoreNullOrUndefinedResult */
);
var FontIcon = function(props) {
  var iconName = props.iconName, className = props.className, _a2 = props.style, style = _a2 === void 0 ? {} : _a2;
  var iconContent = getIconContent(iconName) || {};
  var iconClassName = iconContent.iconClassName, children = iconContent.children, fontFamily = iconContent.fontFamily, mergeImageProps = iconContent.mergeImageProps;
  var nativeProps = getNativeProps(props, htmlElementProperties);
  var accessibleName = props["aria-label"] || props.title;
  var containerProps = props["aria-label"] || props["aria-labelledby"] || props.title ? {
    role: mergeImageProps ? void 0 : "img"
  } : {
    "aria-hidden": true
  };
  var finalChildren = children;
  if (mergeImageProps) {
    if (typeof children === "object" && typeof children.props === "object" && accessibleName) {
      finalChildren = React__namespace.cloneElement(children, { alt: accessibleName });
    }
  }
  return React__namespace.createElement("i", __assign$1({ "data-icon-name": iconName }, containerProps, nativeProps, mergeImageProps ? {
    title: void 0,
    "aria-label": void 0
  } : {}, {
    className: css$3(MS_ICON, classNames$2.root, iconClassName, !iconName && classNames$2.placeholder, className),
    // Apply the font family this way to ensure it doesn't get overridden by Fabric Core ms-Icon styles
    // https://github.com/microsoft/fluentui/issues/10449
    style: __assign$1({ fontFamily }, style)
  }), finalChildren);
};
memoizeFunction(function(iconName, className, ariaLabel) {
  return FontIcon({ iconName, className, "aria-label": ariaLabel });
});
var getClassNames$L = classNamesFunction({
  // Icon is used a lot by other components.
  // It's likely to see expected cases which pass different className to the Icon.
  // Therefore setting a larger cache size.
  cacheSize: 100
});
var IconBase = (
  /** @class */
  function(_super) {
    __extends(IconBase2, _super);
    function IconBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._onImageLoadingStateChange = function(state) {
        if (_this.props.imageProps && _this.props.imageProps.onLoadingStateChange) {
          _this.props.imageProps.onLoadingStateChange(state);
        }
        if (state === ImageLoadState.error) {
          _this.setState({ imageLoadError: true });
        }
      };
      _this.state = {
        imageLoadError: false
      };
      return _this;
    }
    IconBase2.prototype.render = function() {
      var _a2 = this.props, children = _a2.children, className = _a2.className, styles2 = _a2.styles, iconName = _a2.iconName, imageErrorAs = _a2.imageErrorAs, theme = _a2.theme;
      var isPlaceholder = typeof iconName === "string" && iconName.length === 0;
      var isImage = (
        // eslint-disable-next-line deprecation/deprecation
        !!this.props.imageProps || this.props.iconType === IconType.image || this.props.iconType === IconType.Image
      );
      var iconContent = getIconContent(iconName) || {};
      var iconClassName = iconContent.iconClassName, iconContentChildren = iconContent.children, mergeImageProps = iconContent.mergeImageProps;
      var classNames2 = getClassNames$L(styles2, {
        theme,
        className,
        iconClassName,
        isImage,
        isPlaceholder
      });
      var RootType = isImage ? "span" : "i";
      var nativeProps = getNativeProps(this.props, htmlElementProperties, [
        "aria-label"
      ]);
      var imageLoadError = this.state.imageLoadError;
      var imageProps = __assign$1(__assign$1({}, this.props.imageProps), { onLoadingStateChange: this._onImageLoadingStateChange });
      var ImageType = imageLoadError && imageErrorAs || Image;
      var ariaLabel = this.props["aria-label"] || this.props.ariaLabel;
      var accessibleName = imageProps.alt || ariaLabel || this.props.title;
      var hasName = !!(accessibleName || this.props["aria-labelledby"] || imageProps["aria-label"] || imageProps["aria-labelledby"]);
      var containerProps = hasName ? {
        role: isImage || mergeImageProps ? void 0 : "img",
        "aria-label": isImage || mergeImageProps ? void 0 : accessibleName
      } : {
        "aria-hidden": true
      };
      var finalIconContentChildren = iconContentChildren;
      if (mergeImageProps && iconContentChildren && typeof iconContentChildren === "object" && accessibleName) {
        finalIconContentChildren = React__namespace.cloneElement(iconContentChildren, {
          alt: accessibleName
        });
      }
      return React__namespace.createElement(RootType, __assign$1({ "data-icon-name": iconName }, containerProps, nativeProps, mergeImageProps ? {
        title: void 0,
        "aria-label": void 0
      } : {}, { className: classNames2.root }), isImage ? React__namespace.createElement(ImageType, __assign$1({}, imageProps)) : children || finalIconContentChildren);
    };
    return IconBase2;
  }(React__namespace.Component)
);
var Icon = styled(IconBase, getStyles$I, void 0, {
  scope: "Icon"
}, true);
Icon.displayName = "Icon";
var ImageIcon = function(props) {
  var className = props.className, imageProps = props.imageProps;
  var nativeProps = getNativeProps(props, htmlElementProperties, [
    "aria-label",
    "aria-labelledby",
    "title",
    "aria-describedby"
  ]);
  var altText = imageProps.alt || props["aria-label"];
  var hasName = altText || props["aria-labelledby"] || props.title || imageProps["aria-label"] || imageProps["aria-labelledby"] || imageProps.title;
  var imageNameProps = {
    "aria-labelledby": props["aria-labelledby"],
    "aria-describedby": props["aria-describedby"],
    title: props.title
  };
  var containerProps = hasName ? {} : {
    "aria-hidden": true
  };
  return React__namespace.createElement(
    "div",
    __assign$1({}, containerProps, nativeProps, { className: css$3(MS_ICON, classNames$2.root, classNames$2.image, className) }),
    React__namespace.createElement(Image, __assign$1({}, imageNameProps, imageProps, { alt: hasName ? altText : "" }))
  );
};
var SELECTION_FORWARD = "forward";
var SELECTION_BACKWARD = "backward";
var Autofill = (
  /** @class */
  function(_super) {
    __extends(Autofill2, _super);
    function Autofill2(props) {
      var _this = _super.call(this, props) || this;
      _this._inputElement = React__namespace.createRef();
      _this._autoFillEnabled = true;
      _this._onCompositionStart = function(ev) {
        _this.setState({ isComposing: true });
        _this._autoFillEnabled = false;
      };
      _this._onCompositionUpdate = function() {
        if (isIE11()) {
          _this._updateValue(_this._getCurrentInputValue(), true);
        }
      };
      _this._onCompositionEnd = function(ev) {
        var inputValue = _this._getCurrentInputValue();
        _this._tryEnableAutofill(inputValue, _this.value, false, true);
        _this.setState({ isComposing: false });
        _this._async.setTimeout(function() {
          _this._updateValue(_this._getCurrentInputValue(), false);
        }, 0);
      };
      _this._onClick = function() {
        if (_this.value && _this.value !== "" && _this._autoFillEnabled) {
          _this._autoFillEnabled = false;
        }
      };
      _this._onKeyDown = function(ev) {
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(ev);
        }
        if (!ev.nativeEvent.isComposing) {
          switch (ev.which) {
            case KeyCodes.backspace:
              _this._autoFillEnabled = false;
              break;
            case KeyCodes.left:
            case KeyCodes.right:
              if (_this._autoFillEnabled) {
                _this.setState({ inputValue: _this.props.suggestedDisplayValue || "" });
                _this._autoFillEnabled = false;
              }
              break;
            default:
              if (!_this._autoFillEnabled) {
                if (_this.props.enableAutofillOnKeyPress.indexOf(ev.which) !== -1) {
                  _this._autoFillEnabled = true;
                }
              }
              break;
          }
        }
      };
      _this._onInputChanged = function(ev) {
        var value = _this._getCurrentInputValue(ev);
        if (!_this.state.isComposing) {
          _this._tryEnableAutofill(value, _this.value, ev.nativeEvent.isComposing);
        }
        if (!(isIE11() && _this.state.isComposing)) {
          var nativeEventComposing = ev.nativeEvent.isComposing;
          var isComposing = nativeEventComposing === void 0 ? _this.state.isComposing : nativeEventComposing;
          _this._updateValue(value, isComposing);
        }
      };
      _this._onChanged = function() {
        return;
      };
      _this._updateValue = function(newValue, composing) {
        if (!newValue && newValue === _this.value) {
          return;
        }
        var _a2 = _this.props, onInputChange = _a2.onInputChange, onInputValueChange = _a2.onInputValueChange;
        if (onInputChange) {
          newValue = (onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(newValue, composing)) || "";
        }
        _this.setState({ inputValue: newValue }, function() {
          return onInputValueChange === null || onInputValueChange === void 0 ? void 0 : onInputValueChange(newValue, composing);
        });
      };
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      _this.state = {
        inputValue: props.defaultVisibleValue || "",
        isComposing: false
      };
      return _this;
    }
    Autofill2.getDerivedStateFromProps = function(props, state) {
      if (props.updateValueInWillReceiveProps) {
        var updatedInputValue = props.updateValueInWillReceiveProps();
        if (updatedInputValue !== null && updatedInputValue !== state.inputValue && !state.isComposing) {
          return __assign$1(__assign$1({}, state), { inputValue: updatedInputValue });
        }
      }
      return null;
    };
    Object.defineProperty(Autofill2.prototype, "cursorLocation", {
      get: function() {
        if (this._inputElement.current) {
          var inputElement = this._inputElement.current;
          if (inputElement.selectionDirection !== SELECTION_FORWARD) {
            return inputElement.selectionEnd;
          } else {
            return inputElement.selectionStart;
          }
        } else {
          return -1;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Autofill2.prototype, "isValueSelected", {
      get: function() {
        return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Autofill2.prototype, "value", {
      get: function() {
        return this._getControlledValue() || this.state.inputValue || "";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Autofill2.prototype, "selectionStart", {
      get: function() {
        return this._inputElement.current ? this._inputElement.current.selectionStart : -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Autofill2.prototype, "selectionEnd", {
      get: function() {
        return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Autofill2.prototype, "inputElement", {
      get: function() {
        return this._inputElement.current;
      },
      enumerable: false,
      configurable: true
    });
    Autofill2.prototype.componentDidUpdate = function(_, _1, cursor2) {
      var _a2 = this.props, suggestedDisplayValue = _a2.suggestedDisplayValue, shouldSelectFullInputValueInComponentDidUpdate = _a2.shouldSelectFullInputValueInComponentDidUpdate, preventValueSelection = _a2.preventValueSelection;
      var differenceIndex = 0;
      if (preventValueSelection) {
        return;
      }
      var isFocused = this._inputElement.current && this._inputElement.current === document.activeElement;
      if (isFocused && this._autoFillEnabled && this.value && suggestedDisplayValue && _doesTextStartWith(suggestedDisplayValue, this.value)) {
        var shouldSelectFullRange = false;
        if (shouldSelectFullInputValueInComponentDidUpdate) {
          shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();
        }
        if (shouldSelectFullRange) {
          this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);
        } else {
          while (differenceIndex < this.value.length && this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()) {
            differenceIndex++;
          }
          if (differenceIndex > 0) {
            this._inputElement.current.setSelectionRange(differenceIndex, suggestedDisplayValue.length, SELECTION_BACKWARD);
          }
        }
      } else if (this._inputElement.current) {
        if (cursor2 !== null && !this._autoFillEnabled && !this.state.isComposing) {
          this._inputElement.current.setSelectionRange(cursor2.start, cursor2.end, cursor2.dir);
        }
      }
    };
    Autofill2.prototype.componentWillUnmount = function() {
      this._async.dispose();
    };
    Autofill2.prototype.render = function() {
      var nativeProps = getNativeProps(this.props, inputProperties);
      var style = __assign$1(__assign$1({}, this.props.style), { fontFamily: "inherit" });
      return React__namespace.createElement("input", __assign$1({ autoCapitalize: "off", autoComplete: "off", "aria-autocomplete": "both" }, nativeProps, {
        style,
        ref: this._inputElement,
        value: this._getDisplayValue(),
        onCompositionStart: this._onCompositionStart,
        onCompositionUpdate: this._onCompositionUpdate,
        onCompositionEnd: this._onCompositionEnd,
        // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.
        onChange: this._onChanged,
        onInput: this._onInputChanged,
        onKeyDown: this._onKeyDown,
        onClick: this.props.onClick ? this.props.onClick : this._onClick,
        "data-lpignore": true
      }));
    };
    Autofill2.prototype.focus = function() {
      this._inputElement.current && this._inputElement.current.focus();
    };
    Autofill2.prototype.clear = function() {
      this._autoFillEnabled = true;
      this._updateValue("", false);
      this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);
    };
    Autofill2.prototype.getSnapshotBeforeUpdate = function() {
      var _a2, _b2;
      var inel = this._inputElement.current;
      if (inel && inel.selectionStart !== this.value.length) {
        return {
          start: (_a2 = inel.selectionStart) !== null && _a2 !== void 0 ? _a2 : inel.value.length,
          end: (_b2 = inel.selectionEnd) !== null && _b2 !== void 0 ? _b2 : inel.value.length,
          dir: inel.selectionDirection || "backward"
        };
      }
      return null;
    };
    Autofill2.prototype._getCurrentInputValue = function(ev) {
      if (ev && ev.target && ev.target.value) {
        return ev.target.value;
      } else if (this.inputElement && this.inputElement.value) {
        return this.inputElement.value;
      } else {
        return "";
      }
    };
    Autofill2.prototype._tryEnableAutofill = function(newValue, oldValue, isComposing, isComposed) {
      if (!isComposing && newValue && this._inputElement.current && this._inputElement.current.selectionStart === newValue.length && !this._autoFillEnabled && (newValue.length > oldValue.length || isComposed)) {
        this._autoFillEnabled = true;
      }
    };
    Autofill2.prototype._getDisplayValue = function() {
      if (this._autoFillEnabled) {
        return _getDisplayValue(this.value, this.props.suggestedDisplayValue);
      }
      return this.value;
    };
    Autofill2.prototype._getControlledValue = function() {
      var value = this.props.value;
      if (value === void 0 || typeof value === "string") {
        return value;
      }
      console.warn("props.value of Autofill should be a string, but it is " + value + " with type of " + typeof value);
      return value.toString();
    };
    Autofill2.defaultProps = {
      enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up]
    };
    return Autofill2;
  }(React__namespace.Component)
);
function _getDisplayValue(inputValue, suggestedDisplayValue) {
  var displayValue = inputValue;
  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {
    displayValue = suggestedDisplayValue;
  }
  return displayValue;
}
function _doesTextStartWith(text, startWith) {
  if (!text || !startWith) {
    return false;
  }
  if (process.env.NODE_ENV !== "production") {
    for (var _i = 0, _a2 = [text, startWith]; _i < _a2.length; _i++) {
      var val = _a2[_i];
      if (typeof val !== "string") {
        throw new Error(Autofill.name + ' received non-string value "' + val + '" of type ' + typeof val + " from either input's value or suggestedDisplayValue");
      }
    }
  }
  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;
}
var getClassNames$K = classNamesFunction();
var AnnouncedBase = (
  /** @class */
  function(_super) {
    __extends(AnnouncedBase2, _super);
    function AnnouncedBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnnouncedBase2.prototype.render = function() {
      var _a2 = this.props, message = _a2.message, styles2 = _a2.styles, _b2 = _a2.as, Root = _b2 === void 0 ? "div" : _b2, className = _a2.className;
      var classNames2 = getClassNames$K(styles2, { className });
      return React__namespace.createElement(
        Root,
        __assign$1({ role: "status", className: classNames2.root }, getNativeProps(this.props, divProperties, ["className"])),
        React__namespace.createElement(
          DelayedRender,
          null,
          React__namespace.createElement("div", { className: classNames2.screenReaderText }, message)
        )
      );
    };
    AnnouncedBase2.defaultProps = {
      "aria-live": "polite"
    };
    return AnnouncedBase2;
  }(React__namespace.Component)
);
var getStyles$H = function(props) {
  return {
    root: props.className,
    screenReaderText: hiddenContentStyle
  };
};
var Announced = styled(AnnouncedBase, getStyles$H);
var FocusZoneTabbableElements = {
  /** Tabbing is not allowed */
  none: 0,
  /** All tabbing action is allowed */
  all: 1,
  /** Tabbing is allowed only on input elements */
  inputOnly: 2
};
var FocusZoneDirection;
(function(FocusZoneDirection2) {
  FocusZoneDirection2[FocusZoneDirection2["vertical"] = 0] = "vertical";
  FocusZoneDirection2[FocusZoneDirection2["horizontal"] = 1] = "horizontal";
  FocusZoneDirection2[FocusZoneDirection2["bidirectional"] = 2] = "bidirectional";
  FocusZoneDirection2[FocusZoneDirection2["domOrder"] = 3] = "domOrder";
})(FocusZoneDirection || (FocusZoneDirection = {}));
var IS_FOCUSABLE_ATTRIBUTE = "data-is-focusable";
var IS_ENTER_DISABLED_ATTRIBUTE = "data-disable-click-on-enter";
var FOCUSZONE_ID_ATTRIBUTE = "data-focuszone-id";
var TABINDEX = "tabindex";
var NO_VERTICAL_WRAP = "data-no-vertical-wrap";
var NO_HORIZONTAL_WRAP = "data-no-horizontal-wrap";
var LARGE_DISTANCE_FROM_CENTER = 999999999;
var LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;
var focusZoneStyles;
var focusZoneClass = "ms-FocusZone";
function raiseClickFromKeyboardEvent(target, ev) {
  var event;
  if (typeof MouseEvent === "function") {
    event = new MouseEvent("click", {
      ctrlKey: ev === null || ev === void 0 ? void 0 : ev.ctrlKey,
      metaKey: ev === null || ev === void 0 ? void 0 : ev.metaKey,
      shiftKey: ev === null || ev === void 0 ? void 0 : ev.shiftKey,
      altKey: ev === null || ev === void 0 ? void 0 : ev.altKey,
      bubbles: ev === null || ev === void 0 ? void 0 : ev.bubbles,
      cancelable: ev === null || ev === void 0 ? void 0 : ev.cancelable
    });
  } else {
    event = document.createEvent("MouseEvents");
    event.initMouseEvent(
      "click",
      ev ? ev.bubbles : false,
      ev ? ev.cancelable : false,
      window,
      // not using getWindow() since this can only be run client side
      0,
      // detail
      0,
      // screen x
      0,
      // screen y
      0,
      // client x
      0,
      // client y
      ev ? ev.ctrlKey : false,
      ev ? ev.altKey : false,
      ev ? ev.shiftKey : false,
      ev ? ev.metaKey : false,
      0,
      // button
      null
    );
  }
  target.dispatchEvent(event);
}
function getRootClass() {
  if (!focusZoneStyles) {
    focusZoneStyles = mergeStyles({
      selectors: {
        ":focus": {
          outline: "none"
        }
      }
    }, focusZoneClass);
  }
  return focusZoneStyles;
}
var _allInstances = {};
var _outerZones = /* @__PURE__ */ new Set();
var ALLOWED_INPUT_TYPES = ["text", "number", "password", "email", "tel", "url", "search", "textarea"];
var ALLOW_VIRTUAL_ELEMENTS = false;
var FocusZone = (
  /** @class */
  function(_super) {
    __extends(FocusZone2, _super);
    function FocusZone2(props) {
      var _a2, _b2, _c2, _d2;
      var _this = _super.call(this, props) || this;
      _this._root = React__namespace.createRef();
      _this._mergedRef = createMergedRef();
      _this._onFocus = function(ev) {
        if (_this._portalContainsElement(ev.target)) {
          return;
        }
        var _a3 = _this.props, onActiveElementChanged = _a3.onActiveElementChanged, doNotAllowFocusEventToPropagate = _a3.doNotAllowFocusEventToPropagate, stopFocusPropagation = _a3.stopFocusPropagation, onFocusNotification = _a3.onFocusNotification, onFocus2 = _a3.onFocus, shouldFocusInnerElementWhenReceivedFocus = _a3.shouldFocusInnerElementWhenReceivedFocus, defaultTabbableElement = _a3.defaultTabbableElement;
        var isImmediateDescendant = _this._isImmediateDescendantOfZone(ev.target);
        var newActiveElement;
        if (isImmediateDescendant) {
          newActiveElement = ev.target;
        } else {
          var parentElement = ev.target;
          while (parentElement && parentElement !== _this._root.current) {
            if (isElementTabbable(parentElement) && _this._isImmediateDescendantOfZone(parentElement)) {
              newActiveElement = parentElement;
              break;
            }
            parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
          }
        }
        if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {
          var maybeElementToFocus = defaultTabbableElement && typeof defaultTabbableElement === "function" && _this._root.current && defaultTabbableElement(_this._root.current);
          if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {
            newActiveElement = maybeElementToFocus;
            maybeElementToFocus.focus();
          } else {
            _this.focus(true);
            if (_this._activeElement) {
              newActiveElement = null;
            }
          }
        }
        var initialElementFocused = !_this._activeElement;
        if (newActiveElement && newActiveElement !== _this._activeElement) {
          if (isImmediateDescendant || initialElementFocused) {
            _this._setFocusAlignment(newActiveElement, true, true);
          }
          _this._activeElement = newActiveElement;
          if (initialElementFocused) {
            _this._updateTabIndexes();
          }
        }
        if (onActiveElementChanged) {
          onActiveElementChanged(_this._activeElement, ev);
        }
        if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {
          ev.stopPropagation();
        }
        if (onFocus2) {
          onFocus2(ev);
        } else if (onFocusNotification) {
          onFocusNotification();
        }
      };
      _this._onBlur = function() {
        _this._setParkedFocus(false);
      };
      _this._onMouseDown = function(ev) {
        if (_this._portalContainsElement(ev.target)) {
          return;
        }
        var disabled = _this.props.disabled;
        if (disabled) {
          return;
        }
        var target = ev.target;
        var path = [];
        while (target && target !== _this._root.current) {
          path.push(target);
          target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
        }
        while (path.length) {
          target = path.pop();
          if (target && isElementTabbable(target)) {
            _this._setActiveElement(target, true);
          }
          if (isElementFocusZone(target)) {
            break;
          }
        }
      };
      _this._onKeyDown = function(ev, theme) {
        if (_this._portalContainsElement(ev.target)) {
          return;
        }
        var _a3 = _this.props, direction = _a3.direction, disabled = _a3.disabled, isInnerZoneKeystroke = _a3.isInnerZoneKeystroke, pagingSupportDisabled = _a3.pagingSupportDisabled, shouldEnterInnerZone = _a3.shouldEnterInnerZone;
        if (disabled) {
          return;
        }
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(ev);
        }
        if (ev.isDefaultPrevented()) {
          return;
        }
        if (_this._getDocument().activeElement === _this._root.current && _this._isInnerZone) {
          return;
        }
        if ((shouldEnterInnerZone && shouldEnterInnerZone(ev) || isInnerZoneKeystroke && isInnerZoneKeystroke(ev)) && _this._isImmediateDescendantOfZone(ev.target)) {
          var innerZone = _this._getFirstInnerZone();
          if (innerZone) {
            if (!innerZone.focus(true)) {
              return;
            }
          } else if (isElementFocusSubZone(ev.target)) {
            if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {
              return;
            }
          } else {
            return;
          }
        } else if (ev.altKey) {
          return;
        } else {
          switch (ev.which) {
            case KeyCodes.space:
              if (_this._shouldRaiseClicksOnSpace && _this._tryInvokeClickForFocusable(ev.target, ev)) {
                break;
              }
              return;
            case KeyCodes.left:
              if (direction !== FocusZoneDirection.vertical) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusLeft(theme)) {
                  break;
                }
              }
              return;
            case KeyCodes.right:
              if (direction !== FocusZoneDirection.vertical) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusRight(theme)) {
                  break;
                }
              }
              return;
            case KeyCodes.up:
              if (direction !== FocusZoneDirection.horizontal) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusUp()) {
                  break;
                }
              }
              return;
            case KeyCodes.down:
              if (direction !== FocusZoneDirection.horizontal) {
                _this._preventDefaultWhenHandled(ev);
                if (_this._moveFocusDown()) {
                  break;
                }
              }
              return;
            case KeyCodes.pageDown:
              if (!pagingSupportDisabled && _this._moveFocusPaging(true)) {
                break;
              }
              return;
            case KeyCodes.pageUp:
              if (!pagingSupportDisabled && _this._moveFocusPaging(false)) {
                break;
              }
              return;
            case KeyCodes.tab:
              if (
                // eslint-disable-next-line deprecation/deprecation
                _this.props.allowTabKey || _this.props.handleTabKey === FocusZoneTabbableElements.all || _this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && _this._isElementInput(ev.target)
              ) {
                var focusChanged = false;
                _this._processingTabKey = true;
                if (direction === FocusZoneDirection.vertical || !_this._shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {
                  focusChanged = ev.shiftKey ? _this._moveFocusUp() : _this._moveFocusDown();
                } else {
                  var tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;
                  focusChanged = tabWithDirection ? _this._moveFocusLeft(theme) : _this._moveFocusRight(theme);
                }
                _this._processingTabKey = false;
                if (focusChanged) {
                  break;
                } else if (_this.props.shouldResetActiveElementWhenTabFromZone) {
                  _this._activeElement = null;
                }
              }
              return;
            case KeyCodes.home:
              if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, false)) {
                return false;
              }
              var firstChild = _this._root.current && _this._root.current.firstChild;
              if (_this._root.current && firstChild && _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {
                break;
              }
              return;
            case KeyCodes.end:
              if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, true)) {
                return false;
              }
              var lastChild = _this._root.current && _this._root.current.lastChild;
              if (_this._root.current && _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {
                break;
              }
              return;
            case KeyCodes.enter:
              if (_this._shouldRaiseClicksOnEnter && _this._tryInvokeClickForFocusable(ev.target, ev)) {
                break;
              }
              return;
            default:
              return;
          }
        }
        ev.preventDefault();
        ev.stopPropagation();
      };
      _this._getHorizontalDistanceFromCenter = function(isForward, activeRect, targetRect) {
        var leftAlignment = _this._focusAlignment.left || _this._focusAlignment.x || 0;
        var targetRectTop = Math.floor(targetRect.top);
        var activeRectBottom = Math.floor(activeRect.bottom);
        var targetRectBottom = Math.floor(targetRect.bottom);
        var activeRectTop = Math.floor(activeRect.top);
        var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;
        var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;
        if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {
          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
            return 0;
          }
          return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
        }
        if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
          return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
        }
        return LARGE_DISTANCE_FROM_CENTER;
      };
      initializeComponentRef(_this);
      if (process.env.NODE_ENV !== "production") {
        warnDeprecations("FocusZone", props, {
          rootProps: void 0,
          allowTabKey: "handleTabKey",
          elementType: "as",
          ariaDescribedBy: "aria-describedby",
          ariaLabelledBy: "aria-labelledby"
        });
      }
      _this._id = getId("FocusZone");
      _this._focusAlignment = {
        left: 0,
        top: 0
      };
      _this._processingTabKey = false;
      var shouldRaiseClicksFallback = (_b2 = (_a2 = props.shouldRaiseClicks) !== null && _a2 !== void 0 ? _a2 : FocusZone2.defaultProps.shouldRaiseClicks) !== null && _b2 !== void 0 ? _b2 : true;
      _this._shouldRaiseClicksOnEnter = (_c2 = props.shouldRaiseClicksOnEnter) !== null && _c2 !== void 0 ? _c2 : shouldRaiseClicksFallback;
      _this._shouldRaiseClicksOnSpace = (_d2 = props.shouldRaiseClicksOnSpace) !== null && _d2 !== void 0 ? _d2 : shouldRaiseClicksFallback;
      return _this;
    }
    FocusZone2.getOuterZones = function() {
      return _outerZones.size;
    };
    FocusZone2._onKeyDownCapture = function(ev) {
      if (ev.which === KeyCodes.tab) {
        _outerZones.forEach(function(zone) {
          return zone._updateTabIndexes();
        });
      }
    };
    FocusZone2.prototype.componentDidMount = function() {
      var root2 = this._root.current;
      _allInstances[this._id] = this;
      if (root2) {
        var parentElement = getParent(root2, ALLOW_VIRTUAL_ELEMENTS);
        while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {
          if (isElementFocusZone(parentElement)) {
            this._isInnerZone = true;
            break;
          }
          parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
        }
        if (!this._isInnerZone) {
          _outerZones.add(this);
          this._root.current && this._root.current.addEventListener("keydown", FocusZone2._onKeyDownCapture, true);
        }
        this._root.current && this._root.current.addEventListener("blur", this._onBlur, true);
        this._updateTabIndexes();
        if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === "string") {
          this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement);
        } else if (this.props.defaultActiveElement) {
          this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement);
        }
        if (this.props.shouldFocusOnMount) {
          this.focus();
        }
      }
    };
    FocusZone2.prototype.componentDidUpdate = function() {
      var root2 = this._root.current;
      var doc = this._getDocument();
      if (this._activeElement && !elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) || this._defaultFocusElement && !elementContains(this._root.current, this._defaultFocusElement, ALLOW_VIRTUAL_ELEMENTS)) {
        this._activeElement = null;
        this._defaultFocusElement = null;
        this._updateTabIndexes();
      }
      if (!this.props.preventFocusRestoration && doc && this._lastIndexPath && (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root2)) {
        var elementToFocus = getFocusableByIndexPath(root2, this._lastIndexPath);
        if (elementToFocus) {
          this._setActiveElement(elementToFocus, true);
          elementToFocus.focus();
          this._setParkedFocus(false);
        } else {
          this._setParkedFocus(true);
        }
      }
    };
    FocusZone2.prototype.componentWillUnmount = function() {
      delete _allInstances[this._id];
      if (!this._isInnerZone) {
        _outerZones.delete(this);
        this._root.current && this._root.current.removeEventListener("keydown", FocusZone2._onKeyDownCapture, true);
      }
      if (this._root.current) {
        this._root.current.removeEventListener("blur", this._onBlur, true);
      }
      this._activeElement = null;
      this._defaultFocusElement = null;
    };
    FocusZone2.prototype.render = function() {
      var _this = this;
      var _a2 = this.props, tag = _a2.as, elementType = _a2.elementType, rootProps = _a2.rootProps, ariaDescribedBy = _a2.ariaDescribedBy, ariaLabelledBy = _a2.ariaLabelledBy, className = _a2.className;
      var divProps = getNativeProps(this.props, htmlElementProperties);
      var Tag = tag || elementType || "div";
      this._evaluateFocusBeforeRender();
      var theme = getTheme();
      return React__namespace.createElement(Tag, __assign$1({ "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy }, divProps, rootProps, {
        // Once the getClassName correctly memoizes inputs this should
        // be replaced so that className is passed to getRootClass and is included there so
        // the class names will always be in the same order.
        className: css$3(getRootClass(), className),
        // eslint-disable-next-line deprecation/deprecation
        ref: this._mergedRef(this.props.elementRef, this._root),
        "data-focuszone-id": this._id,
        // eslint-disable-next-line react/jsx-no-bind
        onKeyDown: function(ev) {
          return _this._onKeyDown(ev, theme);
        },
        onFocus: this._onFocus,
        onMouseDownCapture: this._onMouseDown
      }), this.props.children);
    };
    FocusZone2.prototype.focus = function(forceIntoFirstElement, bypassHiddenElements) {
      if (forceIntoFirstElement === void 0) {
        forceIntoFirstElement = false;
      }
      if (bypassHiddenElements === void 0) {
        bypassHiddenElements = false;
      }
      if (this._root.current) {
        if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true" && this._isInnerZone) {
          var ownerZoneElement = this._getOwnerZone(this._root.current);
          if (ownerZoneElement !== this._root.current) {
            var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
            return !!ownerZone && ownerZone.focusElement(this._root.current);
          }
          return false;
        } else if (!forceIntoFirstElement && this._activeElement && elementContains(this._root.current, this._activeElement) && isElementTabbable(this._activeElement) && (!bypassHiddenElements || isElementVisibleAndNotHidden(this._activeElement))) {
          this._activeElement.focus();
          return true;
        } else {
          var firstChild = this._root.current.firstChild;
          return this.focusElement(getNextElement(this._root.current, firstChild, true, void 0, void 0, void 0, void 0, void 0, bypassHiddenElements));
        }
      }
      return false;
    };
    FocusZone2.prototype.focusLast = function() {
      if (this._root.current) {
        var lastChild = this._root.current && this._root.current.lastChild;
        return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));
      }
      return false;
    };
    FocusZone2.prototype.focusElement = function(element, forceAlignment) {
      var _a2 = this.props, onBeforeFocus = _a2.onBeforeFocus, shouldReceiveFocus = _a2.shouldReceiveFocus;
      if (shouldReceiveFocus && !shouldReceiveFocus(element) || onBeforeFocus && !onBeforeFocus(element)) {
        return false;
      }
      if (element) {
        this._setActiveElement(element, forceAlignment);
        if (this._activeElement) {
          this._activeElement.focus();
        }
        return true;
      }
      return false;
    };
    FocusZone2.prototype.setFocusAlignment = function(point) {
      this._focusAlignment = point;
    };
    Object.defineProperty(FocusZone2.prototype, "defaultFocusElement", {
      get: function() {
        return this._defaultFocusElement;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FocusZone2.prototype, "activeElement", {
      get: function() {
        return this._activeElement;
      },
      enumerable: false,
      configurable: true
    });
    FocusZone2.prototype._evaluateFocusBeforeRender = function() {
      var root2 = this._root.current;
      var doc = this._getDocument();
      if (doc) {
        var focusedElement = doc.activeElement;
        if (focusedElement !== root2) {
          var shouldRestoreFocus = elementContains(root2, focusedElement, false);
          this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root2, focusedElement) : void 0;
        }
      }
    };
    FocusZone2.prototype._setParkedFocus = function(isParked) {
      var root2 = this._root.current;
      if (root2 && this._isParked !== isParked) {
        this._isParked = isParked;
        if (isParked) {
          if (!this.props.allowFocusRoot) {
            this._parkedTabIndex = root2.getAttribute("tabindex");
            root2.setAttribute("tabindex", "-1");
          }
          root2.focus();
        } else if (!this.props.allowFocusRoot) {
          if (this._parkedTabIndex) {
            root2.setAttribute("tabindex", this._parkedTabIndex);
            this._parkedTabIndex = void 0;
          } else {
            root2.removeAttribute("tabindex");
          }
        }
      }
    };
    FocusZone2.prototype._setActiveElement = function(element, forceAlignment) {
      var previousActiveElement = this._activeElement;
      this._activeElement = element;
      if (previousActiveElement) {
        if (isElementFocusZone(previousActiveElement)) {
          this._updateTabIndexes(previousActiveElement);
        }
        previousActiveElement.tabIndex = -1;
      }
      if (this._activeElement) {
        if (!this._focusAlignment || forceAlignment) {
          this._setFocusAlignment(element, true, true);
        }
        this._activeElement.tabIndex = 0;
      }
    };
    FocusZone2.prototype._preventDefaultWhenHandled = function(ev) {
      this.props.preventDefaultWhenHandled && ev.preventDefault();
    };
    FocusZone2.prototype._tryInvokeClickForFocusable = function(targetElement, ev) {
      var target = targetElement;
      if (target === this._root.current) {
        return false;
      }
      do {
        if (target.tagName === "BUTTON" || target.tagName === "A" || target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.tagName === "SUMMARY") {
          return false;
        }
        if (this._isImmediateDescendantOfZone(target) && target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true" && target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== "true") {
          raiseClickFromKeyboardEvent(target, ev);
          return true;
        }
        target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);
      } while (target !== this._root.current);
      return false;
    };
    FocusZone2.prototype._getFirstInnerZone = function(rootElement) {
      rootElement = rootElement || this._activeElement || this._root.current;
      if (!rootElement) {
        return null;
      }
      if (isElementFocusZone(rootElement)) {
        return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
      }
      var child = rootElement.firstElementChild;
      while (child) {
        if (isElementFocusZone(child)) {
          return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
        }
        var match2 = this._getFirstInnerZone(child);
        if (match2) {
          return match2;
        }
        child = child.nextElementSibling;
      }
      return null;
    };
    FocusZone2.prototype._moveFocus = function(isForward, getDistanceFromCenter, ev, useDefaultWrap) {
      if (useDefaultWrap === void 0) {
        useDefaultWrap = true;
      }
      var element = this._activeElement;
      var candidateDistance = -1;
      var candidateElement = void 0;
      var changedFocus = false;
      var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;
      if (!element || !this._root.current) {
        return false;
      }
      if (this._isElementInput(element)) {
        if (!this._shouldInputLoseFocus(element, isForward)) {
          return false;
        }
      }
      var activeRect = isBidirectional ? element.getBoundingClientRect() : null;
      do {
        element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);
        if (isBidirectional) {
          if (element) {
            var targetRect = element.getBoundingClientRect();
            var elementDistance = getDistanceFromCenter(activeRect, targetRect);
            if (elementDistance === -1 && candidateDistance === -1) {
              candidateElement = element;
              break;
            }
            if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
              candidateDistance = elementDistance;
              candidateElement = element;
            }
            if (candidateDistance >= 0 && elementDistance < 0) {
              break;
            }
          }
        } else {
          candidateElement = element;
          break;
        }
      } while (element);
      if (candidateElement && candidateElement !== this._activeElement) {
        changedFocus = true;
        this.focusElement(candidateElement);
      } else if (this.props.isCircularNavigation && useDefaultWrap) {
        if (isForward) {
          return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
        } else {
          return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
        }
      }
      return changedFocus;
    };
    FocusZone2.prototype._moveFocusDown = function() {
      var _this = this;
      var targetTop = -1;
      var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
      if (this._moveFocus(true, function(activeRect, targetRect) {
        var distance = -1;
        var targetRectTop = Math.floor(targetRect.top);
        var activeRectBottom = Math.floor(activeRect.bottom);
        if (targetRectTop < activeRectBottom) {
          if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
          }
          return LARGE_DISTANCE_FROM_CENTER;
        }
        if (targetTop === -1 && targetRectTop >= activeRectBottom || targetRectTop === targetTop) {
          targetTop = targetRectTop;
          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
            distance = 0;
          } else {
            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
          }
        }
        return distance;
      })) {
        this._setFocusAlignment(this._activeElement, false, true);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusUp = function() {
      var _this = this;
      var targetTop = -1;
      var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
      if (this._moveFocus(false, function(activeRect, targetRect) {
        var distance = -1;
        var targetRectBottom = Math.floor(targetRect.bottom);
        var targetRectTop = Math.floor(targetRect.top);
        var activeRectTop = Math.floor(activeRect.top);
        if (targetRectBottom > activeRectTop) {
          if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
          }
          return LARGE_DISTANCE_FROM_CENTER;
        }
        if (targetTop === -1 && targetRectBottom <= activeRectTop || targetRectTop === targetTop) {
          targetTop = targetRectTop;
          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
            distance = 0;
          } else {
            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
          }
        }
        return distance;
      })) {
        this._setFocusAlignment(this._activeElement, false, true);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusLeft = function(theme) {
      var _this = this;
      var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
      if (this._moveFocus(getRTL(theme), function(activeRect, targetRect) {
        var distance = -1;
        var topBottomComparison;
        if (getRTL(theme)) {
          topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
        } else {
          topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
        }
        if (topBottomComparison && targetRect.right <= activeRect.right && _this.props.direction !== FocusZoneDirection.vertical) {
          distance = activeRect.right - targetRect.right;
        } else if (!shouldWrap) {
          distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
        }
        return distance;
      }, void 0, shouldWrap)) {
        this._setFocusAlignment(this._activeElement, true, false);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusRight = function(theme) {
      var _this = this;
      var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
      if (this._moveFocus(!getRTL(theme), function(activeRect, targetRect) {
        var distance = -1;
        var topBottomComparison;
        if (getRTL(theme)) {
          topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
        } else {
          topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
        }
        if (topBottomComparison && targetRect.left >= activeRect.left && _this.props.direction !== FocusZoneDirection.vertical) {
          distance = targetRect.left - activeRect.left;
        } else if (!shouldWrap) {
          distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
        }
        return distance;
      }, void 0, shouldWrap)) {
        this._setFocusAlignment(this._activeElement, true, false);
        return true;
      }
      return false;
    };
    FocusZone2.prototype._moveFocusPaging = function(isForward, useDefaultWrap) {
      if (useDefaultWrap === void 0) {
        useDefaultWrap = true;
      }
      var element = this._activeElement;
      if (!element || !this._root.current) {
        return false;
      }
      if (this._isElementInput(element)) {
        if (!this._shouldInputLoseFocus(element, isForward)) {
          return false;
        }
      }
      var scrollableParent = findScrollableParent(element);
      if (!scrollableParent) {
        return false;
      }
      var candidateDistance = -1;
      var candidateElement = void 0;
      var targetTop = -1;
      var targetBottom = -1;
      var pagesize = scrollableParent.clientHeight;
      var activeRect = element.getBoundingClientRect();
      do {
        element = isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element);
        if (element) {
          var targetRect = element.getBoundingClientRect();
          var targetRectTop = Math.floor(targetRect.top);
          var activeRectBottom = Math.floor(activeRect.bottom);
          var targetRectBottom = Math.floor(targetRect.bottom);
          var activeRectTop = Math.floor(activeRect.top);
          var elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);
          var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;
          var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;
          if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {
            break;
          }
          if (elementDistance > -1) {
            if (isForward && targetRectTop > targetTop) {
              targetTop = targetRectTop;
              candidateDistance = elementDistance;
              candidateElement = element;
            } else if (!isForward && targetRectBottom < targetBottom) {
              targetBottom = targetRectBottom;
              candidateDistance = elementDistance;
              candidateElement = element;
            } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {
              candidateDistance = elementDistance;
              candidateElement = element;
            }
          }
        }
      } while (element);
      var changedFocus = false;
      if (candidateElement && candidateElement !== this._activeElement) {
        changedFocus = true;
        this.focusElement(candidateElement);
        this._setFocusAlignment(candidateElement, false, true);
      } else if (this.props.isCircularNavigation && useDefaultWrap) {
        if (isForward) {
          return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
        }
        return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
      }
      return changedFocus;
    };
    FocusZone2.prototype._setFocusAlignment = function(element, isHorizontal, isVertical) {
      if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {
        var rect = element.getBoundingClientRect();
        var left = rect.left + rect.width / 2;
        var top_1 = rect.top + rect.height / 2;
        if (!this._focusAlignment) {
          this._focusAlignment = { left, top: top_1 };
        }
        if (isHorizontal) {
          this._focusAlignment.left = left;
        }
        if (isVertical) {
          this._focusAlignment.top = top_1;
        }
      }
    };
    FocusZone2.prototype._isImmediateDescendantOfZone = function(element) {
      return this._getOwnerZone(element) === this._root.current;
    };
    FocusZone2.prototype._getOwnerZone = function(element) {
      var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS);
      while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {
        if (isElementFocusZone(parentElement)) {
          return parentElement;
        }
        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
      }
      return parentElement;
    };
    FocusZone2.prototype._updateTabIndexes = function(element) {
      if (!this._activeElement && this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === "function") {
        this._activeElement = this.props.defaultTabbableElement(this._root.current);
      }
      if (!element && this._root.current) {
        this._defaultFocusElement = null;
        element = this._root.current;
        if (this._activeElement && !elementContains(element, this._activeElement)) {
          this._activeElement = null;
        }
      }
      if (this._activeElement && !isElementTabbable(this._activeElement)) {
        this._activeElement = null;
      }
      var childNodes = element && element.children;
      for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
        var child = childNodes[childIndex];
        if (!isElementFocusZone(child)) {
          if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "false") {
            child.setAttribute(TABINDEX, "-1");
          }
          if (isElementTabbable(child)) {
            if (this.props.disabled) {
              child.setAttribute(TABINDEX, "-1");
            } else if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
              this._defaultFocusElement = child;
              if (child.getAttribute(TABINDEX) !== "0") {
                child.setAttribute(TABINDEX, "0");
              }
            } else if (child.getAttribute(TABINDEX) !== "-1") {
              child.setAttribute(TABINDEX, "-1");
            }
          } else if (child.tagName === "svg" && child.getAttribute("focusable") !== "false") {
            child.setAttribute("focusable", "false");
          }
        } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true") {
          if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
            this._defaultFocusElement = child;
            if (child.getAttribute(TABINDEX) !== "0") {
              child.setAttribute(TABINDEX, "0");
            }
          } else if (child.getAttribute(TABINDEX) !== "-1") {
            child.setAttribute(TABINDEX, "-1");
          }
        }
        this._updateTabIndexes(child);
      }
    };
    FocusZone2.prototype._isContentEditableElement = function(element) {
      return element && element.getAttribute("contenteditable") === "true";
    };
    FocusZone2.prototype._isElementInput = function(element) {
      if (element && element.tagName && (element.tagName.toLowerCase() === "input" || element.tagName.toLowerCase() === "textarea")) {
        return true;
      }
      return false;
    };
    FocusZone2.prototype._shouldInputLoseFocus = function(element, isForward) {
      if (!this._processingTabKey && element && element.type && ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {
        var selectionStart = element.selectionStart;
        var selectionEnd = element.selectionEnd;
        var isRangeSelected = selectionStart !== selectionEnd;
        var inputValue = element.value;
        var isReadonly = element.readOnly;
        if (isRangeSelected || selectionStart > 0 && !isForward && !isReadonly || selectionStart !== inputValue.length && isForward && !isReadonly || !!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element))) {
          return false;
        }
      }
      return true;
    };
    FocusZone2.prototype._shouldWrapFocus = function(element, noWrapDataAttribute) {
      return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;
    };
    FocusZone2.prototype._portalContainsElement = function(element) {
      return element && !!this._root.current && portalContainsElement(element, this._root.current);
    };
    FocusZone2.prototype._getDocument = function() {
      return getDocument(this._root.current);
    };
    FocusZone2.defaultProps = {
      isCircularNavigation: false,
      direction: FocusZoneDirection.bidirectional,
      shouldRaiseClicks: true
    };
    return FocusZone2;
  }(React__namespace.Component)
);
var getClassNames$J = classNamesFunction();
var useLink = function(props, forwardedRef) {
  var as = props.as, className = props.className, disabled = props.disabled, href = props.href, onClick = props.onClick, styles2 = props.styles, theme = props.theme, underline = props.underline;
  var rootRef = React__namespace.useRef(null);
  var mergedRootRefs = useMergedRefs(rootRef, forwardedRef);
  useComponentRef$4(props, rootRef);
  useFocusRects(rootRef);
  var classNames2 = getClassNames$J(styles2, {
    className,
    isButton: !href,
    isDisabled: disabled,
    isUnderlined: underline,
    theme
  });
  var _onClick = function(ev) {
    if (disabled) {
      ev.preventDefault();
    } else if (onClick) {
      onClick(ev);
    }
  };
  var rootType = as ? as : href ? "a" : "button";
  var state = {};
  var slots = { root: rootType };
  var slotProps = {
    root: __assign$1(__assign$1({}, adjustPropsForRootType(rootType, props)), { "aria-disabled": disabled, className: classNames2.root, onClick: _onClick, ref: mergedRootRefs })
  };
  return { state, slots, slotProps };
};
var useComponentRef$4 = function(props, link) {
  React__namespace.useImperativeHandle(props.componentRef, function() {
    return {
      focus: function() {
        if (link.current) {
          link.current.focus();
        }
      }
    };
  }, [link]);
};
var adjustPropsForRootType = function(RootType, props) {
  props.as;
  var disabled = props.disabled, target = props.target, href = props.href;
  props.theme;
  props.getStyles;
  props.styles;
  props.componentRef;
  props.underline;
  var restProps = __rest$1(props, ["as", "disabled", "target", "href", "theme", "getStyles", "styles", "componentRef", "underline"]);
  if (typeof RootType === "string") {
    if (RootType === "a") {
      return __assign$1({ target, href: disabled ? void 0 : href }, restProps);
    }
    if (RootType === "button") {
      return __assign$1({ type: "button", disabled }, restProps);
    }
    return __assign$1(__assign$1({}, restProps), { disabled });
  }
  return __assign$1({ target, href, disabled }, restProps);
};
var LinkBase = React__namespace.forwardRef(function(props, ref) {
  var _a2 = useLink(props, ref), slots = _a2.slots, slotProps = _a2.slotProps;
  return React__namespace.createElement(slots.root, __assign$1({}, slotProps.root));
});
LinkBase.displayName = "LinkBase";
var GlobalClassNames$v = {
  root: "ms-Link"
};
var getStyles$G = function(props) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g;
  var className = props.className, isButton = props.isButton, isDisabled = props.isDisabled, isUnderlined = props.isUnderlined, theme = props.theme;
  var semanticColors = theme.semanticColors;
  var linkColor = semanticColors.link;
  var linkInteractedColor = semanticColors.linkHovered;
  var linkDisabledColor = semanticColors.disabledText;
  var focusBorderColor = semanticColors.focusBorder;
  var classNames2 = getGlobalClassNames(GlobalClassNames$v, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        color: linkColor,
        outline: "none",
        fontSize: "inherit",
        fontWeight: "inherit",
        textDecoration: isUnderlined ? "underline" : "none",
        selectors: (_a2 = {
          ".ms-Fabric--isFocusVisible &:focus": {
            // Can't use getFocusStyle because it doesn't support wrapping links
            // https://github.com/microsoft/fluentui/issues/4883#issuecomment-406743543
            // Using box-shadow and outline allows the focus rect to wrap links that span multiple lines
            // and helps the focus rect avoid getting clipped.
            boxShadow: "0 0 0 1px " + focusBorderColor + " inset",
            outline: "1px auto " + focusBorderColor,
            selectors: (_b2 = {}, _b2[HighContrastSelector] = {
              outline: "1px solid WindowText"
            }, _b2)
          }
        }, _a2[HighContrastSelector] = {
          // For IE high contrast mode
          borderBottom: "none"
        }, _a2)
      },
      isButton && {
        background: "none",
        backgroundColor: "transparent",
        border: "none",
        cursor: "pointer",
        display: "inline",
        margin: 0,
        overflow: "inherit",
        padding: 0,
        textAlign: "left",
        textOverflow: "inherit",
        userSelect: "text",
        borderBottom: "1px solid transparent",
        selectors: (_c2 = {}, _c2[HighContrastSelector] = {
          color: "LinkText",
          forcedColorAdjust: "none"
        }, _c2)
      },
      !isButton && {
        selectors: (_d2 = {}, _d2[HighContrastSelector] = {
          // This is mainly for MessageBar, which sets MsHighContrastAdjust: none by default
          MsHighContrastAdjust: "auto",
          forcedColorAdjust: "auto"
        }, _d2)
      },
      isDisabled && [
        "is-disabled",
        {
          color: linkDisabledColor,
          cursor: "default"
        },
        {
          selectors: (_e2 = {
            "&:link, &:visited": {
              pointerEvents: "none"
            }
          }, _e2[HighContrastSelector] = {
            // We need to specify the color in High Contrast because of the case of Links rendering as buttons.
            color: "GrayText"
          }, _e2)
        }
      ],
      !isDisabled && {
        selectors: {
          "&:active, &:hover, &:active:hover": {
            color: linkInteractedColor,
            textDecoration: "underline",
            selectors: (_f = {}, _f[HighContrastSelector] = {
              color: "LinkText"
            }, _f)
          },
          "&:focus": {
            color: linkColor,
            selectors: (_g = {}, _g[HighContrastSelector] = {
              color: "LinkText"
            }, _g)
          }
        }
      },
      classNames2.root,
      className
    ]
  };
};
var Link = styled(LinkBase, getStyles$G, void 0, {
  scope: "Link"
});
var ContextualMenuItemType;
(function(ContextualMenuItemType2) {
  ContextualMenuItemType2[ContextualMenuItemType2["Normal"] = 0] = "Normal";
  ContextualMenuItemType2[ContextualMenuItemType2["Divider"] = 1] = "Divider";
  ContextualMenuItemType2[ContextualMenuItemType2["Header"] = 2] = "Header";
  ContextualMenuItemType2[ContextualMenuItemType2["Section"] = 3] = "Section";
})(ContextualMenuItemType || (ContextualMenuItemType = {}));
function getIsChecked(item) {
  if (item.canCheck) {
    return !!(item.isChecked || item.checked);
  }
  if (typeof item.isChecked === "boolean") {
    return item.isChecked;
  }
  if (typeof item.checked === "boolean") {
    return item.checked;
  }
  return null;
}
function hasSubmenu(item) {
  return !!(item.subMenuProps || item.items);
}
function isItemDisabled(item) {
  return !!(item.isDisabled || item.disabled);
}
function getMenuItemAriaRole(item) {
  var isChecked = getIsChecked(item);
  var canCheck = isChecked !== null;
  return canCheck ? "menuitemcheckbox" : "menuitem";
}
var defaultIconRenderer = function(props) {
  var item = props.item, classNames2 = props.classNames;
  var iconProps = item.iconProps;
  return React__namespace.createElement(Icon, __assign$1({}, iconProps, { className: classNames2.icon }));
};
var renderItemIcon = function(props) {
  var item = props.item, hasIcons = props.hasIcons;
  if (!hasIcons) {
    return null;
  }
  if (item.onRenderIcon) {
    return item.onRenderIcon(props, defaultIconRenderer);
  }
  return defaultIconRenderer(props);
};
var renderCheckMarkIcon = function(_a2) {
  var onCheckmarkClick = _a2.onCheckmarkClick, item = _a2.item, classNames2 = _a2.classNames;
  var isItemChecked = getIsChecked(item);
  if (onCheckmarkClick) {
    var onClick = function(e) {
      return onCheckmarkClick(item, e);
    };
    return React__namespace.createElement(Icon, {
      iconName: item.canCheck !== false && isItemChecked ? "CheckMark" : "",
      className: classNames2.checkmarkIcon,
      // eslint-disable-next-line react/jsx-no-bind
      onClick
    });
  }
  return null;
};
var renderItemName = function(_a2) {
  var item = _a2.item, classNames2 = _a2.classNames;
  if (item.text || item.name) {
    return React__namespace.createElement("span", { className: classNames2.label }, item.text || item.name);
  }
  return null;
};
var renderSecondaryText = function(_a2) {
  var item = _a2.item, classNames2 = _a2.classNames;
  if (item.secondaryText) {
    return React__namespace.createElement("span", { className: classNames2.secondaryText }, item.secondaryText);
  }
  return null;
};
var renderSubMenuIcon = function(_a2) {
  var item = _a2.item, classNames2 = _a2.classNames, theme = _a2.theme;
  if (hasSubmenu(item)) {
    return React__namespace.createElement(Icon, __assign$1({ iconName: getRTL(theme) ? "ChevronLeft" : "ChevronRight" }, item.submenuIconProps, { className: classNames2.subMenuIcon }));
  }
  return null;
};
var ContextualMenuItemBase = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuItemBase2, _super);
    function ContextualMenuItemBase2(props) {
      var _this = _super.call(this, props) || this;
      _this.openSubMenu = function() {
        var _a2 = _this.props, item = _a2.item, openSubMenu = _a2.openSubMenu, getSubmenuTarget = _a2.getSubmenuTarget;
        if (getSubmenuTarget) {
          var submenuTarget = getSubmenuTarget();
          if (hasSubmenu(item) && openSubMenu && submenuTarget) {
            openSubMenu(item, submenuTarget);
          }
        }
      };
      _this.dismissSubMenu = function() {
        var _a2 = _this.props, item = _a2.item, dismissSubMenu = _a2.dismissSubMenu;
        if (hasSubmenu(item) && dismissSubMenu) {
          dismissSubMenu();
        }
      };
      _this.dismissMenu = function(dismissAll) {
        var dismissMenu = _this.props.dismissMenu;
        if (dismissMenu) {
          dismissMenu(void 0, dismissAll);
        }
      };
      initializeComponentRef(_this);
      return _this;
    }
    ContextualMenuItemBase2.prototype.render = function() {
      var _a2 = this.props, item = _a2.item, classNames2 = _a2.classNames;
      var renderContent = item.onRenderContent || this._renderLayout;
      return React__namespace.createElement("div", { className: item.split ? classNames2.linkContentMenu : classNames2.linkContent }, renderContent(this.props, {
        renderCheckMarkIcon,
        renderItemIcon,
        renderItemName,
        renderSecondaryText,
        renderSubMenuIcon
      }));
    };
    ContextualMenuItemBase2.prototype._renderLayout = function(props, defaultRenders) {
      return React__namespace.createElement(
        React__namespace.Fragment,
        null,
        defaultRenders.renderCheckMarkIcon(props),
        defaultRenders.renderItemIcon(props),
        defaultRenders.renderItemName(props),
        defaultRenders.renderSecondaryText(props),
        defaultRenders.renderSubMenuIcon(props)
      );
    };
    return ContextualMenuItemBase2;
  }(React__namespace.Component)
);
var getDividerClassNames = memoizeFunction(
  // eslint-disable-next-line deprecation/deprecation
  function(theme) {
    return mergeStyleSets({
      wrapper: {
        display: "inline-flex",
        height: "100%",
        alignItems: "center"
      },
      divider: {
        width: 1,
        height: "100%",
        backgroundColor: theme.palette.neutralTertiaryAlt
      }
    });
  }
);
var CONTEXTUAL_MENU_ITEM_HEIGHT = 36;
var MediumScreenSelector$1 = getScreenSelector(0, ScreenWidthMaxMedium);
var getMenuItemStyles = memoizeFunction(function(theme) {
  var _a2, _b2, _c2, _d2, _e2;
  var semanticColors = theme.semanticColors, fonts = theme.fonts, palette = theme.palette;
  var ContextualMenuItemBackgroundHoverColor = semanticColors.menuItemBackgroundHovered;
  var ContextualMenuItemTextHoverColor = semanticColors.menuItemTextHovered;
  var ContextualMenuItemBackgroundSelectedColor = semanticColors.menuItemBackgroundPressed;
  var ContextualMenuItemDividerColor = semanticColors.bodyDivider;
  var menuItemStyles = {
    item: [
      fonts.medium,
      {
        color: semanticColors.bodyText,
        position: "relative",
        boxSizing: "border-box"
      }
    ],
    divider: {
      display: "block",
      height: "1px",
      backgroundColor: ContextualMenuItemDividerColor,
      position: "relative"
    },
    root: [
      getFocusStyle(theme),
      fonts.medium,
      {
        color: semanticColors.bodyText,
        backgroundColor: "transparent",
        border: "none",
        width: "100%",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
        display: "block",
        cursor: "pointer",
        padding: "0px 8px 0 4px",
        textAlign: "left"
      }
    ],
    rootDisabled: {
      color: semanticColors.disabledBodyText,
      cursor: "default",
      pointerEvents: "none",
      selectors: (_a2 = {}, _a2[HighContrastSelector] = {
        // ensure disabled text looks different than enabled
        color: "GrayText",
        opacity: 1
      }, _a2)
    },
    rootHovered: {
      backgroundColor: ContextualMenuItemBackgroundHoverColor,
      color: ContextualMenuItemTextHoverColor,
      selectors: {
        ".ms-ContextualMenu-icon": {
          color: palette.themeDarkAlt
        },
        ".ms-ContextualMenu-submenuIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootFocused: {
      backgroundColor: palette.white
    },
    rootChecked: {
      selectors: {
        ".ms-ContextualMenu-checkmarkIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootPressed: {
      backgroundColor: ContextualMenuItemBackgroundSelectedColor,
      selectors: {
        ".ms-ContextualMenu-icon": {
          color: palette.themeDark
        },
        ".ms-ContextualMenu-submenuIcon": {
          color: palette.neutralPrimary
        }
      }
    },
    rootExpanded: {
      backgroundColor: ContextualMenuItemBackgroundSelectedColor,
      color: semanticColors.bodyTextChecked,
      selectors: (_b2 = {
        ".ms-ContextualMenu-submenuIcon": (_c2 = {}, _c2[HighContrastSelector] = {
          // icons inside of anchor tags are not properly inheriting color in high contrast
          color: "inherit"
        }, _c2)
      }, _b2[HighContrastSelector] = __assign$1({}, getHighContrastNoAdjustStyle()), _b2)
    },
    linkContent: {
      whiteSpace: "nowrap",
      height: "inherit",
      display: "flex",
      alignItems: "center",
      maxWidth: "100%"
    },
    anchorLink: {
      padding: "0px 8px 0 4px",
      textRendering: "auto",
      color: "inherit",
      letterSpacing: "normal",
      wordSpacing: "normal",
      textTransform: "none",
      textIndent: "0px",
      textShadow: "none",
      textDecoration: "none",
      boxSizing: "border-box"
    },
    label: {
      margin: "0 4px",
      verticalAlign: "middle",
      display: "inline-block",
      flexGrow: "1",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden"
    },
    secondaryText: {
      color: theme.palette.neutralSecondary,
      paddingLeft: "20px",
      textAlign: "right"
    },
    icon: {
      display: "inline-block",
      minHeight: "1px",
      maxHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
      fontSize: IconFontSizes.medium,
      width: IconFontSizes.medium,
      margin: "0 4px",
      verticalAlign: "middle",
      flexShrink: "0",
      selectors: (_d2 = {}, _d2[MediumScreenSelector$1] = {
        fontSize: IconFontSizes.large,
        width: IconFontSizes.large
      }, _d2)
    },
    iconColor: {
      color: semanticColors.menuIcon
    },
    iconDisabled: {
      color: semanticColors.disabledBodyText
    },
    checkmarkIcon: {
      color: semanticColors.bodySubtext
    },
    subMenuIcon: {
      height: CONTEXTUAL_MENU_ITEM_HEIGHT,
      lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
      color: palette.neutralSecondary,
      textAlign: "center",
      display: "inline-block",
      verticalAlign: "middle",
      flexShrink: "0",
      fontSize: IconFontSizes.small,
      selectors: (_e2 = {
        ":hover": {
          color: palette.neutralPrimary
        },
        ":active": {
          color: palette.neutralPrimary
        }
      }, _e2[MediumScreenSelector$1] = {
        fontSize: IconFontSizes.medium
        // 16px
      }, _e2)
    },
    splitButtonFlexContainer: [
      getFocusStyle(theme),
      {
        display: "flex",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        flexWrap: "nowrap",
        justifyContent: "center",
        alignItems: "flex-start"
      }
    ]
  };
  return concatStyleSets(menuItemStyles);
});
var CONTEXTUAL_SPLIT_MENU_MINWIDTH = "28px";
var MediumScreenSelector = getScreenSelector(0, ScreenWidthMaxMedium);
var getSplitButtonVerticalDividerClassNames = memoizeFunction(
  /* eslint-disable deprecation/deprecation */
  function(theme) {
    var _a2;
    return mergeStyleSets(getDividerClassNames(theme), {
      /* eslint-enable deprecation/deprecation */
      wrapper: {
        position: "absolute",
        right: 28,
        selectors: (_a2 = {}, _a2[MediumScreenSelector] = {
          right: 32
          // fontSize of the icon increased from 12px to 16px
        }, _a2)
      },
      divider: {
        height: 16,
        width: 1
      }
    });
  }
);
var GlobalClassNames$u = {
  item: "ms-ContextualMenu-item",
  divider: "ms-ContextualMenu-divider",
  root: "ms-ContextualMenu-link",
  isChecked: "is-checked",
  isExpanded: "is-expanded",
  isDisabled: "is-disabled",
  linkContent: "ms-ContextualMenu-linkContent",
  linkContentMenu: "ms-ContextualMenu-linkContent",
  icon: "ms-ContextualMenu-icon",
  iconColor: "ms-ContextualMenu-iconColor",
  checkmarkIcon: "ms-ContextualMenu-checkmarkIcon",
  subMenuIcon: "ms-ContextualMenu-submenuIcon",
  label: "ms-ContextualMenu-itemText",
  secondaryText: "ms-ContextualMenu-secondaryText",
  splitMenu: "ms-ContextualMenu-splitMenu",
  screenReaderText: "ms-ContextualMenu-screenReaderText"
};
var getItemClassNames = memoizeFunction(function(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className) {
  var _a2, _b2, _c2, _d2;
  var styles2 = getMenuItemStyles(theme);
  var classNames2 = getGlobalClassNames(GlobalClassNames$u, theme);
  return mergeStyleSets({
    item: [classNames2.item, styles2.item, itemClassName],
    divider: [classNames2.divider, styles2.divider, dividerClassName],
    root: [
      classNames2.root,
      styles2.root,
      checked && [classNames2.isChecked, styles2.rootChecked],
      isAnchorLink && styles2.anchorLink,
      expanded && [classNames2.isExpanded, styles2.rootExpanded],
      disabled && [classNames2.isDisabled, styles2.rootDisabled],
      !disabled && !expanded && [
        {
          selectors: (_a2 = {
            ":hover": styles2.rootHovered,
            ":active": styles2.rootPressed
          }, _a2["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles2.rootFocused, _a2["." + IsFocusVisibleClassName + " &:hover"] = { background: "inherit;" }, _a2)
        }
      ],
      className
    ],
    splitPrimary: [
      styles2.root,
      {
        width: "calc(100% - " + CONTEXTUAL_SPLIT_MENU_MINWIDTH + ")"
      },
      checked && ["is-checked", styles2.rootChecked],
      (disabled || primaryDisabled) && ["is-disabled", styles2.rootDisabled],
      !(disabled || primaryDisabled) && !checked && [
        {
          selectors: (_b2 = {
            ":hover": styles2.rootHovered
          }, // when hovering over the splitPrimary also affect the splitMenu
          _b2[":hover ~ ." + classNames2.splitMenu] = styles2.rootHovered, _b2[":active"] = styles2.rootPressed, _b2["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles2.rootFocused, _b2["." + IsFocusVisibleClassName + " &:hover"] = { background: "inherit;" }, _b2)
        }
      ]
    ],
    splitMenu: [
      classNames2.splitMenu,
      styles2.root,
      {
        flexBasis: "0",
        padding: "0 8px",
        minWidth: CONTEXTUAL_SPLIT_MENU_MINWIDTH
      },
      expanded && ["is-expanded", styles2.rootExpanded],
      disabled && ["is-disabled", styles2.rootDisabled],
      !disabled && !expanded && [
        {
          selectors: (_c2 = {
            ":hover": styles2.rootHovered,
            ":active": styles2.rootPressed
          }, _c2["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles2.rootFocused, _c2["." + IsFocusVisibleClassName + " &:hover"] = { background: "inherit;" }, _c2)
        }
      ]
    ],
    anchorLink: styles2.anchorLink,
    linkContent: [classNames2.linkContent, styles2.linkContent],
    linkContentMenu: [
      classNames2.linkContentMenu,
      styles2.linkContent,
      {
        justifyContent: "center"
      }
    ],
    icon: [
      classNames2.icon,
      knownIcon && styles2.iconColor,
      styles2.icon,
      iconClassName,
      disabled && [classNames2.isDisabled, styles2.iconDisabled]
    ],
    iconColor: styles2.iconColor,
    checkmarkIcon: [classNames2.checkmarkIcon, knownIcon && styles2.checkmarkIcon, styles2.icon, iconClassName],
    subMenuIcon: [
      classNames2.subMenuIcon,
      styles2.subMenuIcon,
      subMenuClassName,
      expanded && { color: theme.palette.neutralPrimary },
      disabled && [styles2.iconDisabled]
    ],
    label: [classNames2.label, styles2.label],
    secondaryText: [classNames2.secondaryText, styles2.secondaryText],
    splitContainer: [
      styles2.splitButtonFlexContainer,
      !disabled && !checked && [
        {
          selectors: (_d2 = {}, _d2["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles2.rootFocused, _d2)
        }
      ]
    ],
    screenReaderText: [
      classNames2.screenReaderText,
      styles2.screenReaderText,
      hiddenContentStyle,
      { visibility: "hidden" }
    ]
  });
});
var getItemStyles = function(props) {
  var theme = props.theme, disabled = props.disabled, expanded = props.expanded, checked = props.checked, isAnchorLink = props.isAnchorLink, knownIcon = props.knownIcon, itemClassName = props.itemClassName, dividerClassName = props.dividerClassName, iconClassName = props.iconClassName, subMenuClassName = props.subMenuClassName, primaryDisabled = props.primaryDisabled, className = props.className;
  return getItemClassNames(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className);
};
var ContextualMenuItem = styled(ContextualMenuItemBase, getItemStyles, void 0, { scope: "ContextualMenuItem" });
var ContextualMenuItemWrapper = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuItemWrapper2, _super);
    function ContextualMenuItemWrapper2(props) {
      var _this = _super.call(this, props) || this;
      _this._onItemMouseEnter = function(ev) {
        var _a2 = _this.props, item = _a2.item, onItemMouseEnter = _a2.onItemMouseEnter;
        if (onItemMouseEnter) {
          onItemMouseEnter(item, ev, ev.currentTarget);
        }
      };
      _this._onItemClick = function(ev) {
        var _a2 = _this.props, item = _a2.item, onItemClickBase = _a2.onItemClickBase;
        if (onItemClickBase) {
          onItemClickBase(item, ev, ev.currentTarget);
        }
      };
      _this._onItemMouseLeave = function(ev) {
        var _a2 = _this.props, item = _a2.item, onItemMouseLeave = _a2.onItemMouseLeave;
        if (onItemMouseLeave) {
          onItemMouseLeave(item, ev);
        }
      };
      _this._onItemKeyDown = function(ev) {
        var _a2 = _this.props, item = _a2.item, onItemKeyDown = _a2.onItemKeyDown;
        if (onItemKeyDown) {
          onItemKeyDown(item, ev);
        }
      };
      _this._onItemMouseMove = function(ev) {
        var _a2 = _this.props, item = _a2.item, onItemMouseMove = _a2.onItemMouseMove;
        if (onItemMouseMove) {
          onItemMouseMove(item, ev, ev.currentTarget);
        }
      };
      _this._getSubmenuTarget = function() {
        return void 0;
      };
      initializeComponentRef(_this);
      return _this;
    }
    ContextualMenuItemWrapper2.prototype.shouldComponentUpdate = function(newProps) {
      return !shallowCompare(newProps, this.props);
    };
    return ContextualMenuItemWrapper2;
  }(React__namespace.Component)
);
var KTP_PREFIX = "ktp";
var KTP_SEPARATOR = "-";
var DATAKTP_TARGET = "data-ktp-target";
var DATAKTP_EXECUTE_TARGET = "data-ktp-execute-target";
var KTP_LAYER_ID = "ktp-layer-id";
var KeytipEvents;
(function(KeytipEvents2) {
  KeytipEvents2.KEYTIP_ADDED = "keytipAdded";
  KeytipEvents2.KEYTIP_REMOVED = "keytipRemoved";
  KeytipEvents2.KEYTIP_UPDATED = "keytipUpdated";
  KeytipEvents2.PERSISTED_KEYTIP_ADDED = "persistedKeytipAdded";
  KeytipEvents2.PERSISTED_KEYTIP_REMOVED = "persistedKeytipRemoved";
  KeytipEvents2.PERSISTED_KEYTIP_EXECUTE = "persistedKeytipExecute";
  KeytipEvents2.ENTER_KEYTIP_MODE = "enterKeytipMode";
  KeytipEvents2.EXIT_KEYTIP_MODE = "exitKeytipMode";
})(KeytipEvents || (KeytipEvents = {}));
var KeytipManager = (
  /** @class */
  function() {
    function KeytipManager2() {
      this.keytips = {};
      this.persistedKeytips = {};
      this.sequenceMapping = {};
      this.inKeytipMode = false;
      this.shouldEnterKeytipMode = true;
      this.delayUpdatingKeytipChange = false;
    }
    KeytipManager2.getInstance = function() {
      return this._instance;
    };
    KeytipManager2.prototype.init = function(delayUpdatingKeytipChange) {
      this.delayUpdatingKeytipChange = delayUpdatingKeytipChange;
    };
    KeytipManager2.prototype.register = function(keytipProps, persisted) {
      if (persisted === void 0) {
        persisted = false;
      }
      var props = keytipProps;
      if (!persisted) {
        props = this.addParentOverflow(keytipProps);
        this.sequenceMapping[props.keySequences.toString()] = props;
      }
      var uniqueKeytip = this._getUniqueKtp(props);
      persisted ? this.persistedKeytips[uniqueKeytip.uniqueID] = uniqueKeytip : this.keytips[uniqueKeytip.uniqueID] = uniqueKeytip;
      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
        var event_1 = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;
        EventGroup.raise(this, event_1, {
          keytip: props,
          uniqueID: uniqueKeytip.uniqueID
        });
      }
      return uniqueKeytip.uniqueID;
    };
    KeytipManager2.prototype.update = function(keytipProps, uniqueID) {
      var newKeytipProps = this.addParentOverflow(keytipProps);
      var uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);
      var oldKeyTip = this.keytips[uniqueID];
      if (oldKeyTip) {
        uniqueKeytip.keytip.visible = oldKeyTip.keytip.visible;
        this.keytips[uniqueID] = uniqueKeytip;
        delete this.sequenceMapping[oldKeyTip.keytip.keySequences.toString()];
        this.sequenceMapping[uniqueKeytip.keytip.keySequences.toString()] = uniqueKeytip.keytip;
        if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
          EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {
            keytip: uniqueKeytip.keytip,
            uniqueID: uniqueKeytip.uniqueID
          });
        }
      }
    };
    KeytipManager2.prototype.unregister = function(keytipToRemove, uniqueID, persisted) {
      if (persisted === void 0) {
        persisted = false;
      }
      persisted ? delete this.persistedKeytips[uniqueID] : delete this.keytips[uniqueID];
      !persisted && delete this.sequenceMapping[keytipToRemove.keySequences.toString()];
      var event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;
      if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
        EventGroup.raise(this, event, {
          keytip: keytipToRemove,
          uniqueID
        });
      }
    };
    KeytipManager2.prototype.enterKeytipMode = function() {
      EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);
    };
    KeytipManager2.prototype.exitKeytipMode = function() {
      EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);
    };
    KeytipManager2.prototype.getKeytips = function() {
      var _this = this;
      return Object.keys(this.keytips).map(function(key) {
        return _this.keytips[key].keytip;
      });
    };
    KeytipManager2.prototype.addParentOverflow = function(keytipProps) {
      var fullSequence = __spreadArray([], keytipProps.keySequences);
      fullSequence.pop();
      if (fullSequence.length !== 0) {
        var parentKeytip = this.sequenceMapping[fullSequence.toString()];
        if (parentKeytip && parentKeytip.overflowSetSequence) {
          return __assign$1(__assign$1({}, keytipProps), { overflowSetSequence: parentKeytip.overflowSetSequence });
        }
      }
      return keytipProps;
    };
    KeytipManager2.prototype.menuExecute = function(overflowButtonSequences, keytipSequences) {
      EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {
        overflowButtonSequences,
        keytipSequences
      });
    };
    KeytipManager2.prototype._getUniqueKtp = function(keytipProps, uniqueID) {
      if (uniqueID === void 0) {
        uniqueID = getId();
      }
      return { keytip: __assign$1({}, keytipProps), uniqueID };
    };
    KeytipManager2._instance = new KeytipManager2();
    return KeytipManager2;
  }()
);
function sequencesToID(keySequences) {
  return keySequences.reduce(function(prevValue, keySequence) {
    return prevValue + KTP_SEPARATOR + keySequence.split("").join(KTP_SEPARATOR);
  }, KTP_PREFIX);
}
function mergeOverflows(keySequences, overflowKeySequences) {
  var overflowSequenceLen = overflowKeySequences.length;
  var overflowSequence = __spreadArray([], overflowKeySequences).pop();
  var newKeySequences = __spreadArray([], keySequences);
  return addElementAtIndex(newKeySequences, overflowSequenceLen - 1, overflowSequence);
}
function getAriaDescribedBy(keySequences) {
  var describedby = " " + KTP_LAYER_ID;
  if (!keySequences.length) {
    return describedby;
  }
  return describedby + " " + sequencesToID(keySequences);
}
function useKeytipData(options2) {
  var uniqueId = React__namespace.useRef();
  var keytipProps = options2.keytipProps ? __assign$1({ disabled: options2.disabled }, options2.keytipProps) : void 0;
  var keytipManager = useConst(KeytipManager.getInstance());
  var prevOptions = usePrevious(options2);
  useIsomorphicLayoutEffect(function() {
    if (uniqueId.current && keytipProps && ((prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.keytipProps) !== options2.keytipProps || (prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.disabled) !== options2.disabled)) {
      keytipManager.update(keytipProps, uniqueId.current);
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (keytipProps) {
      uniqueId.current = keytipManager.register(keytipProps);
    }
    return function() {
      keytipProps && keytipManager.unregister(keytipProps, uniqueId.current);
    };
  }, []);
  var nativeKeytipProps = {
    ariaDescribedBy: void 0,
    keytipId: void 0
  };
  if (keytipProps) {
    nativeKeytipProps = getKeytipData(keytipManager, keytipProps, options2.ariaDescribedBy);
  }
  return nativeKeytipProps;
}
function getKeytipData(keytipManager, keytipProps, describedByPrepend) {
  var newKeytipProps = keytipManager.addParentOverflow(keytipProps);
  var ariaDescribedBy = mergeAriaAttributeValues(describedByPrepend, getAriaDescribedBy(newKeytipProps.keySequences));
  var keySequences = __spreadArray([], newKeytipProps.keySequences);
  if (newKeytipProps.overflowSetSequence) {
    keySequences = mergeOverflows(keySequences, newKeytipProps.overflowSetSequence);
  }
  var keytipId = sequencesToID(keySequences);
  return {
    ariaDescribedBy,
    keytipId
  };
}
var KeytipData = function(props) {
  var _a2;
  var children = props.children, keytipDataProps = __rest$1(props, ["children"]);
  var _b2 = useKeytipData(keytipDataProps), keytipId = _b2.keytipId, ariaDescribedBy = _b2.ariaDescribedBy;
  return children((_a2 = {}, _a2[DATAKTP_TARGET] = keytipId, _a2[DATAKTP_EXECUTE_TARGET] = keytipId, _a2["aria-describedby"] = ariaDescribedBy, _a2));
};
var ContextualMenuAnchor = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuAnchor2, _super);
    function ContextualMenuAnchor2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._anchor = React__namespace.createRef();
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign$1(__assign$1({}, keytipProps), { hasMenu: true });
      });
      _this._getSubmenuTarget = function() {
        return _this._anchor.current ? _this._anchor.current : void 0;
      };
      _this._onItemClick = function(ev) {
        var _a2 = _this.props, item = _a2.item, onItemClick = _a2.onItemClick;
        if (onItemClick) {
          onItemClick(item, ev);
        }
      };
      _this._renderAriaDescription = function(ariaDescription, className) {
        return ariaDescription ? React__namespace.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
      };
      return _this;
    }
    ContextualMenuAnchor2.prototype.render = function() {
      var _this = this;
      var _a2 = this.props, item = _a2.item, classNames2 = _a2.classNames, index2 = _a2.index, focusableElementIndex = _a2.focusableElementIndex, totalItemCount = _a2.totalItemCount, hasCheckmarks = _a2.hasCheckmarks, hasIcons = _a2.hasIcons, _b2 = _a2.contextualMenuItemAs, ChildrenRenderer = _b2 === void 0 ? ContextualMenuItem : _b2, expandedMenuItemKey = _a2.expandedMenuItemKey, onItemClick = _a2.onItemClick, openSubMenu = _a2.openSubMenu, dismissSubMenu = _a2.dismissSubMenu, dismissMenu = _a2.dismissMenu;
      var anchorRel = item.rel;
      if (item.target && item.target.toLowerCase() === "_blank") {
        anchorRel = anchorRel ? anchorRel : "nofollow noopener noreferrer";
      }
      var itemHasSubmenu = hasSubmenu(item);
      var nativeProps = getNativeProps(item, anchorProperties);
      var disabled = isItemDisabled(item);
      var itemProps = item.itemProps, ariaDescription = item.ariaDescription;
      var keytipProps = item.keytipProps;
      if (keytipProps && itemHasSubmenu) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      if (ariaDescription) {
        this._ariaDescriptionId = getId();
      }
      var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : void 0, nativeProps["aria-describedby"]);
      var additionalItemProperties = {
        "aria-describedby": ariaDescribedByIds
      };
      return React__namespace.createElement(
        "div",
        null,
        React__namespace.createElement(KeytipData, { keytipProps: item.keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled }, function(keytipAttributes) {
          return React__namespace.createElement(
            "a",
            __assign$1({}, additionalItemProperties, nativeProps, keytipAttributes, {
              ref: _this._anchor,
              href: item.href,
              target: item.target,
              rel: anchorRel,
              className: classNames2.root,
              role: "menuitem",
              "aria-haspopup": itemHasSubmenu || void 0,
              "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0,
              "aria-posinset": focusableElementIndex + 1,
              "aria-setsize": totalItemCount,
              "aria-disabled": isItemDisabled(item),
              // eslint-disable-next-line deprecation/deprecation
              style: item.style,
              onClick: _this._onItemClick,
              onMouseEnter: _this._onItemMouseEnter,
              onMouseLeave: _this._onItemMouseLeave,
              onMouseMove: _this._onItemMouseMove,
              onKeyDown: itemHasSubmenu ? _this._onItemKeyDown : void 0
            }),
            React__namespace.createElement(ChildrenRenderer, __assign$1({ componentRef: item.componentRef, item, classNames: classNames2, index: index2, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
            _this._renderAriaDescription(ariaDescription, classNames2.screenReaderText)
          );
        })
      );
    };
    return ContextualMenuAnchor2;
  }(ContextualMenuItemWrapper)
);
var ContextualMenuButton = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuButton2, _super);
    function ContextualMenuButton2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._btn = React__namespace.createRef();
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign$1(__assign$1({}, keytipProps), { hasMenu: true });
      });
      _this._renderAriaDescription = function(ariaDescription, className) {
        return ariaDescription ? React__namespace.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
      };
      _this._getSubmenuTarget = function() {
        return _this._btn.current ? _this._btn.current : void 0;
      };
      return _this;
    }
    ContextualMenuButton2.prototype.render = function() {
      var _this = this;
      var _a2 = this.props, item = _a2.item, classNames2 = _a2.classNames, index2 = _a2.index, focusableElementIndex = _a2.focusableElementIndex, totalItemCount = _a2.totalItemCount, hasCheckmarks = _a2.hasCheckmarks, hasIcons = _a2.hasIcons, _b2 = _a2.contextualMenuItemAs, ChildrenRenderer = _b2 === void 0 ? ContextualMenuItem : _b2, expandedMenuItemKey = _a2.expandedMenuItemKey, onItemMouseDown2 = _a2.onItemMouseDown, onItemClick = _a2.onItemClick, openSubMenu = _a2.openSubMenu, dismissSubMenu = _a2.dismissSubMenu, dismissMenu = _a2.dismissMenu;
      var isChecked = getIsChecked(item);
      var canCheck = isChecked !== null;
      var defaultRole = getMenuItemAriaRole(item);
      var itemHasSubmenu = hasSubmenu(item);
      var itemProps = item.itemProps, ariaLabel = item.ariaLabel, ariaDescription = item.ariaDescription;
      var buttonNativeProperties = getNativeProps(item, buttonProperties);
      delete buttonNativeProperties.disabled;
      var itemRole = item.role || defaultRole;
      if (ariaDescription) {
        this._ariaDescriptionId = getId();
      }
      var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : void 0, buttonNativeProperties["aria-describedby"]);
      var itemButtonProperties = {
        className: classNames2.root,
        onClick: this._onItemClick,
        onKeyDown: itemHasSubmenu ? this._onItemKeyDown : void 0,
        onMouseEnter: this._onItemMouseEnter,
        onMouseLeave: this._onItemMouseLeave,
        onMouseDown: function(ev) {
          return onItemMouseDown2 ? onItemMouseDown2(item, ev) : void 0;
        },
        onMouseMove: this._onItemMouseMove,
        href: item.href,
        title: item.title,
        "aria-label": ariaLabel,
        "aria-describedby": ariaDescribedByIds,
        "aria-haspopup": itemHasSubmenu || void 0,
        "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0,
        "aria-posinset": focusableElementIndex + 1,
        "aria-setsize": totalItemCount,
        "aria-disabled": isItemDisabled(item),
        "aria-checked": (itemRole === "menuitemcheckbox" || itemRole === "menuitemradio") && canCheck ? !!isChecked : void 0,
        "aria-selected": itemRole === "menuitem" && canCheck ? !!isChecked : void 0,
        role: itemRole,
        // eslint-disable-next-line deprecation/deprecation
        style: item.style
      };
      var keytipProps = item.keytipProps;
      if (keytipProps && itemHasSubmenu) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      return React__namespace.createElement(KeytipData, { keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled: isItemDisabled(item) }, function(keytipAttributes) {
        return React__namespace.createElement(
          "button",
          __assign$1({ ref: _this._btn }, buttonNativeProperties, itemButtonProperties, keytipAttributes),
          React__namespace.createElement(ChildrenRenderer, __assign$1({ componentRef: item.componentRef, item, classNames: classNames2, index: index2, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
          _this._renderAriaDescription(ariaDescription, classNames2.screenReaderText)
        );
      });
    };
    return ContextualMenuButton2;
  }(ContextualMenuItemWrapper)
);
var getStyles$F = function(props) {
  var theme = props.theme, getClassNames2 = props.getClassNames, className = props.className;
  if (!theme) {
    throw new Error("Theme is undefined or null.");
  }
  if (getClassNames2) {
    var names = getClassNames2(theme);
    return {
      wrapper: [names.wrapper],
      divider: [names.divider]
    };
  }
  return {
    wrapper: [
      {
        display: "inline-flex",
        height: "100%",
        alignItems: "center"
      },
      className
    ],
    divider: [
      {
        width: 1,
        height: "100%",
        backgroundColor: theme.palette.neutralTertiaryAlt
      }
    ]
  };
};
var getClassNames$I = classNamesFunction();
var VerticalDividerBase = React__namespace.forwardRef(function(props, ref) {
  var styles2 = props.styles, theme = props.theme, deprecatedGetClassNames = props.getClassNames, className = props.className;
  var classNames2 = getClassNames$I(styles2, { theme, getClassNames: deprecatedGetClassNames, className });
  return React__namespace.createElement(
    "span",
    { className: classNames2.wrapper, ref },
    React__namespace.createElement("span", { className: classNames2.divider })
  );
});
VerticalDividerBase.displayName = "VerticalDividerBase";
var VerticalDivider = styled(VerticalDividerBase, getStyles$F, void 0, {
  scope: "VerticalDivider"
});
var TouchIdleDelay$2 = 500;
var ContextualMenuSplitButton = (
  /** @class */
  function(_super) {
    __extends(ContextualMenuSplitButton2, _super);
    function ContextualMenuSplitButton2(props) {
      var _this = _super.call(this, props) || this;
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign$1(__assign$1({}, keytipProps), { hasMenu: true });
      });
      _this._onItemKeyDown = function(ev) {
        var _a2 = _this.props, item = _a2.item, onItemKeyDown = _a2.onItemKeyDown;
        if (ev.which === KeyCodes.enter) {
          _this._executeItemClick(ev);
          ev.preventDefault();
          ev.stopPropagation();
        } else if (onItemKeyDown) {
          onItemKeyDown(item, ev);
        }
      };
      _this._getSubmenuTarget = function() {
        return _this._splitButton;
      };
      _this._renderAriaDescription = function(ariaDescription, className) {
        return ariaDescription ? React__namespace.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
      };
      _this._onItemMouseEnterPrimary = function(ev) {
        var _a2 = _this.props, item = _a2.item, onItemMouseEnter = _a2.onItemMouseEnter;
        if (onItemMouseEnter) {
          onItemMouseEnter(__assign$1(__assign$1({}, item), { subMenuProps: void 0, items: void 0 }), ev, _this._splitButton);
        }
      };
      _this._onItemMouseEnterIcon = function(ev) {
        var _a2 = _this.props, item = _a2.item, onItemMouseEnter = _a2.onItemMouseEnter;
        if (onItemMouseEnter) {
          onItemMouseEnter(item, ev, _this._splitButton);
        }
      };
      _this._onItemMouseMovePrimary = function(ev) {
        var _a2 = _this.props, item = _a2.item, onItemMouseMove = _a2.onItemMouseMove;
        if (onItemMouseMove) {
          onItemMouseMove(__assign$1(__assign$1({}, item), { subMenuProps: void 0, items: void 0 }), ev, _this._splitButton);
        }
      };
      _this._onItemMouseMoveIcon = function(ev) {
        var _a2 = _this.props, item = _a2.item, onItemMouseMove = _a2.onItemMouseMove;
        if (onItemMouseMove) {
          onItemMouseMove(item, ev, _this._splitButton);
        }
      };
      _this._onIconItemClick = function(ev) {
        var _a2 = _this.props, item = _a2.item, onItemClickBase = _a2.onItemClickBase;
        if (onItemClickBase) {
          onItemClickBase(item, ev, _this._splitButton ? _this._splitButton : ev.currentTarget);
        }
      };
      _this._executeItemClick = function(ev) {
        var _a2 = _this.props, item = _a2.item, executeItemClick = _a2.executeItemClick, onItemClick = _a2.onItemClick;
        if (item.disabled || item.isDisabled) {
          return;
        }
        if (_this._processingTouch && onItemClick) {
          return onItemClick(item, ev);
        }
        if (executeItemClick) {
          executeItemClick(item, ev);
        }
      };
      _this._onTouchStart = function(ev) {
        if (_this._splitButton && !("onpointerdown" in _this._splitButton)) {
          _this._handleTouchAndPointerEvent(ev);
        }
      };
      _this._onPointerDown = function(ev) {
        if (ev.pointerType === "touch") {
          _this._handleTouchAndPointerEvent(ev);
          ev.preventDefault();
          ev.stopImmediatePropagation();
        }
      };
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      return _this;
    }
    ContextualMenuSplitButton2.prototype.componentDidMount = function() {
      if (this._splitButton && "onpointerdown" in this._splitButton) {
        this._events.on(this._splitButton, "pointerdown", this._onPointerDown, true);
      }
    };
    ContextualMenuSplitButton2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    ContextualMenuSplitButton2.prototype.render = function() {
      var _this = this;
      var _a2;
      var _b2 = this.props, item = _b2.item, classNames2 = _b2.classNames, index2 = _b2.index, focusableElementIndex = _b2.focusableElementIndex, totalItemCount = _b2.totalItemCount, hasCheckmarks = _b2.hasCheckmarks, hasIcons = _b2.hasIcons, onItemMouseLeave = _b2.onItemMouseLeave, expandedMenuItemKey = _b2.expandedMenuItemKey;
      var itemHasSubmenu = hasSubmenu(item);
      var keytipProps = item.keytipProps;
      if (keytipProps) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      var ariaDescription = item.ariaDescription;
      if (ariaDescription) {
        this._ariaDescriptionId = getId();
      }
      var ariaChecked = (_a2 = getIsChecked(item)) !== null && _a2 !== void 0 ? _a2 : void 0;
      return React__namespace.createElement(KeytipData, { keytipProps, disabled: isItemDisabled(item) }, function(keytipAttributes) {
        return React__namespace.createElement(
          "div",
          { "data-ktp-target": keytipAttributes["data-ktp-target"], ref: function(splitButton) {
            return _this._splitButton = splitButton;
          }, role: getMenuItemAriaRole(item), "aria-label": item.ariaLabel, className: classNames2.splitContainer, "aria-disabled": isItemDisabled(item), "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0, "aria-haspopup": true, "aria-describedby": mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? _this._ariaDescriptionId : void 0, keytipAttributes["aria-describedby"]), "aria-checked": ariaChecked, "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount, onMouseEnter: _this._onItemMouseEnterPrimary, onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(_this, __assign$1(__assign$1({}, item), { subMenuProps: null, items: null })) : void 0, onMouseMove: _this._onItemMouseMovePrimary, onKeyDown: _this._onItemKeyDown, onClick: _this._executeItemClick, onTouchStart: _this._onTouchStart, tabIndex: 0, "data-is-focusable": true, "aria-roledescription": item["aria-roledescription"] },
          _this._renderSplitPrimaryButton(item, classNames2, index2, hasCheckmarks, hasIcons),
          _this._renderSplitDivider(item),
          _this._renderSplitIconButton(item, classNames2, index2, keytipAttributes),
          _this._renderAriaDescription(ariaDescription, classNames2.screenReaderText)
        );
      });
    };
    ContextualMenuSplitButton2.prototype._renderSplitPrimaryButton = function(item, classNames2, index2, hasCheckmarks, hasIcons) {
      var _a2 = this.props, _b2 = _a2.contextualMenuItemAs, ChildrenRenderer = _b2 === void 0 ? ContextualMenuItem : _b2, onItemClick = _a2.onItemClick;
      var itemProps = {
        key: item.key,
        disabled: isItemDisabled(item) || item.primaryDisabled,
        /* eslint-disable deprecation/deprecation */
        name: item.name,
        text: item.text || item.name,
        secondaryText: item.secondaryText,
        /* eslint-enable deprecation/deprecation */
        className: classNames2.splitPrimary,
        canCheck: item.canCheck,
        isChecked: item.isChecked,
        checked: item.checked,
        iconProps: item.iconProps,
        onRenderIcon: item.onRenderIcon,
        data: item.data,
        "data-is-focusable": false
      };
      var itemComponentProps = item.itemProps;
      return React__namespace.createElement(
        "button",
        __assign$1({}, getNativeProps(itemProps, buttonProperties)),
        React__namespace.createElement(ChildrenRenderer, __assign$1({ "data-is-focusable": false, item: itemProps, classNames: classNames2, index: index2, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons }, itemComponentProps))
      );
    };
    ContextualMenuSplitButton2.prototype._renderSplitDivider = function(item) {
      var getDividerClassNames2 = item.getSplitButtonVerticalDividerClassNames || getSplitButtonVerticalDividerClassNames;
      return React__namespace.createElement(VerticalDivider, { getClassNames: getDividerClassNames2 });
    };
    ContextualMenuSplitButton2.prototype._renderSplitIconButton = function(item, classNames2, index2, keytipAttributes) {
      var _a2 = this.props, _b2 = _a2.contextualMenuItemAs, ChildrenRenderer = _b2 === void 0 ? ContextualMenuItem : _b2, onItemMouseLeave = _a2.onItemMouseLeave, onItemMouseDown2 = _a2.onItemMouseDown, openSubMenu = _a2.openSubMenu, dismissSubMenu = _a2.dismissSubMenu, dismissMenu = _a2.dismissMenu;
      var itemProps = {
        onClick: this._onIconItemClick,
        disabled: isItemDisabled(item),
        className: classNames2.splitMenu,
        subMenuProps: item.subMenuProps,
        submenuIconProps: item.submenuIconProps,
        split: true,
        key: item.key
      };
      var buttonProps = __assign$1(__assign$1({}, getNativeProps(itemProps, buttonProperties)), {
        onMouseEnter: this._onItemMouseEnterIcon,
        onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(this, item) : void 0,
        onMouseDown: function(ev) {
          return onItemMouseDown2 ? onItemMouseDown2(item, ev) : void 0;
        },
        onMouseMove: this._onItemMouseMoveIcon,
        "data-is-focusable": false,
        "data-ktp-execute-target": keytipAttributes["data-ktp-execute-target"],
        "aria-hidden": true
      });
      var itemComponentProps = item.itemProps;
      return React__namespace.createElement(
        "button",
        __assign$1({}, buttonProps),
        React__namespace.createElement(ChildrenRenderer, __assign$1({ componentRef: item.componentRef, item: itemProps, classNames: classNames2, index: index2, hasIcons: false, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: this._getSubmenuTarget }, itemComponentProps))
      );
    };
    ContextualMenuSplitButton2.prototype._handleTouchAndPointerEvent = function(ev) {
      var _this = this;
      var onTap = this.props.onTap;
      if (onTap) {
        onTap(ev);
      }
      if (this._lastTouchTimeoutId) {
        this._async.clearTimeout(this._lastTouchTimeoutId);
        this._lastTouchTimeoutId = void 0;
      }
      this._processingTouch = true;
      this._lastTouchTimeoutId = this._async.setTimeout(function() {
        _this._processingTouch = false;
        _this._lastTouchTimeoutId = void 0;
      }, TouchIdleDelay$2);
    };
    return ContextualMenuSplitButton2;
  }(ContextualMenuItemWrapper)
);
var BaseDecorator = (
  /** @class */
  function(_super) {
    __extends(BaseDecorator2, _super);
    function BaseDecorator2(props) {
      var _this = _super.call(this, props) || this;
      _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
      return _this;
    }
    BaseDecorator2.prototype._updateComposedComponentRef = function(composedComponentInstance) {
      this._composedComponentInstance = composedComponentInstance;
      if (composedComponentInstance) {
        this._hoisted = hoistMethods(this, composedComponentInstance);
      } else if (this._hoisted) {
        unhoistMethods(this, this._hoisted);
      }
    };
    return BaseDecorator2;
  }(React__namespace.Component)
);
var ResponsiveMode;
(function(ResponsiveMode2) {
  ResponsiveMode2[ResponsiveMode2["small"] = 0] = "small";
  ResponsiveMode2[ResponsiveMode2["medium"] = 1] = "medium";
  ResponsiveMode2[ResponsiveMode2["large"] = 2] = "large";
  ResponsiveMode2[ResponsiveMode2["xLarge"] = 3] = "xLarge";
  ResponsiveMode2[ResponsiveMode2["xxLarge"] = 4] = "xxLarge";
  ResponsiveMode2[ResponsiveMode2["xxxLarge"] = 5] = "xxxLarge";
  ResponsiveMode2[ResponsiveMode2["unknown"] = 999] = "unknown";
})(ResponsiveMode || (ResponsiveMode = {}));
var RESPONSIVE_MAX_CONSTRAINT = [479, 639, 1023, 1365, 1919, 99999999];
var _lastMode;
function getInitialResponsiveMode() {
  var _a2;
  return (_a2 = _lastMode) !== null && _a2 !== void 0 ? _a2 : ResponsiveMode.large;
}
function withResponsiveMode(ComposedComponent) {
  var _a2;
  var resultClass = (_a2 = /** @class */
  function(_super) {
    __extends(WithResponsiveMode, _super);
    function WithResponsiveMode(props) {
      var _this = _super.call(this, props) || this;
      _this._onResize = function() {
        var responsiveMode = getResponsiveMode(_this.context.window);
        if (responsiveMode !== _this.state.responsiveMode) {
          _this.setState({
            responsiveMode
          });
        }
      };
      _this._events = new EventGroup(_this);
      _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
      _this.state = {
        responsiveMode: getInitialResponsiveMode()
      };
      return _this;
    }
    WithResponsiveMode.prototype.componentDidMount = function() {
      this._events.on(this.context.window, "resize", this._onResize);
      this._onResize();
    };
    WithResponsiveMode.prototype.componentWillUnmount = function() {
      this._events.dispose();
    };
    WithResponsiveMode.prototype.render = function() {
      var responsiveMode = this.state.responsiveMode;
      return responsiveMode === ResponsiveMode.unknown ? null : React__namespace.createElement(ComposedComponent, __assign$1({ ref: this._updateComposedComponentRef, responsiveMode }, this.props));
    };
    return WithResponsiveMode;
  }(BaseDecorator), _a2.contextType = WindowContext, _a2);
  return hoistStatics(ComposedComponent, resultClass);
}
function getWidthOfCurrentWindow(currentWindow) {
  try {
    return currentWindow.document.documentElement.clientWidth;
  } catch (e) {
    return currentWindow.innerWidth;
  }
}
function getResponsiveMode(currentWindow) {
  var responsiveMode = ResponsiveMode.small;
  if (currentWindow) {
    try {
      while (getWidthOfCurrentWindow(currentWindow) > RESPONSIVE_MAX_CONSTRAINT[responsiveMode]) {
        responsiveMode++;
      }
    } catch (e) {
      responsiveMode = getInitialResponsiveMode();
    }
    _lastMode = responsiveMode;
  } else {
    {
      throw new Error("Content was rendered in a server environment without providing a default responsive mode. Call setResponsiveMode to define what the responsive mode is.");
    }
  }
  return responsiveMode;
}
var useResponsiveMode = function(elementRef, overrideResponsiveMode) {
  var _a2 = React__namespace.useState(getInitialResponsiveMode()), lastResponsiveMode = _a2[0], setLastResponsiveMode = _a2[1];
  var onResize = React__namespace.useCallback(function() {
    var newResponsiveMode = getResponsiveMode(getWindow$1(elementRef.current));
    if (lastResponsiveMode !== newResponsiveMode) {
      setLastResponsiveMode(newResponsiveMode);
    }
  }, [elementRef, lastResponsiveMode]);
  var win2 = useWindow();
  useOnEvent(win2, "resize", onResize);
  React__namespace.useEffect(function() {
    if (overrideResponsiveMode === void 0) {
      onResize();
    }
  }, [overrideResponsiveMode]);
  return overrideResponsiveMode !== null && overrideResponsiveMode !== void 0 ? overrideResponsiveMode : lastResponsiveMode;
};
var MenuContext = React__namespace.createContext({});
var getClassNames$H = classNamesFunction();
var getContextualMenuItemClassNames = classNamesFunction();
var DEFAULT_PROPS$7 = {
  items: [],
  shouldFocusOnMount: true,
  gapSpace: 0,
  directionalHint: DirectionalHint.bottomAutoEdge,
  beakWidth: 16
};
function getSubmenuItems(item, options2) {
  var target = options2 === null || options2 === void 0 ? void 0 : options2.target;
  var items = item.subMenuProps ? item.subMenuProps.items : item.items;
  if (items) {
    var overrideItems = [];
    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
      var subItem = items_1[_i];
      if (subItem.preferMenuTargetAsEventTarget) {
        var onClick = subItem.onClick, contextItem = __rest$1(subItem, ["onClick"]);
        overrideItems.push(__assign$1(__assign$1({}, contextItem), { onClick: getOnClickWithOverrideTarget(onClick, target) }));
      } else {
        overrideItems.push(subItem);
      }
    }
    return overrideItems;
  }
}
function canAnyMenuItemsCheck(items) {
  return items.some(function(item) {
    if (item.canCheck) {
      return true;
    }
    if (item.sectionProps && item.sectionProps.items.some(function(submenuItem) {
      return submenuItem.canCheck === true;
    })) {
      return true;
    }
    return false;
  });
}
var NavigationIdleDelay = 250;
var COMPONENT_NAME$b = "ContextualMenu";
var _getMenuItemStylesFunction = memoizeFunction(function() {
  var styles2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    styles2[_i] = arguments[_i];
  }
  return function(styleProps) {
    return concatStyleSetsWithProps.apply(void 0, __spreadArray([styleProps, getItemStyles], styles2));
  };
});
function useVisibility(props, targetWindow) {
  var _a2 = props.hidden, hidden = _a2 === void 0 ? false : _a2, onMenuDismissed = props.onMenuDismissed, onMenuOpened = props.onMenuOpened;
  var previousHidden = usePrevious(hidden);
  var onMenuOpenedRef = React__namespace.useRef(onMenuOpened);
  var onMenuClosedRef = React__namespace.useRef(onMenuDismissed);
  var propsRef = React__namespace.useRef(props);
  onMenuOpenedRef.current = onMenuOpened;
  onMenuClosedRef.current = onMenuDismissed;
  propsRef.current = props;
  React__namespace.useEffect(function() {
    var _a3, _b2;
    if (hidden && previousHidden === false) {
      (_a3 = onMenuClosedRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(onMenuClosedRef, propsRef.current);
    } else if (!hidden && previousHidden !== false) {
      (_b2 = onMenuOpenedRef.current) === null || _b2 === void 0 ? void 0 : _b2.call(onMenuOpenedRef, propsRef.current);
    }
  }, [hidden, previousHidden]);
  React__namespace.useEffect(function() {
    return function() {
      var _a3;
      return (_a3 = onMenuClosedRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(onMenuClosedRef, propsRef.current);
    };
  }, []);
}
function useSubMenuState(_a2, dismiss) {
  var hidden = _a2.hidden, items = _a2.items, theme = _a2.theme, className = _a2.className, id = _a2.id, menuTarget = _a2.target;
  var _b2 = React__namespace.useState(), expandedMenuItemKey = _b2[0], setExpandedMenuItemKey = _b2[1];
  var _c2 = React__namespace.useState(), submenuTarget = _c2[0], setSubmenuTarget = _c2[1];
  var _d2 = React__namespace.useState(), shouldFocusOnContainer = _d2[0], setShouldFocusOnContainer = _d2[1];
  var subMenuId = useId(COMPONENT_NAME$b, id);
  var closeSubMenu = React__namespace.useCallback(function() {
    setShouldFocusOnContainer(void 0);
    setExpandedMenuItemKey(void 0);
    setSubmenuTarget(void 0);
  }, []);
  var openSubMenu = React__namespace.useCallback(function(_a3, target, focusContainer) {
    var submenuItemKey = _a3.key;
    if (expandedMenuItemKey === submenuItemKey) {
      return;
    }
    target.focus();
    setShouldFocusOnContainer(focusContainer);
    setExpandedMenuItemKey(submenuItemKey);
    setSubmenuTarget(target);
  }, [expandedMenuItemKey]);
  React__namespace.useEffect(function() {
    if (hidden) {
      closeSubMenu();
    }
  }, [hidden, closeSubMenu]);
  var onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);
  var getSubmenuProps = function() {
    var item = findItemByKeyFromItems(expandedMenuItemKey, items);
    var submenuProps = null;
    if (item) {
      submenuProps = {
        items: getSubmenuItems(item, { target: menuTarget }),
        target: submenuTarget,
        onDismiss: onSubMenuDismiss,
        isSubMenu: true,
        id: subMenuId,
        shouldFocusOnMount: true,
        shouldFocusOnContainer,
        directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,
        className,
        gapSpace: 0,
        isBeakVisible: false
      };
      if (item.subMenuProps) {
        assign$2(submenuProps, item.subMenuProps);
      }
      if (item.preferMenuTargetAsEventTarget) {
        var onItemClick = item.onItemClick;
        submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);
      }
    }
    return submenuProps;
  };
  return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss];
}
function useShouldUpdateFocusOnMouseMove(_a2) {
  var delayUpdateFocusOnHover = _a2.delayUpdateFocusOnHover, hidden = _a2.hidden;
  var shouldUpdateFocusOnMouseEvent = React__namespace.useRef(!delayUpdateFocusOnHover);
  var gotMouseMove = React__namespace.useRef(false);
  React__namespace.useEffect(function() {
    shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;
    gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;
  }, [delayUpdateFocusOnHover, hidden]);
  var onMenuFocusCapture = React__namespace.useCallback(function() {
    if (delayUpdateFocusOnHover) {
      shouldUpdateFocusOnMouseEvent.current = false;
    }
  }, [delayUpdateFocusOnHover]);
  return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture];
}
function usePreviousActiveElement(_a2, targetWindow, hostElement) {
  var hidden = _a2.hidden, onRestoreFocus = _a2.onRestoreFocus;
  var previousActiveElement = React__namespace.useRef();
  var tryFocusPreviousActiveElement = React__namespace.useCallback(function(options2) {
    var _a3, _b2;
    if (onRestoreFocus) {
      onRestoreFocus(options2);
    } else if (options2 === null || options2 === void 0 ? void 0 : options2.documentContainsFocus) {
      (_b2 = (_a3 = previousActiveElement.current) === null || _a3 === void 0 ? void 0 : _a3.focus) === null || _b2 === void 0 ? void 0 : _b2.call(_a3);
    }
  }, [onRestoreFocus]);
  useIsomorphicLayoutEffect(function() {
    var _a3, _b2;
    if (!hidden) {
      var newElement = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement;
      if (!((_a3 = hostElement.current) === null || _a3 === void 0 ? void 0 : _a3.contains(newElement)) && newElement.tagName !== "BODY") {
        previousActiveElement.current = newElement;
      }
    } else if (previousActiveElement.current) {
      tryFocusPreviousActiveElement({
        originalElement: previousActiveElement.current,
        containsFocus: true,
        documentContainsFocus: ((_b2 = getDocument()) === null || _b2 === void 0 ? void 0 : _b2.hasFocus()) || false
      });
      previousActiveElement.current = void 0;
    }
  }, [hidden, targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement, tryFocusPreviousActiveElement, hostElement]);
  return [tryFocusPreviousActiveElement];
}
function useKeyHandlers(_a2, dismiss, hostElement, openSubMenu) {
  var theme = _a2.theme, isSubMenu = _a2.isSubMenu, _b2 = _a2.focusZoneProps, _c2 = _b2 === void 0 ? {} : _b2, checkForNoWrap = _c2.checkForNoWrap, _d2 = _c2.direction, focusZoneDirection = _d2 === void 0 ? FocusZoneDirection.vertical : _d2;
  var lastKeyDownWasAltOrMeta = React__namespace.useRef();
  var keyHandler = function(ev, shouldHandleKey, dismissAllMenus) {
    var handled = false;
    if (shouldHandleKey(ev)) {
      dismiss(ev, dismissAllMenus);
      ev.preventDefault();
      ev.stopPropagation();
      handled = true;
    }
    return handled;
  };
  var shouldCloseSubMenu = function(ev) {
    var submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left;
    if (ev.which !== submenuCloseKey || !isSubMenu) {
      return false;
    }
    return !!(focusZoneDirection === FocusZoneDirection.vertical || checkForNoWrap && !shouldWrapFocus(ev.target, "data-no-horizontal-wrap"));
  };
  var shouldHandleKeyDown = function(ev) {
    return (
      // eslint-disable-next-line deprecation/deprecation
      ev.which === KeyCodes.escape || shouldCloseSubMenu(ev) || // eslint-disable-next-line deprecation/deprecation
      ev.which === KeyCodes.up && (ev.altKey || ev.metaKey)
    );
  };
  var onKeyDown = function(ev) {
    lastKeyDownWasAltOrMeta.current = isAltOrMeta$1(ev);
    var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());
    return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);
  };
  var shouldHandleKeyUp = function(ev) {
    var keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta$1(ev);
    lastKeyDownWasAltOrMeta.current = false;
    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());
  };
  var onKeyUp = function(ev) {
    return keyHandler(
      ev,
      shouldHandleKeyUp,
      true
      /* dismissAllMenus */
    );
  };
  var onMenuKeyDown = function(ev) {
    var handled = onKeyDown(ev);
    if (handled || !hostElement.current) {
      return;
    }
    var hasModifier = !!(ev.altKey || ev.metaKey);
    var isUp = ev.which === KeyCodes.up;
    var isDown = ev.which === KeyCodes.down;
    if (!hasModifier && (isUp || isDown)) {
      var elementToFocus = isUp ? getLastFocusable(hostElement.current, hostElement.current.lastChild, true) : getFirstFocusable(hostElement.current, hostElement.current.firstChild, true);
      if (elementToFocus) {
        elementToFocus.focus();
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  };
  var onItemKeyDown = function(item, ev) {
    var openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;
    if (!item.disabled && // eslint-disable-next-line deprecation/deprecation
    (ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {
      openSubMenu(item, ev.currentTarget);
      ev.preventDefault();
    }
  };
  return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown];
}
function useScrollHandler(asyncTracker) {
  var isScrollIdle = React__namespace.useRef(true);
  var scrollIdleTimeoutId = React__namespace.useRef();
  var onScroll = function() {
    if (!isScrollIdle.current && scrollIdleTimeoutId.current !== void 0) {
      asyncTracker.clearTimeout(scrollIdleTimeoutId.current);
      scrollIdleTimeoutId.current = void 0;
    } else {
      isScrollIdle.current = false;
    }
    scrollIdleTimeoutId.current = asyncTracker.setTimeout(function() {
      isScrollIdle.current = true;
    }, NavigationIdleDelay);
  };
  return [onScroll, isScrollIdle];
}
function useOnSubmenuDismiss(dismiss, closeSubMenu) {
  var isMountedRef = React__namespace.useRef(false);
  React__namespace.useEffect(function() {
    isMountedRef.current = true;
    return function() {
      isMountedRef.current = false;
    };
  }, []);
  var onSubMenuDismiss = function(ev, dismissAll) {
    if (dismissAll) {
      dismiss(ev, dismissAll);
    } else if (isMountedRef.current) {
      closeSubMenu();
    }
  };
  return onSubMenuDismiss;
}
function useSubmenuEnterTimer(_a2, asyncTracker) {
  var _b2 = _a2.subMenuHoverDelay, subMenuHoverDelay = _b2 === void 0 ? NavigationIdleDelay : _b2;
  var enterTimerRef = React__namespace.useRef(void 0);
  var cancelSubMenuTimer = function() {
    if (enterTimerRef.current !== void 0) {
      asyncTracker.clearTimeout(enterTimerRef.current);
      enterTimerRef.current = void 0;
    }
  };
  var startSubmenuTimer = function(onTimerExpired) {
    enterTimerRef.current = asyncTracker.setTimeout(function() {
      onTimerExpired();
      cancelSubMenuTimer();
    }, subMenuHoverDelay);
  };
  return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef];
}
function useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss) {
  var menuTarget = props.target;
  var onItemMouseEnterBase = function(item, ev, target) {
    if (shouldUpdateFocusOnMouseEvent.current) {
      gotMouseMove.current = true;
    }
    if (shouldIgnoreMouseEvent()) {
      return;
    }
    updateFocusOnMouseEvent(item, ev, target);
  };
  var onItemMouseMoveBase = function(item, ev, target) {
    var targetElement = ev.currentTarget;
    if (shouldUpdateFocusOnMouseEvent.current) {
      gotMouseMove.current = true;
    } else {
      return;
    }
    if (!isScrollIdle.current || subMenuEntryTimer.current !== void 0 || targetElement === (targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement)) {
      return;
    }
    updateFocusOnMouseEvent(item, ev, target);
  };
  var shouldIgnoreMouseEvent = function() {
    return !isScrollIdle.current || !gotMouseMove.current;
  };
  var onMouseItemLeave = function(item, ev) {
    var _a2;
    if (shouldIgnoreMouseEvent()) {
      return;
    }
    cancelSubMenuTimer();
    if (expandedMenuItemKey !== void 0) {
      return;
    }
    if (hostElement.current.setActive) {
      try {
        hostElement.current.setActive();
      } catch (e) {
      }
    } else {
      (_a2 = hostElement.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    }
  };
  var updateFocusOnMouseEvent = function(item, ev, target) {
    var targetElement = target ? target : ev.currentTarget;
    if (item.key === expandedMenuItemKey) {
      return;
    }
    cancelSubMenuTimer();
    if (expandedMenuItemKey === void 0) {
      targetElement.focus();
    }
    if (hasSubmenu(item)) {
      ev.stopPropagation();
      startSubmenuTimer(function() {
        targetElement.focus();
        openSubMenu(item, targetElement, true);
      });
    } else {
      startSubmenuTimer(function() {
        onSubMenuDismiss(ev);
        targetElement.focus();
      });
    }
  };
  var onItemClick = function(item, ev) {
    onItemClickBase(item, ev, ev.currentTarget);
  };
  var onItemClickBase = function(item, ev, target) {
    var items = getSubmenuItems(item, { target: menuTarget });
    cancelSubMenuTimer();
    if (!hasSubmenu(item) && (!items || !items.length)) {
      executeItemClick(item, ev);
    } else {
      if (item.key !== expandedMenuItemKey) {
        var shouldFocusOnContainer = typeof props.shouldFocusOnContainer === "boolean" ? props.shouldFocusOnContainer : ev.nativeEvent.pointerType === "mouse";
        openSubMenu(item, target, shouldFocusOnContainer);
      }
    }
    ev.stopPropagation();
    ev.preventDefault();
  };
  var onAnchorClick = function(item, ev) {
    executeItemClick(item, ev);
    ev.stopPropagation();
  };
  var executeItemClick = function(item, ev) {
    if (item.disabled || item.isDisabled) {
      return;
    }
    if (item.preferMenuTargetAsEventTarget) {
      overrideTarget(ev, menuTarget);
    }
    var shouldDismiss = false;
    if (item.onClick) {
      shouldDismiss = !!item.onClick(ev, item);
    } else if (props.onItemClick) {
      shouldDismiss = !!props.onItemClick(ev, item);
    }
    if (shouldDismiss || !ev.defaultPrevented) {
      dismiss(ev, true);
    }
  };
  return [
    onItemMouseEnterBase,
    onItemMouseMoveBase,
    onMouseItemLeave,
    onItemClick,
    onAnchorClick,
    executeItemClick,
    onItemClickBase
  ];
}
var ContextualMenuBase = React__namespace.memo(React__namespace.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var _a2;
  var _b2 = getPropsWithDefaults(DEFAULT_PROPS$7, propsWithoutDefaults);
  _b2.ref;
  var props = __rest$1(_b2, ["ref"]);
  var hostElement = React__namespace.useRef(null);
  var asyncTracker = useAsync();
  var menuId = useId(COMPONENT_NAME$b, props.id);
  useWarnings({
    name: COMPONENT_NAME$b,
    props,
    deprecations: {
      getMenuClassNames: "styles"
    }
  });
  var dismiss = function(ev, dismissAll) {
    var _a3;
    return (_a3 = props.onDismiss) === null || _a3 === void 0 ? void 0 : _a3.call(props, ev, dismissAll);
  };
  var _c2 = useTarget(props.target, hostElement), targetRef = _c2[0], targetWindow = _c2[1];
  var tryFocusPreviousActiveElement = usePreviousActiveElement(props, targetWindow, hostElement)[0];
  var _d2 = useSubMenuState(props, dismiss), expandedMenuItemKey = _d2[0], openSubMenu = _d2[1], getSubmenuProps = _d2[2], onSubMenuDismiss = _d2[3];
  var _e2 = useShouldUpdateFocusOnMouseMove(props), shouldUpdateFocusOnMouseEvent = _e2[0], gotMouseMove = _e2[1], onMenuFocusCapture = _e2[2];
  var _f = useScrollHandler(asyncTracker), onScroll = _f[0], isScrollIdle = _f[1];
  var _g = useSubmenuEnterTimer(props, asyncTracker), cancelSubMenuTimer = _g[0], startSubmenuTimer = _g[1], subMenuEntryTimer = _g[2];
  var responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);
  useVisibility(props);
  var _h = useKeyHandlers(props, dismiss, hostElement, openSubMenu), onKeyDown = _h[0], onKeyUp = _h[1], onMenuKeyDown = _h[2], onItemKeyDown = _h[3];
  var _j = useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss), onItemMouseEnterBase = _j[0], onItemMouseMoveBase = _j[1], onMouseItemLeave = _j[2], onItemClick = _j[3], onAnchorClick = _j[4], executeItemClick = _j[5], onItemClickBase = _j[6];
  var onDefaultRenderMenuList = function(menuListProps, menuClassNames, defaultRender) {
    var indexCorrection = 0;
    var items2 = menuListProps.items, totalItemCount = menuListProps.totalItemCount, hasCheckmarks2 = menuListProps.hasCheckmarks, hasIcons2 = menuListProps.hasIcons;
    return React__namespace.createElement("ul", { className: menuClassNames.list, onKeyDown, onKeyUp, role: "presentation" }, items2.map(function(item2, index2) {
      var menuItem = renderMenuItem(item2, index2, indexCorrection, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames);
      if (item2.itemType !== ContextualMenuItemType.Divider && item2.itemType !== ContextualMenuItemType.Header) {
        var indexIncrease = item2.customOnRenderListLength ? item2.customOnRenderListLength : 1;
        indexCorrection += indexIncrease;
      }
      return menuItem;
    }));
  };
  var renderFocusZone = function(children, adjustedFocusZoneProps2) {
    var _a3 = props.focusZoneAs, ChildrenRenderer = _a3 === void 0 ? FocusZone : _a3;
    return React__namespace.createElement(ChildrenRenderer, __assign$1({}, adjustedFocusZoneProps2), children);
  };
  var renderMenuItem = function(item2, index2, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames) {
    var _a3;
    var renderedItems = [];
    var iconProps = item2.iconProps || { iconName: "None" };
    var getItemClassNames2 = item2.getItemClassNames, itemProps = item2.itemProps;
    var styles3 = itemProps ? itemProps.styles : void 0;
    var dividerClassName = item2.itemType === ContextualMenuItemType.Divider ? item2.className : void 0;
    var subMenuIconClassName = item2.submenuIconProps ? item2.submenuIconProps.className : "";
    var itemClassNames;
    if (getItemClassNames2) {
      itemClassNames = getItemClassNames2(props.theme, isItemDisabled(item2), expandedMenuItemKey === item2.key, !!getIsChecked(item2), !!item2.href, iconProps.iconName !== "None", item2.className, dividerClassName, iconProps.className, subMenuIconClassName, item2.primaryDisabled);
    } else {
      var itemStyleProps = {
        theme: props.theme,
        disabled: isItemDisabled(item2),
        expanded: expandedMenuItemKey === item2.key,
        checked: !!getIsChecked(item2),
        isAnchorLink: !!item2.href,
        knownIcon: iconProps.iconName !== "None",
        itemClassName: item2.className,
        dividerClassName,
        iconClassName: iconProps.className,
        subMenuClassName: subMenuIconClassName,
        primaryDisabled: item2.primaryDisabled
      };
      itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a3 = menuClassNames.subComponentStyles) === null || _a3 === void 0 ? void 0 : _a3.menuItem, styles3), itemStyleProps);
    }
    if (item2.text === "-" || item2.name === "-") {
      item2.itemType = ContextualMenuItemType.Divider;
    }
    switch (item2.itemType) {
      case ContextualMenuItemType.Divider:
        renderedItems.push(renderSeparator(index2, itemClassNames));
        break;
      case ContextualMenuItemType.Header:
        renderedItems.push(renderSeparator(index2, itemClassNames));
        var headerItem = renderHeaderMenuItem(item2, itemClassNames, menuClassNames, index2, hasCheckmarks2, hasIcons2);
        renderedItems.push(renderListItem(headerItem, item2.key || index2, itemClassNames, item2.title));
        break;
      case ContextualMenuItemType.Section:
        renderedItems.push(renderSectionItem(item2, itemClassNames, menuClassNames, index2, hasCheckmarks2, hasIcons2));
        break;
      default:
        var defaultRenderNormalItem = function() {
          return renderNormalItem(item2, itemClassNames, index2, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2);
        };
        var menuItem = props.onRenderContextualMenuItem ? props.onRenderContextualMenuItem(item2, defaultRenderNormalItem) : defaultRenderNormalItem();
        renderedItems.push(renderListItem(menuItem, item2.key || index2, itemClassNames, item2.title));
        break;
    }
    return React__namespace.createElement(React__namespace.Fragment, { key: item2.key }, renderedItems);
  };
  var defaultMenuItemRenderer = function(item2, menuClassNames) {
    var index2 = item2.index, focusableElementIndex = item2.focusableElementIndex, totalItemCount = item2.totalItemCount, hasCheckmarks2 = item2.hasCheckmarks, hasIcons2 = item2.hasIcons;
    return renderMenuItem(item2, index2, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames);
  };
  var renderSectionItem = function(sectionItem, itemClassNames, menuClassNames, index2, hasCheckmarks2, hasIcons2) {
    var sectionProps = sectionItem.sectionProps;
    if (!sectionProps) {
      return;
    }
    var headerItem;
    var groupProps;
    if (sectionProps.title) {
      var headerContextualMenuItem = void 0;
      var ariaLabelledby = "";
      if (typeof sectionProps.title === "string") {
        var id_1 = menuId + sectionProps.title.replace(/\s/g, "");
        headerContextualMenuItem = {
          key: "section-" + sectionProps.title + "-title",
          itemType: ContextualMenuItemType.Header,
          text: sectionProps.title,
          id: id_1
        };
        ariaLabelledby = id_1;
      } else {
        var id_2 = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\s/g, "");
        headerContextualMenuItem = __assign$1(__assign$1({}, sectionProps.title), { id: id_2 });
        ariaLabelledby = id_2;
      }
      if (headerContextualMenuItem) {
        groupProps = {
          role: "group",
          "aria-labelledby": ariaLabelledby
        };
        headerItem = renderHeaderMenuItem(headerContextualMenuItem, itemClassNames, menuClassNames, index2, hasCheckmarks2, hasIcons2);
      }
    }
    if (sectionProps.items && sectionProps.items.length > 0) {
      return React__namespace.createElement(
        "li",
        { role: "presentation", key: sectionProps.key || sectionItem.key || "section-" + index2 },
        React__namespace.createElement(
          "div",
          __assign$1({}, groupProps),
          React__namespace.createElement(
            "ul",
            { className: menuClassNames.list, role: "presentation" },
            sectionProps.topDivider && renderSeparator(index2, itemClassNames, true, true),
            headerItem && renderListItem(headerItem, sectionItem.key || index2, itemClassNames, sectionItem.title),
            sectionProps.items.map(function(contextualMenuItem, itemsIndex) {
              return renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks2, hasIcons2, menuClassNames);
            }),
            sectionProps.bottomDivider && renderSeparator(index2, itemClassNames, false, true)
          )
        )
      );
    }
  };
  var renderListItem = function(content, key, classNames3, title2) {
    return React__namespace.createElement("li", { role: "presentation", title: title2, key, className: classNames3.item }, content);
  };
  var renderSeparator = function(index2, classNames3, top, fromSection) {
    if (fromSection || index2 > 0) {
      return React__namespace.createElement("li", { role: "separator", key: "separator-" + index2 + (top === void 0 ? "" : top ? "-top" : "-bottom"), className: classNames3.divider, "aria-hidden": "true" });
    }
    return null;
  };
  var renderNormalItem = function(item2, classNames3, index2, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2) {
    if (item2.onRender) {
      return item2.onRender(__assign$1({ "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount }, item2), dismiss);
    }
    var contextualMenuItemAs = props.contextualMenuItemAs;
    var commonProps = {
      item: item2,
      classNames: classNames3,
      index: index2,
      focusableElementIndex,
      totalItemCount,
      hasCheckmarks: hasCheckmarks2,
      hasIcons: hasIcons2,
      contextualMenuItemAs,
      onItemMouseEnter: onItemMouseEnterBase,
      onItemMouseLeave: onMouseItemLeave,
      onItemMouseMove: onItemMouseMoveBase,
      onItemMouseDown,
      executeItemClick,
      onItemKeyDown,
      expandedMenuItemKey,
      openSubMenu,
      dismissSubMenu: onSubMenuDismiss,
      dismissMenu: dismiss
    };
    if (item2.href) {
      return React__namespace.createElement(ContextualMenuAnchor, __assign$1({}, commonProps, { onItemClick: onAnchorClick }));
    }
    if (item2.split && hasSubmenu(item2)) {
      return React__namespace.createElement(ContextualMenuSplitButton, __assign$1({}, commonProps, { onItemClick, onItemClickBase, onTap: cancelSubMenuTimer }));
    }
    return React__namespace.createElement(ContextualMenuButton, __assign$1({}, commonProps, { onItemClick, onItemClickBase }));
  };
  var renderHeaderMenuItem = function(item2, itemClassNames, menuClassNames, index2, hasCheckmarks2, hasIcons2) {
    var _a3 = props.contextualMenuItemAs, ChildrenRenderer = _a3 === void 0 ? ContextualMenuItem : _a3;
    var itemProps = item2.itemProps, id2 = item2.id;
    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);
    return (
      // eslint-disable-next-line deprecation/deprecation
      React__namespace.createElement(
        "div",
        __assign$1({ id: id2, className: menuClassNames.header }, divHtmlProperties, { style: item2.style }),
        React__namespace.createElement(ChildrenRenderer, __assign$1({ item: item2, classNames: itemClassNames, index: index2, onCheckmarkClick: hasCheckmarks2 ? onItemClick : void 0, hasIcons: hasIcons2 }, itemProps))
      )
    );
  };
  var isBeakVisible = props.isBeakVisible;
  var items = props.items, labelElementId = props.labelElementId, id = props.id, className = props.className, beakWidth = props.beakWidth, directionalHint = props.directionalHint, directionalHintForRTL = props.directionalHintForRTL, alignTargetEdge = props.alignTargetEdge, gapSpace = props.gapSpace, coverTarget = props.coverTarget, ariaLabel = props.ariaLabel, doNotLayer = props.doNotLayer, target = props.target, bounds = props.bounds, useTargetWidth = props.useTargetWidth, useTargetAsMinWidth = props.useTargetAsMinWidth, directionalHintFixed = props.directionalHintFixed, shouldFocusOnMount = props.shouldFocusOnMount, shouldFocusOnContainer = props.shouldFocusOnContainer, title = props.title, styles2 = props.styles, theme = props.theme, calloutProps = props.calloutProps, _k = props.onRenderSubMenu, onRenderSubMenu2 = _k === void 0 ? onDefaultRenderSubMenu : _k, _l = props.onRenderMenuList, onRenderMenuList = _l === void 0 ? function(menuListProps, defaultRender) {
    return onDefaultRenderMenuList(menuListProps, classNames2);
  } : _l, focusZoneProps = props.focusZoneProps, getMenuClassNames = props.getMenuClassNames;
  var classNames2 = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames$H(styles2, {
    theme,
    className
  });
  var hasIcons = itemsHaveIcons(items);
  function itemsHaveIcons(contextualMenuItems) {
    for (var _i2 = 0, contextualMenuItems_1 = contextualMenuItems; _i2 < contextualMenuItems_1.length; _i2++) {
      var item2 = contextualMenuItems_1[_i2];
      if (item2.iconProps) {
        return true;
      }
      if (item2.itemType === ContextualMenuItemType.Section && item2.sectionProps && itemsHaveIcons(item2.sectionProps.items)) {
        return true;
      }
    }
    return false;
  }
  var adjustedFocusZoneProps = __assign$1(__assign$1({ direction: FocusZoneDirection.vertical, handleTabKey: FocusZoneTabbableElements.all, isCircularNavigation: true }, focusZoneProps), { className: css$3(classNames2.root, (_a2 = props.focusZoneProps) === null || _a2 === void 0 ? void 0 : _a2.className) });
  var hasCheckmarks = canAnyMenuItemsCheck(items);
  var submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;
  isBeakVisible = isBeakVisible === void 0 ? responsiveMode <= ResponsiveMode.medium : isBeakVisible;
  var contextMenuStyle;
  var targetAsHtmlElement = targetRef.current;
  if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {
    var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();
    var targetWidth = targetBoundingRect.width - 2;
    if (useTargetWidth) {
      contextMenuStyle = {
        width: targetWidth
      };
    } else if (useTargetAsMinWidth) {
      contextMenuStyle = {
        minWidth: targetWidth
      };
    }
  }
  if (items && items.length > 0) {
    var totalItemCount_1 = 0;
    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
      var item = items_2[_i];
      if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
        var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
        totalItemCount_1 += itemCount;
      }
    }
    var calloutStyles_1 = classNames2.subComponentStyles ? classNames2.subComponentStyles.callout : void 0;
    return React__namespace.createElement(MenuContext.Consumer, null, function(menuContext) {
      return React__namespace.createElement(
        Callout,
        __assign$1({ styles: calloutStyles_1, onRestoreFocus: tryFocusPreviousActiveElement }, calloutProps, { target: target || menuContext.target, isBeakVisible, beakWidth, directionalHint, directionalHintForRTL, gapSpace, coverTarget, doNotLayer, className: css$3("ms-ContextualMenu-Callout", calloutProps && calloutProps.className), setInitialFocus: shouldFocusOnMount, onDismiss: props.onDismiss || menuContext.onDismiss, onScroll, bounds, directionalHintFixed, alignTargetEdge, hidden: props.hidden || menuContext.hidden, ref: forwardedRef }),
        React__namespace.createElement(
          "div",
          { style: contextMenuStyle, ref: hostElement, id, className: classNames2.container, tabIndex: shouldFocusOnContainer ? 0 : -1, onKeyDown: onMenuKeyDown, onKeyUp, onFocusCapture: onMenuFocusCapture, "aria-label": ariaLabel, "aria-labelledby": labelElementId, role: "menu" },
          title && React__namespace.createElement(
            "div",
            { className: classNames2.title },
            " ",
            title,
            " "
          ),
          items && items.length ? renderFocusZone(onRenderMenuList({
            ariaLabel,
            items,
            totalItemCount: totalItemCount_1,
            hasCheckmarks,
            hasIcons,
            defaultMenuItemRenderer: function(item2) {
              return defaultMenuItemRenderer(item2, classNames2);
            },
            labelElementId
          }, function(menuListProps, defaultRender) {
            return onDefaultRenderMenuList(menuListProps, classNames2);
          }), adjustedFocusZoneProps) : null,
          submenuProps && onRenderSubMenu2(submenuProps, onDefaultRenderSubMenu)
        ),
        React__namespace.createElement(FocusRects, null)
      );
    });
  } else {
    return null;
  }
}), function(prevProps, newProps) {
  if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {
    return true;
  }
  return shallowCompare(prevProps, newProps);
});
ContextualMenuBase.displayName = "ContextualMenuBase";
function isAltOrMeta$1(ev) {
  return ev.which === KeyCodes.alt || ev.key === "Meta";
}
function onItemMouseDown(item, ev) {
  var _a2;
  (_a2 = item.onMouseDown) === null || _a2 === void 0 ? void 0 : _a2.call(item, item, ev);
}
function onDefaultRenderSubMenu(subMenuProps, defaultRender) {
  throw Error("ContextualMenuBase: onRenderSubMenu callback is null or undefined. Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.");
}
function findItemByKeyFromItems(key, items) {
  for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {
    var item = items_3[_i];
    if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {
      var match2 = findItemByKeyFromItems(key, item.sectionProps.items);
      if (match2) {
        return match2;
      }
    } else if (item.key && item.key === key) {
      return item;
    }
  }
}
function getOnClickWithOverrideTarget(onClick, target) {
  return onClick ? function(ev, item) {
    overrideTarget(ev, target);
    return onClick(ev, item);
  } : onClick;
}
function overrideTarget(ev, target) {
  if (ev && target) {
    ev.persist();
    if (target instanceof Event) {
      ev.target = target.target;
    } else if (target instanceof Element) {
      ev.target = target;
    }
  }
}
var GlobalClassNames$t = {
  root: "ms-ContextualMenu",
  container: "ms-ContextualMenu-container",
  list: "ms-ContextualMenu-list",
  header: "ms-ContextualMenu-header",
  title: "ms-ContextualMenu-title",
  isopen: "is-open"
};
var getStyles$E = function(props) {
  var className = props.className, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames$t, theme);
  var fonts = theme.fonts, semanticColors = theme.semanticColors, effects = theme.effects;
  return {
    root: [
      theme.fonts.medium,
      classNames2.root,
      classNames2.isopen,
      {
        backgroundColor: semanticColors.menuBackground,
        minWidth: "180px"
      },
      className
    ],
    container: [
      classNames2.container,
      {
        selectors: {
          ":focus": { outline: 0 }
        }
      }
    ],
    list: [
      classNames2.list,
      classNames2.isopen,
      {
        listStyleType: "none",
        margin: "0",
        padding: "0"
      }
    ],
    header: [
      classNames2.header,
      fonts.small,
      {
        fontWeight: FontWeights.semibold,
        color: semanticColors.menuHeader,
        background: "none",
        backgroundColor: "transparent",
        border: "none",
        height: CONTEXTUAL_MENU_ITEM_HEIGHT,
        lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
        cursor: "default",
        padding: "0px 6px",
        userSelect: "none",
        textAlign: "left"
      }
    ],
    title: [
      classNames2.title,
      {
        fontSize: fonts.mediumPlus.fontSize,
        paddingRight: "14px",
        paddingLeft: "14px",
        paddingBottom: "5px",
        paddingTop: "5px",
        backgroundColor: semanticColors.menuItemBackgroundPressed
      }
    ],
    subComponentStyles: {
      callout: {
        root: {
          boxShadow: effects.elevation8
        }
      },
      menuItem: {}
    }
  };
};
function onRenderSubMenu(subMenuProps) {
  return React__namespace.createElement(LocalContextualMenu, __assign$1({}, subMenuProps));
}
var LocalContextualMenu = styled(ContextualMenuBase, getStyles$E, function(props) {
  return {
    onRenderSubMenu: props.onRenderSubMenu ? composeRenderFunction(props.onRenderSubMenu, onRenderSubMenu) : onRenderSubMenu
  };
}, { scope: "ContextualMenu" });
var ContextualMenu = LocalContextualMenu;
ContextualMenu.displayName = "ContextualMenu";
var ButtonGlobalClassNames = {
  msButton: "ms-Button",
  msButtonHasMenu: "ms-Button--hasMenu",
  msButtonIcon: "ms-Button-icon",
  msButtonMenuIcon: "ms-Button-menuIcon",
  msButtonLabel: "ms-Button-label",
  msButtonDescription: "ms-Button-description",
  msButtonScreenReaderText: "ms-Button-screenReaderText",
  msButtonFlexContainer: "ms-Button-flexContainer",
  msButtonTextContainer: "ms-Button-textContainer"
};
var getBaseButtonClassNames = memoizeFunction(function(theme, styles2, className, variantClassName, iconClassName, menuIconClassName, disabled, hasMenu, checked, expanded, isSplit) {
  var _a2, _b2;
  var classNames2 = getGlobalClassNames(ButtonGlobalClassNames, theme || {});
  var isExpanded = expanded && !isSplit;
  return mergeStyleSets({
    root: [
      classNames2.msButton,
      styles2.root,
      variantClassName,
      checked && ["is-checked", styles2.rootChecked],
      isExpanded && [
        "is-expanded",
        styles2.rootExpanded,
        {
          selectors: (_a2 = {}, _a2[":hover ." + classNames2.msButtonIcon] = styles2.iconExpandedHovered, // menuIcon falls back to rootExpandedHovered to support original behavior
          _a2[":hover ." + classNames2.msButtonMenuIcon] = styles2.menuIconExpandedHovered || styles2.rootExpandedHovered, _a2[":hover"] = styles2.rootExpandedHovered, _a2)
        }
      ],
      hasMenu && [ButtonGlobalClassNames.msButtonHasMenu, styles2.rootHasMenu],
      disabled && ["is-disabled", styles2.rootDisabled],
      !disabled && !isExpanded && !checked && {
        selectors: (_b2 = {
          ":hover": styles2.rootHovered
        }, _b2[":hover ." + classNames2.msButtonLabel] = styles2.labelHovered, _b2[":hover ." + classNames2.msButtonIcon] = styles2.iconHovered, _b2[":hover ." + classNames2.msButtonDescription] = styles2.descriptionHovered, _b2[":hover ." + classNames2.msButtonMenuIcon] = styles2.menuIconHovered, _b2[":focus"] = styles2.rootFocused, _b2[":active"] = styles2.rootPressed, _b2[":active ." + classNames2.msButtonIcon] = styles2.iconPressed, _b2[":active ." + classNames2.msButtonDescription] = styles2.descriptionPressed, _b2[":active ." + classNames2.msButtonMenuIcon] = styles2.menuIconPressed, _b2)
      },
      disabled && checked && [styles2.rootCheckedDisabled],
      !disabled && checked && {
        selectors: {
          ":hover": styles2.rootCheckedHovered,
          ":active": styles2.rootCheckedPressed
        }
      },
      className
    ],
    flexContainer: [classNames2.msButtonFlexContainer, styles2.flexContainer],
    textContainer: [classNames2.msButtonTextContainer, styles2.textContainer],
    icon: [
      classNames2.msButtonIcon,
      iconClassName,
      styles2.icon,
      isExpanded && styles2.iconExpanded,
      checked && styles2.iconChecked,
      disabled && styles2.iconDisabled
    ],
    label: [classNames2.msButtonLabel, styles2.label, checked && styles2.labelChecked, disabled && styles2.labelDisabled],
    menuIcon: [
      classNames2.msButtonMenuIcon,
      menuIconClassName,
      styles2.menuIcon,
      checked && styles2.menuIconChecked,
      disabled && !isSplit && styles2.menuIconDisabled,
      !disabled && !isExpanded && !checked && {
        selectors: {
          ":hover": styles2.menuIconHovered,
          ":active": styles2.menuIconPressed
        }
      },
      isExpanded && ["is-expanded", styles2.menuIconExpanded]
    ],
    description: [
      classNames2.msButtonDescription,
      styles2.description,
      checked && styles2.descriptionChecked,
      disabled && styles2.descriptionDisabled
    ],
    screenReaderText: [classNames2.msButtonScreenReaderText, styles2.screenReaderText]
  });
});
var getSplitButtonClassNames = memoizeFunction(function(styles2, disabled, expanded, checked, primaryDisabled) {
  return {
    root: mergeStyles(styles2.splitButtonMenuButton, expanded && [styles2.splitButtonMenuButtonExpanded], disabled && [styles2.splitButtonMenuButtonDisabled], checked && !disabled && [styles2.splitButtonMenuButtonChecked], primaryDisabled && !disabled && [
      {
        selectors: {
          ":focus": styles2.splitButtonMenuFocused
        }
      }
    ]),
    splitButtonContainer: mergeStyles(styles2.splitButtonContainer, !disabled && checked && [
      styles2.splitButtonContainerChecked,
      {
        selectors: {
          ":hover": styles2.splitButtonContainerCheckedHovered
        }
      }
    ], !disabled && !checked && [
      {
        selectors: {
          ":hover": styles2.splitButtonContainerHovered,
          ":focus": styles2.splitButtonContainerFocused
        }
      }
    ], disabled && styles2.splitButtonContainerDisabled),
    icon: mergeStyles(styles2.splitButtonMenuIcon, disabled && styles2.splitButtonMenuIconDisabled, !disabled && primaryDisabled && styles2.splitButtonMenuIcon),
    flexContainer: mergeStyles(styles2.splitButtonFlexContainer),
    divider: mergeStyles(styles2.splitButtonDivider, (primaryDisabled || disabled) && styles2.splitButtonDividerDisabled)
  };
});
var TouchIdleDelay$1 = 500;
var COMPONENT_NAME$a = "BaseButton";
var BaseButton = (
  /** @class */
  function(_super) {
    __extends(BaseButton2, _super);
    function BaseButton2(props) {
      var _this = _super.call(this, props) || this;
      _this._buttonElement = React__namespace.createRef();
      _this._splitButtonContainer = React__namespace.createRef();
      _this._mergedRef = createMergedRef();
      _this._renderedVisibleMenu = false;
      _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
        return __assign$1(__assign$1({}, keytipProps), { hasMenu: true });
      });
      _this._onRenderIcon = function(buttonProps, defaultRender) {
        var iconProps = _this.props.iconProps;
        if (iconProps && (iconProps.iconName !== void 0 || iconProps.imageProps)) {
          var className = iconProps.className, imageProps = iconProps.imageProps, rest = __rest$1(iconProps, ["className", "imageProps"]);
          if (iconProps.styles) {
            return React__namespace.createElement(Icon, __assign$1({ className: css$3(_this._classNames.icon, className), imageProps }, rest));
          }
          if (iconProps.iconName) {
            return React__namespace.createElement(FontIcon, __assign$1({ className: css$3(_this._classNames.icon, className) }, rest));
          }
          if (imageProps) {
            return React__namespace.createElement(ImageIcon, __assign$1({ className: css$3(_this._classNames.icon, className), imageProps }, rest));
          }
        }
        return null;
      };
      _this._onRenderTextContents = function() {
        var _a2 = _this.props, text = _a2.text, children = _a2.children, _b2 = _a2.secondaryText, secondaryText = _b2 === void 0 ? _this.props.description : _b2, _c2 = _a2.onRenderText, onRenderText = _c2 === void 0 ? _this._onRenderText : _c2, _d2 = _a2.onRenderDescription, onRenderDescription = _d2 === void 0 ? _this._onRenderDescription : _d2;
        if (text || typeof children === "string" || secondaryText) {
          return React__namespace.createElement(
            "span",
            { className: _this._classNames.textContainer },
            onRenderText(_this.props, _this._onRenderText),
            onRenderDescription(_this.props, _this._onRenderDescription)
          );
        }
        return [onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription)];
      };
      _this._onRenderText = function() {
        var text = _this.props.text;
        var children = _this.props.children;
        if (text === void 0 && typeof children === "string") {
          text = children;
        }
        if (_this._hasText()) {
          return React__namespace.createElement("span", { key: _this._labelId, className: _this._classNames.label, id: _this._labelId }, text);
        }
        return null;
      };
      _this._onRenderChildren = function() {
        var children = _this.props.children;
        if (typeof children === "string") {
          return null;
        }
        return children;
      };
      _this._onRenderDescription = function(props2) {
        var _a2 = props2.secondaryText, secondaryText = _a2 === void 0 ? _this.props.description : _a2;
        return secondaryText ? React__namespace.createElement("span", { key: _this._descriptionId, className: _this._classNames.description, id: _this._descriptionId }, secondaryText) : null;
      };
      _this._onRenderAriaDescription = function() {
        var ariaDescription = _this.props.ariaDescription;
        return ariaDescription ? React__namespace.createElement("span", { className: _this._classNames.screenReaderText, id: _this._ariaDescriptionId }, ariaDescription) : null;
      };
      _this._onRenderMenuIcon = function(props2) {
        var menuIconProps = _this.props.menuIconProps;
        return React__namespace.createElement(FontIcon, __assign$1({ iconName: "ChevronDown" }, menuIconProps, { className: _this._classNames.menuIcon }));
      };
      _this._onRenderMenu = function(menuProps) {
        var MenuType = _this.props.menuAs ? composeComponentAs(_this.props.menuAs, ContextualMenu) : ContextualMenu;
        return React__namespace.createElement(MenuType, __assign$1({}, menuProps));
      };
      _this._onDismissMenu = function(ev) {
        var menuProps = _this.props.menuProps;
        if (menuProps && menuProps.onDismiss) {
          menuProps.onDismiss(ev);
        }
        if (!ev || !ev.defaultPrevented) {
          _this._dismissMenu();
        }
      };
      _this._dismissMenu = function() {
        _this._menuShouldFocusOnMount = void 0;
        _this._menuShouldFocusOnContainer = void 0;
        _this.setState({ menuHidden: true });
      };
      _this._openMenu = function(shouldFocusOnContainer, shouldFocusOnMount) {
        if (shouldFocusOnMount === void 0) {
          shouldFocusOnMount = true;
        }
        if (_this.props.menuProps) {
          _this._menuShouldFocusOnContainer = shouldFocusOnContainer;
          _this._menuShouldFocusOnMount = shouldFocusOnMount;
          _this._renderedVisibleMenu = true;
          _this.setState({ menuHidden: false });
        }
      };
      _this._onToggleMenu = function(shouldFocusOnContainer) {
        var shouldFocusOnMount = true;
        if (_this.props.menuProps && _this.props.menuProps.shouldFocusOnMount === false) {
          shouldFocusOnMount = false;
        }
        _this.state.menuHidden ? _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : _this._dismissMenu();
      };
      _this._onSplitContainerFocusCapture = function(ev) {
        var container = _this._splitButtonContainer.current;
        if (!container || ev.target && portalContainsElement(ev.target, container)) {
          return;
        }
        container.focus();
      };
      _this._onSplitButtonPrimaryClick = function(ev) {
        if (!_this.state.menuHidden) {
          _this._dismissMenu();
        }
        if (!_this._processingTouch && _this.props.onClick) {
          _this.props.onClick(ev);
        } else if (_this._processingTouch) {
          _this._onMenuClick(ev);
        }
      };
      _this._onKeyDown = function(ev) {
        if (_this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {
          ev.preventDefault();
          ev.stopPropagation();
        } else if (!_this.props.disabled) {
          if (_this.props.menuProps) {
            _this._onMenuKeyDown(ev);
          } else if (_this.props.onKeyDown !== void 0) {
            _this.props.onKeyDown(ev);
          }
        }
      };
      _this._onKeyUp = function(ev) {
        if (!_this.props.disabled && _this.props.onKeyUp !== void 0) {
          _this.props.onKeyUp(ev);
        }
      };
      _this._onKeyPress = function(ev) {
        if (!_this.props.disabled && _this.props.onKeyPress !== void 0) {
          _this.props.onKeyPress(ev);
        }
      };
      _this._onMouseUp = function(ev) {
        if (!_this.props.disabled && _this.props.onMouseUp !== void 0) {
          _this.props.onMouseUp(ev);
        }
      };
      _this._onMouseDown = function(ev) {
        if (!_this.props.disabled && _this.props.onMouseDown !== void 0) {
          _this.props.onMouseDown(ev);
        }
      };
      _this._onClick = function(ev) {
        if (!_this.props.disabled) {
          if (_this.props.menuProps) {
            _this._onMenuClick(ev);
          } else if (_this.props.onClick !== void 0) {
            _this.props.onClick(ev);
          }
        }
      };
      _this._onSplitButtonContainerKeyDown = function(ev) {
        if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
          if (_this._buttonElement.current) {
            _this._buttonElement.current.click();
            ev.preventDefault();
            ev.stopPropagation();
          }
        } else {
          _this._onMenuKeyDown(ev);
        }
      };
      _this._onMenuKeyDown = function(ev) {
        var _a2;
        if (_this.props.disabled) {
          return;
        }
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(ev);
        }
        var isUp = ev.which === KeyCodes.up;
        var isDown = ev.which === KeyCodes.down;
        if (!ev.defaultPrevented && _this._isValidMenuOpenKey(ev)) {
          var onMenuClick = _this.props.onMenuClick;
          if (onMenuClick) {
            onMenuClick(ev, _this.props);
          }
          _this._onToggleMenu(false);
          ev.preventDefault();
          ev.stopPropagation();
        }
        if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
          setFocusVisibility(true, ev.target, (_a2 = _this.context) === null || _a2 === void 0 ? void 0 : _a2.registeredProviders);
        }
        if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {
          if (!_this.state.menuHidden && _this.props.menuProps) {
            var currentShouldFocusOnMount = _this._menuShouldFocusOnMount !== void 0 ? _this._menuShouldFocusOnMount : _this.props.menuProps.shouldFocusOnMount;
            if (!currentShouldFocusOnMount) {
              ev.preventDefault();
              ev.stopPropagation();
              _this._menuShouldFocusOnMount = true;
              _this.forceUpdate();
            }
          }
        }
      };
      _this._onTouchStart = function() {
        if (_this._isSplitButton && _this._splitButtonContainer.current && !("onpointerdown" in _this._splitButtonContainer.current)) {
          _this._handleTouchAndPointerEvent();
        }
      };
      _this._onMenuClick = function(ev) {
        var _a2 = _this.props, onMenuClick = _a2.onMenuClick, menuProps = _a2.menuProps;
        if (onMenuClick) {
          onMenuClick(ev, _this.props);
        }
        var shouldFocusOnContainer = typeof (menuProps === null || menuProps === void 0 ? void 0 : menuProps.shouldFocusOnContainer) === "boolean" ? menuProps.shouldFocusOnContainer : ev.nativeEvent.pointerType === "mouse";
        if (!ev.defaultPrevented) {
          _this._onToggleMenu(shouldFocusOnContainer);
          ev.preventDefault();
          ev.stopPropagation();
        }
      };
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      warnConditionallyRequiredProps(COMPONENT_NAME$a, props, ["menuProps", "onClick"], "split", _this.props.split);
      warnDeprecations(COMPONENT_NAME$a, props, {
        rootProps: void 0,
        description: "secondaryText",
        toggled: "checked"
      });
      _this._labelId = getId();
      _this._descriptionId = getId();
      _this._ariaDescriptionId = getId();
      _this.state = {
        menuHidden: true
      };
      return _this;
    }
    Object.defineProperty(BaseButton2.prototype, "_isSplitButton", {
      get: function() {
        return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;
      },
      enumerable: false,
      configurable: true
    });
    BaseButton2.prototype.render = function() {
      var _a2;
      var _b2 = this.props, ariaDescription = _b2.ariaDescription, ariaLabel = _b2.ariaLabel, ariaHidden = _b2.ariaHidden, className = _b2.className, disabled = _b2.disabled, allowDisabledFocus = _b2.allowDisabledFocus, primaryDisabled = _b2.primaryDisabled, _c2 = _b2.secondaryText, secondaryText = _c2 === void 0 ? this.props.description : _c2, href = _b2.href, iconProps = _b2.iconProps, menuIconProps = _b2.menuIconProps, styles2 = _b2.styles, checked = _b2.checked, variantClassName = _b2.variantClassName, theme = _b2.theme, toggle = _b2.toggle, getClassNames2 = _b2.getClassNames, role = _b2.role;
      var menuHidden = this.state.menuHidden;
      var isPrimaryButtonDisabled = disabled || primaryDisabled;
      this._classNames = getClassNames2 ? getClassNames2(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !menuHidden, !!this.props.menuProps, this.props.split, !!allowDisabledFocus) : getBaseButtonClassNames(theme, styles2, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, !!this.props.menuProps, checked, !menuHidden, this.props.split);
      var _d2 = this, _ariaDescriptionId = _d2._ariaDescriptionId, _labelId = _d2._labelId, _descriptionId = _d2._descriptionId;
      var renderAsAnchor = !isPrimaryButtonDisabled && !!href;
      var tag = renderAsAnchor ? "a" : "button";
      var nativeProps = getNativeProps(
        // eslint-disable-next-line deprecation/deprecation
        assign$2(renderAsAnchor ? {} : { type: "button" }, this.props.rootProps, this.props),
        renderAsAnchor ? anchorProperties : buttonProperties,
        [
          "disabled"
          // let disabled buttons be focused and styled as disabled.
        ]
      );
      var resolvedAriaLabel = ariaLabel || nativeProps["aria-label"];
      var ariaDescribedBy = void 0;
      if (ariaDescription) {
        ariaDescribedBy = _ariaDescriptionId;
      } else if (secondaryText && this.props.onRenderDescription !== nullRender) {
        ariaDescribedBy = _descriptionId;
      } else if (nativeProps["aria-describedby"]) {
        ariaDescribedBy = nativeProps["aria-describedby"];
      }
      var ariaLabelledBy = void 0;
      if (nativeProps["aria-labelledby"]) {
        ariaLabelledBy = nativeProps["aria-labelledby"];
      } else if (ariaDescribedBy && !resolvedAriaLabel) {
        ariaLabelledBy = this._hasText() ? _labelId : void 0;
      }
      var dataIsFocusable = this.props["data-is-focusable"] === false || disabled && !allowDisabledFocus || this._isSplitButton ? false : true;
      var isCheckboxTypeRole = role === "menuitemcheckbox" || role === "checkbox";
      var checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : void 0;
      var buttonProps = assign$2(nativeProps, (_a2 = {
        className: this._classNames.root,
        // eslint-disable-next-line deprecation/deprecation
        ref: this._mergedRef(this.props.elementRef, this._buttonElement),
        disabled: isPrimaryButtonDisabled && !allowDisabledFocus,
        onKeyDown: this._onKeyDown,
        onKeyPress: this._onKeyPress,
        onKeyUp: this._onKeyUp,
        onMouseDown: this._onMouseDown,
        onMouseUp: this._onMouseUp,
        onClick: this._onClick,
        "aria-label": resolvedAriaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy,
        "aria-disabled": isPrimaryButtonDisabled,
        "data-is-focusable": dataIsFocusable
      }, // aria-pressed attribute should only be present for toggle buttons
      // aria-checked attribute should only be present for toggle buttons with checkbox type role
      _a2[isCheckboxTypeRole ? "aria-checked" : "aria-pressed"] = checkedOrPressedValue, _a2));
      if (ariaHidden) {
        buttonProps["aria-hidden"] = true;
      }
      if (this._isSplitButton) {
        return this._onRenderSplitButtonContent(tag, buttonProps);
      } else if (this.props.menuProps) {
        var _e2 = this.props.menuProps.id, id = _e2 === void 0 ? this._labelId + "-menu" : _e2;
        assign$2(buttonProps, {
          "aria-expanded": !menuHidden,
          "aria-controls": !menuHidden ? id : null,
          "aria-haspopup": true
        });
      }
      return this._onRenderContent(tag, buttonProps);
    };
    BaseButton2.prototype.componentDidMount = function() {
      if (this._isSplitButton && this._splitButtonContainer.current) {
        if ("onpointerdown" in this._splitButtonContainer.current) {
          this._events.on(this._splitButtonContainer.current, "pointerdown", this._onPointerDown, true);
        }
        if ("onpointerup" in this._splitButtonContainer.current && this.props.onPointerUp) {
          this._events.on(this._splitButtonContainer.current, "pointerup", this.props.onPointerUp, true);
        }
      }
    };
    BaseButton2.prototype.componentDidUpdate = function(prevProps, prevState) {
      if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {
        this.props.onAfterMenuDismiss();
      }
    };
    BaseButton2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    BaseButton2.prototype.focus = function() {
      var _a2, _b2;
      if (this._isSplitButton && this._splitButtonContainer.current) {
        setFocusVisibility(true, void 0, (_a2 = this.context) === null || _a2 === void 0 ? void 0 : _a2.registeredProviders);
        this._splitButtonContainer.current.focus();
      } else if (this._buttonElement.current) {
        setFocusVisibility(true, void 0, (_b2 = this.context) === null || _b2 === void 0 ? void 0 : _b2.registeredProviders);
        this._buttonElement.current.focus();
      }
    };
    BaseButton2.prototype.dismissMenu = function() {
      this._dismissMenu();
    };
    BaseButton2.prototype.openMenu = function(shouldFocusOnContainer, shouldFocusOnMount) {
      this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);
    };
    BaseButton2.prototype._onRenderContent = function(tag, buttonProps) {
      var _this = this;
      var props = this.props;
      var Tag = tag;
      var menuIconProps = props.menuIconProps, menuProps = props.menuProps, _a2 = props.onRenderIcon, onRenderIcon = _a2 === void 0 ? this._onRenderIcon : _a2, _b2 = props.onRenderAriaDescription, onRenderAriaDescription = _b2 === void 0 ? this._onRenderAriaDescription : _b2, _c2 = props.onRenderChildren, onRenderChildren = _c2 === void 0 ? this._onRenderChildren : _c2, _d2 = props.onRenderMenu, onRenderMenu = _d2 === void 0 ? this._onRenderMenu : _d2, _e2 = props.onRenderMenuIcon, onRenderMenuIcon = _e2 === void 0 ? this._onRenderMenuIcon : _e2, disabled = props.disabled;
      var keytipProps = props.keytipProps;
      if (keytipProps && menuProps) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      var Button = function(keytipAttributes) {
        return React__namespace.createElement(
          Tag,
          __assign$1({}, buttonProps, keytipAttributes),
          React__namespace.createElement(
            "span",
            { className: _this._classNames.flexContainer, "data-automationid": "splitbuttonprimary" },
            onRenderIcon(props, _this._onRenderIcon),
            _this._onRenderTextContents(),
            onRenderAriaDescription(props, _this._onRenderAriaDescription),
            onRenderChildren(props, _this._onRenderChildren),
            !_this._isSplitButton && (menuProps || menuIconProps || _this.props.onRenderMenuIcon) && onRenderMenuIcon(_this.props, _this._onRenderMenuIcon),
            menuProps && !menuProps.doNotLayer && _this._shouldRenderMenu() && onRenderMenu(_this._getMenuProps(menuProps), _this._onRenderMenu)
          )
        );
      };
      var Content = keytipProps ? (
        // If we're making a split button, we won't put the keytip here
        React__namespace.createElement(KeytipData, { keytipProps: !this._isSplitButton ? keytipProps : void 0, ariaDescribedBy: buttonProps["aria-describedby"], disabled }, function(keytipAttributes) {
          return Button(keytipAttributes);
        })
      ) : Button();
      if (menuProps && menuProps.doNotLayer) {
        return React__namespace.createElement(
          React__namespace.Fragment,
          null,
          Content,
          this._shouldRenderMenu() && onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu)
        );
      }
      return React__namespace.createElement(
        React__namespace.Fragment,
        null,
        Content,
        React__namespace.createElement(FocusRects, null)
      );
    };
    BaseButton2.prototype._shouldRenderMenu = function() {
      var menuHidden = this.state.menuHidden;
      var _a2 = this.props, persistMenu = _a2.persistMenu, renderPersistedMenuHiddenOnMount = _a2.renderPersistedMenuHiddenOnMount;
      if (!menuHidden) {
        return true;
      } else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {
        return true;
      }
      return false;
    };
    BaseButton2.prototype._hasText = function() {
      return this.props.text !== null && (this.props.text !== void 0 || typeof this.props.children === "string");
    };
    BaseButton2.prototype._getMenuProps = function(menuProps) {
      var persistMenu = this.props.persistMenu;
      var menuHidden = this.state.menuHidden;
      if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {
        menuProps = __assign$1(__assign$1({}, menuProps), { labelElementId: this._labelId });
      }
      return __assign$1(__assign$1({ id: this._labelId + "-menu", directionalHint: DirectionalHint.bottomLeftEdge }, menuProps), { shouldFocusOnContainer: this._menuShouldFocusOnContainer, shouldFocusOnMount: this._menuShouldFocusOnMount, hidden: persistMenu ? menuHidden : void 0, className: css$3("ms-BaseButton-menuhost", menuProps.className), target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current, onDismiss: this._onDismissMenu });
    };
    BaseButton2.prototype._onRenderSplitButtonContent = function(tag, buttonProps) {
      var _this = this;
      var _a2 = this.props, _b2 = _a2.styles, styles2 = _b2 === void 0 ? {} : _b2, disabled = _a2.disabled, allowDisabledFocus = _a2.allowDisabledFocus, checked = _a2.checked, getSplitButtonClassNames$1 = _a2.getSplitButtonClassNames, primaryDisabled = _a2.primaryDisabled, menuProps = _a2.menuProps, toggle = _a2.toggle, role = _a2.role, primaryActionButtonProps = _a2.primaryActionButtonProps;
      var keytipProps = this.props.keytipProps;
      var menuHidden = this.state.menuHidden;
      var classNames2 = getSplitButtonClassNames$1 ? getSplitButtonClassNames$1(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus) : styles2 && getSplitButtonClassNames(styles2, !!disabled, !menuHidden, !!checked, !!primaryDisabled);
      assign$2(buttonProps, {
        onClick: void 0,
        onPointerDown: void 0,
        onPointerUp: void 0,
        tabIndex: -1,
        "data-is-focusable": false
      });
      if (keytipProps && menuProps) {
        keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
      }
      var containerProps = getNativeProps(buttonProps, [], ["disabled"]);
      if (primaryActionButtonProps) {
        assign$2(buttonProps, primaryActionButtonProps);
      }
      var SplitButton = function(keytipAttributes) {
        return React__namespace.createElement(
          "div",
          __assign$1({}, containerProps, { "data-ktp-target": keytipAttributes ? keytipAttributes["data-ktp-target"] : void 0, role: role ? role : "button", "aria-disabled": disabled, "aria-haspopup": true, "aria-expanded": !menuHidden, "aria-pressed": toggle ? !!checked : void 0, "aria-describedby": mergeAriaAttributeValues(buttonProps["aria-describedby"], keytipAttributes ? keytipAttributes["aria-describedby"] : void 0), className: classNames2 && classNames2.splitButtonContainer, onKeyDown: _this._onSplitButtonContainerKeyDown, onTouchStart: _this._onTouchStart, ref: _this._splitButtonContainer, "data-is-focusable": true, onClick: !disabled && !primaryDisabled ? _this._onSplitButtonPrimaryClick : void 0, tabIndex: !disabled && !primaryDisabled || allowDisabledFocus ? 0 : void 0, "aria-roledescription": buttonProps["aria-roledescription"], onFocusCapture: _this._onSplitContainerFocusCapture }),
          React__namespace.createElement(
            "span",
            { style: { display: "flex", width: "100%" } },
            _this._onRenderContent(tag, buttonProps),
            _this._onRenderSplitButtonMenuButton(classNames2, keytipAttributes),
            _this._onRenderSplitButtonDivider(classNames2)
          )
        );
      };
      return keytipProps ? React__namespace.createElement(KeytipData, { keytipProps, disabled }, function(keytipAttributes) {
        return SplitButton(keytipAttributes);
      }) : SplitButton();
    };
    BaseButton2.prototype._onRenderSplitButtonDivider = function(classNames2) {
      if (classNames2 && classNames2.divider) {
        var onClick = function(ev) {
          ev.stopPropagation();
        };
        return React__namespace.createElement("span", { className: classNames2.divider, "aria-hidden": true, onClick });
      }
      return null;
    };
    BaseButton2.prototype._onRenderSplitButtonMenuButton = function(classNames2, keytipAttributes) {
      var _a2 = this.props, allowDisabledFocus = _a2.allowDisabledFocus, checked = _a2.checked, disabled = _a2.disabled, splitButtonMenuProps = _a2.splitButtonMenuProps, splitButtonAriaLabel = _a2.splitButtonAriaLabel, primaryDisabled = _a2.primaryDisabled;
      var menuHidden = this.state.menuHidden;
      var menuIconProps = this.props.menuIconProps;
      if (menuIconProps === void 0) {
        menuIconProps = {
          iconName: "ChevronDown"
        };
      }
      var splitButtonProps = __assign$1(__assign$1({}, splitButtonMenuProps), { styles: classNames2, checked, disabled, allowDisabledFocus, onClick: this._onMenuClick, menuProps: void 0, iconProps: __assign$1(__assign$1({}, menuIconProps), { className: this._classNames.menuIcon }), ariaLabel: splitButtonAriaLabel, "aria-haspopup": true, "aria-expanded": !menuHidden, "data-is-focusable": false });
      return React__namespace.createElement(BaseButton2, __assign$1({}, splitButtonProps, { "data-ktp-execute-target": keytipAttributes ? keytipAttributes["data-ktp-execute-target"] : keytipAttributes, onMouseDown: this._onMouseDown, tabIndex: primaryDisabled && !allowDisabledFocus ? 0 : -1 }));
    };
    BaseButton2.prototype._onPointerDown = function(ev) {
      var onPointerDown = this.props.onPointerDown;
      if (onPointerDown) {
        onPointerDown(ev);
      }
      if (ev.pointerType === "touch") {
        this._handleTouchAndPointerEvent();
        ev.preventDefault();
        ev.stopImmediatePropagation();
      }
    };
    BaseButton2.prototype._handleTouchAndPointerEvent = function() {
      var _this = this;
      if (this._lastTouchTimeoutId !== void 0) {
        this._async.clearTimeout(this._lastTouchTimeoutId);
        this._lastTouchTimeoutId = void 0;
      }
      this._processingTouch = true;
      this._lastTouchTimeoutId = this._async.setTimeout(function() {
        _this._processingTouch = false;
        _this._lastTouchTimeoutId = void 0;
        if (_this.state.menuHidden) {
          _this.focus();
        }
      }, TouchIdleDelay$1);
    };
    BaseButton2.prototype._isValidMenuOpenKey = function(ev) {
      if (this.props.menuTriggerKeyCode) {
        return ev.which === this.props.menuTriggerKeyCode;
      } else if (this.props.menuProps) {
        return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);
      }
      return false;
    };
    BaseButton2.defaultProps = {
      baseClassName: "ms-Button",
      styles: {},
      split: false
    };
    BaseButton2.contextType = FocusRectsContext;
    return BaseButton2;
  }(React__namespace.Component)
);
var noOutline = {
  outline: 0
};
var iconStyle = function(fontSize) {
  return {
    fontSize,
    margin: "0 4px",
    height: "16px",
    lineHeight: "16px",
    textAlign: "center",
    flexShrink: 0
  };
};
var getStyles$D = memoizeFunction(function(theme) {
  var _a2, _b2;
  var semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
  var border = semanticColors.buttonBorder;
  var disabledBackground = semanticColors.disabledBackground;
  var disabledText = semanticColors.disabledText;
  var buttonHighContrastFocus = {
    left: -2,
    top: -2,
    bottom: -2,
    right: -2,
    outlineColor: "ButtonText"
  };
  return {
    root: [
      getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: "transparent" }),
      theme.fonts.medium,
      {
        border: "1px solid " + border,
        borderRadius: effects.roundedCorner2,
        boxSizing: "border-box",
        cursor: "pointer",
        display: "inline-block",
        padding: "0 16px",
        textDecoration: "none",
        textAlign: "center",
        userSelect: "none",
        selectors: {
          // IE11 workaround for preventing shift of child elements of a button when active.
          ":active > span": {
            position: "relative",
            left: 0,
            top: 0
          }
        }
      }
    ],
    rootDisabled: [
      getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: "transparent" }),
      {
        backgroundColor: disabledBackground,
        borderColor: disabledBackground,
        color: disabledText,
        cursor: "default",
        selectors: {
          ":hover": noOutline,
          ":focus": noOutline
        }
      }
    ],
    iconDisabled: {
      color: disabledText,
      selectors: (_a2 = {}, _a2[HighContrastSelector] = {
        color: "GrayText"
      }, _a2)
    },
    menuIconDisabled: {
      color: disabledText,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        color: "GrayText"
      }, _b2)
    },
    flexContainer: {
      display: "flex",
      height: "100%",
      flexWrap: "nowrap",
      justifyContent: "center",
      alignItems: "center"
    },
    description: {
      display: "block"
    },
    textContainer: {
      flexGrow: 1,
      display: "block"
    },
    icon: iconStyle(fonts.mediumPlus.fontSize),
    menuIcon: iconStyle(fonts.small.fontSize),
    label: {
      margin: "0 4px",
      lineHeight: "100%",
      display: "block"
    },
    screenReaderText: hiddenContentStyle
  };
});
var getStyles$C = memoizeFunction(function(theme, customStyles) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l, _m, _o;
  var effects = theme.effects, palette = theme.palette, semanticColors = theme.semanticColors;
  var buttonHighContrastFocus = {
    left: -2,
    top: -2,
    bottom: -2,
    right: -2,
    border: "none"
  };
  var splitButtonDividerBaseStyles2 = {
    position: "absolute",
    width: 1,
    right: 31,
    top: 8,
    bottom: 8
  };
  var splitButtonStyles = {
    splitButtonContainer: [
      getFocusStyle(theme, { highContrastStyle: buttonHighContrastFocus, inset: 2, pointerEvents: "none" }),
      {
        display: "inline-flex",
        selectors: {
          ".ms-Button--default": {
            borderTopRightRadius: "0",
            borderBottomRightRadius: "0",
            borderRight: "none",
            flexGrow: "1"
          },
          ".ms-Button--primary": {
            borderTopRightRadius: "0",
            borderBottomRightRadius: "0",
            border: "none",
            flexGrow: "1",
            selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign$1({ color: "WindowText", backgroundColor: "Window", border: "1px solid WindowText", borderRightWidth: "0" }, getHighContrastNoAdjustStyle()), _a2[":hover"] = {
              border: "none"
            }, _a2[":active"] = {
              border: "none"
            }, _a2)
          },
          ".ms-Button--primary + .ms-Button": {
            border: "none",
            selectors: (_b2 = {}, _b2[HighContrastSelector] = {
              border: "1px solid WindowText",
              borderLeftWidth: "0"
            }, _b2)
          }
        }
      }
    ],
    splitButtonContainerHovered: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_c2 = {}, _c2[HighContrastSelector] = {
            color: "Window",
            backgroundColor: "Highlight"
          }, _c2)
        },
        ".ms-Button.is-disabled": {
          color: semanticColors.buttonTextDisabled,
          selectors: (_d2 = {}, _d2[HighContrastSelector] = {
            color: "GrayText",
            borderColor: "GrayText",
            backgroundColor: "Window"
          }, _d2)
        }
      }
    },
    splitButtonContainerChecked: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_e2 = {}, _e2[HighContrastSelector] = __assign$1({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _e2)
        }
      }
    },
    splitButtonContainerCheckedHovered: {
      selectors: {
        ".ms-Button--primary": {
          selectors: (_f = {}, _f[HighContrastSelector] = __assign$1({ color: "Window", backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _f)
        }
      }
    },
    splitButtonContainerFocused: {
      outline: "none!important"
    },
    splitButtonMenuButton: (_g = {
      padding: 6,
      height: "auto",
      boxSizing: "border-box",
      borderRadius: 0,
      borderTopRightRadius: effects.roundedCorner2,
      borderBottomRightRadius: effects.roundedCorner2,
      border: "1px solid " + palette.neutralSecondaryAlt,
      borderLeft: "none",
      outline: "transparent",
      userSelect: "none",
      display: "inline-block",
      textDecoration: "none",
      textAlign: "center",
      cursor: "pointer",
      verticalAlign: "top",
      width: 32,
      marginLeft: -1,
      marginTop: 0,
      marginRight: 0,
      marginBottom: 0
    }, _g[HighContrastSelector] = {
      ".ms-Button-menuIcon": {
        color: "WindowText"
      }
    }, _g),
    splitButtonDivider: __assign$1(__assign$1({}, splitButtonDividerBaseStyles2), { selectors: (_h = {}, _h[HighContrastSelector] = {
      backgroundColor: "WindowText"
    }, _h) }),
    splitButtonDividerDisabled: __assign$1(__assign$1({}, splitButtonDividerBaseStyles2), { selectors: (_j = {}, _j[HighContrastSelector] = {
      backgroundColor: "GrayText"
    }, _j) }),
    splitButtonMenuButtonDisabled: {
      pointerEvents: "none",
      border: "none",
      selectors: (_k = {
        ":hover": {
          cursor: "default"
        },
        ".ms-Button--primary": {
          selectors: (_l = {}, _l[HighContrastSelector] = {
            color: "GrayText",
            borderColor: "GrayText",
            backgroundColor: "Window"
          }, _l)
        },
        ".ms-Button-menuIcon": {
          selectors: (_m = {}, _m[HighContrastSelector] = {
            color: "GrayText"
          }, _m)
        }
      }, _k[HighContrastSelector] = {
        color: "GrayText",
        border: "1px solid GrayText",
        backgroundColor: "Window"
      }, _k)
    },
    splitButtonFlexContainer: {
      display: "flex",
      height: "100%",
      flexWrap: "nowrap",
      justifyContent: "center",
      alignItems: "center"
    },
    splitButtonContainerDisabled: {
      outline: "none",
      border: "none",
      selectors: (_o = {}, _o[HighContrastSelector] = __assign$1({ color: "GrayText", borderColor: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _o)
    },
    splitButtonMenuFocused: __assign$1({}, getFocusStyle(theme, { highContrastStyle: buttonHighContrastFocus, inset: 2 }))
  };
  return concatStyleSets(splitButtonStyles, customStyles);
});
var splitButtonDividerBaseStyles = function() {
  return {
    position: "absolute",
    width: 1,
    right: 31,
    top: 8,
    bottom: 8
  };
};
function standardStyles(theme) {
  var _a2, _b2, _c2, _d2, _e2;
  var s = theme.semanticColors, p = theme.palette;
  var buttonBackground = s.buttonBackground;
  var buttonBackgroundPressed = s.buttonBackgroundPressed;
  var buttonBackgroundHovered = s.buttonBackgroundHovered;
  var buttonBackgroundDisabled = s.buttonBackgroundDisabled;
  var buttonText = s.buttonText;
  var buttonTextHovered = s.buttonTextHovered;
  var buttonTextDisabled = s.buttonTextDisabled;
  var buttonTextChecked = s.buttonTextChecked;
  var buttonTextCheckedHovered = s.buttonTextCheckedHovered;
  return {
    root: {
      backgroundColor: buttonBackground,
      color: buttonText
    },
    rootHovered: {
      backgroundColor: buttonBackgroundHovered,
      color: buttonTextHovered,
      selectors: (_a2 = {}, _a2[HighContrastSelector] = {
        borderColor: "Highlight",
        color: "Highlight"
      }, _a2)
    },
    rootPressed: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootExpanded: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootChecked: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextChecked
    },
    rootCheckedHovered: {
      backgroundColor: buttonBackgroundPressed,
      color: buttonTextCheckedHovered
    },
    rootDisabled: {
      color: buttonTextDisabled,
      backgroundColor: buttonBackgroundDisabled,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        color: "GrayText",
        borderColor: "GrayText",
        backgroundColor: "Window"
      }, _b2)
    },
    // Split button styles
    splitButtonContainer: {
      selectors: (_c2 = {}, _c2[HighContrastSelector] = {
        border: "none"
      }, _c2)
    },
    splitButtonMenuButton: {
      color: p.white,
      backgroundColor: "transparent",
      selectors: {
        ":hover": {
          backgroundColor: p.neutralLight,
          selectors: (_d2 = {}, _d2[HighContrastSelector] = {
            color: "Highlight"
          }, _d2)
        }
      }
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: s.buttonBackgroundDisabled,
      selectors: {
        ":hover": {
          backgroundColor: s.buttonBackgroundDisabled
        }
      }
    },
    splitButtonDivider: __assign$1(__assign$1({}, splitButtonDividerBaseStyles()), { backgroundColor: p.neutralTertiaryAlt, selectors: (_e2 = {}, _e2[HighContrastSelector] = {
      backgroundColor: "WindowText"
    }, _e2) }),
    splitButtonDividerDisabled: {
      backgroundColor: theme.palette.neutralTertiaryAlt
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuIcon: {
      color: s.buttonText
    },
    splitButtonMenuIconDisabled: {
      color: s.buttonTextDisabled
    }
  };
}
function primaryStyles(theme) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j;
  var p = theme.palette, s = theme.semanticColors;
  return {
    root: {
      backgroundColor: s.primaryButtonBackground,
      border: "1px solid " + s.primaryButtonBackground,
      color: s.primaryButtonText,
      selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign$1({ color: "Window", backgroundColor: "WindowText", borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _a2["." + IsFocusVisibleClassName + " &:focus"] = {
        selectors: {
          ":after": {
            border: "none",
            outlineColor: p.white
          }
        }
      }, _a2)
    },
    rootHovered: {
      backgroundColor: s.primaryButtonBackgroundHovered,
      border: "1px solid " + s.primaryButtonBackgroundHovered,
      color: s.primaryButtonTextHovered,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        color: "Window",
        backgroundColor: "Highlight",
        borderColor: "Highlight"
      }, _b2)
    },
    rootPressed: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      border: "1px solid " + s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed,
      selectors: (_c2 = {}, _c2[HighContrastSelector] = __assign$1({ color: "Window", backgroundColor: "WindowText", borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _c2)
    },
    rootExpanded: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootChecked: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootCheckedHovered: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      color: s.primaryButtonTextPressed
    },
    rootDisabled: {
      color: s.primaryButtonTextDisabled,
      backgroundColor: s.primaryButtonBackgroundDisabled,
      selectors: (_d2 = {}, _d2[HighContrastSelector] = {
        color: "GrayText",
        borderColor: "GrayText",
        backgroundColor: "Window"
      }, _d2)
    },
    // Split button styles
    splitButtonContainer: {
      selectors: (_e2 = {}, _e2[HighContrastSelector] = {
        border: "none"
      }, _e2)
    },
    splitButtonDivider: __assign$1(__assign$1({}, splitButtonDividerBaseStyles()), { backgroundColor: p.white, selectors: (_f = {}, _f[HighContrastSelector] = {
      backgroundColor: "Window"
    }, _f) }),
    splitButtonMenuButton: {
      backgroundColor: s.primaryButtonBackground,
      color: s.primaryButtonText,
      selectors: (_g = {}, _g[HighContrastSelector] = {
        backgroundColor: "Canvas"
      }, _g[":hover"] = {
        backgroundColor: s.primaryButtonBackgroundHovered,
        selectors: (_h = {}, _h[HighContrastSelector] = {
          color: "Highlight"
        }, _h)
      }, _g)
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: s.primaryButtonBackgroundDisabled,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundDisabled
        }
      }
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundPressed
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: s.primaryButtonBackgroundPressed,
      selectors: {
        ":hover": {
          backgroundColor: s.primaryButtonBackgroundPressed
        }
      }
    },
    splitButtonMenuIcon: {
      color: s.primaryButtonText
    },
    splitButtonMenuIconDisabled: {
      color: p.neutralTertiary,
      selectors: (_j = {}, _j[HighContrastSelector] = {
        color: "GrayText"
      }, _j)
    }
  };
}
var DEFAULT_BUTTON_HEIGHT$1 = "32px";
var DEFAULT_BUTTON_MIN_WIDTH = "80px";
var getStyles$B = memoizeFunction(function(theme, customStyles, primary) {
  var baseButtonStyles = getStyles$D(theme);
  var splitButtonStyles = getStyles$C(theme);
  var defaultButtonStyles = {
    root: {
      minWidth: DEFAULT_BUTTON_MIN_WIDTH,
      height: DEFAULT_BUTTON_HEIGHT$1
    },
    label: {
      fontWeight: FontWeights.semibold
    }
  };
  return concatStyleSets(baseButtonStyles, defaultButtonStyles, primary ? primaryStyles(theme) : standardStyles(theme), splitButtonStyles, customStyles);
});
var DefaultButton = (
  /** @class */
  function(_super) {
    __extends(DefaultButton2, _super);
    function DefaultButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultButton2.prototype.render = function() {
      var _a2 = this.props, _b2 = _a2.primary, primary = _b2 === void 0 ? false : _b2, styles2 = _a2.styles, theme = _a2.theme;
      return React__namespace.createElement(BaseButton, __assign$1({}, this.props, { variantClassName: primary ? "ms-Button--primary" : "ms-Button--default", styles: getStyles$B(theme, styles2, primary), onRenderDescription: nullRender }));
    };
    DefaultButton2 = __decorate([
      customizable("DefaultButton", ["theme", "styles"], true)
    ], DefaultButton2);
    return DefaultButton2;
  }(React__namespace.Component)
);
var DEFAULT_BUTTON_HEIGHT = "40px";
var DEFAULT_PADDING = "0 4px";
var getStyles$A = memoizeFunction(function(theme, customStyles) {
  var _a2, _b2, _c2;
  var baseButtonStyles = getStyles$D(theme);
  var actionButtonStyles = {
    root: {
      padding: DEFAULT_PADDING,
      height: DEFAULT_BUTTON_HEIGHT,
      color: theme.palette.neutralPrimary,
      backgroundColor: "transparent",
      border: "1px solid transparent",
      selectors: (_a2 = {}, _a2[HighContrastSelector] = {
        borderColor: "Window"
      }, _a2)
    },
    rootHovered: {
      color: theme.palette.themePrimary,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        color: "Highlight"
      }, _b2)
    },
    iconHovered: {
      color: theme.palette.themePrimary
    },
    rootPressed: {
      color: theme.palette.black
    },
    rootExpanded: {
      color: theme.palette.themePrimary
    },
    iconPressed: {
      color: theme.palette.themeDarker
    },
    rootDisabled: {
      color: theme.palette.neutralTertiary,
      backgroundColor: "transparent",
      borderColor: "transparent",
      selectors: (_c2 = {}, _c2[HighContrastSelector] = {
        color: "GrayText"
      }, _c2)
    },
    rootChecked: {
      color: theme.palette.black
    },
    iconChecked: {
      color: theme.palette.themeDarker
    },
    flexContainer: {
      justifyContent: "flex-start"
    },
    icon: {
      color: theme.palette.themeDarkAlt
    },
    iconDisabled: {
      color: "inherit"
    },
    menuIcon: {
      color: theme.palette.neutralSecondary
    },
    textContainer: {
      flexGrow: 0
    }
  };
  return concatStyleSets(baseButtonStyles, actionButtonStyles, customStyles);
});
var ActionButton = (
  /** @class */
  function(_super) {
    __extends(ActionButton2, _super);
    function ActionButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ActionButton2.prototype.render = function() {
      var _a2 = this.props, styles2 = _a2.styles, theme = _a2.theme;
      return React__namespace.createElement(BaseButton, __assign$1({}, this.props, { variantClassName: "ms-Button--action ms-Button--command", styles: getStyles$A(theme, styles2), onRenderDescription: nullRender }));
    };
    ActionButton2 = __decorate([
      customizable("ActionButton", ["theme", "styles"], true)
    ], ActionButton2);
    return ActionButton2;
  }(React__namespace.Component)
);
var getStyles$z = memoizeFunction(function(theme, customStyles) {
  var _a2;
  var baseButtonStyles = getStyles$D(theme);
  var splitButtonStyles = getStyles$C(theme);
  var palette = theme.palette, semanticColors = theme.semanticColors;
  var iconButtonStyles = {
    root: {
      padding: "0 4px",
      width: "32px",
      height: "32px",
      backgroundColor: "transparent",
      border: "none",
      color: semanticColors.link
    },
    rootHovered: {
      color: palette.themeDarkAlt,
      backgroundColor: palette.neutralLighter,
      selectors: (_a2 = {}, _a2[HighContrastSelector] = {
        borderColor: "Highlight",
        color: "Highlight"
      }, _a2)
    },
    rootHasMenu: {
      width: "auto"
    },
    rootPressed: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootExpanded: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootChecked: {
      color: palette.themeDark,
      backgroundColor: palette.neutralLight
    },
    rootCheckedHovered: {
      color: palette.themeDark,
      backgroundColor: palette.neutralQuaternaryAlt
    },
    rootDisabled: {
      color: palette.neutralTertiaryAlt
    }
  };
  return concatStyleSets(baseButtonStyles, iconButtonStyles, splitButtonStyles, customStyles);
});
var IconButton = (
  /** @class */
  function(_super) {
    __extends(IconButton2, _super);
    function IconButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IconButton2.prototype.render = function() {
      var _a2 = this.props, styles2 = _a2.styles, theme = _a2.theme;
      return React__namespace.createElement(BaseButton, __assign$1({}, this.props, { variantClassName: "ms-Button--icon", styles: getStyles$z(theme, styles2), onRenderText: nullRender, onRenderDescription: nullRender }));
    };
    IconButton2 = __decorate([
      customizable("IconButton", ["theme", "styles"], true)
    ], IconButton2);
    return IconButton2;
  }(React__namespace.Component)
);
var PrimaryButton = (
  /** @class */
  function(_super) {
    __extends(PrimaryButton2, _super);
    function PrimaryButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PrimaryButton2.prototype.render = function() {
      return React__namespace.createElement(DefaultButton, __assign$1({}, this.props, { primary: true, onRenderDescription: nullRender }));
    };
    PrimaryButton2 = __decorate([
      customizable("PrimaryButton", ["theme", "styles"], true)
    ], PrimaryButton2);
    return PrimaryButton2;
  }(React__namespace.Component)
);
var getStyles$y = memoizeFunction(function(theme, customStyles, focusInset, focusColor) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p;
  var baseButtonStyles = getStyles$D(theme);
  var baseSplitButtonStyles = getStyles$C(theme);
  var p = theme.palette, semanticColors = theme.semanticColors;
  var commandButtonHighContrastFocus = {
    left: 4,
    top: 4,
    bottom: 4,
    right: 4,
    border: "none"
  };
  var commandButtonStyles = {
    root: [
      getFocusStyle(theme, {
        inset: 2,
        highContrastStyle: commandButtonHighContrastFocus,
        borderColor: "transparent"
      }),
      theme.fonts.medium,
      {
        minWidth: "40px",
        backgroundColor: p.white,
        color: p.neutralPrimary,
        padding: "0 4px",
        border: "none",
        borderRadius: 0,
        selectors: (_a2 = {}, _a2[HighContrastSelector] = {
          border: "none"
        }, _a2)
      }
    ],
    rootHovered: {
      backgroundColor: p.neutralLighter,
      color: p.neutralDark,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        color: "Highlight"
      }, _b2["." + ButtonGlobalClassNames.msButtonIcon] = {
        color: p.themeDarkAlt
      }, _b2["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
        color: p.neutralPrimary
      }, _b2)
    },
    rootPressed: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_c2 = {}, _c2["." + ButtonGlobalClassNames.msButtonIcon] = {
        color: p.themeDark
      }, _c2["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
        color: p.neutralPrimary
      }, _c2)
    },
    rootChecked: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_d2 = {}, _d2["." + ButtonGlobalClassNames.msButtonIcon] = {
        color: p.themeDark
      }, _d2["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
        color: p.neutralPrimary
      }, _d2)
    },
    rootCheckedHovered: {
      backgroundColor: p.neutralQuaternaryAlt,
      selectors: (_e2 = {}, _e2["." + ButtonGlobalClassNames.msButtonIcon] = {
        color: p.themeDark
      }, _e2["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
        color: p.neutralPrimary
      }, _e2)
    },
    rootExpanded: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: (_f = {}, _f["." + ButtonGlobalClassNames.msButtonIcon] = {
        color: p.themeDark
      }, _f["." + ButtonGlobalClassNames.msButtonMenuIcon] = {
        color: p.neutralPrimary
      }, _f)
    },
    rootExpandedHovered: {
      backgroundColor: p.neutralQuaternaryAlt
    },
    rootDisabled: {
      backgroundColor: p.white,
      selectors: (_g = {}, _g["." + ButtonGlobalClassNames.msButtonIcon] = {
        color: semanticColors.disabledBodySubtext,
        selectors: (_h = {}, _h[HighContrastSelector] = __assign$1({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _h)
      }, _g[HighContrastSelector] = __assign$1({ color: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _g)
    },
    // Split button styles
    splitButtonContainer: {
      height: "100%",
      selectors: (_j = {}, _j[HighContrastSelector] = {
        border: "none"
      }, _j)
    },
    splitButtonDividerDisabled: {
      selectors: (_k = {}, _k[HighContrastSelector] = {
        backgroundColor: "Window"
      }, _k)
    },
    splitButtonDivider: {
      backgroundColor: p.neutralTertiaryAlt
    },
    splitButtonMenuButton: {
      backgroundColor: p.white,
      border: "none",
      borderTopRightRadius: "0",
      borderBottomRightRadius: "0",
      color: p.neutralSecondary,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralLighter,
          color: p.neutralDark,
          selectors: (_l = {}, _l[HighContrastSelector] = {
            color: "Highlight"
          }, _l["." + ButtonGlobalClassNames.msButtonIcon] = {
            color: p.neutralPrimary
          }, _l)
        },
        ":active": {
          backgroundColor: p.neutralLight,
          selectors: (_m = {}, _m["." + ButtonGlobalClassNames.msButtonIcon] = {
            color: p.neutralPrimary
          }, _m)
        }
      }
    },
    splitButtonMenuButtonDisabled: {
      backgroundColor: p.white,
      selectors: (_o = {}, _o[HighContrastSelector] = __assign$1({ color: "GrayText", border: "none", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _o)
    },
    splitButtonMenuButtonChecked: {
      backgroundColor: p.neutralLight,
      color: p.neutralDark,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuButtonExpanded: {
      backgroundColor: p.neutralLight,
      color: p.black,
      selectors: {
        ":hover": {
          backgroundColor: p.neutralQuaternaryAlt
        }
      }
    },
    splitButtonMenuIcon: {
      color: p.neutralPrimary
    },
    splitButtonMenuIconDisabled: {
      color: p.neutralTertiary
    },
    label: {
      fontWeight: "normal"
      // theme.fontWeights.semibold,
    },
    icon: {
      color: p.themePrimary
    },
    menuIcon: (_p = {
      color: p.neutralSecondary
    }, _p[HighContrastSelector] = {
      color: "GrayText"
    }, _p)
  };
  return concatStyleSets(baseButtonStyles, baseSplitButtonStyles, commandButtonStyles, customStyles);
});
var CommandBarButton = (
  /** @class */
  function(_super) {
    __extends(CommandBarButton2, _super);
    function CommandBarButton2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CommandBarButton2.prototype.render = function() {
      var _a2 = this.props, styles2 = _a2.styles, theme = _a2.theme;
      return React__namespace.createElement(BaseButton, __assign$1({}, this.props, { variantClassName: "ms-Button--commandBar", styles: getStyles$y(theme, styles2), onRenderDescription: nullRender }));
    };
    CommandBarButton2 = __decorate([
      customizable("CommandBarButton", ["theme", "styles"], true)
    ], CommandBarButton2);
    return CommandBarButton2;
  }(React__namespace.Component)
);
var CommandButton = ActionButton;
var ResizeGroupDirection;
(function(ResizeGroupDirection2) {
  ResizeGroupDirection2[ResizeGroupDirection2["horizontal"] = 0] = "horizontal";
  ResizeGroupDirection2[ResizeGroupDirection2["vertical"] = 1] = "vertical";
})(ResizeGroupDirection || (ResizeGroupDirection = {}));
var RESIZE_DELAY$2 = 16;
var getMeasurementCache = function() {
  var measurementsCache = {};
  return {
    /**
     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a
     * corresponding entry in the measurementsCache, then it will return that value.
     * Returns undefined otherwise.
     */
    getCachedMeasurement: function(data) {
      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {
        return measurementsCache[data.cacheKey];
      }
      return void 0;
    },
    /**
     * Should be called whenever there is a new measurement associated with a given data object.
     * If the data has a cacheKey, store that measurement in the measurementsCache.
     */
    addMeasurementToCache: function(data, measurement) {
      if (data.cacheKey) {
        measurementsCache[data.cacheKey] = measurement;
      }
    }
  };
};
var getNextResizeGroupStateProvider = function(measurementCache) {
  if (measurementCache === void 0) {
    measurementCache = getMeasurementCache();
  }
  var _measurementCache = measurementCache;
  var _containerDimension;
  function _getMeasuredDimension(measuredData, getElementToMeasureDimension) {
    var cachedDimension = _measurementCache.getCachedMeasurement(measuredData);
    if (cachedDimension !== void 0) {
      return cachedDimension;
    }
    var measuredDimension = getElementToMeasureDimension();
    _measurementCache.addMeasurementToCache(measuredData, measuredDimension);
    return measuredDimension;
  }
  function _shrinkContentsUntilTheyFit(data, onReduceData, getElementToMeasureDimension) {
    var dataToMeasure = data;
    var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);
    while (measuredDimension > _containerDimension) {
      var nextMeasuredData = onReduceData(dataToMeasure);
      if (nextMeasuredData === void 0) {
        return {
          renderedData: dataToMeasure,
          resizeDirection: void 0,
          dataToMeasure: void 0
        };
      }
      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);
      if (measuredDimension === void 0) {
        return {
          dataToMeasure: nextMeasuredData,
          resizeDirection: "shrink"
        };
      }
      dataToMeasure = nextMeasuredData;
    }
    return {
      renderedData: dataToMeasure,
      resizeDirection: void 0,
      dataToMeasure: void 0
    };
  }
  function _growDataUntilItDoesNotFit(data, onGrowData, getElementToMeasureDimension, onReduceData) {
    var dataToMeasure = data;
    var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);
    while (measuredDimension < _containerDimension) {
      var nextMeasuredData = onGrowData(dataToMeasure);
      if (nextMeasuredData === void 0) {
        return {
          renderedData: dataToMeasure,
          resizeDirection: void 0,
          dataToMeasure: void 0
        };
      }
      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);
      if (measuredDimension === void 0) {
        return {
          dataToMeasure: nextMeasuredData
        };
      }
      dataToMeasure = nextMeasuredData;
    }
    return __assign$1({ resizeDirection: "shrink" }, _shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureDimension));
  }
  function _updateContainerDimension(newDimension, fullDimensionData, renderedData, onGrowData) {
    var nextState;
    if (newDimension > _containerDimension) {
      if (onGrowData) {
        nextState = {
          resizeDirection: "grow",
          dataToMeasure: onGrowData(renderedData)
        };
      } else {
        nextState = {
          resizeDirection: "shrink",
          dataToMeasure: fullDimensionData
        };
      }
    } else {
      nextState = {
        resizeDirection: "shrink",
        dataToMeasure: renderedData
      };
    }
    _containerDimension = newDimension;
    return __assign$1(__assign$1({}, nextState), { measureContainer: false });
  }
  function getNextState(props, currentState, getElementToMeasureDimension, newContainerDimension) {
    if (newContainerDimension === void 0 && currentState.dataToMeasure === void 0) {
      return void 0;
    }
    if (newContainerDimension) {
      if (_containerDimension && currentState.renderedData && !currentState.dataToMeasure) {
        return __assign$1(__assign$1({}, currentState), _updateContainerDimension(newContainerDimension, props.data, currentState.renderedData, props.onGrowData));
      }
      _containerDimension = newContainerDimension;
    }
    var nextState = __assign$1(__assign$1({}, currentState), { measureContainer: false });
    if (currentState.dataToMeasure) {
      if (currentState.resizeDirection === "grow" && props.onGrowData) {
        nextState = __assign$1(__assign$1({}, nextState), _growDataUntilItDoesNotFit(currentState.dataToMeasure, props.onGrowData, getElementToMeasureDimension, props.onReduceData));
      } else {
        nextState = __assign$1(__assign$1({}, nextState), _shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureDimension));
      }
    }
    return nextState;
  }
  function shouldRenderDataForMeasurement(dataToMeasure) {
    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== void 0) {
      return false;
    }
    return true;
  }
  function getInitialResizeGroupState(data) {
    return {
      dataToMeasure: __assign$1({}, data),
      resizeDirection: "grow",
      measureContainer: true
    };
  }
  return {
    getNextState,
    shouldRenderDataForMeasurement,
    getInitialResizeGroupState
  };
};
var MeasuredContext = React__namespace.createContext({ isMeasured: false });
var hiddenDivStyles = { position: "fixed", visibility: "hidden" };
var hiddenParentStyles = { position: "relative" };
var COMPONENT_NAME$9 = "ResizeGroup";
function resizeDataReducer(state, action) {
  var _a2;
  switch (action.type) {
    case "resizeData":
      return __assign$1({}, action.value);
    case "dataToMeasure":
      return __assign$1(__assign$1({}, state), { dataToMeasure: action.value, resizeDirection: "grow", measureContainer: true });
    default:
      return __assign$1(__assign$1({}, state), (_a2 = {}, _a2[action.type] = action.value, _a2));
  }
}
function useResizeState(props, nextResizeGroupStateProvider, rootRef) {
  var initialStateData = useConst(function() {
    return nextResizeGroupStateProvider.getInitialResizeGroupState(props.data);
  });
  var _a2 = React__namespace.useReducer(resizeDataReducer, initialStateData), resizeData = _a2[0], dispatchResizeDataAction = _a2[1];
  React__namespace.useEffect(function() {
    dispatchResizeDataAction({
      type: "dataToMeasure",
      value: props.data
    });
  }, [props.data]);
  var stateRef = React__namespace.useRef(initialStateData);
  stateRef.current = __assign$1({}, resizeData);
  var updateResizeState = React__namespace.useCallback(function(nextState) {
    if (nextState) {
      dispatchResizeDataAction({
        type: "resizeData",
        value: nextState
      });
    }
  }, []);
  var remeasure = React__namespace.useCallback(function() {
    if (rootRef.current) {
      dispatchResizeDataAction({
        type: "measureContainer",
        value: true
      });
    }
  }, [rootRef]);
  return [stateRef, updateResizeState, remeasure];
}
function useResizingBehavior(props, rootRef) {
  var nextResizeGroupStateProvider = useConst(getNextResizeGroupStateProvider);
  var initialHiddenDiv = React__namespace.useRef(null);
  var updateHiddenDiv = React__namespace.useRef(null);
  var hasRenderedContent = React__namespace.useRef(false);
  var async = useAsync();
  var _a2 = useResizeState(props, nextResizeGroupStateProvider, rootRef), stateRef = _a2[0], updateResizeState = _a2[1], remeasure = _a2[2];
  React__namespace.useEffect(function() {
    var _a3;
    if (stateRef.current.renderedData) {
      hasRenderedContent.current = true;
      (_a3 = props.dataDidRender) === null || _a3 === void 0 ? void 0 : _a3.call(props, stateRef.current.renderedData);
    }
  });
  React__namespace.useEffect(function() {
    async.requestAnimationFrame(function() {
      var containerDimension = void 0;
      if (stateRef.current.measureContainer && rootRef.current) {
        var boundingRect = rootRef.current.getBoundingClientRect();
        containerDimension = props.direction === ResizeGroupDirection.vertical ? boundingRect.height : boundingRect.width;
      }
      var nextState = nextResizeGroupStateProvider.getNextState(props, stateRef.current, function() {
        var refToMeasure = !hasRenderedContent.current ? initialHiddenDiv : updateHiddenDiv;
        if (!refToMeasure.current) {
          return 0;
        }
        var measuredBoundingRect = refToMeasure.current.getBoundingClientRect();
        return props.direction === ResizeGroupDirection.vertical ? measuredBoundingRect.height : measuredBoundingRect.width;
      }, containerDimension);
      updateResizeState(nextState);
    }, rootRef.current);
  });
  var win2 = useWindow();
  useOnEvent(win2, "resize", async.debounce(remeasure, RESIZE_DELAY$2, { leading: true }));
  var dataNeedsMeasuring = nextResizeGroupStateProvider.shouldRenderDataForMeasurement(stateRef.current.dataToMeasure);
  var isInitialMeasure = !hasRenderedContent.current && dataNeedsMeasuring;
  return [
    stateRef.current.dataToMeasure,
    stateRef.current.renderedData,
    remeasure,
    initialHiddenDiv,
    updateHiddenDiv,
    dataNeedsMeasuring,
    isInitialMeasure
  ];
}
function useDebugWarnings$2(props) {
  if (process.env.NODE_ENV !== "production") {
    useWarnings({
      name: COMPONENT_NAME$9,
      props,
      deprecations: { styles: "className" }
    });
  }
}
var measuredContextValue = { isMeasured: true };
var ResizeGroupBase = React__namespace.forwardRef(function(props, forwardedRef) {
  var rootRef = React__namespace.useRef(null);
  var mergedRootRef = useMergedRefs(rootRef, forwardedRef);
  var _a2 = useResizingBehavior(props, rootRef), dataToMeasure = _a2[0], renderedData = _a2[1], remeasure = _a2[2], initialHiddenDiv = _a2[3], updateHiddenDiv = _a2[4], dataNeedsMeasuring = _a2[5], isInitialMeasure = _a2[6];
  React__namespace.useImperativeHandle(props.componentRef, function() {
    return { remeasure };
  }, [remeasure]);
  useDebugWarnings$2(props);
  var className = props.className, onRenderData = props.onRenderData;
  var divProps = getNativeProps(props, divProperties, ["data"]);
  return React__namespace.createElement(
    "div",
    __assign$1({}, divProps, { className, ref: mergedRootRef }),
    React__namespace.createElement(
      "div",
      { style: hiddenParentStyles },
      dataNeedsMeasuring && !isInitialMeasure && React__namespace.createElement(
        "div",
        { style: hiddenDivStyles, ref: updateHiddenDiv },
        React__namespace.createElement(MeasuredContext.Provider, { value: measuredContextValue }, onRenderData(dataToMeasure))
      ),
      React__namespace.createElement("div", { ref: initialHiddenDiv, style: isInitialMeasure ? hiddenDivStyles : void 0, "data-automation-id": "visibleContent" }, isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData))
    )
  );
});
ResizeGroupBase.displayName = "ResizeGroupBase";
var ResizeGroup = ResizeGroupBase;
var DayOfWeek;
(function(DayOfWeek2) {
  DayOfWeek2[DayOfWeek2["Sunday"] = 0] = "Sunday";
  DayOfWeek2[DayOfWeek2["Monday"] = 1] = "Monday";
  DayOfWeek2[DayOfWeek2["Tuesday"] = 2] = "Tuesday";
  DayOfWeek2[DayOfWeek2["Wednesday"] = 3] = "Wednesday";
  DayOfWeek2[DayOfWeek2["Thursday"] = 4] = "Thursday";
  DayOfWeek2[DayOfWeek2["Friday"] = 5] = "Friday";
  DayOfWeek2[DayOfWeek2["Saturday"] = 6] = "Saturday";
})(DayOfWeek || (DayOfWeek = {}));
var MonthOfYear;
(function(MonthOfYear2) {
  MonthOfYear2[MonthOfYear2["January"] = 0] = "January";
  MonthOfYear2[MonthOfYear2["February"] = 1] = "February";
  MonthOfYear2[MonthOfYear2["March"] = 2] = "March";
  MonthOfYear2[MonthOfYear2["April"] = 3] = "April";
  MonthOfYear2[MonthOfYear2["May"] = 4] = "May";
  MonthOfYear2[MonthOfYear2["June"] = 5] = "June";
  MonthOfYear2[MonthOfYear2["July"] = 6] = "July";
  MonthOfYear2[MonthOfYear2["August"] = 7] = "August";
  MonthOfYear2[MonthOfYear2["September"] = 8] = "September";
  MonthOfYear2[MonthOfYear2["October"] = 9] = "October";
  MonthOfYear2[MonthOfYear2["November"] = 10] = "November";
  MonthOfYear2[MonthOfYear2["December"] = 11] = "December";
})(MonthOfYear || (MonthOfYear = {}));
var FirstWeekOfYear;
(function(FirstWeekOfYear2) {
  FirstWeekOfYear2[FirstWeekOfYear2["FirstDay"] = 0] = "FirstDay";
  FirstWeekOfYear2[FirstWeekOfYear2["FirstFullWeek"] = 1] = "FirstFullWeek";
  FirstWeekOfYear2[FirstWeekOfYear2["FirstFourDayWeek"] = 2] = "FirstFourDayWeek";
})(FirstWeekOfYear || (FirstWeekOfYear = {}));
var DateRangeType;
(function(DateRangeType2) {
  DateRangeType2[DateRangeType2["Day"] = 0] = "Day";
  DateRangeType2[DateRangeType2["Week"] = 1] = "Week";
  DateRangeType2[DateRangeType2["Month"] = 2] = "Month";
  DateRangeType2[DateRangeType2["WorkWeek"] = 3] = "WorkWeek";
})(DateRangeType || (DateRangeType = {}));
var DAYS_IN_WEEK = 7;
var TimeConstants = {
  MillisecondsInOneDay: 864e5,
  MillisecondsIn1Sec: 1e3,
  MillisecondsIn1Min: 6e4,
  MillisecondsIn30Mins: 18e5,
  MillisecondsIn1Hour: 36e5,
  MinutesInOneDay: 1440,
  MinutesInOneHour: 60,
  DaysInOneWeek: 7,
  MonthInOneYear: 12,
  HoursInOneDay: 24,
  SecondsInOneMinute: 60,
  OffsetTo24HourFormat: 12,
  /**
   * Matches a time string. Groups:
   * 1. hours (with or without leading 0)
   * 2. minutes
   * 3. seconds (optional)
   * 4. meridiem (am/pm, case-insensitive, optional)
   */
  TimeFormatRegex: /^(\d\d?):(\d\d):?(\d\d)? ?([ap]m)?/i
};
function addDays(date, days2) {
  var result = new Date(date.getTime());
  result.setDate(result.getDate() + days2);
  return result;
}
function addWeeks(date, weeks) {
  return addDays(date, weeks * TimeConstants.DaysInOneWeek);
}
function addMonths(date, months2) {
  var result = new Date(date.getTime());
  var newMonth = result.getMonth() + months2;
  result.setMonth(newMonth);
  if (result.getMonth() !== (newMonth % TimeConstants.MonthInOneYear + TimeConstants.MonthInOneYear) % TimeConstants.MonthInOneYear) {
    result = addDays(result, -result.getDate());
  }
  return result;
}
function addYears(date, years) {
  var result = new Date(date.getTime());
  result.setFullYear(date.getFullYear() + years);
  if (result.getMonth() !== (date.getMonth() % TimeConstants.MonthInOneYear + TimeConstants.MonthInOneYear) % TimeConstants.MonthInOneYear) {
    result = addDays(result, -result.getDate());
  }
  return result;
}
function getMonthStart(date) {
  return new Date(date.getFullYear(), date.getMonth(), 1, 0, 0, 0, 0);
}
function getMonthEnd(date) {
  return new Date(date.getFullYear(), date.getMonth() + 1, 0, 0, 0, 0, 0);
}
function getYearStart(date) {
  return new Date(date.getFullYear(), 0, 1, 0, 0, 0, 0);
}
function getYearEnd(date) {
  return new Date(date.getFullYear() + 1, 0, 0, 0, 0, 0, 0);
}
function setMonth(date, month) {
  return addMonths(date, month - date.getMonth());
}
function compareDates(date1, date2) {
  if (!date1 && !date2) {
    return true;
  } else if (!date1 || !date2) {
    return false;
  } else {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  }
}
function compareDatePart(date1, date2) {
  return getDatePartHashValue(date1) - getDatePartHashValue(date2);
}
function getDateRangeArray(date, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView) {
  if (daysToSelectInDayView === void 0) {
    daysToSelectInDayView = 1;
  }
  var datesArray = [];
  var startDate;
  var endDate = null;
  if (!workWeekDays) {
    workWeekDays = [DayOfWeek.Monday, DayOfWeek.Tuesday, DayOfWeek.Wednesday, DayOfWeek.Thursday, DayOfWeek.Friday];
  }
  daysToSelectInDayView = Math.max(daysToSelectInDayView, 1);
  switch (dateRangeType) {
    case DateRangeType.Day:
      startDate = getDatePart(date);
      endDate = addDays(startDate, daysToSelectInDayView);
      break;
    case DateRangeType.Week:
    case DateRangeType.WorkWeek:
      startDate = getStartDateOfWeek(getDatePart(date), firstDayOfWeek);
      endDate = addDays(startDate, TimeConstants.DaysInOneWeek);
      break;
    case DateRangeType.Month:
      startDate = new Date(date.getFullYear(), date.getMonth(), 1);
      endDate = addMonths(startDate, 1);
      break;
    default:
      throw new Error("Unexpected object: " + dateRangeType);
  }
  var nextDate = startDate;
  do {
    if (dateRangeType !== DateRangeType.WorkWeek) {
      datesArray.push(nextDate);
    } else if (workWeekDays.indexOf(nextDate.getDay()) !== -1) {
      datesArray.push(nextDate);
    }
    nextDate = addDays(nextDate, 1);
  } while (!compareDates(nextDate, endDate));
  return datesArray;
}
function isInDateRangeArray(date, dateRange) {
  for (var _i = 0, dateRange_1 = dateRange; _i < dateRange_1.length; _i++) {
    var dateInRange = dateRange_1[_i];
    if (compareDates(date, dateInRange)) {
      return true;
    }
  }
  return false;
}
function getWeekNumbersInMonth(weeksInMonth, firstDayOfWeek, firstWeekOfYear, navigatedDate) {
  var selectedYear = navigatedDate.getFullYear();
  var selectedMonth = navigatedDate.getMonth();
  var dayOfMonth = 1;
  var fistDayOfMonth = new Date(selectedYear, selectedMonth, dayOfMonth);
  var endOfFirstWeek = dayOfMonth + (firstDayOfWeek + TimeConstants.DaysInOneWeek - 1) - adjustWeekDay(firstDayOfWeek, fistDayOfMonth.getDay());
  var endOfWeekRange = new Date(selectedYear, selectedMonth, endOfFirstWeek);
  dayOfMonth = endOfWeekRange.getDate();
  var weeksArray = [];
  for (var i = 0; i < weeksInMonth; i++) {
    weeksArray.push(getWeekNumber(endOfWeekRange, firstDayOfWeek, firstWeekOfYear));
    dayOfMonth += TimeConstants.DaysInOneWeek;
    endOfWeekRange = new Date(selectedYear, selectedMonth, dayOfMonth);
  }
  return weeksArray;
}
function getWeekNumber(date, firstDayOfWeek, firstWeekOfYear) {
  var fourDayWeek = 4;
  switch (firstWeekOfYear) {
    case FirstWeekOfYear.FirstFullWeek:
      return getWeekOfYearFullDays(date, firstDayOfWeek, TimeConstants.DaysInOneWeek);
    case FirstWeekOfYear.FirstFourDayWeek:
      return getWeekOfYearFullDays(date, firstDayOfWeek, fourDayWeek);
    default:
      return getFirstDayWeekOfYear(date, firstDayOfWeek);
  }
}
function getStartDateOfWeek(date, firstDayOfWeek) {
  var daysOffset = firstDayOfWeek - date.getDay();
  if (daysOffset > 0) {
    daysOffset -= TimeConstants.DaysInOneWeek;
  }
  return addDays(date, daysOffset);
}
function getDatePart(date) {
  return new Date(date.getFullYear(), date.getMonth(), date.getDate());
}
function getDatePartHashValue(date) {
  return date.getDate() + (date.getMonth() << 5) + (date.getFullYear() << 9);
}
function getWeekOfYearFullDays(date, firstDayOfWeek, numberOfFullDays) {
  var dayOfYear = getDayOfYear(date) - 1;
  var num = date.getDay() - dayOfYear % TimeConstants.DaysInOneWeek;
  var lastDayOfPrevYear = new Date(date.getFullYear() - 1, MonthOfYear.December, 31);
  var daysInYear = getDayOfYear(lastDayOfPrevYear) - 1;
  var num2 = (firstDayOfWeek - num + 2 * TimeConstants.DaysInOneWeek) % TimeConstants.DaysInOneWeek;
  if (num2 !== 0 && num2 >= numberOfFullDays) {
    num2 -= TimeConstants.DaysInOneWeek;
  }
  var num3 = dayOfYear - num2;
  if (num3 < 0) {
    num -= daysInYear % TimeConstants.DaysInOneWeek;
    num2 = (firstDayOfWeek - num + 2 * TimeConstants.DaysInOneWeek) % TimeConstants.DaysInOneWeek;
    if (num2 !== 0 && num2 + 1 >= numberOfFullDays) {
      num2 -= TimeConstants.DaysInOneWeek;
    }
    num3 = daysInYear - num2;
  }
  return Math.floor(num3 / TimeConstants.DaysInOneWeek + 1);
}
function getFirstDayWeekOfYear(date, firstDayOfWeek) {
  var num = getDayOfYear(date) - 1;
  var num2 = date.getDay() - num % TimeConstants.DaysInOneWeek;
  var num3 = (num2 - firstDayOfWeek + 2 * TimeConstants.DaysInOneWeek) % TimeConstants.DaysInOneWeek;
  return Math.floor((num + num3) / TimeConstants.DaysInOneWeek + 1);
}
function adjustWeekDay(firstDayOfWeek, dateWeekDay) {
  return firstDayOfWeek !== DayOfWeek.Sunday && dateWeekDay < firstDayOfWeek ? dateWeekDay + TimeConstants.DaysInOneWeek : dateWeekDay;
}
function getDayOfYear(date) {
  var month = date.getMonth();
  var year = date.getFullYear();
  var daysUntilDate = 0;
  for (var i = 0; i < month; i++) {
    daysUntilDate += daysInMonth(i + 1, year);
  }
  daysUntilDate += date.getDate();
  return daysUntilDate;
}
function daysInMonth(month, year) {
  return new Date(year, month, 0).getDate();
}
var formatDay = function(date) {
  return date.getDate().toString();
};
var formatMonthDayYear = function(date, strings) {
  return strings.months[date.getMonth()] + " " + date.getDate() + ", " + date.getFullYear();
};
var formatMonthYear = function(date, strings) {
  return strings.months[date.getMonth()] + " " + date.getFullYear();
};
var formatMonth = function(date, strings) {
  return strings.months[date.getMonth()];
};
var formatYear = function(date) {
  return date.getFullYear().toString();
};
var DEFAULT_DATE_GRID_STRINGS = {
  months: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["S", "M", "T", "W", "T", "F", "S"]
};
var DEFAULT_DATE_FORMATTING = {
  formatDay,
  formatMonth,
  formatYear,
  formatMonthDayYear,
  formatMonthYear
};
var DEFAULT_CALENDAR_STRINGS = __assign$1(__assign$1({}, DEFAULT_DATE_GRID_STRINGS), { goToToday: "Go to today", weekNumberFormatString: "Week number {0}", prevMonthAriaLabel: "Previous month", nextMonthAriaLabel: "Next month", prevYearAriaLabel: "Previous year", nextYearAriaLabel: "Next year", prevYearRangeAriaLabel: "Previous year range", nextYearRangeAriaLabel: "Next year range", closeButtonAriaLabel: "Close", selectedDateFormatString: "Selected date {0}", todayDateFormatString: "Today's date {0}", monthPickerHeaderAriaLabel: "{0}, change year", yearPickerHeaderAriaLabel: "{0}, change month", dayMarkedAriaLabel: "marked" });
var isBeforeMinDate = function(date, options2) {
  var minDate = options2.minDate;
  return minDate ? compareDatePart(minDate, date) >= 1 : false;
};
var isAfterMaxDate = function(date, options2) {
  var maxDate = options2.maxDate;
  return maxDate ? compareDatePart(date, maxDate) >= 1 : false;
};
var isRestrictedDate = function(date, options2) {
  var restrictedDates = options2.restrictedDates, minDate = options2.minDate, maxDate = options2.maxDate;
  if (!restrictedDates && !minDate && !maxDate) {
    return false;
  }
  var inRestrictedDates = restrictedDates && restrictedDates.some(function(rd) {
    return compareDates(rd, date);
  });
  return inRestrictedDates || isBeforeMinDate(date, options2) || isAfterMaxDate(date, options2);
};
var findAvailableDate = function(options2) {
  var targetDate = options2.targetDate, initialDate = options2.initialDate, direction = options2.direction, restrictedDateOptions = __rest$1(options2, ["targetDate", "initialDate", "direction"]);
  var availableDate = targetDate;
  if (!isRestrictedDate(targetDate, restrictedDateOptions)) {
    return targetDate;
  }
  while (compareDatePart(initialDate, availableDate) !== 0 && isRestrictedDate(availableDate, restrictedDateOptions) && !isAfterMaxDate(availableDate, restrictedDateOptions) && !isBeforeMinDate(availableDate, restrictedDateOptions)) {
    availableDate = addDays(availableDate, direction);
  }
  if (compareDatePart(initialDate, availableDate) !== 0 && !isRestrictedDate(availableDate, restrictedDateOptions)) {
    return availableDate;
  }
  return void 0;
};
var getBoundedDateRange = function(dateRange, minDate, maxDate) {
  var boundedDateRange = __spreadArray([], dateRange);
  if (minDate) {
    boundedDateRange = boundedDateRange.filter(function(date) {
      return compareDatePart(date, minDate) >= 0;
    });
  }
  if (maxDate) {
    boundedDateRange = boundedDateRange.filter(function(date) {
      return compareDatePart(date, maxDate) <= 0;
    });
  }
  return boundedDateRange;
};
var isContiguous = function(days2, isSingleWeek, firstDayOfWeek) {
  var daySet = new Set(days2);
  var amountOfNoNeighbors = 0;
  for (var _i = 0, days_1 = days2; _i < days_1.length; _i++) {
    var day = days_1[_i];
    var nextDay = (day + 1) % 7;
    if (!(daySet.has(nextDay) && (!isSingleWeek || firstDayOfWeek !== nextDay))) {
      amountOfNoNeighbors++;
    }
  }
  return amountOfNoNeighbors < 2;
};
var getDateRangeTypeToUse$1 = function(dateRangeType, workWeekDays, firstDayOfWeek) {
  if (workWeekDays && dateRangeType === DateRangeType.WorkWeek) {
    if (!isContiguous(workWeekDays, true, firstDayOfWeek) || workWeekDays.length === 0) {
      return DateRangeType.Week;
    }
  }
  return dateRangeType;
};
var getDayGrid = function(options2) {
  var selectedDate = options2.selectedDate, dateRangeType = options2.dateRangeType, firstDayOfWeek = options2.firstDayOfWeek, today = options2.today, minDate = options2.minDate, maxDate = options2.maxDate, weeksToShow = options2.weeksToShow, workWeekDays = options2.workWeekDays, daysToSelectInDayView = options2.daysToSelectInDayView, restrictedDates = options2.restrictedDates, markedDays = options2.markedDays;
  var restrictedDateOptions = { minDate, maxDate, restrictedDates };
  var todaysDate = today || /* @__PURE__ */ new Date();
  var navigatedDate = options2.navigatedDate ? options2.navigatedDate : todaysDate;
  var date;
  if (weeksToShow && weeksToShow <= 4) {
    date = new Date(navigatedDate.getFullYear(), navigatedDate.getMonth(), navigatedDate.getDate());
  } else {
    date = new Date(navigatedDate.getFullYear(), navigatedDate.getMonth(), 1);
  }
  var weeks = [];
  while (date.getDay() !== firstDayOfWeek) {
    date.setDate(date.getDate() - 1);
  }
  date = addDays(date, -DAYS_IN_WEEK);
  var isAllDaysOfWeekOutOfMonth = false;
  var selectedDateRangeType = getDateRangeTypeToUse$1(dateRangeType, workWeekDays, firstDayOfWeek);
  var selectedDates = [];
  if (selectedDate) {
    selectedDates = getDateRangeArray(selectedDate, selectedDateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);
    selectedDates = getBoundedDateRange(selectedDates, minDate, maxDate);
  }
  var shouldGetWeeks = true;
  for (var weekIndex = 0; shouldGetWeeks; weekIndex++) {
    var week = [];
    isAllDaysOfWeekOutOfMonth = true;
    var _loop_1 = function(dayIndex2) {
      var originalDate = new Date(date.getTime());
      var dayInfo = {
        key: date.toString(),
        date: date.getDate().toString(),
        originalDate,
        isInMonth: date.getMonth() === navigatedDate.getMonth(),
        isToday: compareDates(todaysDate, date),
        isSelected: isInDateRangeArray(date, selectedDates),
        isInBounds: !isRestrictedDate(date, restrictedDateOptions),
        isMarked: (markedDays === null || markedDays === void 0 ? void 0 : markedDays.some(function(markedDay) {
          return compareDates(originalDate, markedDay);
        })) || false
      };
      week.push(dayInfo);
      if (dayInfo.isInMonth) {
        isAllDaysOfWeekOutOfMonth = false;
      }
      date.setDate(date.getDate() + 1);
    };
    for (var dayIndex = 0; dayIndex < DAYS_IN_WEEK; dayIndex++) {
      _loop_1(dayIndex);
    }
    shouldGetWeeks = weeksToShow ? weekIndex < weeksToShow + 1 : !isAllDaysOfWeekOutOfMonth || weekIndex === 0;
    weeks.push(week);
  }
  return weeks;
};
var CalendarMonthHeaderRow = function(props) {
  var showWeekNumbers = props.showWeekNumbers, strings = props.strings, firstDayOfWeek = props.firstDayOfWeek, allFocusable = props.allFocusable, weeksToShow = props.weeksToShow, weeks = props.weeks, classNames2 = props.classNames;
  var dayLabels = strings.shortDays.slice();
  var firstOfMonthIndex = findIndex(weeks[1], function(day) {
    return day.originalDate.getDate() === 1;
  });
  if (weeksToShow === 1 && firstOfMonthIndex >= 0) {
    var firstOfMonthIndexOffset = (firstOfMonthIndex + firstDayOfWeek) % DAYS_IN_WEEK;
    dayLabels[firstOfMonthIndexOffset] = strings.shortMonths[weeks[1][firstOfMonthIndex].originalDate.getMonth()];
  }
  return React__namespace.createElement(
    "tr",
    null,
    showWeekNumbers && React__namespace.createElement("th", { className: classNames2.dayCell }),
    dayLabels.map(function(val, index2) {
      var i = (index2 + firstDayOfWeek) % DAYS_IN_WEEK;
      var label = strings.days[i];
      return React__namespace.createElement("th", { className: css$3(classNames2.dayCell, classNames2.weekDayLabelCell), scope: "col", key: dayLabels[i] + " " + index2, title: label, "aria-label": label, "data-is-focusable": allFocusable ? true : void 0 }, dayLabels[i]);
    })
  );
};
var CalendarGridDayCell = function(props) {
  var _a2;
  var navigatedDate = props.navigatedDate, dateTimeFormatter = props.dateTimeFormatter, allFocusable = props.allFocusable, strings = props.strings, activeDescendantId = props.activeDescendantId, navigatedDayRef = props.navigatedDayRef, calculateRoundedStyles = props.calculateRoundedStyles, weeks = props.weeks, classNames2 = props.classNames, day = props.day, dayIndex = props.dayIndex, weekIndex = props.weekIndex, weekCorners = props.weekCorners, ariaHidden = props.ariaHidden, customDayCellRef = props.customDayCellRef, dateRangeType = props.dateRangeType, daysToSelectInDayView = props.daysToSelectInDayView, onSelectDate = props.onSelectDate, restrictedDates = props.restrictedDates, minDate = props.minDate, maxDate = props.maxDate, onNavigateDate = props.onNavigateDate, getDayInfosInRangeOfDay = props.getDayInfosInRangeOfDay, getRefsFromDayInfos = props.getRefsFromDayInfos;
  var cornerStyle = (_a2 = weekCorners === null || weekCorners === void 0 ? void 0 : weekCorners[weekIndex + "_" + dayIndex]) !== null && _a2 !== void 0 ? _a2 : "";
  var isNavigatedDate = compareDates(navigatedDate, day.originalDate);
  var navigateMonthEdge = function(ev, date) {
    var targetDate = void 0;
    var direction = 1;
    if (ev.which === KeyCodes.up) {
      targetDate = addWeeks(date, -1);
      direction = -1;
    } else if (ev.which === KeyCodes.down) {
      targetDate = addWeeks(date, 1);
    } else if (ev.which === getRTLSafeKeyCode(KeyCodes.left)) {
      targetDate = addDays(date, -1);
      direction = -1;
    } else if (ev.which === getRTLSafeKeyCode(KeyCodes.right)) {
      targetDate = addDays(date, 1);
    }
    if (!targetDate) {
      return;
    }
    var findAvailableDateOptions = {
      initialDate: date,
      targetDate,
      direction,
      restrictedDates,
      minDate,
      maxDate
    };
    var nextDate = findAvailableDate(findAvailableDateOptions);
    if (!nextDate) {
      findAvailableDateOptions.direction = -direction;
      nextDate = findAvailableDate(findAvailableDateOptions);
    }
    var isInCurrentView = weeks && nextDate && weeks.slice(1, weeks.length - 1).some(function(week) {
      return week.some(function(dayToCompare) {
        return compareDates(dayToCompare.originalDate, nextDate);
      });
    });
    if (isInCurrentView) {
      return;
    }
    if (nextDate) {
      onNavigateDate(nextDate, true);
      ev.preventDefault();
    }
  };
  var onMouseOverDay = function(ev) {
    var dayInfos = getDayInfosInRangeOfDay(day);
    var dayRefs = getRefsFromDayInfos(dayInfos);
    dayRefs.forEach(function(dayRef, index2) {
      var _a3;
      if (dayRef) {
        dayRef.classList.add("ms-CalendarDay-hoverStyle");
        if (!dayInfos[index2].isSelected && dateRangeType === DateRangeType.Day && daysToSelectInDayView && daysToSelectInDayView > 1) {
          dayRef.classList.remove(classNames2.bottomLeftCornerDate, classNames2.bottomRightCornerDate, classNames2.topLeftCornerDate, classNames2.topRightCornerDate);
          var classNamesToAdd = calculateRoundedStyles(classNames2, false, false, index2 > 0, index2 < dayRefs.length - 1).trim();
          if (classNamesToAdd) {
            (_a3 = dayRef.classList).add.apply(_a3, classNamesToAdd.split(" "));
          }
        }
      }
    });
  };
  var onMouseDownDay = function(ev) {
    var dayInfos = getDayInfosInRangeOfDay(day);
    var dayRefs = getRefsFromDayInfos(dayInfos);
    dayRefs.forEach(function(dayRef) {
      if (dayRef) {
        dayRef.classList.add("ms-CalendarDay-pressedStyle");
      }
    });
  };
  var onMouseUpDay = function(ev) {
    var dayInfos = getDayInfosInRangeOfDay(day);
    var dayRefs = getRefsFromDayInfos(dayInfos);
    dayRefs.forEach(function(dayRef) {
      if (dayRef) {
        dayRef.classList.remove("ms-CalendarDay-pressedStyle");
      }
    });
  };
  var onMouseOutDay = function(ev) {
    var dayInfos = getDayInfosInRangeOfDay(day);
    var dayRefs = getRefsFromDayInfos(dayInfos);
    dayRefs.forEach(function(dayRef, index2) {
      var _a3;
      if (dayRef) {
        dayRef.classList.remove("ms-CalendarDay-hoverStyle");
        dayRef.classList.remove("ms-CalendarDay-pressedStyle");
        if (!dayInfos[index2].isSelected && dateRangeType === DateRangeType.Day && daysToSelectInDayView && daysToSelectInDayView > 1) {
          var classNamesToAdd = calculateRoundedStyles(classNames2, false, false, index2 > 0, index2 < dayRefs.length - 1).trim();
          if (classNamesToAdd) {
            (_a3 = dayRef.classList).remove.apply(_a3, classNamesToAdd.split(" "));
          }
        }
      }
    });
  };
  var onDayKeyDown = function(ev) {
    if (ev.which === KeyCodes.enter) {
      onSelectDate === null || onSelectDate === void 0 ? void 0 : onSelectDate(day.originalDate);
    } else {
      navigateMonthEdge(ev, day.originalDate);
    }
  };
  var ariaLabel = day.originalDate.getDate() + ", " + strings.months[day.originalDate.getMonth()] + ", " + day.originalDate.getFullYear();
  if (day.isMarked) {
    ariaLabel = ariaLabel + ", " + strings.dayMarkedAriaLabel;
  }
  return React__namespace.createElement(
    "td",
    { className: css$3(classNames2.dayCell, weekCorners && cornerStyle, day.isSelected && classNames2.daySelected, day.isSelected && "ms-CalendarDay-daySelected", !day.isInBounds && classNames2.dayOutsideBounds, !day.isInMonth && classNames2.dayOutsideNavigatedMonth), ref: function(element) {
      customDayCellRef === null || customDayCellRef === void 0 ? void 0 : customDayCellRef(element, day.originalDate, classNames2);
      day.setRef(element);
      isNavigatedDate && (navigatedDayRef.current = element);
    }, "aria-hidden": ariaHidden, "aria-disabled": !ariaHidden && !day.isInBounds, onClick: day.isInBounds && !ariaHidden ? day.onSelected : void 0, onMouseOver: !ariaHidden ? onMouseOverDay : void 0, onMouseDown: !ariaHidden ? onMouseDownDay : void 0, onMouseUp: !ariaHidden ? onMouseUpDay : void 0, onMouseOut: !ariaHidden ? onMouseOutDay : void 0, onKeyDown: !ariaHidden ? onDayKeyDown : void 0, role: "gridcell", tabIndex: isNavigatedDate ? 0 : void 0, "aria-current": day.isToday ? "date" : void 0, "aria-selected": day.isInBounds ? day.isSelected : void 0, "data-is-focusable": !ariaHidden && (allFocusable || (day.isInBounds ? true : void 0)) },
    React__namespace.createElement(
      "button",
      { key: day.key + "button", "aria-hidden": ariaHidden, className: css$3(classNames2.dayButton, day.isToday && classNames2.dayIsToday, day.isToday && "ms-CalendarDay-dayIsToday"), "aria-label": ariaLabel, id: isNavigatedDate ? activeDescendantId : void 0, disabled: !ariaHidden && !day.isInBounds, type: "button", tabIndex: -1, "data-is-focusable": "false" },
      React__namespace.createElement("span", { "aria-hidden": "true" }, dateTimeFormatter.formatDay(day.originalDate)),
      day.isMarked && React__namespace.createElement("div", { "aria-hidden": "true", className: classNames2.dayMarker })
    )
  );
};
var CalendarGridRow = function(props) {
  var classNames2 = props.classNames, week = props.week, weeks = props.weeks, weekIndex = props.weekIndex, rowClassName = props.rowClassName, ariaRole = props.ariaRole, showWeekNumbers = props.showWeekNumbers, firstDayOfWeek = props.firstDayOfWeek, firstWeekOfYear = props.firstWeekOfYear, navigatedDate = props.navigatedDate, strings = props.strings;
  var weekNumbers = showWeekNumbers ? getWeekNumbersInMonth(weeks.length, firstDayOfWeek, firstWeekOfYear, navigatedDate) : null;
  var titleString = weekNumbers ? strings.weekNumberFormatString && format$1(strings.weekNumberFormatString, weekNumbers[weekIndex]) : "";
  return React__namespace.createElement(
    "tr",
    { role: ariaRole, className: rowClassName, key: weekIndex + "_" + week[0].key },
    showWeekNumbers && weekNumbers && React__namespace.createElement(
      "th",
      { className: classNames2.weekNumberCell, key: weekIndex, title: titleString, "aria-label": titleString, scope: "row" },
      React__namespace.createElement("span", null, weekNumbers[weekIndex])
    ),
    week.map(function(day, dayIndex) {
      return React__namespace.createElement(CalendarGridDayCell, __assign$1({}, props, { key: day.key, day, dayIndex }));
    })
  );
};
var getClassNames$G = classNamesFunction();
function useDayRefs() {
  var daysRef = React__namespace.useRef({});
  var getSetRefCallback = function(dayKey) {
    return function(element) {
      if (element === null) {
        delete daysRef.current[dayKey];
      } else {
        daysRef.current[dayKey] = element;
      }
    };
  };
  return [daysRef, getSetRefCallback];
}
function useWeeks(props, onSelectDate, getSetRefCallback) {
  var weeks = React__namespace.useMemo(function() {
    var _a2;
    var weeksGrid = getDayGrid(props);
    var firstVisibleDay = weeksGrid[1][0].originalDate;
    var lastVisibleDay = weeksGrid[weeksGrid.length - 1][6].originalDate;
    var markedDays = ((_a2 = props.getMarkedDays) === null || _a2 === void 0 ? void 0 : _a2.call(props, firstVisibleDay, lastVisibleDay)) || [];
    var returnValue = [];
    for (var weekIndex = 0; weekIndex < weeksGrid.length; weekIndex++) {
      var week = [];
      var _loop_1 = function(dayIndex2) {
        var day = weeksGrid[weekIndex][dayIndex2];
        var dayInfo = __assign$1(__assign$1({ onSelected: function() {
          return onSelectDate(day.originalDate);
        }, setRef: getSetRefCallback(day.key) }, day), { isMarked: day.isMarked || (markedDays === null || markedDays === void 0 ? void 0 : markedDays.some(function(markedDay) {
          return compareDates(day.originalDate, markedDay);
        })) });
        week.push(dayInfo);
      };
      for (var dayIndex = 0; dayIndex < DAYS_IN_WEEK; dayIndex++) {
        _loop_1(dayIndex);
      }
      returnValue.push(week);
    }
    return returnValue;
  }, [props]);
  return weeks;
}
function useAnimateBackwards$2(weeks) {
  var previousNavigatedDate = usePrevious(weeks[0][0].originalDate);
  if (!previousNavigatedDate || previousNavigatedDate.getTime() === weeks[0][0].originalDate.getTime()) {
    return void 0;
  } else if (previousNavigatedDate <= weeks[0][0].originalDate) {
    return false;
  } else {
    return true;
  }
}
function useWeekCornerStyles(props) {
  var getWeekCornerStyles = function(classNames2, initialWeeks) {
    var weekCornersStyled = {};
    var weeks = initialWeeks.slice(1, initialWeeks.length - 1);
    weeks.forEach(function(week, weekIndex) {
      week.forEach(function(day, dayIndex) {
        var above = weeks[weekIndex - 1] && weeks[weekIndex - 1][dayIndex] && isInSameHoverRange(weeks[weekIndex - 1][dayIndex].originalDate, day.originalDate, weeks[weekIndex - 1][dayIndex].isSelected, day.isSelected);
        var below = weeks[weekIndex + 1] && weeks[weekIndex + 1][dayIndex] && isInSameHoverRange(weeks[weekIndex + 1][dayIndex].originalDate, day.originalDate, weeks[weekIndex + 1][dayIndex].isSelected, day.isSelected);
        var left = weeks[weekIndex][dayIndex - 1] && isInSameHoverRange(weeks[weekIndex][dayIndex - 1].originalDate, day.originalDate, weeks[weekIndex][dayIndex - 1].isSelected, day.isSelected);
        var right = weeks[weekIndex][dayIndex + 1] && isInSameHoverRange(weeks[weekIndex][dayIndex + 1].originalDate, day.originalDate, weeks[weekIndex][dayIndex + 1].isSelected, day.isSelected);
        var style = [];
        style.push(calculateRoundedStyles(classNames2, above, below, left, right));
        style.push(calculateBorderStyles(classNames2, above, below, left, right));
        weekCornersStyled[weekIndex + "_" + dayIndex] = style.join(" ");
      });
    });
    return weekCornersStyled;
  };
  var calculateRoundedStyles = function(classNames2, above, below, left, right) {
    var style = [];
    var roundedTopLeft = !above && !left;
    var roundedTopRight = !above && !right;
    var roundedBottomLeft = !below && !left;
    var roundedBottomRight = !below && !right;
    if (roundedTopLeft) {
      style.push(getRTL() ? classNames2.topRightCornerDate : classNames2.topLeftCornerDate);
    }
    if (roundedTopRight) {
      style.push(getRTL() ? classNames2.topLeftCornerDate : classNames2.topRightCornerDate);
    }
    if (roundedBottomLeft) {
      style.push(getRTL() ? classNames2.bottomRightCornerDate : classNames2.bottomLeftCornerDate);
    }
    if (roundedBottomRight) {
      style.push(getRTL() ? classNames2.bottomLeftCornerDate : classNames2.bottomRightCornerDate);
    }
    return style.join(" ");
  };
  var calculateBorderStyles = function(classNames2, above, below, left, right) {
    var style = [];
    if (!above) {
      style.push(classNames2.datesAbove);
    }
    if (!below) {
      style.push(classNames2.datesBelow);
    }
    if (!left) {
      style.push(getRTL() ? classNames2.datesRight : classNames2.datesLeft);
    }
    if (!right) {
      style.push(getRTL() ? classNames2.datesLeft : classNames2.datesRight);
    }
    return style.join(" ");
  };
  var isInSameHoverRange = function(date1, date2, date1Selected, date2Selected) {
    var dateRangeType = props.dateRangeType, firstDayOfWeek = props.firstDayOfWeek, workWeekDays = props.workWeekDays;
    var dateRangeHoverType = dateRangeType === DateRangeType.WorkWeek ? DateRangeType.Week : dateRangeType;
    var dateRange = getDateRangeArray(date1, dateRangeHoverType, firstDayOfWeek, workWeekDays);
    if (date1Selected !== date2Selected) {
      return false;
    } else if (date1Selected && date2Selected) {
      return true;
    }
    return dateRange.filter(function(date) {
      return date.getTime() === date2.getTime();
    }).length > 0;
  };
  return [getWeekCornerStyles, calculateRoundedStyles];
}
var CalendarDayGridBase = function(props) {
  var navigatedDayRef = React__namespace.useRef(null);
  var activeDescendantId = useId();
  var onSelectDate = function(selectedDate) {
    var _a3, _b3;
    var firstDayOfWeek = props.firstDayOfWeek, minDate = props.minDate, maxDate = props.maxDate, workWeekDays = props.workWeekDays, daysToSelectInDayView = props.daysToSelectInDayView, restrictedDates = props.restrictedDates;
    var restrictedDatesOptions = { minDate, maxDate, restrictedDates };
    var dateRange = getDateRangeArray(selectedDate, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);
    dateRange = getBoundedDateRange(dateRange, minDate, maxDate);
    dateRange = dateRange.filter(function(d) {
      return !isRestrictedDate(d, restrictedDatesOptions);
    });
    (_a3 = props.onSelectDate) === null || _a3 === void 0 ? void 0 : _a3.call(props, selectedDate, dateRange);
    (_b3 = props.onNavigateDate) === null || _b3 === void 0 ? void 0 : _b3.call(props, selectedDate, true);
  };
  var _a2 = useDayRefs(), daysRef = _a2[0], getSetRefCallback = _a2[1];
  var weeks = useWeeks(props, onSelectDate, getSetRefCallback);
  var animateBackwards = useAnimateBackwards$2(weeks);
  var _b2 = useWeekCornerStyles(props), getWeekCornerStyles = _b2[0], calculateRoundedStyles = _b2[1];
  React__namespace.useImperativeHandle(props.componentRef, function() {
    return {
      focus: function() {
        var _a3, _b3;
        (_b3 = (_a3 = navigatedDayRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus) === null || _b3 === void 0 ? void 0 : _b3.call(_a3);
      }
    };
  }, []);
  var getDayInfosInRangeOfDay = function(dayToCompare) {
    var dateRangeHoverType = getDateRangeTypeToUse(props.dateRangeType, props.workWeekDays);
    var dateRange = getDateRangeArray(dayToCompare.originalDate, dateRangeHoverType, props.firstDayOfWeek, props.workWeekDays, props.daysToSelectInDayView).map(function(date) {
      return date.getTime();
    });
    var dayInfosInRange = weeks.reduce(function(accumulatedValue, currentWeek) {
      return accumulatedValue.concat(currentWeek.filter(function(weekDay) {
        return dateRange.indexOf(weekDay.originalDate.getTime()) !== -1;
      }));
    }, []);
    return dayInfosInRange;
  };
  var getRefsFromDayInfos = function(dayInfosInRange) {
    var dayRefs = [];
    dayRefs = dayInfosInRange.map(function(dayInfo) {
      return daysRef.current[dayInfo.key];
    });
    return dayRefs;
  };
  var styles2 = props.styles, theme = props.theme, className = props.className, dateRangeType = props.dateRangeType, showWeekNumbers = props.showWeekNumbers, labelledBy = props.labelledBy, lightenDaysOutsideNavigatedMonth = props.lightenDaysOutsideNavigatedMonth, animationDirection = props.animationDirection;
  var classNames2 = getClassNames$G(styles2, {
    theme,
    className,
    dateRangeType,
    showWeekNumbers,
    lightenDaysOutsideNavigatedMonth: lightenDaysOutsideNavigatedMonth === void 0 ? true : lightenDaysOutsideNavigatedMonth,
    animationDirection,
    animateBackwards
  });
  var weekCorners = getWeekCornerStyles(classNames2, weeks);
  var partialWeekProps = {
    weeks,
    navigatedDayRef,
    calculateRoundedStyles,
    activeDescendantId,
    classNames: classNames2,
    weekCorners,
    getDayInfosInRangeOfDay,
    getRefsFromDayInfos
  };
  return React__namespace.createElement(
    FocusZone,
    { className: classNames2.wrapper, preventDefaultWhenHandled: true },
    React__namespace.createElement(
      "table",
      { className: classNames2.table, "aria-multiselectable": "false", "aria-labelledby": labelledBy, "aria-activedescendant": activeDescendantId, role: "grid" },
      React__namespace.createElement(
        "tbody",
        null,
        React__namespace.createElement(CalendarMonthHeaderRow, __assign$1({}, props, { classNames: classNames2, weeks })),
        React__namespace.createElement(CalendarGridRow, __assign$1({}, props, partialWeekProps, { week: weeks[0], weekIndex: -1, rowClassName: classNames2.firstTransitionWeek, ariaRole: "presentation", ariaHidden: true })),
        weeks.slice(1, weeks.length - 1).map(function(week, weekIndex) {
          return React__namespace.createElement(CalendarGridRow, __assign$1({}, props, partialWeekProps, { key: weekIndex, week, weekIndex, rowClassName: classNames2.weekRow }));
        }),
        React__namespace.createElement(CalendarGridRow, __assign$1({}, props, partialWeekProps, { week: weeks[weeks.length - 1], weekIndex: -2, rowClassName: classNames2.lastTransitionWeek, ariaRole: "presentation", ariaHidden: true }))
      )
    )
  );
};
CalendarDayGridBase.displayName = "CalendarDayGridBase";
function getDateRangeTypeToUse(dateRangeType, workWeekDays) {
  if (workWeekDays && dateRangeType === DateRangeType.WorkWeek) {
    var sortedWWDays = workWeekDays.slice().sort();
    var isContiguous2 = true;
    for (var i = 1; i < sortedWWDays.length; i++) {
      if (sortedWWDays[i] !== sortedWWDays[i - 1] + 1) {
        isContiguous2 = false;
        break;
      }
    }
    if (!isContiguous2 || workWeekDays.length === 0) {
      return DateRangeType.Week;
    }
  }
  return dateRangeType;
}
var AnimationDirection;
(function(AnimationDirection2) {
  AnimationDirection2[AnimationDirection2["Horizontal"] = 0] = "Horizontal";
  AnimationDirection2[AnimationDirection2["Vertical"] = 1] = "Vertical";
})(AnimationDirection || (AnimationDirection = {}));
var GlobalClassNames$s = {
  hoverStyle: "ms-CalendarDay-hoverStyle",
  pressedStyle: "ms-CalendarDay-pressedStyle",
  dayIsTodayStyle: "ms-CalendarDay-dayIsToday",
  daySelectedStyle: "ms-CalendarDay-daySelected"
};
var transitionRowDisappearance = keyframes$1({
  "100%": {
    width: 0,
    height: 0,
    overflow: "hidden"
  },
  "99.9%": {
    width: "100%",
    height: 28,
    overflow: "visible"
  },
  "0%": {
    width: "100%",
    height: 28,
    overflow: "visible"
  }
});
var styles$6 = function(props) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k;
  var theme = props.theme, dateRangeType = props.dateRangeType, showWeekNumbers = props.showWeekNumbers, lightenDaysOutsideNavigatedMonth = props.lightenDaysOutsideNavigatedMonth, animateBackwards = props.animateBackwards, animationDirection = props.animationDirection;
  var palette = theme.palette;
  var classNames2 = getGlobalClassNames(GlobalClassNames$s, theme);
  var rowAnimationStyle = {};
  if (animateBackwards !== void 0) {
    if (animationDirection === AnimationDirection.Horizontal) {
      rowAnimationStyle = animateBackwards ? AnimationStyles.slideRightIn20 : AnimationStyles.slideLeftIn20;
    } else {
      rowAnimationStyle = animateBackwards ? AnimationStyles.slideDownIn20 : AnimationStyles.slideUpIn20;
    }
  }
  var firstTransitionRowAnimationStyle = {};
  var lastTransitionRowAnimationStyle = {};
  if (animateBackwards !== void 0) {
    if (animationDirection !== AnimationDirection.Horizontal) {
      firstTransitionRowAnimationStyle = animateBackwards ? { animationName: "" } : AnimationStyles.slideUpOut20;
      lastTransitionRowAnimationStyle = animateBackwards ? AnimationStyles.slideDownOut20 : { animationName: "" };
    }
  }
  var disabledStyle = {
    selectors: {
      "&, &:disabled, & button": {
        color: palette.neutralTertiaryAlt,
        pointerEvents: "none"
      }
    }
  };
  return {
    wrapper: {
      paddingBottom: 10
    },
    table: [
      {
        textAlign: "center",
        borderCollapse: "collapse",
        borderSpacing: "0",
        tableLayout: "fixed",
        fontSize: "inherit",
        marginTop: 4,
        width: 196,
        position: "relative",
        paddingBottom: 10
      },
      showWeekNumbers && {
        width: 226
      }
    ],
    dayCell: [
      getFocusStyle(theme, { inset: -3 }),
      {
        margin: 0,
        padding: 0,
        width: 28,
        height: 28,
        lineHeight: 28,
        fontSize: FontSizes.small,
        fontWeight: FontWeights.regular,
        color: palette.neutralPrimary,
        cursor: "pointer",
        position: "relative",
        selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign$1({ color: "WindowText", backgroundColor: "transparent", zIndex: 0 }, getHighContrastNoAdjustStyle()), _a2["&." + classNames2.hoverStyle] = {
          backgroundColor: palette.neutralLighter,
          selectors: (_b2 = {}, _b2[HighContrastSelector] = {
            zIndex: 3,
            backgroundColor: "Window",
            outline: "1px solid Highlight"
          }, _b2)
        }, _a2["&." + classNames2.pressedStyle] = {
          backgroundColor: palette.neutralLight,
          selectors: (_c2 = {}, _c2[HighContrastSelector] = {
            borderColor: "Highlight",
            color: "Highlight",
            backgroundColor: "Window"
          }, _c2)
        }, _a2["&." + classNames2.pressedStyle + "." + classNames2.hoverStyle] = {
          selectors: (_d2 = {}, _d2[HighContrastSelector] = {
            backgroundColor: "Window",
            outline: "1px solid Highlight"
          }, _d2)
        }, _a2)
      }
    ],
    daySelected: [
      dateRangeType !== DateRangeType.Month && {
        backgroundColor: palette.neutralLight + "!important",
        selectors: (_e2 = {
          "&::before": {
            content: '""',
            position: "absolute",
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
          }
        }, _e2["&:hover, &." + classNames2.hoverStyle + ", &." + classNames2.pressedStyle] = (_f = {
          backgroundColor: palette.neutralLight + "!important"
        }, _f[HighContrastSelector] = {
          color: "HighlightText!important",
          background: "Highlight!important"
        }, _f), _e2[HighContrastSelector] = __assign$1({ background: "Highlight!important", color: "HighlightText!important", borderColor: "Highlight!important" }, getHighContrastNoAdjustStyle()), _e2)
      }
    ],
    weekRow: rowAnimationStyle,
    weekDayLabelCell: AnimationStyles.fadeIn200,
    weekNumberCell: {
      margin: 0,
      padding: 0,
      borderRight: "1px solid",
      borderColor: palette.neutralLight,
      backgroundColor: palette.neutralLighterAlt,
      color: palette.neutralSecondary,
      boxSizing: "border-box",
      width: 28,
      height: 28,
      fontWeight: FontWeights.regular,
      fontSize: FontSizes.small
    },
    dayOutsideBounds: disabledStyle,
    dayOutsideNavigatedMonth: lightenDaysOutsideNavigatedMonth && {
      color: palette.neutralSecondary,
      fontWeight: FontWeights.regular
    },
    dayButton: {
      width: 24,
      height: 24,
      lineHeight: 24,
      fontSize: FontSizes.small,
      fontWeight: "inherit",
      borderRadius: 2,
      border: "none",
      padding: 0,
      color: "inherit",
      backgroundColor: "transparent",
      cursor: "pointer",
      overflow: "visible",
      selectors: {
        span: {
          height: "inherit",
          lineHeight: "inherit"
        }
      }
    },
    dayIsToday: {
      backgroundColor: palette.themePrimary + "!important",
      borderRadius: "100%",
      color: palette.white + "!important",
      fontWeight: FontWeights.semibold + "!important",
      selectors: (_g = {}, _g[HighContrastSelector] = __assign$1({ background: "WindowText!important", color: "Window!important", borderColor: "WindowText!important" }, getHighContrastNoAdjustStyle()), _g)
    },
    firstTransitionWeek: __assign$1(__assign$1({ position: "absolute", opacity: 0, width: 0, height: 0, overflow: "hidden" }, firstTransitionRowAnimationStyle), { animationName: firstTransitionRowAnimationStyle.animationName + "," + transitionRowDisappearance }),
    lastTransitionWeek: __assign$1(__assign$1({ position: "absolute", opacity: 0, width: 0, height: 0, overflow: "hidden", marginTop: -28 }, lastTransitionRowAnimationStyle), { animationName: lastTransitionRowAnimationStyle.animationName + "," + transitionRowDisappearance }),
    dayMarker: {
      width: 4,
      height: 4,
      backgroundColor: palette.neutralSecondary,
      borderRadius: "100%",
      bottom: 1,
      left: 0,
      right: 0,
      position: "absolute",
      margin: "auto",
      selectors: (_h = {}, _h["." + classNames2.dayIsTodayStyle + " &"] = {
        backgroundColor: palette.white,
        selectors: (_j = {}, _j[HighContrastSelector] = {
          backgroundColor: "Window"
        }, _j)
      }, _h["." + classNames2.daySelectedStyle + " &"] = {
        selectors: (_k = {}, _k[HighContrastSelector] = {
          backgroundColor: "HighlightText"
        }, _k)
      }, _h[HighContrastSelector] = __assign$1({ backgroundColor: "WindowText" }, getHighContrastNoAdjustStyle()), _h)
    },
    topRightCornerDate: {
      borderTopRightRadius: "2px"
    },
    topLeftCornerDate: {
      borderTopLeftRadius: "2px"
    },
    bottomRightCornerDate: {
      borderBottomRightRadius: "2px"
    },
    bottomLeftCornerDate: {
      borderBottomLeftRadius: "2px"
    },
    datesAbove: {
      "&::before": {
        borderTop: "1px solid " + palette.neutralSecondary
      }
    },
    datesBelow: {
      "&::before": {
        borderBottom: "1px solid " + palette.neutralSecondary
      }
    },
    datesLeft: {
      "&::before": {
        borderLeft: "1px solid " + palette.neutralSecondary
      }
    },
    datesRight: {
      "&::before": {
        borderRight: "1px solid " + palette.neutralSecondary
      }
    }
  };
};
var CalendarDayGrid = styled(CalendarDayGridBase, styles$6, void 0, { scope: "CalendarDayGrid" });
var getClassNames$F = classNamesFunction();
var CalendarDayBase = function(props) {
  var dayGrid = React__namespace.useRef(null);
  React__namespace.useImperativeHandle(props.componentRef, function() {
    return {
      focus: function() {
        var _a2, _b2;
        (_b2 = (_a2 = dayGrid.current) === null || _a2 === void 0 ? void 0 : _a2.focus) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
    };
  }, []);
  var strings = props.strings, navigatedDate = props.navigatedDate, dateTimeFormatter = props.dateTimeFormatter, styles2 = props.styles, theme = props.theme, className = props.className, onHeaderSelect = props.onHeaderSelect, showSixWeeksByDefault = props.showSixWeeksByDefault, minDate = props.minDate, maxDate = props.maxDate, restrictedDates = props.restrictedDates, onNavigateDate = props.onNavigateDate, showWeekNumbers = props.showWeekNumbers, dateRangeType = props.dateRangeType, animationDirection = props.animationDirection;
  var monthAndYearId = useId();
  var classNames2 = getClassNames$F(styles2, {
    theme,
    className,
    headerIsClickable: !!onHeaderSelect,
    showWeekNumbers,
    animationDirection
  });
  var monthAndYear = dateTimeFormatter.formatMonthYear(navigatedDate, strings);
  var HeaderButtonComponentType = onHeaderSelect ? "button" : "div";
  var headerAriaLabel = strings.yearPickerHeaderAriaLabel ? format$1(strings.yearPickerHeaderAriaLabel, monthAndYear) : monthAndYear;
  return React__namespace.createElement(
    "div",
    { className: classNames2.root },
    React__namespace.createElement(
      "div",
      { className: classNames2.header },
      React__namespace.createElement(
        HeaderButtonComponentType,
        { "aria-label": onHeaderSelect ? headerAriaLabel : void 0, className: classNames2.monthAndYear, onClick: onHeaderSelect, "data-is-focusable": !!onHeaderSelect, tabIndex: onHeaderSelect ? 0 : -1, onKeyDown: onButtonKeyDown$1(onHeaderSelect), type: "button" },
        React__namespace.createElement("span", { id: monthAndYearId, "aria-live": "polite", "aria-atomic": "true" }, monthAndYear)
      ),
      React__namespace.createElement(CalendarDayNavigationButtons, __assign$1({}, props, { classNames: classNames2 }))
    ),
    React__namespace.createElement(CalendarDayGrid, __assign$1({}, props, { styles: styles2, componentRef: dayGrid, strings, navigatedDate, weeksToShow: showSixWeeksByDefault ? 6 : void 0, dateTimeFormatter, minDate, maxDate, restrictedDates, onNavigateDate, labelledBy: monthAndYearId, dateRangeType }))
  );
};
CalendarDayBase.displayName = "CalendarDayBase";
var CalendarDayNavigationButtons = function(props) {
  var _a2, _b2;
  var minDate = props.minDate, maxDate = props.maxDate, navigatedDate = props.navigatedDate, allFocusable = props.allFocusable, strings = props.strings, navigationIcons = props.navigationIcons, showCloseButton = props.showCloseButton, classNames2 = props.classNames, onNavigateDate = props.onNavigateDate, onDismiss = props.onDismiss;
  var onSelectNextMonth = function() {
    onNavigateDate(addMonths(navigatedDate, 1), false);
  };
  var onSelectPrevMonth = function() {
    onNavigateDate(addMonths(navigatedDate, -1), false);
  };
  var leftNavigationIcon = navigationIcons.leftNavigation;
  var rightNavigationIcon = navigationIcons.rightNavigation;
  var closeNavigationIcon = navigationIcons.closeIcon;
  var prevMonthInBounds = minDate ? compareDatePart(minDate, getMonthStart(navigatedDate)) < 0 : true;
  var nextMonthInBounds = maxDate ? compareDatePart(getMonthEnd(navigatedDate), maxDate) < 0 : true;
  return React__namespace.createElement(
    "div",
    { className: classNames2.monthComponents },
    React__namespace.createElement(
      "button",
      { className: css$3(classNames2.headerIconButton, (_a2 = {}, _a2[classNames2.disabledStyle] = !prevMonthInBounds, _a2)), tabIndex: prevMonthInBounds ? void 0 : allFocusable ? 0 : -1, "aria-disabled": !prevMonthInBounds, onClick: prevMonthInBounds ? onSelectPrevMonth : void 0, onKeyDown: prevMonthInBounds ? onButtonKeyDown$1(onSelectPrevMonth) : void 0, title: strings.prevMonthAriaLabel ? strings.prevMonthAriaLabel + " " + strings.months[addMonths(navigatedDate, -1).getMonth()] : void 0, type: "button" },
      React__namespace.createElement(Icon, { iconName: leftNavigationIcon })
    ),
    React__namespace.createElement(
      "button",
      { className: css$3(classNames2.headerIconButton, (_b2 = {}, _b2[classNames2.disabledStyle] = !nextMonthInBounds, _b2)), tabIndex: nextMonthInBounds ? void 0 : allFocusable ? 0 : -1, "aria-disabled": !nextMonthInBounds, onClick: nextMonthInBounds ? onSelectNextMonth : void 0, onKeyDown: nextMonthInBounds ? onButtonKeyDown$1(onSelectNextMonth) : void 0, title: strings.nextMonthAriaLabel ? strings.nextMonthAriaLabel + " " + strings.months[addMonths(navigatedDate, 1).getMonth()] : void 0, type: "button" },
      React__namespace.createElement(Icon, { iconName: rightNavigationIcon })
    ),
    showCloseButton && React__namespace.createElement(
      "button",
      { className: css$3(classNames2.headerIconButton), onClick: onDismiss, onKeyDown: onButtonKeyDown$1(onDismiss), title: strings.closeButtonAriaLabel, type: "button" },
      React__namespace.createElement(Icon, { iconName: closeNavigationIcon })
    )
  );
};
CalendarDayNavigationButtons.displayName = "CalendarDayNavigationButtons";
var onButtonKeyDown$1 = function(callback) {
  return function(ev) {
    switch (ev.which) {
      case KeyCodes.enter:
        callback === null || callback === void 0 ? void 0 : callback();
        break;
    }
  };
};
var styles$5 = function(props) {
  var _a2;
  var className = props.className, theme = props.theme, headerIsClickable = props.headerIsClickable, showWeekNumbers = props.showWeekNumbers;
  var palette = theme.palette;
  var disabledStyle = {
    selectors: (_a2 = {
      "&, &:disabled, & button": {
        color: palette.neutralTertiaryAlt,
        pointerEvents: "none"
      }
    }, _a2[HighContrastSelector] = {
      color: "GrayText",
      forcedColorAdjust: "none"
    }, _a2)
  };
  return {
    root: [
      normalize,
      {
        width: 196,
        padding: 12,
        boxSizing: "content-box"
      },
      showWeekNumbers && {
        width: 226
      },
      className
    ],
    header: {
      position: "relative",
      display: "inline-flex",
      height: 28,
      lineHeight: 44,
      width: "100%"
    },
    monthAndYear: [
      getFocusStyle(theme, { inset: 1 }),
      __assign$1(__assign$1({}, AnimationStyles.fadeIn200), { alignItems: "center", fontSize: FontSizes.medium, fontFamily: "inherit", color: palette.neutralPrimary, display: "inline-block", flexGrow: 1, fontWeight: FontWeights.semibold, padding: "0 4px 0 10px", border: "none", backgroundColor: "transparent", borderRadius: 2, lineHeight: 28, overflow: "hidden", whiteSpace: "nowrap", textAlign: "left", textOverflow: "ellipsis" }),
      headerIsClickable && {
        selectors: {
          "&:hover": {
            cursor: "pointer",
            background: palette.neutralLight,
            color: palette.black
          }
        }
      }
    ],
    monthComponents: {
      display: "inline-flex",
      alignSelf: "flex-end"
    },
    headerIconButton: [
      getFocusStyle(theme, { inset: -1 }),
      {
        width: 28,
        height: 28,
        display: "block",
        textAlign: "center",
        lineHeight: 28,
        fontSize: FontSizes.small,
        fontFamily: "inherit",
        color: palette.neutralPrimary,
        borderRadius: 2,
        position: "relative",
        backgroundColor: "transparent",
        border: "none",
        padding: 0,
        overflow: "visible",
        selectors: {
          "&:hover": {
            color: palette.neutralDark,
            backgroundColor: palette.neutralLight,
            cursor: "pointer",
            outline: "1px solid transparent"
          }
        }
      }
    ],
    disabledStyle
  };
};
var CalendarDay = styled(CalendarDayBase, styles$5, void 0, {
  scope: "CalendarDay"
});
var getStyles$x = function(props) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g;
  var className = props.className, theme = props.theme, hasHeaderClickCallback = props.hasHeaderClickCallback, highlightCurrent = props.highlightCurrent, highlightSelected = props.highlightSelected, animateBackwards = props.animateBackwards, animationDirection = props.animationDirection;
  var palette = theme.palette;
  var animationStyle = {};
  if (animateBackwards !== void 0) {
    if (animationDirection === AnimationDirection.Horizontal) {
      animationStyle = animateBackwards ? AnimationStyles.slideRightIn20 : AnimationStyles.slideLeftIn20;
    } else {
      animationStyle = animateBackwards ? AnimationStyles.slideDownIn20 : AnimationStyles.slideUpIn20;
    }
  }
  var headerAnimationStyle = animateBackwards !== void 0 ? AnimationStyles.fadeIn200 : {};
  return {
    root: [
      normalize,
      {
        width: 196,
        padding: 12,
        boxSizing: "content-box",
        overflow: "hidden"
      },
      className
    ],
    headerContainer: {
      display: "flex"
    },
    currentItemButton: [
      getFocusStyle(theme, { inset: -1 }),
      __assign$1(__assign$1({}, headerAnimationStyle), { fontSize: FontSizes.medium, fontWeight: FontWeights.semibold, fontFamily: "inherit", textAlign: "left", color: "inherit", backgroundColor: "transparent", flexGrow: 1, padding: "0 4px 0 10px", border: "none", overflow: "visible" }),
      hasHeaderClickCallback && {
        selectors: {
          "&:hover, &:active": {
            cursor: !hasHeaderClickCallback ? "default" : "pointer",
            color: palette.neutralDark,
            outline: "1px solid transparent",
            backgroundColor: palette.neutralLight
          }
        }
      }
    ],
    navigationButtonsContainer: {
      display: "flex",
      alignItems: "center"
    },
    navigationButton: [
      getFocusStyle(theme, { inset: -1 }),
      {
        fontFamily: "inherit",
        width: 28,
        minWidth: 28,
        height: 28,
        minHeight: 28,
        display: "block",
        textAlign: "center",
        lineHeight: 28,
        fontSize: FontSizes.small,
        color: palette.neutralPrimary,
        borderRadius: 2,
        position: "relative",
        backgroundColor: "transparent",
        border: "none",
        padding: 0,
        overflow: "visible",
        selectors: {
          "&:hover": {
            color: palette.neutralDark,
            cursor: "pointer",
            outline: "1px solid transparent",
            backgroundColor: palette.neutralLight
          }
        }
      }
    ],
    gridContainer: {
      marginTop: 4
    },
    buttonRow: __assign$1(__assign$1({}, animationStyle), { marginBottom: 16, selectors: {
      "&:nth-child(n + 3)": {
        marginBottom: 0
      }
    } }),
    itemButton: [
      getFocusStyle(theme, { inset: -1 }),
      {
        width: 40,
        height: 40,
        minWidth: 40,
        minHeight: 40,
        lineHeight: 40,
        fontSize: FontSizes.small,
        fontFamily: "inherit",
        padding: 0,
        margin: "0 12px 0 0",
        color: palette.neutralPrimary,
        backgroundColor: "transparent",
        border: "none",
        borderRadius: 2,
        overflow: "visible",
        selectors: {
          "&:nth-child(4n + 4)": {
            marginRight: 0
          },
          "&:nth-child(n + 9)": {
            marginBottom: 0
          },
          "& div": {
            fontWeight: FontWeights.regular
          },
          "&:hover": {
            color: palette.neutralDark,
            backgroundColor: palette.neutralLight,
            cursor: "pointer",
            outline: "1px solid transparent",
            selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign$1({ background: "Window", color: "WindowText", outline: "1px solid Highlight" }, getHighContrastNoAdjustStyle()), _a2)
          },
          "&:active": {
            backgroundColor: palette.themeLight,
            selectors: (_b2 = {}, _b2[HighContrastSelector] = __assign$1({ background: "Window", color: "Highlight" }, getHighContrastNoAdjustStyle()), _b2)
          }
        }
      }
    ],
    current: highlightCurrent ? {
      color: palette.white,
      backgroundColor: palette.themePrimary,
      selectors: (_c2 = {
        "& div": {
          fontWeight: FontWeights.semibold
        },
        "&:hover": {
          backgroundColor: palette.themePrimary,
          selectors: (_d2 = {}, _d2[HighContrastSelector] = __assign$1({ backgroundColor: "WindowText", color: "Window" }, getHighContrastNoAdjustStyle()), _d2)
        }
      }, _c2[HighContrastSelector] = __assign$1({ backgroundColor: "WindowText", color: "Window" }, getHighContrastNoAdjustStyle()), _c2)
    } : {},
    selected: highlightSelected ? {
      color: palette.neutralPrimary,
      backgroundColor: palette.themeLight,
      fontWeight: FontWeights.semibold,
      selectors: (_e2 = {
        "& div": {
          fontWeight: FontWeights.semibold
        },
        "&:hover, &:active": {
          backgroundColor: palette.themeLight,
          selectors: (_f = {}, _f[HighContrastSelector] = __assign$1({ color: "Window", background: "Highlight" }, getHighContrastNoAdjustStyle()), _f)
        }
      }, _e2[HighContrastSelector] = __assign$1({ background: "Highlight", color: "Window" }, getHighContrastNoAdjustStyle()), _e2)
    } : {},
    disabled: {
      selectors: (_g = {
        "&, &:disabled, & button": {
          color: palette.neutralTertiaryAlt,
          pointerEvents: "none"
        }
      }, _g[HighContrastSelector] = {
        color: "GrayText",
        forcedColorAdjust: "none"
      }, _g)
    }
  };
};
var getStyles$w = function(props) {
  return getStyles$x(props);
};
var getStyles$v = function(props) {
  return getStyles$x(props);
};
var defaultCalendarStrings = DEFAULT_CALENDAR_STRINGS;
var defaultCalendarNavigationIcons = {
  leftNavigation: "Up",
  rightNavigation: "Down",
  closeIcon: "CalculatorMultiply"
};
var getClassNames$E = classNamesFunction();
var CELL_COUNT = 12;
var CELLS_PER_ROW = 4;
var DefaultCalendarYearStrings = {
  prevRangeAriaLabel: void 0,
  nextRangeAriaLabel: void 0
};
var CalendarYearGridCell = function(props) {
  var _a2;
  var _b2;
  var styles2 = props.styles, theme = props.theme, className = props.className, highlightCurrentYear = props.highlightCurrentYear, highlightSelectedYear = props.highlightSelectedYear, year = props.year, selected = props.selected, disabled = props.disabled, componentRef = props.componentRef, onSelectYear = props.onSelectYear, onRenderYear = props.onRenderYear;
  var buttonRef = React__namespace.useRef(null);
  React__namespace.useImperativeHandle(componentRef, function() {
    return {
      focus: function() {
        var _a3, _b3;
        (_b3 = (_a3 = buttonRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus) === null || _b3 === void 0 ? void 0 : _b3.call(_a3);
      }
    };
  }, []);
  var onClick = function() {
    onSelectYear === null || onSelectYear === void 0 ? void 0 : onSelectYear(year);
  };
  var onKeyDown = function(ev) {
    if (ev.which === KeyCodes.enter) {
      onSelectYear === null || onSelectYear === void 0 ? void 0 : onSelectYear(year);
    }
  };
  var classNames2 = getClassNames$E(styles2, {
    theme,
    className,
    highlightCurrent: highlightCurrentYear,
    highlightSelected: highlightSelectedYear
  });
  return React__namespace.createElement("button", { className: css$3(classNames2.itemButton, (_a2 = {}, _a2[classNames2.selected] = selected, _a2[classNames2.disabled] = disabled, _a2)), type: "button", role: "gridcell", onClick: !disabled ? onClick : void 0, onKeyDown: !disabled ? onKeyDown : void 0, disabled, "aria-selected": selected, ref: buttonRef }, (_b2 = onRenderYear === null || onRenderYear === void 0 ? void 0 : onRenderYear(year)) !== null && _b2 !== void 0 ? _b2 : year);
};
CalendarYearGridCell.displayName = "CalendarYearGridCell";
var CalendarYearGrid = function(props) {
  var styles2 = props.styles, theme = props.theme, className = props.className, fromYear = props.fromYear, toYear = props.toYear, animationDirection = props.animationDirection, animateBackwards = props.animateBackwards, minYear = props.minYear, maxYear = props.maxYear, onSelectYear = props.onSelectYear, selectedYear = props.selectedYear, componentRef = props.componentRef;
  var selectedCellRef = React__namespace.useRef(null);
  var currentCellRef = React__namespace.useRef(null);
  React__namespace.useImperativeHandle(componentRef, function() {
    return {
      focus: function() {
        var _a2, _b2;
        (_b2 = (_a2 = selectedCellRef.current || currentCellRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
    };
  }, []);
  var renderCell = function(yearToRender) {
    var selected = yearToRender === selectedYear;
    var disabled = minYear !== void 0 && yearToRender < minYear || maxYear !== void 0 && yearToRender > maxYear;
    var current = yearToRender === (/* @__PURE__ */ new Date()).getFullYear();
    return React__namespace.createElement(CalendarYearGridCell, __assign$1({}, props, { key: yearToRender, year: yearToRender, selected, current, disabled, onSelectYear, componentRef: selected ? selectedCellRef : current ? currentCellRef : void 0, theme }));
  };
  var classNames2 = getClassNames$E(styles2, {
    theme,
    className,
    animateBackwards,
    animationDirection
  });
  var onRenderYear = function(value) {
    var _a2, _b2;
    return (_b2 = (_a2 = props.onRenderYear) === null || _a2 === void 0 ? void 0 : _a2.call(props, value)) !== null && _b2 !== void 0 ? _b2 : value;
  };
  var gridAriaLabel = onRenderYear(fromYear) + " - " + onRenderYear(toYear);
  var year = fromYear;
  var cells = [];
  for (var i = 0; i < (toYear - fromYear + 1) / CELLS_PER_ROW; i++) {
    cells.push([]);
    for (var j = 0; j < CELLS_PER_ROW; j++) {
      cells[i].push(renderCell(year));
      year++;
    }
  }
  return React__namespace.createElement(
    FocusZone,
    null,
    React__namespace.createElement("div", { className: classNames2.gridContainer, role: "grid", "aria-label": gridAriaLabel }, cells.map(function(cellRow, index2) {
      return React__namespace.createElement("div", { key: "yearPickerRow_" + index2 + "_" + fromYear, role: "row", className: classNames2.buttonRow }, cellRow);
    }))
  );
};
CalendarYearGrid.displayName = "CalendarYearGrid";
var CalendarYearNavDirection;
(function(CalendarYearNavDirection2) {
  CalendarYearNavDirection2[CalendarYearNavDirection2["Previous"] = 0] = "Previous";
  CalendarYearNavDirection2[CalendarYearNavDirection2["Next"] = 1] = "Next";
})(CalendarYearNavDirection || (CalendarYearNavDirection = {}));
var CalendarYearNavArrow = function(props) {
  var _a2;
  var styles2 = props.styles, theme = props.theme, className = props.className, _b2 = props.navigationIcons, navigationIcons = _b2 === void 0 ? defaultCalendarNavigationIcons : _b2, _c2 = props.strings, strings = _c2 === void 0 ? DefaultCalendarYearStrings : _c2, direction = props.direction, onSelectPrev = props.onSelectPrev, onSelectNext = props.onSelectNext, fromYear = props.fromYear, toYear = props.toYear, maxYear = props.maxYear, minYear = props.minYear;
  var classNames2 = getClassNames$E(styles2, {
    theme,
    className
  });
  var ariaLabel = direction === CalendarYearNavDirection.Previous ? strings.prevRangeAriaLabel : strings.nextRangeAriaLabel;
  var newRangeOffset = direction === CalendarYearNavDirection.Previous ? -CELL_COUNT : CELL_COUNT;
  var newRange = { fromYear: fromYear + newRangeOffset, toYear: toYear + newRangeOffset };
  var ariaLabelString = ariaLabel ? typeof ariaLabel === "string" ? ariaLabel : ariaLabel(newRange) : void 0;
  var disabled = direction === CalendarYearNavDirection.Previous ? minYear !== void 0 && fromYear < minYear : maxYear !== void 0 && props.fromYear + CELL_COUNT > maxYear;
  var onNavigate = function() {
    direction === CalendarYearNavDirection.Previous ? onSelectPrev === null || onSelectPrev === void 0 ? void 0 : onSelectPrev() : onSelectNext === null || onSelectNext === void 0 ? void 0 : onSelectNext();
  };
  var onKeyDown = function(ev) {
    if (ev.which === KeyCodes.enter) {
      onNavigate();
    }
  };
  var isLeftNavigation = getRTL() ? direction === CalendarYearNavDirection.Next : direction === CalendarYearNavDirection.Previous;
  return React__namespace.createElement(
    "button",
    { className: css$3(classNames2.navigationButton, (_a2 = {}, _a2[classNames2.disabled] = disabled, _a2)), onClick: !disabled ? onNavigate : void 0, onKeyDown: !disabled ? onKeyDown : void 0, type: "button", title: ariaLabelString, disabled },
    React__namespace.createElement(Icon, { iconName: isLeftNavigation ? navigationIcons.leftNavigation : navigationIcons.rightNavigation })
  );
};
CalendarYearNavArrow.displayName = "CalendarYearNavArrow";
var CalendarYearNav = function(props) {
  var styles2 = props.styles, theme = props.theme, className = props.className;
  var classNames2 = getClassNames$E(styles2, {
    theme,
    className
  });
  return React__namespace.createElement(
    "div",
    { className: classNames2.navigationButtonsContainer },
    React__namespace.createElement(CalendarYearNavArrow, __assign$1({}, props, { direction: CalendarYearNavDirection.Previous })),
    React__namespace.createElement(CalendarYearNavArrow, __assign$1({}, props, { direction: CalendarYearNavDirection.Next }))
  );
};
CalendarYearNav.displayName = "CalendarYearNav";
var CalendarYearTitle = function(props) {
  var styles2 = props.styles, theme = props.theme, className = props.className, fromYear = props.fromYear, toYear = props.toYear, _a2 = props.strings, strings = _a2 === void 0 ? DefaultCalendarYearStrings : _a2, animateBackwards = props.animateBackwards, animationDirection = props.animationDirection;
  var onHeaderSelect = function() {
    var _a3;
    (_a3 = props.onHeaderSelect) === null || _a3 === void 0 ? void 0 : _a3.call(props, true);
  };
  var onHeaderKeyDown = function(ev) {
    if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
      onHeaderSelect();
    }
  };
  var onRenderYear = function(year) {
    var _a3, _b2;
    return (_b2 = (_a3 = props.onRenderYear) === null || _a3 === void 0 ? void 0 : _a3.call(props, year)) !== null && _b2 !== void 0 ? _b2 : year;
  };
  var classNames2 = getClassNames$E(styles2, {
    theme,
    className,
    hasHeaderClickCallback: !!props.onHeaderSelect,
    animateBackwards,
    animationDirection
  });
  if (props.onHeaderSelect) {
    var rangeAriaLabel = strings.rangeAriaLabel;
    var headerAriaLabelFormatString = strings.headerAriaLabelFormatString;
    var currentDateRange = rangeAriaLabel ? typeof rangeAriaLabel === "string" ? rangeAriaLabel : rangeAriaLabel(props) : void 0;
    var ariaLabel = headerAriaLabelFormatString ? format$1(headerAriaLabelFormatString, currentDateRange) : currentDateRange;
    return React__namespace.createElement(
      "button",
      { className: classNames2.currentItemButton, onClick: onHeaderSelect, onKeyDown: onHeaderKeyDown, "aria-label": ariaLabel, role: "button", type: "button" },
      React__namespace.createElement(
        "span",
        { "aria-live": "assertive", "aria-atomic": "true" },
        onRenderYear(fromYear),
        " - ",
        onRenderYear(toYear)
      )
    );
  }
  return React__namespace.createElement(
    "div",
    { className: classNames2.current },
    onRenderYear(fromYear),
    " - ",
    onRenderYear(toYear)
  );
};
CalendarYearTitle.displayName = "CalendarYearTitle";
var CalendarYearHeader = function(props) {
  var _a2;
  var styles2 = props.styles, theme = props.theme, className = props.className, animateBackwards = props.animateBackwards, animationDirection = props.animationDirection, onRenderTitle = props.onRenderTitle;
  var classNames2 = getClassNames$E(styles2, {
    theme,
    className,
    hasHeaderClickCallback: !!props.onHeaderSelect,
    animateBackwards,
    animationDirection
  });
  return React__namespace.createElement(
    "div",
    { className: classNames2.headerContainer },
    (_a2 = onRenderTitle === null || onRenderTitle === void 0 ? void 0 : onRenderTitle(props)) !== null && _a2 !== void 0 ? _a2 : React__namespace.createElement(CalendarYearTitle, __assign$1({}, props)),
    React__namespace.createElement(CalendarYearNav, __assign$1({}, props))
  );
};
CalendarYearHeader.displayName = "CalendarYearHeader";
function useAnimateBackwards$1(_a2) {
  var selectedYear = _a2.selectedYear, navigatedYear = _a2.navigatedYear;
  var rangeYear = selectedYear || navigatedYear || (/* @__PURE__ */ new Date()).getFullYear();
  var fromYear = Math.floor(rangeYear / 10) * 10;
  var previousFromYear = usePrevious(fromYear);
  if (!previousFromYear || previousFromYear === fromYear) {
    return void 0;
  } else if (previousFromYear > fromYear) {
    return true;
  } else {
    return false;
  }
}
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2[NavigationDirection2["Previous"] = 0] = "Previous";
  NavigationDirection2[NavigationDirection2["Next"] = 1] = "Next";
})(NavigationDirection || (NavigationDirection = {}));
function useYearRangeState(_a2) {
  var selectedYear = _a2.selectedYear, navigatedYear = _a2.navigatedYear;
  var _b2 = React__namespace.useReducer(function(state, action) {
    return state + (action === NavigationDirection.Next ? CELL_COUNT : -CELL_COUNT);
  }, void 0, function() {
    var rangeYear = selectedYear || navigatedYear || (/* @__PURE__ */ new Date()).getFullYear();
    return Math.floor(rangeYear / 10) * 10;
  }), fromYear = _b2[0], navigate = _b2[1];
  var toYear = fromYear + CELL_COUNT - 1;
  var onNavNext = function() {
    return navigate(NavigationDirection.Next);
  };
  var onNavPrevious = function() {
    return navigate(NavigationDirection.Previous);
  };
  return [fromYear, toYear, onNavNext, onNavPrevious];
}
var CalendarYearBase = function(props) {
  var animateBackwards = useAnimateBackwards$1(props);
  var _a2 = useYearRangeState(props), fromYear = _a2[0], toYear = _a2[1], onNavNext = _a2[2], onNavPrevious = _a2[3];
  var gridRef = React__namespace.useRef(null);
  React__namespace.useImperativeHandle(props.componentRef, function() {
    return {
      focus: function() {
        var _a3, _b2;
        (_b2 = (_a3 = gridRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus) === null || _b2 === void 0 ? void 0 : _b2.call(_a3);
      }
    };
  });
  var styles2 = props.styles, theme = props.theme, className = props.className;
  var classNames2 = getClassNames$E(styles2, {
    theme,
    className
  });
  return React__namespace.createElement(
    "div",
    { className: classNames2.root },
    React__namespace.createElement(CalendarYearHeader, __assign$1({}, props, { fromYear, toYear, onSelectPrev: onNavPrevious, onSelectNext: onNavNext, animateBackwards })),
    React__namespace.createElement(CalendarYearGrid, __assign$1({}, props, { fromYear, toYear, animateBackwards, componentRef: gridRef }))
  );
};
CalendarYearBase.displayName = "CalendarYearBase";
var CalendarYear = styled(CalendarYearBase, getStyles$v, void 0, { scope: "CalendarYear" });
var MONTHS_PER_ROW = 4;
var getClassNames$D = classNamesFunction();
var DEFAULT_PROPS$6 = {
  styles: getStyles$w,
  strings: void 0,
  navigationIcons: defaultCalendarNavigationIcons,
  dateTimeFormatter: DEFAULT_DATE_FORMATTING,
  yearPickerHidden: false
};
function useAnimateBackwards(_a2) {
  var navigatedDate = _a2.navigatedDate;
  var currentYear = navigatedDate.getFullYear();
  var previousYear = usePrevious(currentYear);
  if (previousYear === void 0 || previousYear === currentYear) {
    return void 0;
  } else {
    return previousYear > currentYear;
  }
}
function useFocusLogic$2(_a2) {
  var componentRef = _a2.componentRef;
  var navigatedMonthRef = React__namespace.useRef(null);
  var calendarYearRef = React__namespace.useRef(null);
  var focusOnUpdate = React__namespace.useRef(false);
  var focus = React__namespace.useCallback(function() {
    if (calendarYearRef.current) {
      calendarYearRef.current.focus();
    } else if (navigatedMonthRef.current) {
      navigatedMonthRef.current.focus();
    }
  }, []);
  React__namespace.useImperativeHandle(componentRef, function() {
    return { focus };
  }, [focus]);
  React__namespace.useEffect(function() {
    if (focusOnUpdate.current) {
      focus();
      focusOnUpdate.current = false;
    }
  });
  var focusOnNextUpdate = function() {
    focusOnUpdate.current = true;
  };
  return [navigatedMonthRef, calendarYearRef, focusOnNextUpdate];
}
var CalendarMonthBase = function(propsWithoutDefaults) {
  var _a2, _b2;
  var props = getPropsWithDefaults(DEFAULT_PROPS$6, propsWithoutDefaults);
  var _c2 = useFocusLogic$2(props), navigatedMonthRef = _c2[0], calendarYearRef = _c2[1], focusOnNextUpdate = _c2[2];
  var _d2 = React__namespace.useState(false), isYearPickerVisible = _d2[0], setIsYearPickerVisible = _d2[1];
  var animateBackwards = useAnimateBackwards(props);
  var navigatedDate = props.navigatedDate, selectedDate = props.selectedDate, strings = props.strings, _e2 = props.today, today = _e2 === void 0 ? /* @__PURE__ */ new Date() : _e2, navigationIcons = props.navigationIcons, dateTimeFormatter = props.dateTimeFormatter, minDate = props.minDate, maxDate = props.maxDate, theme = props.theme, styles2 = props.styles, className = props.className, allFocusable = props.allFocusable, highlightCurrentMonth = props.highlightCurrentMonth, highlightSelectedMonth = props.highlightSelectedMonth, animationDirection = props.animationDirection, yearPickerHidden = props.yearPickerHidden, onNavigateDate = props.onNavigateDate;
  var selectMonthCallback = function(newMonth) {
    return function() {
      return onSelectMonth(newMonth);
    };
  };
  var onSelectNextYear = function() {
    onNavigateDate(addYears(navigatedDate, 1), false);
  };
  var onSelectPrevYear = function() {
    onNavigateDate(addYears(navigatedDate, -1), false);
  };
  var onSelectMonth = function(newMonth) {
    var _a3;
    (_a3 = props.onHeaderSelect) === null || _a3 === void 0 ? void 0 : _a3.call(props);
    onNavigateDate(setMonth(navigatedDate, newMonth), true);
  };
  var onHeaderSelect = function() {
    var _a3;
    if (!yearPickerHidden) {
      focusOnNextUpdate();
      setIsYearPickerVisible(true);
    } else {
      (_a3 = props.onHeaderSelect) === null || _a3 === void 0 ? void 0 : _a3.call(props);
    }
  };
  var onSelectYear = function(selectedYear) {
    focusOnNextUpdate();
    var navYear = navigatedDate.getFullYear();
    if (navYear !== selectedYear) {
      var newNavigationDate = new Date(navigatedDate.getTime());
      newNavigationDate.setFullYear(selectedYear);
      if (maxDate && newNavigationDate > maxDate) {
        newNavigationDate = setMonth(newNavigationDate, maxDate.getMonth());
      } else if (minDate && newNavigationDate < minDate) {
        newNavigationDate = setMonth(newNavigationDate, minDate.getMonth());
      }
      onNavigateDate(newNavigationDate, true);
    }
    setIsYearPickerVisible(false);
  };
  var onYearPickerHeaderSelect = function(focus) {
    focusOnNextUpdate();
    setIsYearPickerVisible(false);
  };
  var leftNavigationIcon = navigationIcons.leftNavigation;
  var rightNavigationIcon = navigationIcons.rightNavigation;
  var dateFormatter = dateTimeFormatter;
  var isPrevYearInBounds = minDate ? compareDatePart(minDate, getYearStart(navigatedDate)) < 0 : true;
  var isNextYearInBounds = maxDate ? compareDatePart(getYearEnd(navigatedDate), maxDate) < 0 : true;
  var classNames2 = getClassNames$D(styles2, {
    theme,
    className,
    hasHeaderClickCallback: !!props.onHeaderSelect || !yearPickerHidden,
    highlightCurrent: highlightCurrentMonth,
    highlightSelected: highlightSelectedMonth,
    animateBackwards,
    animationDirection
  });
  if (isYearPickerVisible) {
    var _f = getYearStrings(props), onRenderYear = _f[0], yearStrings = _f[1];
    return React__namespace.createElement(CalendarYear, {
      key: "calendarYear",
      minYear: minDate ? minDate.getFullYear() : void 0,
      maxYear: maxDate ? maxDate.getFullYear() : void 0,
      // eslint-disable-next-line react/jsx-no-bind
      onSelectYear,
      navigationIcons,
      // eslint-disable-next-line react/jsx-no-bind
      onHeaderSelect: onYearPickerHeaderSelect,
      selectedYear: selectedDate ? selectedDate.getFullYear() : navigatedDate ? navigatedDate.getFullYear() : void 0,
      onRenderYear,
      strings: yearStrings,
      componentRef: calendarYearRef,
      styles: styles2,
      highlightCurrentYear: highlightCurrentMonth,
      highlightSelectedYear: highlightSelectedMonth,
      animationDirection
    });
  }
  var rowIndexes = [];
  for (var i = 0; i < strings.shortMonths.length / MONTHS_PER_ROW; i++) {
    rowIndexes.push(i);
  }
  var yearString = dateFormatter.formatYear(navigatedDate);
  var headerAriaLabel = strings.monthPickerHeaderAriaLabel ? format$1(strings.monthPickerHeaderAriaLabel, yearString) : yearString;
  return React__namespace.createElement(
    "div",
    { className: classNames2.root },
    React__namespace.createElement(
      "div",
      { className: classNames2.headerContainer },
      React__namespace.createElement(
        "button",
        { className: classNames2.currentItemButton, onClick: onHeaderSelect, onKeyDown: onButtonKeyDown(onHeaderSelect), "aria-label": headerAriaLabel, "data-is-focusable": !!props.onHeaderSelect || !yearPickerHidden, tabIndex: !!props.onHeaderSelect || !yearPickerHidden ? 0 : -1, type: "button" },
        React__namespace.createElement("span", { "aria-live": "polite", "aria-atomic": "true" }, yearString)
      ),
      React__namespace.createElement(
        "div",
        { className: classNames2.navigationButtonsContainer },
        React__namespace.createElement(
          "button",
          { className: css$3(classNames2.navigationButton, (_a2 = {}, _a2[classNames2.disabled] = !isPrevYearInBounds, _a2)), "aria-disabled": !isPrevYearInBounds, tabIndex: isPrevYearInBounds ? void 0 : allFocusable ? 0 : -1, onClick: isPrevYearInBounds ? onSelectPrevYear : void 0, onKeyDown: isPrevYearInBounds ? onButtonKeyDown(onSelectPrevYear) : void 0, title: strings.prevYearAriaLabel ? strings.prevYearAriaLabel + " " + dateFormatter.formatYear(addYears(navigatedDate, -1)) : void 0, type: "button" },
          React__namespace.createElement(Icon, { iconName: getRTL() ? rightNavigationIcon : leftNavigationIcon })
        ),
        React__namespace.createElement(
          "button",
          { className: css$3(classNames2.navigationButton, (_b2 = {}, _b2[classNames2.disabled] = !isNextYearInBounds, _b2)), "aria-disabled": !isNextYearInBounds, tabIndex: isNextYearInBounds ? void 0 : allFocusable ? 0 : -1, onClick: isNextYearInBounds ? onSelectNextYear : void 0, onKeyDown: isNextYearInBounds ? onButtonKeyDown(onSelectNextYear) : void 0, title: strings.nextYearAriaLabel ? strings.nextYearAriaLabel + " " + dateFormatter.formatYear(addYears(navigatedDate, 1)) : void 0, type: "button" },
          React__namespace.createElement(Icon, { iconName: getRTL() ? leftNavigationIcon : rightNavigationIcon })
        )
      )
    ),
    React__namespace.createElement(
      FocusZone,
      null,
      React__namespace.createElement("div", { className: classNames2.gridContainer, role: "grid", "aria-label": yearString }, rowIndexes.map(function(rowNum) {
        var monthsForRow = strings.shortMonths.slice(rowNum * MONTHS_PER_ROW, (rowNum + 1) * MONTHS_PER_ROW);
        return React__namespace.createElement("div", { key: "monthRow_" + rowNum + navigatedDate.getFullYear(), role: "row", className: classNames2.buttonRow }, monthsForRow.map(function(month, index2) {
          var _a3;
          var monthIndex = rowNum * MONTHS_PER_ROW + index2;
          var indexedMonth = setMonth(navigatedDate, monthIndex);
          var isNavigatedMonth = navigatedDate.getMonth() === monthIndex;
          var isSelectedMonth = selectedDate.getMonth() === monthIndex;
          var isSelectedYear = selectedDate.getFullYear() === navigatedDate.getFullYear();
          var isInBounds = (minDate ? compareDatePart(minDate, getMonthEnd(indexedMonth)) < 1 : true) && (maxDate ? compareDatePart(getMonthStart(indexedMonth), maxDate) < 1 : true);
          return React__namespace.createElement("button", { ref: isNavigatedMonth ? navigatedMonthRef : void 0, role: "gridcell", className: css$3(classNames2.itemButton, (_a3 = {}, _a3[classNames2.current] = highlightCurrentMonth && isCurrentMonth(monthIndex, navigatedDate.getFullYear(), today), _a3[classNames2.selected] = highlightSelectedMonth && isSelectedMonth && isSelectedYear, _a3[classNames2.disabled] = !isInBounds, _a3)), disabled: !allFocusable && !isInBounds, key: monthIndex, onClick: isInBounds ? selectMonthCallback(monthIndex) : void 0, onKeyDown: isInBounds ? onButtonKeyDown(selectMonthCallback(monthIndex)) : void 0, "aria-label": dateFormatter.formatMonth(indexedMonth, strings), "aria-selected": isNavigatedMonth, "data-is-focusable": isInBounds ? true : void 0, type: "button" }, month);
        }));
      }))
    )
  );
};
CalendarMonthBase.displayName = "CalendarMonthBase";
function getYearStrings(_a2) {
  var strings = _a2.strings, navigatedDate = _a2.navigatedDate, dateTimeFormatter = _a2.dateTimeFormatter;
  var yearToString = function(year) {
    if (dateTimeFormatter) {
      var yearFormattingDate = new Date(navigatedDate.getTime());
      yearFormattingDate.setFullYear(year);
      return dateTimeFormatter.formatYear(yearFormattingDate);
    }
    return String(year);
  };
  var yearRangeToString = function(yearRange) {
    return yearToString(yearRange.fromYear) + " - " + yearToString(yearRange.toYear);
  };
  var yearRangeToNextDecadeLabel = function(yearRange) {
    return strings.nextYearRangeAriaLabel ? strings.nextYearRangeAriaLabel + " " + yearRangeToString(yearRange) : "";
  };
  var yearRangeToPrevDecadeLabel = function(yearRange) {
    return strings.prevYearRangeAriaLabel ? strings.prevYearRangeAriaLabel + " " + yearRangeToString(yearRange) : "";
  };
  return [
    yearToString,
    {
      rangeAriaLabel: yearRangeToString,
      prevRangeAriaLabel: yearRangeToPrevDecadeLabel,
      nextRangeAriaLabel: yearRangeToNextDecadeLabel,
      headerAriaLabelFormatString: strings.yearPickerHeaderAriaLabel
    }
  ];
}
function isCurrentMonth(month, year, today) {
  return today.getFullYear() === year && today.getMonth() === month;
}
function onButtonKeyDown(callback) {
  return function(ev) {
    switch (ev.which) {
      case KeyCodes.enter:
        callback();
        break;
    }
  };
}
var CalendarMonth = styled(CalendarMonthBase, getStyles$w, void 0, { scope: "CalendarMonth" });
var MIN_SIZE_FORCE_OVERLAY = 440;
var getClassNames$C = classNamesFunction();
var defaultWorkWeekDays = [
  DayOfWeek.Monday,
  DayOfWeek.Tuesday,
  DayOfWeek.Wednesday,
  DayOfWeek.Thursday,
  DayOfWeek.Friday
];
var DEFAULT_PROPS$5 = {
  isMonthPickerVisible: true,
  isDayPickerVisible: true,
  showMonthPickerAsOverlay: false,
  today: /* @__PURE__ */ new Date(),
  firstDayOfWeek: DayOfWeek.Sunday,
  dateRangeType: DateRangeType.Day,
  showGoToToday: true,
  strings: DEFAULT_CALENDAR_STRINGS,
  highlightCurrentMonth: false,
  highlightSelectedMonth: false,
  navigationIcons: defaultCalendarNavigationIcons,
  showWeekNumbers: false,
  firstWeekOfYear: FirstWeekOfYear.FirstDay,
  dateTimeFormatter: DEFAULT_DATE_FORMATTING,
  showSixWeeksByDefault: false,
  workWeekDays: defaultWorkWeekDays,
  showCloseButton: false,
  allFocusable: false
};
function useDateState(_a2) {
  var value = _a2.value, _b2 = _a2.today, today = _b2 === void 0 ? /* @__PURE__ */ new Date() : _b2, onSelectDate = _a2.onSelectDate;
  var _c2 = useControllableValue(value, today), _d2 = _c2[0], selectedDate = _d2 === void 0 ? today : _d2, setSelectedDate = _c2[1];
  var _e2 = React__namespace.useState(value), _f = _e2[0], navigatedDay = _f === void 0 ? today : _f, setNavigatedDay = _e2[1];
  var _g = React__namespace.useState(value), _h = _g[0], navigatedMonth = _h === void 0 ? today : _h, setNavigatedMonth = _g[1];
  var _j = React__namespace.useState(value), _k = _j[0], lastSelectedDate = _k === void 0 ? today : _k, setLastSelectedDate = _j[1];
  if (value && lastSelectedDate.valueOf() !== value.valueOf()) {
    setNavigatedDay(value);
    setNavigatedMonth(value);
    setLastSelectedDate(value);
  }
  var navigateMonth = function(date) {
    setNavigatedMonth(date);
  };
  var navigateDay = function(date) {
    setNavigatedMonth(date);
    setNavigatedDay(date);
  };
  var onDateSelected = function(date, selectedDateRangeArray) {
    setNavigatedMonth(date);
    setNavigatedDay(date);
    setSelectedDate(date);
    onSelectDate === null || onSelectDate === void 0 ? void 0 : onSelectDate(date, selectedDateRangeArray);
  };
  return [selectedDate, navigatedDay, navigatedMonth, onDateSelected, navigateDay, navigateMonth];
}
function useVisibilityState(props) {
  var _a2 = useControllableValue(getShowMonthPickerAsOverlay(props) ? void 0 : props.isMonthPickerVisible, false), _b2 = _a2[0], isMonthPickerVisible = _b2 === void 0 ? true : _b2, setIsMonthPickerVisible = _a2[1];
  var _c2 = useControllableValue(getShowMonthPickerAsOverlay(props) ? void 0 : props.isDayPickerVisible, true), _d2 = _c2[0], isDayPickerVisible = _d2 === void 0 ? true : _d2, setIsDayPickerVisible = _c2[1];
  var toggleDayMonthPickerVisibility = function() {
    setIsMonthPickerVisible(!isMonthPickerVisible);
    setIsDayPickerVisible(!isDayPickerVisible);
  };
  return [isMonthPickerVisible, isDayPickerVisible, toggleDayMonthPickerVisibility];
}
function useFocusLogic$1(_a2, isDayPickerVisible, isMonthPickerVisible) {
  var componentRef = _a2.componentRef;
  var dayPicker = React__namespace.useRef(null);
  var monthPicker = React__namespace.useRef(null);
  var focusOnUpdate = React__namespace.useRef(false);
  var focus = React__namespace.useCallback(function() {
    if (isDayPickerVisible && dayPicker.current) {
      focusAsync(dayPicker.current);
    } else if (isMonthPickerVisible && monthPicker.current) {
      focusAsync(monthPicker.current);
    }
  }, [isDayPickerVisible, isMonthPickerVisible]);
  React__namespace.useImperativeHandle(componentRef, function() {
    return { focus };
  }, [focus]);
  React__namespace.useEffect(function() {
    if (focusOnUpdate.current) {
      focus();
      focusOnUpdate.current = false;
    }
  });
  var focusOnNextUpdate = function() {
    focusOnUpdate.current = true;
  };
  return [dayPicker, monthPicker, focusOnNextUpdate];
}
var CalendarBase = React__namespace.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults(DEFAULT_PROPS$5, propsWithoutDefaults);
  var _a2 = useDateState(props), selectedDate = _a2[0], navigatedDay = _a2[1], navigatedMonth = _a2[2], onDateSelected = _a2[3], navigateDay = _a2[4], navigateMonth = _a2[5];
  var _b2 = useVisibilityState(props), isMonthPickerVisible = _b2[0], isDayPickerVisible = _b2[1], toggleDayMonthPickerVisibility = _b2[2];
  var _c2 = useFocusLogic$1(props, isDayPickerVisible, isMonthPickerVisible), dayPicker = _c2[0], monthPicker = _c2[1], focusOnNextUpdate = _c2[2];
  var renderGoToTodayButton = function() {
    var goTodayEnabled = showGoToToday;
    if (goTodayEnabled && today) {
      goTodayEnabled = navigatedDay.getFullYear() !== today.getFullYear() || navigatedDay.getMonth() !== today.getMonth() || navigatedMonth.getFullYear() !== today.getFullYear() || navigatedMonth.getMonth() !== today.getMonth();
    }
    return showGoToToday && React__namespace.createElement("button", { className: css$3("js-goToday", classes.goTodayButton), onClick: onGotoToday, onKeyDown: onButtonKeyDown2(onGotoToday), type: "button", disabled: !goTodayEnabled }, strings.goToToday);
  };
  var onNavigateDayDate = function(date, focusOnNavigatedDay) {
    navigateDay(date);
    if (focusOnNavigatedDay) {
      focusOnNextUpdate();
    }
  };
  var onNavigateMonthDate = function(date, focusOnNavigatedDay) {
    if (focusOnNavigatedDay) {
      focusOnNextUpdate();
    }
    if (!focusOnNavigatedDay) {
      navigateMonth(date);
      return;
    }
    if (monthPickerOnly) {
      onDateSelected(date);
    }
    navigateDay(date);
  };
  var onHeaderSelect = getShowMonthPickerAsOverlay(props) ? function() {
    toggleDayMonthPickerVisibility();
    focusOnNextUpdate();
  } : void 0;
  var onGotoToday = function() {
    navigateDay(today);
    focusOnNextUpdate();
  };
  var onButtonKeyDown2 = function(callback) {
    return function(ev) {
      switch (ev.which) {
        case KeyCodes.enter:
        case KeyCodes.space:
          callback();
          break;
      }
    };
  };
  var onDatePickerPopupKeyDown = function(ev) {
    var _a3;
    switch (ev.which) {
      case KeyCodes.enter:
        ev.preventDefault();
        break;
      case KeyCodes.backspace:
        ev.preventDefault();
        break;
      case KeyCodes.escape:
        (_a3 = props.onDismiss) === null || _a3 === void 0 ? void 0 : _a3.call(props);
        break;
      case KeyCodes.pageUp:
        if (ev.ctrlKey) {
          navigateDay(addYears(navigatedDay, 1));
        } else {
          navigateDay(addMonths(navigatedDay, 1));
        }
        ev.preventDefault();
        break;
      case KeyCodes.pageDown:
        if (ev.ctrlKey) {
          navigateDay(addYears(navigatedDay, -1));
        } else {
          navigateDay(addMonths(navigatedDay, -1));
        }
        ev.preventDefault();
        break;
    }
  };
  var rootClass = "ms-DatePicker";
  var firstDayOfWeek = props.firstDayOfWeek, dateRangeType = props.dateRangeType, strings = props.strings, showGoToToday = props.showGoToToday, highlightCurrentMonth = props.highlightCurrentMonth, highlightSelectedMonth = props.highlightSelectedMonth, navigationIcons = props.navigationIcons, minDate = props.minDate, maxDate = props.maxDate, restrictedDates = props.restrictedDates, id = props.id, className = props.className, showCloseButton = props.showCloseButton, allFocusable = props.allFocusable, styles2 = props.styles, showWeekNumbers = props.showWeekNumbers, theme = props.theme, calendarDayProps = props.calendarDayProps, calendarMonthProps = props.calendarMonthProps, dateTimeFormatter = props.dateTimeFormatter, _d2 = props.today, today = _d2 === void 0 ? /* @__PURE__ */ new Date() : _d2;
  var showMonthPickerAsOverlay = getShowMonthPickerAsOverlay(props);
  var monthPickerOnly = !showMonthPickerAsOverlay && !isDayPickerVisible;
  var overlaidWithButton = showMonthPickerAsOverlay && showGoToToday;
  var classes = getClassNames$C(styles2, {
    theme,
    className,
    isMonthPickerVisible,
    isDayPickerVisible,
    monthPickerOnly,
    showMonthPickerAsOverlay,
    overlaidWithButton,
    overlayedWithButton: overlaidWithButton,
    showGoToToday,
    showWeekNumbers
  });
  var todayDateString = "";
  var selectedDateString = "";
  if (dateTimeFormatter && strings.todayDateFormatString) {
    todayDateString = format$1(strings.todayDateFormatString, dateTimeFormatter.formatMonthDayYear(today, strings));
  }
  if (dateTimeFormatter && strings.selectedDateFormatString) {
    selectedDateString = format$1(strings.selectedDateFormatString, dateTimeFormatter.formatMonthDayYear(selectedDate, strings));
  }
  var selectionAndTodayString = selectedDateString + ", " + todayDateString;
  return React__namespace.createElement(
    "div",
    { id, ref: forwardedRef, role: "group", "aria-label": selectionAndTodayString, className: css$3(rootClass, classes.root, className, "ms-slideDownIn10"), onKeyDown: onDatePickerPopupKeyDown },
    React__namespace.createElement(
      "div",
      { className: classes.liveRegion, "aria-live": "polite", "aria-atomic": "true" },
      React__namespace.createElement("span", null, selectedDateString)
    ),
    isDayPickerVisible && React__namespace.createElement(CalendarDay, __assign$1({
      selectedDate,
      navigatedDate: navigatedDay,
      today: props.today,
      onSelectDate: onDateSelected,
      // eslint-disable-next-line react/jsx-no-bind
      onNavigateDate: onNavigateDayDate,
      onDismiss: props.onDismiss,
      firstDayOfWeek,
      dateRangeType,
      strings,
      // eslint-disable-next-line react/jsx-no-bind
      onHeaderSelect,
      navigationIcons,
      showWeekNumbers: props.showWeekNumbers,
      firstWeekOfYear: props.firstWeekOfYear,
      dateTimeFormatter: props.dateTimeFormatter,
      showSixWeeksByDefault: props.showSixWeeksByDefault,
      minDate,
      maxDate,
      restrictedDates,
      workWeekDays: props.workWeekDays,
      componentRef: dayPicker,
      showCloseButton,
      allFocusable
    }, calendarDayProps)),
    isDayPickerVisible && isMonthPickerVisible && React__namespace.createElement("div", { className: classes.divider }),
    isMonthPickerVisible ? React__namespace.createElement(
      "div",
      { className: classes.monthPickerWrapper },
      React__namespace.createElement(CalendarMonth, __assign$1({
        navigatedDate: navigatedMonth,
        selectedDate: navigatedDay,
        strings,
        // eslint-disable-next-line react/jsx-no-bind
        onNavigateDate: onNavigateMonthDate,
        today: props.today,
        highlightCurrentMonth,
        highlightSelectedMonth,
        // eslint-disable-next-line react/jsx-no-bind
        onHeaderSelect,
        navigationIcons,
        dateTimeFormatter: props.dateTimeFormatter,
        minDate,
        maxDate,
        componentRef: monthPicker
      }, calendarMonthProps)),
      renderGoToTodayButton()
    ) : renderGoToTodayButton(),
    React__namespace.createElement(FocusRects, null)
  );
});
CalendarBase.displayName = "CalendarBase";
function getShowMonthPickerAsOverlay(_a2) {
  var showMonthPickerAsOverlay = _a2.showMonthPickerAsOverlay, isDayPickerVisible = _a2.isDayPickerVisible;
  var win2 = getWindow$1();
  return showMonthPickerAsOverlay || isDayPickerVisible && win2 && win2.innerWidth <= MIN_SIZE_FORCE_OVERLAY;
}
var styles$4 = function(props) {
  var className = props.className, theme = props.theme, isDayPickerVisible = props.isDayPickerVisible, isMonthPickerVisible = props.isMonthPickerVisible, showWeekNumbers = props.showWeekNumbers;
  var palette = theme.palette;
  var totalWidth = isDayPickerVisible && isMonthPickerVisible ? 440 : 220;
  if (showWeekNumbers && isDayPickerVisible) {
    totalWidth += 30;
  }
  return {
    root: [
      normalize,
      {
        display: "flex",
        width: totalWidth
      },
      !isMonthPickerVisible && {
        flexDirection: "column"
      },
      className
    ],
    divider: {
      top: 0,
      borderRight: "1px solid",
      borderColor: palette.neutralLight
    },
    monthPickerWrapper: [
      {
        display: "flex",
        flexDirection: "column"
      }
    ],
    goTodayButton: [
      getFocusStyle(theme, { inset: -1 }),
      {
        bottom: 0,
        color: palette.neutralPrimary,
        height: 30,
        lineHeight: 30,
        backgroundColor: "transparent",
        border: "none",
        boxSizing: "content-box",
        padding: "0 4px",
        alignSelf: "flex-end",
        marginRight: 16,
        marginTop: 3,
        fontSize: FontSizes.small,
        fontFamily: "inherit",
        overflow: "visible",
        selectors: {
          "& div": {
            fontSize: FontSizes.small
          },
          "&:hover": {
            color: palette.themePrimary,
            backgroundColor: "transparent",
            cursor: "pointer"
          },
          "&:active": {
            color: palette.themeDark
          },
          "&:disabled": {
            color: palette.neutralTertiaryAlt,
            pointerEvents: "none"
          }
        }
      }
    ],
    liveRegion: {
      border: 0,
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: 0,
      width: "1px",
      position: "absolute"
    }
  };
};
var Calendar = styled(CalendarBase, styles$4, void 0, {
  scope: "Calendar"
});
var getClassNames$B = classNamesFunction();
var CheckBase = React__namespace.forwardRef(function(props, ref) {
  var _a2 = props.checked, checked = _a2 === void 0 ? false : _a2, className = props.className, theme = props.theme, styles2 = props.styles, _b2 = props.useFastIcons, useFastIcons = _b2 === void 0 ? true : _b2;
  var classNames2 = getClassNames$B(styles2, { theme, className, checked });
  var IconComponent = useFastIcons ? FontIcon : Icon;
  return React__namespace.createElement(
    "div",
    { className: classNames2.root, ref },
    React__namespace.createElement(IconComponent, { iconName: "CircleRing", className: classNames2.circle }),
    React__namespace.createElement(IconComponent, { iconName: "StatusCircleCheckmark", className: classNames2.check })
  );
});
CheckBase.displayName = "CheckBase";
var CheckGlobalClassNames = {
  root: "ms-Check",
  circle: "ms-Check-circle",
  check: "ms-Check-check",
  /** Must be manually applied to the parent element of the check. */
  checkHost: "ms-Check-checkHost"
};
var getStyles$u = function(props) {
  var _a2, _b2, _c2, _d2, _e2;
  var _f = props.height, height = _f === void 0 ? props.checkBoxHeight || "18px" : _f, checked = props.checked, className = props.className, theme = props.theme;
  var palette = theme.palette, semanticColors = theme.semanticColors, fonts = theme.fonts;
  var isRTL = getRTL(theme);
  var classNames2 = getGlobalClassNames(CheckGlobalClassNames, theme);
  var sharedCircleCheck = {
    fontSize: height,
    position: "absolute",
    left: 0,
    top: 0,
    width: height,
    height,
    textAlign: "center",
    // inline-flex prevents the check from shifting with custom line height styles
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    verticalAlign: "middle"
  };
  return {
    root: [
      classNames2.root,
      fonts.medium,
      {
        // lineHeight currently needs to be a string to output without 'px'
        lineHeight: "1",
        width: height,
        height,
        verticalAlign: "top",
        position: "relative",
        userSelect: "none",
        selectors: (_a2 = {
          ":before": {
            content: '""',
            position: "absolute",
            top: "1px",
            right: "1px",
            bottom: "1px",
            left: "1px",
            borderRadius: "50%",
            opacity: 1,
            background: semanticColors.bodyBackground
          }
        }, _a2["." + classNames2.checkHost + ":hover &, ." + classNames2.checkHost + ":focus &, &:hover, &:focus"] = {
          opacity: 1
        }, _a2)
      },
      checked && [
        "is-checked",
        {
          selectors: {
            ":before": {
              background: palette.themePrimary,
              opacity: 1,
              selectors: (_b2 = {}, _b2[HighContrastSelector] = {
                background: "Window"
              }, _b2)
            }
          }
        }
      ],
      className
    ],
    circle: [
      classNames2.circle,
      sharedCircleCheck,
      {
        color: palette.neutralSecondary,
        selectors: (_c2 = {}, _c2[HighContrastSelector] = {
          color: "WindowText"
        }, _c2)
      },
      checked && {
        color: palette.white
      }
    ],
    check: [
      classNames2.check,
      sharedCircleCheck,
      {
        opacity: 0,
        color: palette.neutralSecondary,
        fontSize: IconFontSizes.medium,
        left: isRTL ? "-0.5px" : ".5px",
        top: "-1px",
        selectors: (_d2 = {
          ":hover": {
            opacity: 1
          }
        }, _d2[HighContrastSelector] = __assign$1({}, getHighContrastNoAdjustStyle()), _d2)
      },
      checked && {
        opacity: 1,
        color: palette.white,
        fontWeight: 900,
        selectors: (_e2 = {}, _e2[HighContrastSelector] = {
          border: "none",
          color: "WindowText"
        }, _e2)
      }
    ],
    checkHost: classNames2.checkHost
  };
};
var Check = styled(CheckBase, getStyles$u, void 0, {
  scope: "Check"
}, true);
var getClassNames$A = classNamesFunction();
var CheckboxBase = React__namespace.forwardRef(function(props, forwardedRef) {
  var disabled = props.disabled, required = props.required, inputProps = props.inputProps, name = props.name, ariaLabel = props.ariaLabel, ariaLabelledBy = props.ariaLabelledBy, ariaDescribedBy = props.ariaDescribedBy, ariaPositionInSet = props.ariaPositionInSet, ariaSetSize = props.ariaSetSize, title = props.title, checkmarkIconProps = props.checkmarkIconProps, styles2 = props.styles, theme = props.theme, className = props.className, _a2 = props.boxSide, boxSide = _a2 === void 0 ? "start" : _a2;
  var id = useId("checkbox-", props.id);
  var rootRef = React__namespace.useRef(null);
  var mergedRootRefs = useMergedRefs(rootRef, forwardedRef);
  var inputRef = React__namespace.useRef(null);
  var _b2 = useControllableValue(props.checked, props.defaultChecked, props.onChange), isChecked = _b2[0], setIsChecked = _b2[1];
  var _c2 = useControllableValue(props.indeterminate, props.defaultIndeterminate), isIndeterminate = _c2[0], setIsIndeterminate = _c2[1];
  useFocusRects(rootRef);
  useDebugWarning(props);
  var classNames2 = getClassNames$A(styles2, {
    theme,
    className,
    disabled,
    indeterminate: isIndeterminate,
    checked: isChecked,
    reversed: boxSide !== "start",
    isUsingCustomLabelRender: !!props.onRenderLabel
  });
  var onChange2 = React__namespace.useCallback(function(event) {
    if (isIndeterminate) {
      setIsChecked(!!isChecked, event);
      setIsIndeterminate(false);
    } else {
      setIsChecked(!isChecked, event);
    }
  }, [setIsChecked, setIsIndeterminate, isIndeterminate, isChecked]);
  var defaultLabelRenderer = React__namespace.useCallback(function(checkboxProps) {
    if (!checkboxProps) {
      return null;
    }
    return checkboxProps.label ? React__namespace.createElement("span", { className: classNames2.text, title: checkboxProps.title }, checkboxProps.label) : null;
  }, [classNames2.text]);
  var setNativeIndeterminate = React__namespace.useCallback(function(indeterminate) {
    if (!inputRef.current) {
      return;
    }
    var value = !!indeterminate;
    inputRef.current.indeterminate = value;
    setIsIndeterminate(value);
  }, [setIsIndeterminate]);
  useComponentRef$3(props, isChecked, isIndeterminate, setNativeIndeterminate, inputRef);
  React__namespace.useEffect(function() {
    return setNativeIndeterminate(isIndeterminate);
  }, [setNativeIndeterminate, isIndeterminate]);
  var onRenderLabel = props.onRenderLabel || defaultLabelRenderer;
  var ariaChecked = isIndeterminate ? "mixed" : void 0;
  var mergedInputProps = __assign$1(__assign$1({ className: classNames2.input, type: "checkbox" }, inputProps), { checked: !!isChecked, disabled, required, name, id, title, onChange: onChange2, "aria-disabled": disabled, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, "aria-posinset": ariaPositionInSet, "aria-setsize": ariaSetSize, "aria-checked": ariaChecked });
  return React__namespace.createElement(
    "div",
    { className: classNames2.root, title, ref: mergedRootRefs },
    React__namespace.createElement("input", __assign$1({}, mergedInputProps, { ref: inputRef, title, "data-ktp-execute-target": true })),
    React__namespace.createElement(
      "label",
      { className: classNames2.label, htmlFor: id },
      React__namespace.createElement(
        "div",
        { className: classNames2.checkbox, "data-ktp-target": true },
        React__namespace.createElement(Icon, __assign$1({ iconName: "CheckMark" }, checkmarkIconProps, { className: classNames2.checkmark }))
      ),
      onRenderLabel(props, defaultLabelRenderer)
    )
  );
});
CheckboxBase.displayName = "CheckboxBase";
function useDebugWarning(props) {
  if (process.env.NODE_ENV !== "production") {
    useWarnings({
      name: "Checkbox",
      props,
      mutuallyExclusive: {
        checked: "defaultChecked",
        indeterminate: "defaultIndeterminate"
      }
    });
  }
}
function useComponentRef$3(props, isChecked, isIndeterminate, setIndeterminate, checkBoxRef) {
  React__namespace.useImperativeHandle(props.componentRef, function() {
    return {
      get checked() {
        return !!isChecked;
      },
      get indeterminate() {
        return !!isIndeterminate;
      },
      set indeterminate(indeterminate) {
        setIndeterminate(indeterminate);
      },
      focus: function() {
        if (checkBoxRef.current) {
          checkBoxRef.current.focus();
        }
      }
    };
  }, [checkBoxRef, isChecked, isIndeterminate, setIndeterminate]);
}
var GlobalClassNames$r = {
  root: "ms-Checkbox",
  label: "ms-Checkbox-label",
  checkbox: "ms-Checkbox-checkbox",
  checkmark: "ms-Checkbox-checkmark",
  text: "ms-Checkbox-text"
};
var MS_CHECKBOX_LABEL_SIZE = "20px";
var MS_CHECKBOX_TRANSITION_DURATION = "200ms";
var MS_CHECKBOX_TRANSITION_TIMING = "cubic-bezier(.4, 0, .23, 1)";
var getStyles$t = function(props) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  var className = props.className, theme = props.theme, reversed = props.reversed, checked = props.checked, disabled = props.disabled, isUsingCustomLabelRender = props.isUsingCustomLabelRender, indeterminate = props.indeterminate;
  var semanticColors = theme.semanticColors, effects = theme.effects, palette = theme.palette, fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(GlobalClassNames$r, theme);
  var checkmarkFontColor = semanticColors.inputForegroundChecked;
  var checkmarkFontColorHovered = palette.neutralSecondary;
  var checkboxBorderColor = palette.neutralPrimary;
  var checkboxBorderIndeterminateColor = semanticColors.inputBackgroundChecked;
  var checkboxBorderColorChecked = semanticColors.inputBackgroundChecked;
  var checkboxBorderColorDisabled = semanticColors.disabledBodySubtext;
  var checkboxBorderHoveredColor = semanticColors.inputBorderHovered;
  var checkboxBorderIndeterminateHoveredColor = semanticColors.inputBackgroundCheckedHovered;
  var checkboxBackgroundChecked = semanticColors.inputBackgroundChecked;
  var checkboxBackgroundCheckedHovered = semanticColors.inputBackgroundCheckedHovered;
  var checkboxBorderColorCheckedHovered = semanticColors.inputBackgroundCheckedHovered;
  var checkboxHoveredTextColor = semanticColors.inputTextHovered;
  var checkboxBackgroundDisabledChecked = semanticColors.disabledBodySubtext;
  var checkboxTextColor = semanticColors.bodyText;
  var checkboxTextColorDisabled = semanticColors.disabledText;
  var indeterminateDotStyles = [
    (_a2 = {
      content: '""',
      borderRadius: effects.roundedCorner2,
      position: "absolute",
      width: 10,
      height: 10,
      top: 4,
      left: 4,
      boxSizing: "border-box",
      borderWidth: 5,
      borderStyle: "solid",
      borderColor: disabled ? checkboxBorderColorDisabled : checkboxBorderIndeterminateColor,
      transitionProperty: "border-width, border, border-color",
      transitionDuration: MS_CHECKBOX_TRANSITION_DURATION,
      transitionTimingFunction: MS_CHECKBOX_TRANSITION_TIMING
    }, _a2[HighContrastSelector] = {
      borderColor: "WindowText"
    }, _a2)
  ];
  return {
    root: [
      classNames2.root,
      {
        position: "relative",
        display: "flex"
      },
      reversed && "reversed",
      checked && "is-checked",
      !disabled && "is-enabled",
      disabled && "is-disabled",
      !disabled && [
        !checked && (_b2 = {}, _b2[":hover ." + classNames2.checkbox] = (_c2 = {
          borderColor: checkboxBorderHoveredColor
        }, _c2[HighContrastSelector] = {
          borderColor: "Highlight"
        }, _c2), _b2[":focus ." + classNames2.checkbox] = { borderColor: checkboxBorderHoveredColor }, _b2[":hover ." + classNames2.checkmark] = (_d2 = {
          color: checkmarkFontColorHovered,
          opacity: "1"
        }, _d2[HighContrastSelector] = {
          color: "Highlight"
        }, _d2), _b2),
        checked && !indeterminate && (_e2 = {}, _e2[":hover ." + classNames2.checkbox] = {
          background: checkboxBackgroundCheckedHovered,
          borderColor: checkboxBorderColorCheckedHovered
        }, _e2[":focus ." + classNames2.checkbox] = {
          background: checkboxBackgroundCheckedHovered,
          borderColor: checkboxBorderColorCheckedHovered
        }, _e2[HighContrastSelector] = (_f = {}, _f[":hover ." + classNames2.checkbox] = {
          background: "Highlight",
          borderColor: "Highlight"
        }, _f[":focus ." + classNames2.checkbox] = {
          background: "Highlight"
        }, _f[":focus:hover ." + classNames2.checkbox] = {
          background: "Highlight"
        }, _f[":focus:hover ." + classNames2.checkmark] = {
          color: "Window"
        }, _f[":hover ." + classNames2.checkmark] = {
          color: "Window"
        }, _f), _e2),
        indeterminate && (_g = {}, _g[":hover ." + classNames2.checkbox + ", :hover ." + classNames2.checkbox + ":after"] = (_h = {
          borderColor: checkboxBorderIndeterminateHoveredColor
        }, _h[HighContrastSelector] = {
          borderColor: "WindowText"
        }, _h), _g[":focus ." + classNames2.checkbox] = {
          borderColor: checkboxBorderIndeterminateHoveredColor
        }, _g[":hover ." + classNames2.checkmark] = {
          opacity: "0"
        }, _g),
        (_j = {}, _j[":hover ." + classNames2.text + ", :focus ." + classNames2.text] = (_k = {
          color: checkboxHoveredTextColor
        }, _k[HighContrastSelector] = {
          color: disabled ? "GrayText" : "WindowText"
        }, _k), _j)
      ],
      className
    ],
    input: (_l = {
      position: "absolute",
      background: "none",
      opacity: 0
    }, _l["." + IsFocusVisibleClassName + " &:focus + label::before"] = (_m = {
      outline: "1px solid " + theme.palette.neutralSecondary,
      outlineOffset: "2px"
    }, _m[HighContrastSelector] = {
      outline: "1px solid WindowText"
    }, _m), _l),
    label: [
      classNames2.label,
      theme.fonts.medium,
      {
        display: "flex",
        alignItems: isUsingCustomLabelRender ? "center" : "flex-start",
        cursor: disabled ? "default" : "pointer",
        position: "relative",
        userSelect: "none"
      },
      reversed && {
        flexDirection: "row-reverse",
        justifyContent: "flex-end"
      },
      {
        "&::before": {
          position: "absolute",
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          content: '""',
          pointerEvents: "none"
        }
      }
    ],
    checkbox: [
      classNames2.checkbox,
      (_o = {
        position: "relative",
        display: "flex",
        flexShrink: 0,
        alignItems: "center",
        justifyContent: "center",
        height: MS_CHECKBOX_LABEL_SIZE,
        width: MS_CHECKBOX_LABEL_SIZE,
        border: "1px solid " + checkboxBorderColor,
        borderRadius: effects.roundedCorner2,
        boxSizing: "border-box",
        transitionProperty: "background, border, border-color",
        transitionDuration: MS_CHECKBOX_TRANSITION_DURATION,
        transitionTimingFunction: MS_CHECKBOX_TRANSITION_TIMING,
        /* in case the icon is bigger than the box */
        overflow: "hidden",
        ":after": indeterminate ? indeterminateDotStyles : null
      }, _o[HighContrastSelector] = __assign$1({ borderColor: "WindowText" }, getHighContrastNoAdjustStyle()), _o),
      indeterminate && {
        borderColor: checkboxBorderIndeterminateColor
      },
      !reversed ? (
        // This margin on the checkbox is for backwards compat. Notably it has the effect where a customRender
        // is used, there will be only a 4px margin from checkbox to label. The label by default would have
        // another 4px margin for a total of 8px margin between checkbox and label. We don't combine the two
        // (and move it into the text) to not incur a breaking change for everyone using custom render atm.
        {
          marginRight: 4
        }
      ) : {
        marginLeft: 4
      },
      !disabled && !indeterminate && checked && (_p = {
        background: checkboxBackgroundChecked,
        borderColor: checkboxBorderColorChecked
      }, _p[HighContrastSelector] = {
        background: "Highlight",
        borderColor: "Highlight"
      }, _p),
      disabled && (_q = {
        borderColor: checkboxBorderColorDisabled
      }, _q[HighContrastSelector] = {
        borderColor: "GrayText"
      }, _q),
      checked && disabled && (_r = {
        background: checkboxBackgroundDisabledChecked,
        borderColor: checkboxBorderColorDisabled
      }, _r[HighContrastSelector] = {
        background: "Window"
      }, _r)
    ],
    checkmark: [
      classNames2.checkmark,
      (_s = {
        opacity: checked && !indeterminate ? "1" : "0",
        color: checkmarkFontColor
      }, _s[HighContrastSelector] = __assign$1({ color: disabled ? "GrayText" : "Window" }, getHighContrastNoAdjustStyle()), _s)
    ],
    text: [
      classNames2.text,
      (_t = {
        color: disabled ? checkboxTextColorDisabled : checkboxTextColor,
        fontSize: fonts.medium.fontSize,
        lineHeight: "20px"
      }, _t[HighContrastSelector] = __assign$1({ color: disabled ? "GrayText" : "WindowText" }, getHighContrastNoAdjustStyle()), _t),
      !reversed ? {
        marginLeft: 4
      } : {
        marginRight: 4
      }
    ]
  };
};
var Checkbox = styled(CheckboxBase, getStyles$t, void 0, { scope: "Checkbox" });
var getClassNames$z = classNamesFunction({
  // Label is used a lot by other components.
  // It's likely to see expected cases which pass different className to the Label.
  // Therefore setting a larger cache size.
  cacheSize: 100
});
var LabelBase = (
  /** @class */
  function(_super) {
    __extends(LabelBase2, _super);
    function LabelBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LabelBase2.prototype.render = function() {
      var _a2 = this.props, _b2 = _a2.as, RootType = _b2 === void 0 ? "label" : _b2, children = _a2.children, className = _a2.className, disabled = _a2.disabled, styles2 = _a2.styles, required = _a2.required, theme = _a2.theme;
      var classNames2 = getClassNames$z(styles2, {
        className,
        disabled,
        required,
        theme
      });
      return React__namespace.createElement(RootType, __assign$1({}, getNativeProps(this.props, divProperties), { className: classNames2.root }), children);
    };
    return LabelBase2;
  }(React__namespace.Component)
);
var getStyles$s = function(props) {
  var _a2;
  var theme = props.theme, className = props.className, disabled = props.disabled, required = props.required;
  var semanticColors = theme.semanticColors;
  var labelFontWeight = FontWeights.semibold;
  var labelColor = semanticColors.bodyText;
  var labelDisabledColor = semanticColors.disabledBodyText;
  var labelRequiredStarColor = semanticColors.errorText;
  return {
    root: [
      "ms-Label",
      theme.fonts.medium,
      {
        fontWeight: labelFontWeight,
        color: labelColor,
        boxSizing: "border-box",
        boxShadow: "none",
        margin: 0,
        display: "block",
        padding: "5px 0",
        wordWrap: "break-word",
        overflowWrap: "break-word"
      },
      disabled && {
        color: labelDisabledColor,
        selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign$1({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _a2)
      },
      required && {
        selectors: {
          "::after": {
            content: "' *'",
            color: labelRequiredStarColor,
            paddingRight: 12
          }
        }
      },
      className
    ]
  };
};
var Label = styled(LabelBase, getStyles$s, void 0, {
  scope: "Label"
});
var getClassNames$y = classNamesFunction();
var DEFAULT_STATE_VALUE = "";
var COMPONENT_NAME$8 = "TextField";
var REVEAL_ICON_NAME = "RedEye";
var HIDE_ICON_NAME = "Hide";
var TextFieldBase = (
  /** @class */
  function(_super) {
    __extends(TextFieldBase2, _super);
    function TextFieldBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._textElement = React__namespace.createRef();
      _this._onFocus = function(ev) {
        if (_this.props.onFocus) {
          _this.props.onFocus(ev);
        }
        _this.setState({ isFocused: true }, function() {
          if (_this.props.validateOnFocusIn) {
            _this._validate(_this.value);
          }
        });
      };
      _this._onBlur = function(ev) {
        if (_this.props.onBlur) {
          _this.props.onBlur(ev);
        }
        _this.setState({ isFocused: false }, function() {
          if (_this.props.validateOnFocusOut) {
            _this._validate(_this.value);
          }
        });
      };
      _this._onRenderLabel = function(props2) {
        var label = props2.label, required = props2.required;
        var labelStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.label : void 0;
        if (label) {
          return React__namespace.createElement(Label, { required, htmlFor: _this._id, styles: labelStyles, disabled: props2.disabled, id: _this._labelId }, props2.label);
        }
        return null;
      };
      _this._onRenderDescription = function(props2) {
        if (props2.description) {
          return React__namespace.createElement("span", { className: _this._classNames.description }, props2.description);
        }
        return null;
      };
      _this._onRevealButtonClick = function(event) {
        _this.setState(function(prevState) {
          return { isRevealingPassword: !prevState.isRevealingPassword };
        });
      };
      _this._onInputChange = function(event) {
        var _a3, _b2;
        var element = event.target;
        var value = element.value;
        var previousValue = _getValue(_this.props, _this.state) || "";
        if (value === void 0 || value === _this._lastChangeValue || value === previousValue) {
          _this._lastChangeValue = void 0;
          return;
        }
        _this._lastChangeValue = value;
        (_b2 = (_a3 = _this.props).onChange) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, event, value);
        if (!_this._isControlled) {
          _this.setState({ uncontrolledValue: value });
        }
      };
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      if (process.env.NODE_ENV !== "production") {
        warnMutuallyExclusive(COMPONENT_NAME$8, props, {
          errorMessage: "onGetErrorMessage"
        });
      }
      _this._fallbackId = getId(COMPONENT_NAME$8);
      _this._descriptionId = getId(COMPONENT_NAME$8 + "Description");
      _this._labelId = getId(COMPONENT_NAME$8 + "Label");
      _this._prefixId = getId(COMPONENT_NAME$8 + "Prefix");
      _this._suffixId = getId(COMPONENT_NAME$8 + "Suffix");
      _this._warnControlledUsage();
      var _a2 = props.defaultValue, defaultValue = _a2 === void 0 ? DEFAULT_STATE_VALUE : _a2;
      if (typeof defaultValue === "number") {
        defaultValue = String(defaultValue);
      }
      _this.state = {
        uncontrolledValue: _this._isControlled ? void 0 : defaultValue,
        isFocused: false,
        errorMessage: ""
      };
      _this._delayedValidate = _this._async.debounce(_this._validate, _this.props.deferredValidationTime);
      _this._lastValidation = 0;
      return _this;
    }
    Object.defineProperty(TextFieldBase2.prototype, "value", {
      /**
       * Gets the current value of the text field.
       */
      get: function() {
        return _getValue(this.props, this.state);
      },
      enumerable: false,
      configurable: true
    });
    TextFieldBase2.prototype.componentDidMount = function() {
      this._adjustInputHeight();
      if (this.props.validateOnLoad) {
        this._validate(this.value);
      }
    };
    TextFieldBase2.prototype.componentWillUnmount = function() {
      this._async.dispose();
    };
    TextFieldBase2.prototype.getSnapshotBeforeUpdate = function(prevProps, prevState) {
      return {
        selection: [this.selectionStart, this.selectionEnd]
      };
    };
    TextFieldBase2.prototype.componentDidUpdate = function(prevProps, prevState, snapshot) {
      var props = this.props;
      var _a2 = (snapshot || {}).selection, selection = _a2 === void 0 ? [null, null] : _a2;
      var start = selection[0], end = selection[1];
      if (!!prevProps.multiline !== !!props.multiline && prevState.isFocused) {
        this.focus();
        if (start !== null && end !== null && start >= 0 && end >= 0) {
          this.setSelectionRange(start, end);
        }
      }
      if (prevProps.value !== props.value) {
        this._lastChangeValue = void 0;
      }
      var prevValue = _getValue(prevProps, prevState);
      var value = this.value;
      if (prevValue !== value) {
        this._warnControlledUsage(prevProps);
        if (this.state.errorMessage && !props.errorMessage) {
          this.setState({ errorMessage: "" });
        }
        this._adjustInputHeight();
        if (_shouldValidateAllChanges(props)) {
          this._delayedValidate(value);
        }
      }
    };
    TextFieldBase2.prototype.render = function() {
      var _a2 = this.props, borderless = _a2.borderless, className = _a2.className, disabled = _a2.disabled, invalid = _a2.invalid, iconProps = _a2.iconProps, inputClassName = _a2.inputClassName, label = _a2.label, multiline = _a2.multiline, required = _a2.required, underlined = _a2.underlined, prefix2 = _a2.prefix, resizable = _a2.resizable, suffix = _a2.suffix, theme = _a2.theme, styles2 = _a2.styles, autoAdjustHeight = _a2.autoAdjustHeight, canRevealPassword = _a2.canRevealPassword, revealPasswordAriaLabel = _a2.revealPasswordAriaLabel, type = _a2.type, _b2 = _a2.onRenderPrefix, onRenderPrefix = _b2 === void 0 ? this._onRenderPrefix : _b2, _c2 = _a2.onRenderSuffix, onRenderSuffix = _c2 === void 0 ? this._onRenderSuffix : _c2, _d2 = _a2.onRenderLabel, onRenderLabel = _d2 === void 0 ? this._onRenderLabel : _d2, _e2 = _a2.onRenderDescription, onRenderDescription = _e2 === void 0 ? this._onRenderDescription : _e2;
      var _f = this.state, isFocused = _f.isFocused, isRevealingPassword = _f.isRevealingPassword;
      var errorMessage = this._errorMessage;
      var isInvalid = typeof invalid === "boolean" ? invalid : !!errorMessage;
      var hasRevealButton = !!canRevealPassword && type === "password" && _browserNeedsRevealButton();
      var classNames2 = this._classNames = getClassNames$y(styles2, {
        theme,
        className,
        disabled,
        focused: isFocused,
        required,
        multiline,
        hasLabel: !!label,
        hasErrorMessage: isInvalid,
        borderless,
        resizable,
        hasIcon: !!iconProps,
        underlined,
        inputClassName,
        autoAdjustHeight,
        hasRevealButton
      });
      return (
        // eslint-disable-next-line deprecation/deprecation
        React__namespace.createElement(
          "div",
          { ref: this.props.elementRef, className: classNames2.root },
          React__namespace.createElement(
            "div",
            { className: classNames2.wrapper },
            onRenderLabel(this.props, this._onRenderLabel),
            React__namespace.createElement(
              "div",
              { className: classNames2.fieldGroup },
              (prefix2 !== void 0 || this.props.onRenderPrefix) && React__namespace.createElement("div", { className: classNames2.prefix, id: this._prefixId }, onRenderPrefix(this.props, this._onRenderPrefix)),
              multiline ? this._renderTextArea() : this._renderInput(),
              iconProps && React__namespace.createElement(Icon, __assign$1({ className: classNames2.icon }, iconProps)),
              hasRevealButton && // Explicitly set type="button" since the default button type within a form is "submit"
              React__namespace.createElement(
                "button",
                { "aria-label": revealPasswordAriaLabel, className: classNames2.revealButton, onClick: this._onRevealButtonClick, "aria-pressed": !!isRevealingPassword, type: "button" },
                React__namespace.createElement(
                  "span",
                  { className: classNames2.revealSpan },
                  React__namespace.createElement(Icon, { className: classNames2.revealIcon, iconName: isRevealingPassword ? HIDE_ICON_NAME : REVEAL_ICON_NAME })
                )
              ),
              (suffix !== void 0 || this.props.onRenderSuffix) && React__namespace.createElement("div", { className: classNames2.suffix, id: this._suffixId }, onRenderSuffix(this.props, this._onRenderSuffix))
            )
          ),
          this._isDescriptionAvailable && React__namespace.createElement(
            "span",
            { id: this._descriptionId },
            onRenderDescription(this.props, this._onRenderDescription),
            errorMessage && React__namespace.createElement(
              "div",
              { role: "alert" },
              React__namespace.createElement(DelayedRender, null, this._renderErrorMessage())
            )
          )
        )
      );
    };
    TextFieldBase2.prototype.focus = function() {
      if (this._textElement.current) {
        this._textElement.current.focus();
      }
    };
    TextFieldBase2.prototype.blur = function() {
      if (this._textElement.current) {
        this._textElement.current.blur();
      }
    };
    TextFieldBase2.prototype.select = function() {
      if (this._textElement.current) {
        this._textElement.current.select();
      }
    };
    TextFieldBase2.prototype.setSelectionStart = function(value) {
      if (this._textElement.current) {
        this._textElement.current.selectionStart = value;
      }
    };
    TextFieldBase2.prototype.setSelectionEnd = function(value) {
      if (this._textElement.current) {
        this._textElement.current.selectionEnd = value;
      }
    };
    Object.defineProperty(TextFieldBase2.prototype, "selectionStart", {
      /**
       * Gets the selection start of the text field
       */
      get: function() {
        return this._textElement.current ? this._textElement.current.selectionStart : -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextFieldBase2.prototype, "selectionEnd", {
      /**
       * Gets the selection end of the text field
       */
      get: function() {
        return this._textElement.current ? this._textElement.current.selectionEnd : -1;
      },
      enumerable: false,
      configurable: true
    });
    TextFieldBase2.prototype.setSelectionRange = function(start, end) {
      if (this._textElement.current) {
        this._textElement.current.setSelectionRange(start, end);
      }
    };
    TextFieldBase2.prototype._warnControlledUsage = function(prevProps) {
      warnControlledUsage({
        componentId: this._id,
        componentName: COMPONENT_NAME$8,
        props: this.props,
        oldProps: prevProps,
        valueProp: "value",
        defaultValueProp: "defaultValue",
        onChangeProp: "onChange",
        readOnlyProp: "readOnly"
      });
      if (this.props.value === null && !this._hasWarnedNullValue) {
        this._hasWarnedNullValue = true;
        warn("Warning: 'value' prop on '" + COMPONENT_NAME$8 + "' should not be null. Consider using an empty string to clear the component or undefined to indicate an uncontrolled component.");
      }
    };
    Object.defineProperty(TextFieldBase2.prototype, "_id", {
      /** Returns `props.id` if available, or a fallback if not. */
      get: function() {
        return this.props.id || this._fallbackId;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TextFieldBase2.prototype, "_isControlled", {
      get: function() {
        return isControlled(this.props, "value");
      },
      enumerable: false,
      configurable: true
    });
    TextFieldBase2.prototype._onRenderPrefix = function(props) {
      var prefix2 = props.prefix;
      return React__namespace.createElement("span", { style: { paddingBottom: "1px" } }, prefix2);
    };
    TextFieldBase2.prototype._onRenderSuffix = function(props) {
      var suffix = props.suffix;
      return React__namespace.createElement("span", { style: { paddingBottom: "1px" } }, suffix);
    };
    Object.defineProperty(TextFieldBase2.prototype, "_errorMessage", {
      /**
       * Current error message from either `props.errorMessage` or the result of `props.onGetErrorMessage`.
       *
       * - If there is no validation error or we have not validated the input value, errorMessage is an empty string.
       * - If we have done the validation and there is validation error, errorMessage is the validation error message.
       */
      get: function() {
        var _a2 = this.props.errorMessage, errorMessage = _a2 === void 0 ? this.state.errorMessage : _a2;
        return errorMessage || "";
      },
      enumerable: false,
      configurable: true
    });
    TextFieldBase2.prototype._renderErrorMessage = function() {
      var errorMessage = this._errorMessage;
      return errorMessage ? typeof errorMessage === "string" ? React__namespace.createElement(
        "p",
        { className: this._classNames.errorMessage },
        React__namespace.createElement("span", { "data-automation-id": "error-message" }, errorMessage)
      ) : React__namespace.createElement("div", { className: this._classNames.errorMessage, "data-automation-id": "error-message" }, errorMessage) : null;
    };
    Object.defineProperty(TextFieldBase2.prototype, "_isDescriptionAvailable", {
      /**
       * If a custom description render function is supplied then treat description as always available.
       * Otherwise defer to the presence of description or error message text.
       */
      get: function() {
        var props = this.props;
        return !!(props.onRenderDescription || props.description || this._errorMessage);
      },
      enumerable: false,
      configurable: true
    });
    TextFieldBase2.prototype._renderTextArea = function() {
      var _a2 = this.props.invalid, invalid = _a2 === void 0 ? !!this._errorMessage : _a2;
      var textAreaProps = getNativeProps(this.props, textAreaProperties, ["defaultValue"]);
      var ariaLabelledBy = this.props["aria-labelledby"] || (this.props.label ? this._labelId : void 0);
      return React__namespace.createElement("textarea", __assign$1({ id: this._id }, textAreaProps, { ref: this._textElement, value: this.value || "", onInput: this._onInputChange, onChange: this._onInputChange, className: this._classNames.field, "aria-labelledby": ariaLabelledBy, "aria-describedby": this._isDescriptionAvailable ? this._descriptionId : this.props["aria-describedby"], "aria-invalid": invalid, "aria-label": this.props.ariaLabel, readOnly: this.props.readOnly, onFocus: this._onFocus, onBlur: this._onBlur }));
    };
    TextFieldBase2.prototype._renderInput = function() {
      var _a2 = this.props, ariaLabel = _a2.ariaLabel, _b2 = _a2.invalid, invalid = _b2 === void 0 ? !!this._errorMessage : _b2, onRenderPrefix = _a2.onRenderPrefix, onRenderSuffix = _a2.onRenderSuffix, prefix2 = _a2.prefix, suffix = _a2.suffix, _c2 = _a2.type, type = _c2 === void 0 ? "text" : _c2, label = _a2.label;
      var labelIds = [];
      label && labelIds.push(this._labelId);
      (prefix2 !== void 0 || onRenderPrefix) && labelIds.push(this._prefixId);
      (suffix !== void 0 || onRenderSuffix) && labelIds.push(this._suffixId);
      var inputProps = __assign$1(__assign$1({ type: this.state.isRevealingPassword ? "text" : type, id: this._id }, getNativeProps(this.props, inputProperties, ["defaultValue", "type"])), { "aria-labelledby": this.props["aria-labelledby"] || (labelIds.length > 0 ? labelIds.join(" ") : void 0), ref: this._textElement, value: this.value || "", onInput: this._onInputChange, onChange: this._onInputChange, className: this._classNames.field, "aria-label": ariaLabel, "aria-describedby": this._isDescriptionAvailable ? this._descriptionId : this.props["aria-describedby"], "aria-invalid": invalid, onFocus: this._onFocus, onBlur: this._onBlur });
      var defaultRender = function(updatedInputProps) {
        return React__namespace.createElement("input", __assign$1({}, updatedInputProps));
      };
      var onRenderInput = this.props.onRenderInput || defaultRender;
      return onRenderInput(inputProps, defaultRender);
    };
    TextFieldBase2.prototype._validate = function(value) {
      var _this = this;
      if (this._latestValidateValue === value && _shouldValidateAllChanges(this.props)) {
        return;
      }
      this._latestValidateValue = value;
      var onGetErrorMessage = this.props.onGetErrorMessage;
      var result = onGetErrorMessage && onGetErrorMessage(value || "");
      if (result !== void 0) {
        if (typeof result === "string" || !("then" in result)) {
          this.setState({ errorMessage: result });
          this._notifyAfterValidate(value, result);
        } else {
          var currentValidation_1 = ++this._lastValidation;
          result.then(function(errorMessage) {
            if (currentValidation_1 === _this._lastValidation) {
              _this.setState({ errorMessage });
            }
            _this._notifyAfterValidate(value, errorMessage);
          });
        }
      } else {
        this._notifyAfterValidate(value, "");
      }
    };
    TextFieldBase2.prototype._notifyAfterValidate = function(value, errorMessage) {
      if (value === this.value && this.props.onNotifyValidationResult) {
        this.props.onNotifyValidationResult(errorMessage, value);
      }
    };
    TextFieldBase2.prototype._adjustInputHeight = function() {
      if (this._textElement.current && this.props.autoAdjustHeight && this.props.multiline) {
        var textField = this._textElement.current;
        textField.style.height = "";
        textField.style.height = textField.scrollHeight + "px";
      }
    };
    TextFieldBase2.defaultProps = {
      resizable: true,
      deferredValidationTime: 200,
      validateOnLoad: true
    };
    return TextFieldBase2;
  }(React__namespace.Component)
);
function _getValue(props, state) {
  var _a2 = props.value, value = _a2 === void 0 ? state.uncontrolledValue : _a2;
  if (typeof value === "number") {
    return String(value);
  }
  return value;
}
function _shouldValidateAllChanges(props) {
  return !(props.validateOnFocusIn || props.validateOnFocusOut);
}
var __browserNeedsRevealButton;
function _browserNeedsRevealButton() {
  if (typeof __browserNeedsRevealButton !== "boolean") {
    var win2 = getWindow$1();
    if (win2 === null || win2 === void 0 ? void 0 : win2.navigator) {
      var isEdge = /Edg/.test(win2.navigator.userAgent || "");
      __browserNeedsRevealButton = !(isIE11() || isEdge);
    } else {
      __browserNeedsRevealButton = true;
    }
  }
  return __browserNeedsRevealButton;
}
var globalClassNames$1 = {
  root: "ms-TextField",
  description: "ms-TextField-description",
  errorMessage: "ms-TextField-errorMessage",
  field: "ms-TextField-field",
  fieldGroup: "ms-TextField-fieldGroup",
  prefix: "ms-TextField-prefix",
  suffix: "ms-TextField-suffix",
  wrapper: "ms-TextField-wrapper",
  revealButton: "ms-TextField-reveal",
  multiline: "ms-TextField--multiline",
  borderless: "ms-TextField--borderless",
  underlined: "ms-TextField--underlined",
  unresizable: "ms-TextField--unresizable",
  required: "is-required",
  disabled: "is-disabled",
  active: "is-active"
};
function getLabelStyles(props) {
  var underlined = props.underlined, disabled = props.disabled, focused = props.focused, theme = props.theme;
  var palette = theme.palette, fonts = theme.fonts;
  return function() {
    var _a2;
    return {
      root: [
        underlined && disabled && {
          color: palette.neutralTertiary
        },
        underlined && {
          fontSize: fonts.medium.fontSize,
          marginRight: 8,
          paddingLeft: 12,
          paddingRight: 0,
          lineHeight: "22px",
          height: 32
        },
        underlined && focused && {
          selectors: (_a2 = {}, _a2[HighContrastSelector] = {
            height: 31
            // -1px to prevent jumpiness in HC with the increased border-width to 2px
          }, _a2)
        }
      ]
    };
  };
}
function getStyles$r(props) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l, _m;
  var theme = props.theme, className = props.className, disabled = props.disabled, focused = props.focused, required = props.required, multiline = props.multiline, hasLabel = props.hasLabel, borderless = props.borderless, underlined = props.underlined, hasIcon = props.hasIcon, resizable = props.resizable, hasErrorMessage = props.hasErrorMessage, inputClassName = props.inputClassName, autoAdjustHeight = props.autoAdjustHeight, hasRevealButton = props.hasRevealButton;
  var semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(globalClassNames$1, theme);
  var fieldPrefixSuffix = {
    // Suffix/Prefix are not editable so the disabled slot perfectly fits.
    background: semanticColors.disabledBackground,
    color: !disabled ? semanticColors.inputPlaceholderText : semanticColors.disabledText,
    display: "flex",
    alignItems: "center",
    padding: "0 10px",
    lineHeight: 1,
    whiteSpace: "nowrap",
    flexShrink: 0,
    selectors: (_a2 = {}, _a2[HighContrastSelector] = {
      background: "Window",
      color: disabled ? "GrayText" : "WindowText"
    }, _a2)
  };
  var placeholderStyles = [
    {
      color: semanticColors.inputPlaceholderText,
      opacity: 1,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        color: "GrayText"
      }, _b2)
    }
  ];
  var disabledPlaceholderStyles = {
    color: semanticColors.disabledText,
    selectors: (_c2 = {}, _c2[HighContrastSelector] = {
      color: "GrayText"
    }, _c2)
  };
  return {
    root: [
      classNames2.root,
      fonts.medium,
      required && classNames2.required,
      disabled && classNames2.disabled,
      focused && classNames2.active,
      multiline && classNames2.multiline,
      borderless && classNames2.borderless,
      underlined && classNames2.underlined,
      normalize,
      {
        position: "relative"
      },
      className
    ],
    wrapper: [
      classNames2.wrapper,
      underlined && [
        {
          display: "flex",
          borderBottom: "1px solid " + (!hasErrorMessage ? semanticColors.inputBorder : semanticColors.errorText),
          width: "100%"
        },
        disabled && {
          borderBottomColor: semanticColors.disabledBackground,
          selectors: (_d2 = {}, _d2[HighContrastSelector] = __assign$1({ borderColor: "GrayText" }, getHighContrastNoAdjustStyle()), _d2)
        },
        !disabled && {
          selectors: {
            ":hover": {
              borderBottomColor: !hasErrorMessage ? semanticColors.inputBorderHovered : semanticColors.errorText,
              selectors: (_e2 = {}, _e2[HighContrastSelector] = __assign$1({ borderBottomColor: "Highlight" }, getHighContrastNoAdjustStyle()), _e2)
            }
          }
        },
        focused && [
          {
            position: "relative"
          },
          getInputFocusStyle(!hasErrorMessage ? semanticColors.inputFocusBorderAlt : semanticColors.errorText, 0, "borderBottom")
        ]
      ]
    ],
    fieldGroup: [
      classNames2.fieldGroup,
      normalize,
      {
        border: "1px solid " + semanticColors.inputBorder,
        borderRadius: effects.roundedCorner2,
        background: semanticColors.inputBackground,
        cursor: "text",
        height: 32,
        display: "flex",
        flexDirection: "row",
        alignItems: "stretch",
        position: "relative"
      },
      multiline && {
        minHeight: "60px",
        height: "auto",
        display: "flex"
      },
      !focused && !disabled && {
        selectors: {
          ":hover": {
            borderColor: semanticColors.inputBorderHovered,
            selectors: (_f = {}, _f[HighContrastSelector] = __assign$1({ borderColor: "Highlight" }, getHighContrastNoAdjustStyle()), _f)
          }
        }
      },
      focused && !underlined && getInputFocusStyle(!hasErrorMessage ? semanticColors.inputFocusBorderAlt : semanticColors.errorText, effects.roundedCorner2),
      disabled && {
        borderColor: semanticColors.disabledBackground,
        selectors: (_g = {}, _g[HighContrastSelector] = __assign$1({ borderColor: "GrayText" }, getHighContrastNoAdjustStyle()), _g),
        cursor: "default"
      },
      borderless && {
        border: "none"
      },
      borderless && focused && {
        border: "none",
        selectors: {
          ":after": {
            border: "none"
          }
        }
      },
      underlined && {
        flex: "1 1 0px",
        border: "none",
        textAlign: "left"
      },
      underlined && disabled && {
        backgroundColor: "transparent"
      },
      hasErrorMessage && !underlined && {
        borderColor: semanticColors.errorText,
        selectors: {
          "&:hover": {
            borderColor: semanticColors.errorText
          }
        }
      },
      !hasLabel && required && {
        selectors: (_h = {
          ":before": {
            content: "'*'",
            color: semanticColors.errorText,
            position: "absolute",
            top: -5,
            right: -10
          }
        }, _h[HighContrastSelector] = {
          selectors: {
            ":before": {
              color: "WindowText",
              right: -14
              // moving the * 4 pixel to right to alleviate border clipping in HC mode.
            }
          }
        }, _h)
      }
    ],
    field: [
      fonts.medium,
      classNames2.field,
      normalize,
      {
        borderRadius: 0,
        border: "none",
        background: "none",
        backgroundColor: "transparent",
        color: semanticColors.inputText,
        padding: "0 8px",
        width: "100%",
        minWidth: 0,
        textOverflow: "ellipsis",
        outline: 0,
        selectors: (_j = {
          "&:active, &:focus, &:hover": { outline: 0 },
          "::-ms-clear": {
            display: "none"
          }
        }, _j[HighContrastSelector] = {
          background: "Window",
          color: disabled ? "GrayText" : "WindowText"
        }, _j)
      },
      getPlaceholderStyles(placeholderStyles),
      multiline && !resizable && [
        classNames2.unresizable,
        {
          resize: "none"
        }
      ],
      multiline && {
        minHeight: "inherit",
        lineHeight: 17,
        flexGrow: 1,
        paddingTop: 6,
        paddingBottom: 6,
        overflow: "auto",
        width: "100%"
      },
      multiline && autoAdjustHeight && {
        overflow: "hidden"
      },
      hasIcon && !hasRevealButton && {
        paddingRight: 24
      },
      multiline && hasIcon && {
        paddingRight: 40
      },
      disabled && [
        {
          backgroundColor: semanticColors.disabledBackground,
          color: semanticColors.disabledText,
          borderColor: semanticColors.disabledBackground
        },
        getPlaceholderStyles(disabledPlaceholderStyles)
      ],
      underlined && {
        textAlign: "left"
      },
      focused && !borderless && {
        selectors: (_k = {}, _k[HighContrastSelector] = {
          paddingLeft: 11,
          paddingRight: 11
        }, _k)
      },
      focused && multiline && !borderless && {
        selectors: (_l = {}, _l[HighContrastSelector] = {
          paddingTop: 4
          // take into consideration the 2px increased border-width (not when borderless).
        }, _l)
      },
      inputClassName
    ],
    icon: [
      multiline && {
        paddingRight: 24,
        alignItems: "flex-end"
      },
      {
        pointerEvents: "none",
        position: "absolute",
        bottom: 6,
        right: 8,
        top: "auto",
        fontSize: IconFontSizes.medium,
        lineHeight: 18
      },
      disabled && {
        color: semanticColors.disabledText
      }
    ],
    description: [
      classNames2.description,
      {
        color: semanticColors.bodySubtext,
        fontSize: fonts.xSmall.fontSize
      }
    ],
    errorMessage: [
      classNames2.errorMessage,
      AnimationClassNames.slideDownIn20,
      fonts.small,
      {
        color: semanticColors.errorText,
        margin: 0,
        paddingTop: 5,
        display: "flex",
        alignItems: "center"
      }
    ],
    prefix: [classNames2.prefix, fieldPrefixSuffix],
    suffix: [classNames2.suffix, fieldPrefixSuffix],
    revealButton: [
      classNames2.revealButton,
      "ms-Button",
      "ms-Button--icon",
      getFocusStyle(theme, { inset: 1 }),
      {
        height: 30,
        width: 32,
        border: "none",
        padding: "0px 4px",
        backgroundColor: "transparent",
        color: semanticColors.link,
        selectors: {
          ":hover": {
            outline: 0,
            color: semanticColors.primaryButtonBackgroundHovered,
            backgroundColor: semanticColors.buttonBackgroundHovered,
            selectors: (_m = {}, _m[HighContrastSelector] = {
              borderColor: "Highlight",
              color: "Highlight"
            }, _m)
          },
          ":focus": { outline: 0 }
        }
      },
      hasIcon && {
        marginRight: 28
      }
    ],
    revealSpan: {
      display: "flex",
      height: "100%",
      alignItems: "center"
    },
    revealIcon: {
      margin: "0px 4px",
      pointerEvents: "none",
      bottom: 6,
      right: 8,
      top: "auto",
      fontSize: IconFontSizes.medium,
      lineHeight: 18
    },
    subComponentStyles: {
      label: getLabelStyles(props)
    }
  };
}
var TextField = styled(TextFieldBase, getStyles$r, void 0, {
  scope: "TextField"
});
var _a$4, _b$3;
var ComboBoxHeight = 32;
var ComboBoxLineHeight = 30;
var ComboBoxCaretDownWidth = 32;
var ComboBoxOptionHeight = 36;
var getDisabledStyles$1 = memoizeFunction(function(theme) {
  var _a2;
  var semanticColors = theme.semanticColors;
  return {
    backgroundColor: semanticColors.disabledBackground,
    color: semanticColors.disabledText,
    cursor: "default",
    selectors: (_a2 = {
      ":after": {
        borderColor: semanticColors.disabledBackground
      }
    }, _a2[HighContrastSelector] = {
      color: "GrayText",
      selectors: {
        ":after": {
          borderColor: "GrayText"
        }
      }
    }, _a2)
  };
});
var listOptionHighContrastStyles = {
  selectors: (_a$4 = {}, _a$4[HighContrastSelector] = __assign$1({ backgroundColor: "Highlight", borderColor: "Highlight", color: "HighlightText" }, getHighContrastNoAdjustStyle()), _a$4)
};
var inputHighContrastStyles = {
  selectors: (_b$3 = {}, _b$3[HighContrastSelector] = __assign$1({ color: "WindowText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _b$3)
};
var getOptionStyles = memoizeFunction(function(theme, customStylesForAllOptions, customOptionStylesForCurrentOption, isPending, isHidden, isSelected) {
  var _a2;
  var palette = theme.palette, semanticColors = theme.semanticColors;
  var option = {
    textHoveredColor: semanticColors.menuItemTextHovered,
    textSelectedColor: palette.neutralDark,
    textDisabledColor: semanticColors.disabledText,
    backgroundHoveredColor: semanticColors.menuItemBackgroundHovered,
    backgroundPressedColor: semanticColors.menuItemBackgroundPressed
  };
  var optionStyles = {
    root: [
      theme.fonts.medium,
      {
        backgroundColor: isPending ? option.backgroundHoveredColor : "transparent",
        boxSizing: "border-box",
        cursor: "pointer",
        display: isHidden ? "none" : "block",
        width: "100%",
        height: "auto",
        minHeight: ComboBoxOptionHeight,
        lineHeight: "20px",
        padding: "0 8px",
        position: "relative",
        borderWidth: "1px",
        borderStyle: "solid",
        borderColor: "transparent",
        borderRadius: 0,
        wordWrap: "break-word",
        overflowWrap: "break-word",
        textAlign: "left",
        selectors: __assign$1(__assign$1((_a2 = {}, _a2[HighContrastSelector] = {
          border: "none",
          borderColor: "Background"
        }, _a2), !isHidden && {
          "&.ms-Checkbox": {
            display: "flex",
            alignItems: "center"
          }
        }), { "&.ms-Button--command:hover:active": {
          backgroundColor: option.backgroundPressedColor
        }, ".ms-Checkbox-label": {
          width: "100%"
        } })
      },
      isSelected ? [
        {
          backgroundColor: "transparent",
          color: option.textSelectedColor,
          selectors: {
            ":hover": [
              {
                backgroundColor: option.backgroundHoveredColor
              },
              listOptionHighContrastStyles
            ]
          }
        },
        getFocusStyle(theme, { inset: -1, isFocusedOnly: false }),
        listOptionHighContrastStyles
      ] : []
    ],
    rootHovered: {
      backgroundColor: option.backgroundHoveredColor,
      color: option.textHoveredColor
    },
    rootFocused: {
      backgroundColor: option.backgroundHoveredColor
    },
    rootDisabled: {
      color: option.textDisabledColor,
      cursor: "default"
    },
    optionText: {
      overflow: "hidden",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      minWidth: "0px",
      maxWidth: "100%",
      wordWrap: "break-word",
      overflowWrap: "break-word",
      display: "inline-block"
    },
    optionTextWrapper: {
      maxWidth: "100%",
      display: "flex",
      alignItems: "center"
    }
  };
  return concatStyleSets(optionStyles, customStylesForAllOptions, customOptionStylesForCurrentOption);
});
var getCaretDownButtonStyles = memoizeFunction(function(theme, customStyles) {
  var _a2, _b2;
  var semanticColors = theme.semanticColors, fonts = theme.fonts;
  var caret2 = {
    buttonTextColor: semanticColors.bodySubtext,
    buttonTextHoveredCheckedColor: semanticColors.buttonTextChecked,
    buttonBackgroundHoveredColor: semanticColors.listItemBackgroundHovered,
    buttonBackgroundCheckedColor: semanticColors.listItemBackgroundChecked,
    buttonBackgroundCheckedHoveredColor: semanticColors.listItemBackgroundCheckedHovered
  };
  var buttonHighContrastStyles = {
    selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign$1({ backgroundColor: "Highlight", borderColor: "Highlight", color: "HighlightText" }, getHighContrastNoAdjustStyle()), _a2)
  };
  var styles2 = {
    root: {
      color: caret2.buttonTextColor,
      fontSize: fonts.small.fontSize,
      position: "absolute",
      top: 0,
      height: "100%",
      lineHeight: ComboBoxLineHeight,
      width: ComboBoxCaretDownWidth,
      textAlign: "center",
      cursor: "default",
      selectors: (_b2 = {}, _b2[HighContrastSelector] = __assign$1({ backgroundColor: "ButtonFace", borderColor: "ButtonText", color: "ButtonText" }, getHighContrastNoAdjustStyle()), _b2)
    },
    icon: {
      fontSize: fonts.small.fontSize
    },
    rootHovered: [
      {
        backgroundColor: caret2.buttonBackgroundHoveredColor,
        color: caret2.buttonTextHoveredCheckedColor,
        cursor: "pointer"
      },
      buttonHighContrastStyles
    ],
    rootPressed: [
      {
        backgroundColor: caret2.buttonBackgroundCheckedColor,
        color: caret2.buttonTextHoveredCheckedColor
      },
      buttonHighContrastStyles
    ],
    rootChecked: [
      {
        backgroundColor: caret2.buttonBackgroundCheckedColor,
        color: caret2.buttonTextHoveredCheckedColor
      },
      buttonHighContrastStyles
    ],
    rootCheckedHovered: [
      {
        backgroundColor: caret2.buttonBackgroundCheckedHoveredColor,
        color: caret2.buttonTextHoveredCheckedColor
      },
      buttonHighContrastStyles
    ],
    rootDisabled: [
      getDisabledStyles$1(theme),
      {
        position: "absolute"
      }
    ]
  };
  return concatStyleSets(styles2, customStyles);
});
var getStyles$q = memoizeFunction(function(theme, customStyles, comboBoxOptionWidth) {
  var _a2, _b2, _c2, _d2, _e2, _f;
  var semanticColors = theme.semanticColors, fonts = theme.fonts, effects = theme.effects;
  var root2 = {
    textColor: semanticColors.inputText,
    borderColor: semanticColors.inputBorder,
    borderHoveredColor: semanticColors.inputBorderHovered,
    borderPressedColor: semanticColors.inputFocusBorderAlt,
    borderFocusedColor: semanticColors.inputFocusBorderAlt,
    backgroundColor: semanticColors.inputBackground,
    erroredColor: semanticColors.errorText
  };
  var option = {
    headerTextColor: semanticColors.menuHeader,
    dividerBorderColor: semanticColors.bodyDivider
  };
  var placeholderHighContrastStyles = {
    selectors: (_a2 = {}, _a2[HighContrastSelector] = {
      color: "GrayText"
    }, _a2)
  };
  var placeholderStyles = [
    {
      color: semanticColors.inputPlaceholderText
    },
    placeholderHighContrastStyles
  ];
  var placeholderStylesHovered = [
    {
      color: semanticColors.inputTextHovered
    },
    placeholderHighContrastStyles
  ];
  var disabledPlaceholderStyles = [
    {
      color: semanticColors.disabledText
    },
    placeholderHighContrastStyles
  ];
  var ComboBoxRootHighContrastFocused = __assign$1(__assign$1({ color: "HighlightText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), { selectors: {
    ":after": {
      borderColor: "Highlight"
    }
  } });
  var focusBorderStyles = getInputFocusStyle(root2.borderPressedColor, effects.roundedCorner2, "border", 0);
  var styles2 = {
    container: {},
    label: {},
    labelDisabled: {},
    root: [
      theme.fonts.medium,
      {
        boxShadow: "none",
        marginLeft: "0",
        paddingRight: ComboBoxCaretDownWidth,
        paddingLeft: 9,
        color: root2.textColor,
        position: "relative",
        outline: "0",
        userSelect: "none",
        backgroundColor: root2.backgroundColor,
        cursor: "text",
        display: "block",
        height: ComboBoxHeight,
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        boxSizing: "border-box",
        selectors: {
          ".ms-Label": {
            display: "inline-block",
            marginBottom: "8px"
          },
          "&.is-open": {
            selectors: (_b2 = {}, _b2[HighContrastSelector] = ComboBoxRootHighContrastFocused, _b2)
          },
          // setting border using pseudo-element here in order to
          // prevent chevron button to overlap ComboBox border under certain resolutions
          ":after": {
            pointerEvents: "none",
            content: "''",
            position: "absolute",
            left: 0,
            top: 0,
            bottom: 0,
            right: 0,
            borderWidth: "1px",
            borderStyle: "solid",
            borderColor: root2.borderColor,
            borderRadius: effects.roundedCorner2
          }
        }
      }
    ],
    rootHovered: {
      selectors: (_c2 = {
        ":after": {
          borderColor: root2.borderHoveredColor
        },
        ".ms-ComboBox-Input": [
          {
            color: semanticColors.inputTextHovered
          },
          getPlaceholderStyles(placeholderStylesHovered),
          inputHighContrastStyles
        ]
      }, _c2[HighContrastSelector] = __assign$1(__assign$1({ color: "HighlightText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), { selectors: {
        ":after": {
          borderColor: "Highlight"
        }
      } }), _c2)
    },
    rootPressed: [
      {
        position: "relative",
        selectors: (_d2 = {}, _d2[HighContrastSelector] = ComboBoxRootHighContrastFocused, _d2)
      }
    ],
    rootFocused: [
      {
        selectors: (_e2 = {
          ".ms-ComboBox-Input": [
            {
              color: semanticColors.inputTextHovered
            },
            inputHighContrastStyles
          ]
        }, _e2[HighContrastSelector] = ComboBoxRootHighContrastFocused, _e2)
      },
      focusBorderStyles
    ],
    rootDisabled: getDisabledStyles$1(theme),
    rootError: {
      selectors: {
        ":after": {
          borderColor: root2.erroredColor
        },
        ":hover:after": {
          borderColor: semanticColors.inputBorderHovered
        }
      }
    },
    rootDisallowFreeForm: {},
    input: [
      getPlaceholderStyles(placeholderStyles),
      {
        backgroundColor: root2.backgroundColor,
        color: root2.textColor,
        boxSizing: "border-box",
        width: "100%",
        height: "100%",
        borderStyle: "none",
        outline: "none",
        font: "inherit",
        textOverflow: "ellipsis",
        padding: "0",
        selectors: {
          "::-ms-clear": {
            display: "none"
          }
        }
      },
      inputHighContrastStyles
    ],
    inputDisabled: [getDisabledStyles$1(theme), getPlaceholderStyles(disabledPlaceholderStyles)],
    errorMessage: [
      theme.fonts.small,
      {
        color: root2.erroredColor,
        marginTop: "5px"
      }
    ],
    callout: {
      boxShadow: effects.elevation8
    },
    optionsContainerWrapper: {
      width: comboBoxOptionWidth
    },
    optionsContainer: {
      display: "block"
    },
    screenReaderText: hiddenContentStyle,
    header: [
      fonts.medium,
      {
        fontWeight: FontWeights.semibold,
        color: option.headerTextColor,
        backgroundColor: "none",
        borderStyle: "none",
        height: ComboBoxOptionHeight,
        lineHeight: ComboBoxOptionHeight,
        cursor: "default",
        padding: "0 8px",
        userSelect: "none",
        textAlign: "left",
        selectors: (_f = {}, _f[HighContrastSelector] = __assign$1({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _f)
      }
    ],
    divider: {
      height: 1,
      backgroundColor: option.dividerBorderColor
    }
  };
  return concatStyleSets(styles2, customStyles);
});
var getClassNames$x = memoizeFunction(function(styles2, className, isOpen, disabled, required, focused, allowFreeForm, hasErrorMessage) {
  return {
    container: mergeStyles("ms-ComboBox-container", className, styles2.container),
    label: mergeStyles(styles2.label, disabled && styles2.labelDisabled),
    root: mergeStyles("ms-ComboBox", hasErrorMessage ? styles2.rootError : isOpen && "is-open", required && "is-required", styles2.root, !allowFreeForm && styles2.rootDisallowFreeForm, hasErrorMessage && !focused ? styles2.rootError : !disabled && focused && styles2.rootFocused, !disabled && {
      selectors: {
        ":hover": hasErrorMessage ? styles2.rootError : !isOpen && !focused && styles2.rootHovered,
        ":active": hasErrorMessage ? styles2.rootError : styles2.rootPressed,
        ":focus": hasErrorMessage ? styles2.rootError : styles2.rootFocused
      }
    }, disabled && ["is-disabled", styles2.rootDisabled]),
    input: mergeStyles("ms-ComboBox-Input", styles2.input, disabled && styles2.inputDisabled),
    errorMessage: mergeStyles(styles2.errorMessage),
    callout: mergeStyles("ms-ComboBox-callout", styles2.callout),
    optionsContainerWrapper: mergeStyles("ms-ComboBox-optionsContainerWrapper", styles2.optionsContainerWrapper),
    optionsContainer: mergeStyles("ms-ComboBox-optionsContainer", styles2.optionsContainer),
    header: mergeStyles("ms-ComboBox-header", styles2.header),
    divider: mergeStyles("ms-ComboBox-divider", styles2.divider),
    screenReaderText: mergeStyles(styles2.screenReaderText)
  };
});
var getComboBoxOptionClassNames = memoizeFunction(function(styles2) {
  return {
    optionText: mergeStyles("ms-ComboBox-optionText", styles2.optionText),
    root: mergeStyles("ms-ComboBox-option", styles2.root, {
      selectors: {
        ":hover": styles2.rootHovered,
        ":focus": styles2.rootFocused,
        ":active": styles2.rootPressed
      }
    }),
    optionTextWrapper: mergeStyles(styles2.optionTextWrapper)
  };
});
function getAllSelectedOptions(options2, selectedIndices) {
  var selectedOptions = [];
  for (var _i = 0, selectedIndices_1 = selectedIndices; _i < selectedIndices_1.length; _i++) {
    var index2 = selectedIndices_1[_i];
    var option = options2[index2];
    if (option) {
      selectedOptions.push(option);
    }
  }
  return selectedOptions;
}
var SelectableOptionMenuItemType;
(function(SelectableOptionMenuItemType2) {
  SelectableOptionMenuItemType2[SelectableOptionMenuItemType2["Normal"] = 0] = "Normal";
  SelectableOptionMenuItemType2[SelectableOptionMenuItemType2["Divider"] = 1] = "Divider";
  SelectableOptionMenuItemType2[SelectableOptionMenuItemType2["Header"] = 2] = "Header";
  SelectableOptionMenuItemType2[SelectableOptionMenuItemType2["SelectAll"] = 3] = "SelectAll";
})(SelectableOptionMenuItemType || (SelectableOptionMenuItemType = {}));
var SearchDirection;
(function(SearchDirection2) {
  SearchDirection2[SearchDirection2["backward"] = -1] = "backward";
  SearchDirection2[SearchDirection2["none"] = 0] = "none";
  SearchDirection2[SearchDirection2["forward"] = 1] = "forward";
})(SearchDirection || (SearchDirection = {}));
var HoverStatus;
(function(HoverStatus2) {
  HoverStatus2[HoverStatus2["clearAll"] = -2] = "clearAll";
  HoverStatus2[HoverStatus2["default"] = -1] = "default";
})(HoverStatus || (HoverStatus = {}));
var ScrollIdleDelay = 250;
var TouchIdleDelay = 500;
var ReadOnlyPendingAutoCompleteTimeout = 1e3;
var ComboBoxOptionWrapper = React__namespace.memo(function(_a2) {
  var render = _a2.render;
  return render();
}, function(_a2, _b2) {
  _a2.render;
  var oldProps = __rest$1(_a2, ["render"]);
  _b2.render;
  var newProps = __rest$1(_b2, ["render"]);
  return shallowCompare(oldProps, newProps);
});
var COMPONENT_NAME$7 = "ComboBox";
var DEFAULT_PROPS$4 = {
  options: [],
  allowFreeform: false,
  autoComplete: "on",
  buttonIconProps: { iconName: "ChevronDown" }
};
function useOptionsState(_a2) {
  var options2 = _a2.options, defaultSelectedKey = _a2.defaultSelectedKey, selectedKey = _a2.selectedKey;
  var _b2 = React__namespace.useState(function() {
    return getSelectedIndices(options2, buildDefaultSelectedKeys(defaultSelectedKey, selectedKey));
  }), selectedIndices = _b2[0], setSelectedIndices = _b2[1];
  var _c2 = React__namespace.useState(options2), currentOptions = _c2[0], setCurrentOptions = _c2[1];
  var _d2 = React__namespace.useState(), suggestedDisplayValue = _d2[0], setSuggestedDisplayValue = _d2[1];
  React__namespace.useEffect(function() {
    if (selectedKey !== void 0) {
      var selectedKeys = buildSelectedKeys(selectedKey);
      var indices = getSelectedIndices(options2, selectedKeys);
      setSelectedIndices(indices);
    }
    setCurrentOptions(options2);
  }, [options2, selectedKey]);
  React__namespace.useEffect(function() {
    if (selectedKey === null) {
      setSuggestedDisplayValue(void 0);
    }
  }, [selectedKey]);
  return [
    selectedIndices,
    setSelectedIndices,
    currentOptions,
    setCurrentOptions,
    suggestedDisplayValue,
    setSuggestedDisplayValue
  ];
}
var ComboBox = React__namespace.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var _a2 = getPropsWithDefaults(DEFAULT_PROPS$4, propsWithoutDefaults);
  _a2.ref;
  var props = __rest$1(_a2, ["ref"]);
  var rootRef = React__namespace.useRef(null);
  var mergedRootRef = useMergedRefs(rootRef, forwardedRef);
  var _b2 = useOptionsState(props), selectedIndices = _b2[0], setSelectedIndices = _b2[1], currentOptions = _b2[2], setCurrentOptions = _b2[3], suggestedDisplayValue = _b2[4], setSuggestedDisplayValue = _b2[5];
  return React__namespace.createElement(ComboBoxInternal, __assign$1({}, props, { hoisted: {
    mergedRootRef,
    rootRef,
    selectedIndices,
    setSelectedIndices,
    currentOptions,
    setCurrentOptions,
    suggestedDisplayValue,
    setSuggestedDisplayValue
  } }));
});
ComboBox.displayName = COMPONENT_NAME$7;
function findFirstDescendant(element, match2) {
  var children = getChildren(element);
  for (var index2 = 0; index2 < children.length; index2++) {
    var child = children[index2];
    if (match2(child)) {
      return child;
    }
    var candidate = findFirstDescendant(child, match2);
    if (candidate) {
      return candidate;
    }
  }
  return null;
}
var ComboBoxInternal = (
  /** @class */
  function(_super) {
    __extends(ComboBoxInternal2, _super);
    function ComboBoxInternal2(props) {
      var _this = _super.call(this, props) || this;
      _this._autofill = React__namespace.createRef();
      _this._comboBoxWrapper = React__namespace.createRef();
      _this._comboBoxMenu = React__namespace.createRef();
      _this._selectedElement = React__namespace.createRef();
      _this.focus = function(shouldOpenOnFocus, useFocusAsync) {
        if (_this.props.disabled) {
          return;
        }
        if (_this._autofill.current) {
          if (useFocusAsync) {
            focusAsync(_this._autofill.current);
          } else {
            _this._autofill.current.focus();
          }
          if (shouldOpenOnFocus) {
            _this.setState({
              isOpen: true
            });
          }
        }
        if (!_this._hasFocus()) {
          _this.setState({ focusState: "focused" });
        }
      };
      _this.dismissMenu = function() {
        var isOpen = _this.state.isOpen;
        isOpen && _this.setState({ isOpen: false });
      };
      _this._onUpdateValueInAutofillWillReceiveProps = function() {
        var comboBox = _this._autofill.current;
        if (!comboBox) {
          return null;
        }
        if (comboBox.value === null || comboBox.value === void 0) {
          return null;
        }
        return normalizeToString(_this._currentVisibleValue);
      };
      _this._renderComboBoxWrapper = function(multiselectAccessibleText, errorMessageId) {
        var _a2 = _this.props, label = _a2.label, disabled = _a2.disabled, ariaLabel = _a2.ariaLabel, _b2 = _a2.ariaDescribedBy, ariaDescribedBy = _b2 === void 0 ? _this.props["aria-describedby"] : _b2, required = _a2.required, errorMessage = _a2.errorMessage, buttonIconProps = _a2.buttonIconProps, isButtonAriaHidden = _a2.isButtonAriaHidden, title = _a2.title, placeholderProp = _a2.placeholder, tabIndex = _a2.tabIndex, autofill = _a2.autofill, iconButtonProps = _a2.iconButtonProps, suggestedDisplayValue = _a2.hoisted.suggestedDisplayValue;
        var _c2 = _this.state, ariaActiveDescendantValue = _c2.ariaActiveDescendantValue, isOpen = _c2.isOpen;
        var placeholder = _this._hasFocus() && _this.props.multiSelect && multiselectAccessibleText ? multiselectAccessibleText : placeholderProp;
        var labelledBy = [_this.props["aria-labelledby"], label && _this._id + "-label"].join(" ").trim();
        var labelProps = {
          "aria-labelledby": labelledBy ? labelledBy : void 0,
          "aria-label": ariaLabel && !label ? ariaLabel : void 0
        };
        return React__namespace.createElement(
          "div",
          { "data-ktp-target": true, ref: _this._comboBoxWrapper, id: _this._id + "wrapper", className: _this._classNames.root, "aria-owns": isOpen ? _this._id + "-list" : void 0 },
          React__namespace.createElement(Autofill, __assign$1({ "data-ktp-execute-target": true, "data-is-interactable": !disabled, componentRef: _this._autofill, id: _this._id + "-input", className: _this._classNames.input, type: "text", onFocus: _this._onFocus, onBlur: _this._onBlur, onKeyDown: _this._onInputKeyDown, onKeyUp: _this._onInputKeyUp, onClick: _this._onAutofillClick, onTouchStart: _this._onTouchStart, onInputValueChange: _this._onInputChange, "aria-expanded": isOpen, "aria-autocomplete": _this._getAriaAutoCompleteValue(), role: "combobox", readOnly: disabled }, labelProps, { "aria-describedby": errorMessage !== void 0 ? mergeAriaAttributeValues(ariaDescribedBy, errorMessageId) : ariaDescribedBy, "aria-activedescendant": ariaActiveDescendantValue, "aria-required": required, "aria-disabled": disabled, "aria-controls": isOpen ? _this._id + "-list" : void 0, spellCheck: false, defaultVisibleValue: _this._currentVisibleValue, suggestedDisplayValue, updateValueInWillReceiveProps: _this._onUpdateValueInAutofillWillReceiveProps, shouldSelectFullInputValueInComponentDidUpdate: _this._onShouldSelectFullInputValueInAutofillComponentDidUpdate, title, preventValueSelection: !_this._hasFocus(), placeholder, tabIndex: disabled ? -1 : tabIndex }, autofill)),
          React__namespace.createElement(IconButton, __assign$1({ className: "ms-ComboBox-CaretDown-button", styles: _this._getCaretButtonStyles(), role: isButtonAriaHidden ? "presentation" : void 0, "aria-hidden": isButtonAriaHidden }, !isButtonAriaHidden ? labelProps : void 0, { "data-is-focusable": false, tabIndex: -1, onClick: _this._onComboBoxClick, onBlur: _this._onBlur, iconProps: buttonIconProps, disabled, checked: isOpen }, iconButtonProps))
        );
      };
      _this._onShouldSelectFullInputValueInAutofillComponentDidUpdate = function() {
        return _this._currentVisibleValue === _this.props.hoisted.suggestedDisplayValue;
      };
      _this._getVisibleValue = function() {
        var _a2 = _this.props, text = _a2.text, allowFreeform = _a2.allowFreeform, allowFreeInput = _a2.allowFreeInput, autoComplete = _a2.autoComplete, _b2 = _a2.hoisted, suggestedDisplayValue = _b2.suggestedDisplayValue, selectedIndices = _b2.selectedIndices, currentOptions = _b2.currentOptions;
        var _c2 = _this.state, currentPendingValueValidIndex = _c2.currentPendingValueValidIndex, currentPendingValue = _c2.currentPendingValue, isOpen = _c2.isOpen;
        var currentPendingIndexValid = indexWithinBounds(currentOptions, currentPendingValueValidIndex);
        if (!(isOpen && currentPendingIndexValid) && (text || text === "") && (currentPendingValue === null || currentPendingValue === void 0)) {
          return text;
        }
        if (_this.props.multiSelect) {
          if (_this._hasFocus()) {
            var index2 = -1;
            if (autoComplete === "on" && currentPendingIndexValid) {
              index2 = currentPendingValueValidIndex;
            }
            return _this._getPendingString(currentPendingValue, currentOptions, index2);
          } else {
            return _this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue);
          }
        } else {
          var index2 = _this._getFirstSelectedIndex();
          if (allowFreeform || allowFreeInput) {
            if (autoComplete === "on" && currentPendingIndexValid) {
              index2 = currentPendingValueValidIndex;
            }
            return _this._getPendingString(currentPendingValue, currentOptions, index2);
          } else {
            if (currentPendingIndexValid && autoComplete === "on") {
              index2 = currentPendingValueValidIndex;
              return normalizeToString(currentPendingValue);
            } else if (!_this.state.isOpen && currentPendingValue) {
              return indexWithinBounds(currentOptions, index2) ? currentPendingValue : normalizeToString(suggestedDisplayValue);
            } else {
              return indexWithinBounds(currentOptions, index2) ? getPreviewText(currentOptions[index2]) : normalizeToString(suggestedDisplayValue);
            }
          }
        }
      };
      _this._onInputChange = function(updatedValue) {
        if (_this.props.disabled) {
          _this._handleInputWhenDisabled(
            null
            /* event */
          );
          return;
        }
        if (_this.props.onInputValueChange) {
          _this.props.onInputValueChange(updatedValue);
        }
        _this.props.allowFreeform || _this.props.allowFreeInput ? _this._processInputChangeWithFreeform(updatedValue) : _this._processInputChangeWithoutFreeform(updatedValue);
      };
      _this._onFocus = function() {
        var _a2, _b2;
        (_b2 = (_a2 = _this._autofill.current) === null || _a2 === void 0 ? void 0 : _a2.inputElement) === null || _b2 === void 0 ? void 0 : _b2.select();
        if (!_this._hasFocus()) {
          _this.setState({ focusState: "focusing" });
        }
      };
      _this._onResolveOptions = function() {
        if (_this.props.onResolveOptions) {
          var newOptions_1 = _this.props.onResolveOptions(__spreadArray([], _this.props.hoisted.currentOptions));
          if (Array.isArray(newOptions_1)) {
            _this.props.hoisted.setCurrentOptions(newOptions_1);
          } else if (newOptions_1 && newOptions_1.then) {
            _this._currentPromise = newOptions_1;
            newOptions_1.then(function(newOptionsFromPromise) {
              if (newOptions_1 === _this._currentPromise) {
                _this.props.hoisted.setCurrentOptions(newOptionsFromPromise);
              }
            });
          }
        }
      };
      _this._onBlur = function(event) {
        var _a2, _b2;
        var relatedTarget = event.relatedTarget;
        if (event.relatedTarget === null) {
          relatedTarget = document.activeElement;
        }
        if (relatedTarget) {
          var isBlurFromComboBoxTitle = (_a2 = _this.props.hoisted.rootRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(relatedTarget);
          var isBlurFromComboBoxMenu = (_b2 = _this._comboBoxMenu.current) === null || _b2 === void 0 ? void 0 : _b2.contains(relatedTarget);
          var isBlurFromComboBoxMenuAncestor = _this._comboBoxMenu.current && findElementRecursive(_this._comboBoxMenu.current, function(element) {
            return element === relatedTarget;
          });
          if (isBlurFromComboBoxTitle || isBlurFromComboBoxMenu || isBlurFromComboBoxMenuAncestor) {
            if (isBlurFromComboBoxMenuAncestor && _this._hasFocus() && (!_this.props.multiSelect || _this.props.allowFreeform)) {
              _this._submitPendingValue(event);
            }
            event.preventDefault();
            event.stopPropagation();
            return;
          }
        }
        if (_this._hasFocus()) {
          _this.setState({ focusState: "none" });
          if (!_this.props.multiSelect || _this.props.allowFreeform) {
            _this._submitPendingValue(event);
          }
        }
      };
      _this._onRenderContainer = function(props2, defaultRender) {
        var onRenderList = props2.onRenderList, calloutProps = props2.calloutProps, dropdownWidth = props2.dropdownWidth, dropdownMaxWidth = props2.dropdownMaxWidth, _a2 = props2.onRenderUpperContent, onRenderUpperContent = _a2 === void 0 ? _this._onRenderUpperContent : _a2, _b2 = props2.onRenderLowerContent, onRenderLowerContent = _b2 === void 0 ? _this._onRenderLowerContent : _b2, useComboBoxAsMenuWidth = props2.useComboBoxAsMenuWidth, persistMenu = props2.persistMenu, _c2 = props2.shouldRestoreFocus, shouldRestoreFocus = _c2 === void 0 ? true : _c2;
        var isOpen = _this.state.isOpen;
        var id = _this._id;
        var comboBoxMenuWidth = useComboBoxAsMenuWidth && _this._comboBoxWrapper.current ? _this._comboBoxWrapper.current.clientWidth + 2 : void 0;
        return React__namespace.createElement(
          Callout,
          __assign$1({ isBeakVisible: false, gapSpace: 0, doNotLayer: false, directionalHint: DirectionalHint.bottomLeftEdge, directionalHintFixed: false }, calloutProps, { onLayerMounted: _this._onLayerMounted, className: css$3(_this._classNames.callout, calloutProps === null || calloutProps === void 0 ? void 0 : calloutProps.className), target: _this._comboBoxWrapper.current, onDismiss: _this._onDismiss, onMouseDown: _this._onCalloutMouseDown, onScroll: _this._onScroll, setInitialFocus: false, calloutWidth: useComboBoxAsMenuWidth && _this._comboBoxWrapper.current ? comboBoxMenuWidth && comboBoxMenuWidth : dropdownWidth, calloutMaxWidth: dropdownMaxWidth ? dropdownMaxWidth : comboBoxMenuWidth, hidden: persistMenu ? !isOpen : void 0, shouldRestoreFocus }),
          onRenderUpperContent(_this.props, _this._onRenderUpperContent),
          React__namespace.createElement("div", { className: _this._classNames.optionsContainerWrapper, ref: _this._comboBoxMenu }, onRenderList === null || onRenderList === void 0 ? void 0 : onRenderList(__assign$1(__assign$1({}, props2), { id }), _this._onRenderList)),
          onRenderLowerContent(_this.props, _this._onRenderLowerContent)
        );
      };
      _this._onLayerMounted = function() {
        _this._onCalloutLayerMounted();
        _this._async.setTimeout(function() {
          _this._scrollIntoView();
        }, 0);
        if (_this.props.calloutProps && _this.props.calloutProps.onLayerMounted) {
          _this.props.calloutProps.onLayerMounted();
        }
      };
      _this._onRenderLabel = function(onRenderLabelProps) {
        var _a2 = onRenderLabelProps.props, label = _a2.label, disabled = _a2.disabled, required = _a2.required;
        if (label) {
          return React__namespace.createElement(
            Label,
            { id: _this._id + "-label", disabled, required, className: _this._classNames.label },
            label,
            onRenderLabelProps.multiselectAccessibleText && React__namespace.createElement("span", { className: _this._classNames.screenReaderText }, onRenderLabelProps.multiselectAccessibleText)
          );
        }
        return null;
      };
      _this._onRenderList = function(props2) {
        var _a2 = props2.onRenderItem, onRenderItem = _a2 === void 0 ? _this._onRenderItem : _a2, label = props2.label, ariaLabel = props2.ariaLabel, multiSelect = props2.multiSelect;
        var queue = { items: [] };
        var renderedList = [];
        var emptyQueue = function() {
          var newGroup = queue.id ? [
            React__namespace.createElement("div", { role: "group", key: queue.id, "aria-labelledby": queue.id }, queue.items)
          ] : queue.items;
          renderedList = __spreadArray(__spreadArray([], renderedList), newGroup);
          queue = { items: [] };
        };
        var placeRenderedOptionIntoQueue = function(item, index2) {
          switch (item.itemType) {
            case SelectableOptionMenuItemType.Header:
              queue.items.length > 0 && emptyQueue();
              var id_1 = _this._id + item.key;
              queue.items.push(onRenderItem(__assign$1(__assign$1({ id: id_1 }, item), { index: index2 }), _this._onRenderItem));
              queue.id = id_1;
              break;
            case SelectableOptionMenuItemType.Divider:
              index2 > 0 && queue.items.push(onRenderItem(__assign$1(__assign$1({}, item), { index: index2 }), _this._onRenderItem));
              queue.items.length > 0 && emptyQueue();
              break;
            default:
              queue.items.push(onRenderItem(__assign$1(__assign$1({}, item), { index: index2 }), _this._onRenderItem));
          }
        };
        props2.options.forEach(function(item, index2) {
          placeRenderedOptionIntoQueue(item, index2);
        });
        queue.items.length > 0 && emptyQueue();
        var id = _this._id;
        return React__namespace.createElement("div", { id: id + "-list", className: _this._classNames.optionsContainer, "aria-labelledby": label && id + "-label", "aria-label": ariaLabel && !label ? ariaLabel : void 0, "aria-multiselectable": multiSelect ? "true" : void 0, role: "listbox" }, renderedList);
      };
      _this._onRenderItem = function(item) {
        switch (item.itemType) {
          case SelectableOptionMenuItemType.Divider:
            return _this._renderSeparator(item);
          case SelectableOptionMenuItemType.Header:
            return _this._renderHeader(item);
          default:
            return _this._renderOption(item);
        }
      };
      _this._onRenderLowerContent = function() {
        return null;
      };
      _this._onRenderUpperContent = function() {
        return null;
      };
      _this._renderOption = function(item) {
        var _a2;
        var _b2 = _this.props.onRenderOption, onRenderOption = _b2 === void 0 ? _this._onRenderOptionContent : _b2;
        var id = (_a2 = item.id) !== null && _a2 !== void 0 ? _a2 : _this._id + "-list" + item.index;
        var isSelected = _this._isOptionSelected(item.index);
        var isChecked = _this._isOptionChecked(item.index);
        var isIndeterminate = _this._isOptionIndeterminate(item.index);
        var optionStyles = _this._getCurrentOptionStyles(item);
        var optionClassNames = getComboBoxOptionClassNames(_this._getCurrentOptionStyles(item));
        var title = item.title;
        var getOptionComponent = function() {
          return !_this.props.multiSelect ? React__namespace.createElement(CommandButton, {
            id,
            key: item.key,
            "data-index": item.index,
            styles: optionStyles,
            checked: isSelected,
            className: "ms-ComboBox-option",
            onClick: _this._onItemClick(item),
            // eslint-disable-next-line react/jsx-no-bind
            onMouseEnter: _this._onOptionMouseEnter.bind(_this, item.index),
            // eslint-disable-next-line react/jsx-no-bind
            onMouseMove: _this._onOptionMouseMove.bind(_this, item.index),
            onMouseLeave: _this._onOptionMouseLeave,
            role: "option",
            "aria-selected": isSelected ? "true" : "false",
            ariaLabel: item.ariaLabel,
            disabled: item.disabled,
            title
          }, React__namespace.createElement("span", { className: optionClassNames.optionTextWrapper, ref: isSelected ? _this._selectedElement : void 0 }, onRenderOption(item, _this._onRenderOptionContent))) : React__namespace.createElement(Checkbox, {
            id,
            ariaLabel: item.ariaLabel,
            ariaLabelledBy: item.ariaLabel ? void 0 : id + "-label",
            key: item.key,
            styles: optionStyles,
            className: "ms-ComboBox-option",
            onChange: _this._onItemClick(item),
            label: item.text,
            checked: isChecked,
            indeterminate: isIndeterminate,
            title,
            disabled: item.disabled,
            // eslint-disable-next-line react/jsx-no-bind
            onRenderLabel: _this._renderCheckboxLabel.bind(_this, __assign$1(__assign$1({}, item), { id: id + "-label" })),
            inputProps: __assign$1({
              // aria-selected should only be applied to checked items, not hovered items
              "aria-selected": isChecked ? "true" : "false",
              role: "option"
            }, {
              "data-index": item.index,
              "data-is-focusable": true
            })
          });
        };
        return React__namespace.createElement(ComboBoxOptionWrapper, {
          key: item.key,
          index: item.index,
          disabled: item.disabled,
          isSelected,
          isChecked,
          isIndeterminate,
          text: item.text,
          // eslint-disable-next-line react/jsx-no-bind
          render: getOptionComponent,
          data: item.data
        });
      };
      _this._onCalloutMouseDown = function(ev) {
        ev.preventDefault();
      };
      _this._onScroll = function() {
        var _a2;
        if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== void 0) {
          _this._async.clearTimeout(_this._scrollIdleTimeoutId);
          _this._scrollIdleTimeoutId = void 0;
        } else {
          _this._isScrollIdle = false;
        }
        if ((_a2 = _this.props.calloutProps) === null || _a2 === void 0 ? void 0 : _a2.onScroll) {
          _this.props.calloutProps.onScroll();
        }
        _this._scrollIdleTimeoutId = _this._async.setTimeout(function() {
          _this._isScrollIdle = true;
        }, ScrollIdleDelay);
      };
      _this._onRenderOptionContent = function(item) {
        var optionClassNames = getComboBoxOptionClassNames(_this._getCurrentOptionStyles(item));
        return React__namespace.createElement("span", { className: optionClassNames.optionText }, item.text);
      };
      _this._onRenderMultiselectOptionContent = function(item) {
        var optionClassNames = getComboBoxOptionClassNames(_this._getCurrentOptionStyles(item));
        return React__namespace.createElement("span", { id: item.id, "aria-hidden": "true", className: optionClassNames.optionText }, item.text);
      };
      _this._onDismiss = function() {
        var onMenuDismiss = _this.props.onMenuDismiss;
        if (onMenuDismiss) {
          onMenuDismiss();
        }
        if (_this.props.persistMenu) {
          _this._onCalloutLayerMounted();
        }
        _this._setOpenStateAndFocusOnClose(
          false,
          false
          /* focusInputAfterClose */
        );
        _this._resetSelectedIndex();
      };
      _this._onAfterClearPendingInfo = function() {
        _this._processingClearPendingInfo = false;
      };
      _this._onInputKeyDown = function(ev) {
        var _a2 = _this.props, disabled = _a2.disabled, allowFreeform = _a2.allowFreeform, allowFreeInput = _a2.allowFreeInput, autoComplete = _a2.autoComplete, currentOptions = _a2.hoisted.currentOptions;
        var _b2 = _this.state, isOpen = _b2.isOpen, currentPendingValueValidIndexOnHover = _b2.currentPendingValueValidIndexOnHover;
        _this._lastKeyDownWasAltOrMeta = isAltOrMeta(ev);
        if (disabled) {
          _this._handleInputWhenDisabled(ev);
          return;
        }
        var index2 = _this._getPendingSelectedIndex(
          false
          /* includeCurrentPendingValue */
        );
        switch (ev.which) {
          case KeyCodes.enter:
            if (_this._autofill.current && _this._autofill.current.inputElement) {
              _this._autofill.current.inputElement.select();
            }
            _this._submitPendingValue(ev);
            if (_this.props.multiSelect && isOpen) {
              _this.setState({
                currentPendingValueValidIndex: index2
              });
            } else {
              if (isOpen || (!allowFreeform || _this.state.currentPendingValue === void 0 || _this.state.currentPendingValue === null || _this.state.currentPendingValue.length <= 0) && _this.state.currentPendingValueValidIndex < 0) {
                _this.setState({
                  isOpen: !isOpen
                });
              }
            }
            break;
          case KeyCodes.tab:
            if (!_this.props.multiSelect) {
              _this._submitPendingValue(ev);
            }
            if (isOpen) {
              _this._setOpenStateAndFocusOnClose(
                !isOpen,
                false
                /* focusInputAfterClose */
              );
            }
            return;
          case KeyCodes.escape:
            _this._resetSelectedIndex();
            if (isOpen) {
              _this.setState({
                isOpen: false
              });
            } else {
              return;
            }
            break;
          case KeyCodes.up:
            if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {
              index2 = _this.props.hoisted.currentOptions.length;
            }
            if (ev.altKey || ev.metaKey) {
              if (isOpen) {
                _this._setOpenStateAndFocusOnClose(
                  !isOpen,
                  true
                  /* focusInputAfterClose */
                );
                break;
              }
              return;
            }
            ev.preventDefault();
            _this._setPendingInfoFromIndexAndDirection(index2, SearchDirection.backward);
            break;
          case KeyCodes.down:
            if (ev.altKey || ev.metaKey) {
              _this._setOpenStateAndFocusOnClose(
                true,
                true
                /* focusInputAfterClose */
              );
            } else {
              if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {
                index2 = -1;
              }
              ev.preventDefault();
              _this._setPendingInfoFromIndexAndDirection(index2, SearchDirection.forward);
            }
            break;
          case KeyCodes.home:
          case KeyCodes.end:
            if (allowFreeform || allowFreeInput) {
              return;
            }
            index2 = -1;
            var directionToSearch = SearchDirection.forward;
            if (ev.which === KeyCodes.end) {
              index2 = currentOptions.length;
              directionToSearch = SearchDirection.backward;
            }
            _this._setPendingInfoFromIndexAndDirection(index2, directionToSearch);
            break;
          case KeyCodes.space:
            if (!allowFreeform && !allowFreeInput && autoComplete === "off") {
              break;
            }
          default:
            if (ev.which >= 112 && ev.which <= 123) {
              return;
            }
            if (ev.keyCode === KeyCodes.alt || ev.key === "Meta") {
              return;
            }
            if (!allowFreeform && !allowFreeInput && autoComplete === "on") {
              _this._onInputChange(ev.key);
              break;
            }
            return;
        }
        ev.stopPropagation();
        ev.preventDefault();
      };
      _this._onInputKeyUp = function(ev) {
        var _a2 = _this.props, disabled = _a2.disabled, allowFreeform = _a2.allowFreeform, allowFreeInput = _a2.allowFreeInput, autoComplete = _a2.autoComplete;
        var isOpen = _this.state.isOpen;
        var keyPressIsAltOrMetaAlone = _this._lastKeyDownWasAltOrMeta && isAltOrMeta(ev);
        _this._lastKeyDownWasAltOrMeta = false;
        var shouldHandleKey = keyPressIsAltOrMetaAlone && !(isMac() || isIOS());
        if (disabled) {
          _this._handleInputWhenDisabled(ev);
          return;
        }
        switch (ev.which) {
          case KeyCodes.space:
            if (!allowFreeform && !allowFreeInput && autoComplete === "off") {
              _this._setOpenStateAndFocusOnClose(!isOpen, !!isOpen);
            }
            return;
          default:
            if (shouldHandleKey && isOpen) {
              _this._setOpenStateAndFocusOnClose(
                !isOpen,
                true
                /* focusInputAfterClose */
              );
            } else {
              if (_this.state.focusState === "focusing" && _this.props.openOnKeyboardFocus) {
                _this.setState({ isOpen: true });
              }
              if (_this.state.focusState !== "focused") {
                _this.setState({ focusState: "focused" });
              }
            }
            return;
        }
      };
      _this._onOptionMouseLeave = function() {
        if (_this._shouldIgnoreMouseEvent()) {
          return;
        }
        if (_this.props.persistMenu && !_this.state.isOpen) {
          return;
        }
        _this.setState({
          currentPendingValueValidIndexOnHover: HoverStatus.clearAll
        });
      };
      _this._onComboBoxClick = function() {
        var disabled = _this.props.disabled;
        var isOpen = _this.state.isOpen;
        if (!disabled) {
          _this._setOpenStateAndFocusOnClose(
            !isOpen,
            false
            /* focusInputAfterClose */
          );
          _this.setState({ focusState: "focused" });
        }
      };
      _this._onAutofillClick = function() {
        var _a2 = _this.props, disabled = _a2.disabled, allowFreeform = _a2.allowFreeform;
        if (allowFreeform && !disabled) {
          _this.focus(_this.state.isOpen || _this._processingTouch);
        } else {
          _this._onComboBoxClick();
        }
      };
      _this._onTouchStart = function() {
        if (_this._comboBoxWrapper.current && !("onpointerdown" in _this._comboBoxWrapper)) {
          _this._handleTouchAndPointerEvent();
        }
      };
      _this._onPointerDown = function(ev) {
        if (ev.pointerType === "touch") {
          _this._handleTouchAndPointerEvent();
          ev.preventDefault();
          ev.stopImmediatePropagation();
        }
      };
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      warnMutuallyExclusive(COMPONENT_NAME$7, props, {
        defaultSelectedKey: "selectedKey",
        text: "defaultSelectedKey",
        selectedKey: "value",
        dropdownWidth: "useComboBoxAsMenuWidth",
        ariaLabel: "label"
      });
      _this._id = props.id || getId("ComboBox");
      _this._isScrollIdle = true;
      _this._processingTouch = false;
      _this._gotMouseMove = false;
      _this._processingClearPendingInfo = false;
      _this.state = {
        isOpen: false,
        focusState: "none",
        currentPendingValueValidIndex: -1,
        currentPendingValue: void 0,
        currentPendingValueValidIndexOnHover: HoverStatus.default
      };
      return _this;
    }
    Object.defineProperty(ComboBoxInternal2.prototype, "selectedOptions", {
      /**
       * All selected options
       */
      get: function() {
        var _a2 = this.props.hoisted, currentOptions = _a2.currentOptions, selectedIndices = _a2.selectedIndices;
        return getAllSelectedOptions(currentOptions, selectedIndices);
      },
      enumerable: false,
      configurable: true
    });
    ComboBoxInternal2.prototype.componentDidMount = function() {
      if (this._comboBoxWrapper.current && !this.props.disabled) {
        this._events.on(this._comboBoxWrapper.current, "focus", this._onResolveOptions, true);
        if ("onpointerdown" in this._comboBoxWrapper.current) {
          this._events.on(this._comboBoxWrapper.current, "pointerdown", this._onPointerDown, true);
        }
      }
    };
    ComboBoxInternal2.prototype.componentDidUpdate = function(prevProps, prevState) {
      var _this = this;
      var _a2, _b2, _c2;
      var _d2 = this.props, allowFreeform = _d2.allowFreeform, allowFreeInput = _d2.allowFreeInput, text = _d2.text, onMenuOpen = _d2.onMenuOpen, onMenuDismissed = _d2.onMenuDismissed, _e2 = _d2.hoisted, currentOptions = _e2.currentOptions, selectedIndices = _e2.selectedIndices;
      var _f = this.state, currentPendingValue = _f.currentPendingValue, currentPendingValueValidIndex = _f.currentPendingValueValidIndex, isOpen = _f.isOpen;
      if (isOpen && (!prevState.isOpen || prevState.currentPendingValueValidIndex !== currentPendingValueValidIndex)) {
        this._async.setTimeout(function() {
          return _this._scrollIntoView();
        }, 0);
      }
      if (this._hasFocus() && (isOpen || prevState.isOpen && !isOpen && this._focusInputAfterClose && this._autofill.current && document.activeElement !== this._autofill.current.inputElement)) {
        this.focus(
          void 0,
          true
          /*useFocusAsync*/
        );
      }
      if (this._focusInputAfterClose && (prevState.isOpen && !isOpen || this._hasFocus() && (!isOpen && !this.props.multiSelect && prevProps.hoisted.selectedIndices && selectedIndices && prevProps.hoisted.selectedIndices[0] !== selectedIndices[0] || !allowFreeform && !allowFreeInput || text !== prevProps.text))) {
        this._onFocus();
      }
      this._notifyPendingValueChanged(prevState);
      if (isOpen && !prevState.isOpen && onMenuOpen) {
        onMenuOpen();
      }
      if (!isOpen && prevState.isOpen && onMenuDismissed) {
        onMenuDismissed();
      }
      var newCurrentPendingValueValidIndex = currentPendingValueValidIndex;
      var options2 = currentOptions.map(function(item, index2) {
        return __assign$1(__assign$1({}, item), { index: index2 });
      });
      if (!shallowCompare(prevProps.hoisted.currentOptions, currentOptions) && currentPendingValue) {
        newCurrentPendingValueValidIndex = this.props.allowFreeform || this.props.allowFreeInput ? this._processInputChangeWithFreeform(currentPendingValue) : this._updateAutocompleteIndexWithoutFreeform(currentPendingValue);
      }
      var descendantText = void 0;
      if (isOpen && this._hasFocus() && newCurrentPendingValueValidIndex !== -1) {
        descendantText = (_a2 = options2[newCurrentPendingValueValidIndex].id) !== null && _a2 !== void 0 ? _a2 : this._id + "-list" + newCurrentPendingValueValidIndex;
      } else if (isOpen && selectedIndices.length) {
        descendantText = (_c2 = (_b2 = options2[selectedIndices[0]]) === null || _b2 === void 0 ? void 0 : _b2.id) !== null && _c2 !== void 0 ? _c2 : this._id + "-list" + selectedIndices[0];
      }
      if (descendantText !== this.state.ariaActiveDescendantValue) {
        this.setState({
          ariaActiveDescendantValue: descendantText
        });
      }
    };
    ComboBoxInternal2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    ComboBoxInternal2.prototype.render = function() {
      var id = this._id;
      var errorMessageId = id + "-error";
      var _a2 = this.props, className = _a2.className, disabled = _a2.disabled, required = _a2.required, errorMessage = _a2.errorMessage, _b2 = _a2.onRenderContainer, onRenderContainer = _b2 === void 0 ? this._onRenderContainer : _b2, _c2 = _a2.onRenderLabel, onRenderLabel = _c2 === void 0 ? this._onRenderLabel : _c2, _d2 = _a2.onRenderList, onRenderList = _d2 === void 0 ? this._onRenderList : _d2, _e2 = _a2.onRenderItem, onRenderItem = _e2 === void 0 ? this._onRenderItem : _e2, _f = _a2.onRenderOption, onRenderOption = _f === void 0 ? this._onRenderOptionContent : _f, allowFreeform = _a2.allowFreeform, customStyles = _a2.styles, theme = _a2.theme, persistMenu = _a2.persistMenu, multiSelect = _a2.multiSelect, _g = _a2.hoisted, suggestedDisplayValue = _g.suggestedDisplayValue, selectedIndices = _g.selectedIndices, currentOptions = _g.currentOptions;
      var isOpen = this.state.isOpen;
      this._currentVisibleValue = this._getVisibleValue();
      var multiselectAccessibleText = multiSelect ? this._getMultiselectDisplayString(selectedIndices, currentOptions, suggestedDisplayValue) : void 0;
      var divProps = getNativeProps(this.props, divProperties, [
        "onChange",
        "value",
        "aria-describedby",
        "aria-labelledby"
      ]);
      var hasErrorMessage = errorMessage && errorMessage.length > 0 ? true : false;
      this._classNames = this.props.getClassNames ? this.props.getClassNames(theme, !!isOpen, !!disabled, !!required, !!this._hasFocus(), !!allowFreeform, !!hasErrorMessage, className) : getClassNames$x(getStyles$q(theme, customStyles), className, !!isOpen, !!disabled, !!required, !!this._hasFocus(), !!allowFreeform, !!hasErrorMessage);
      var comboBoxWrapper = this._renderComboBoxWrapper(multiselectAccessibleText, errorMessageId);
      return React__namespace.createElement(
        "div",
        __assign$1({}, divProps, { ref: this.props.hoisted.mergedRootRef, className: this._classNames.container }),
        onRenderLabel({ props: this.props, multiselectAccessibleText }, this._onRenderLabel),
        comboBoxWrapper,
        (persistMenu || isOpen) && onRenderContainer(__assign$1(__assign$1({}, this.props), { onRenderList, onRenderItem, onRenderOption, options: currentOptions.map(function(item, index2) {
          return __assign$1(__assign$1({}, item), { index: index2 });
        }), onDismiss: this._onDismiss }), this._onRenderContainer),
        hasErrorMessage && React__namespace.createElement("div", { role: "alert", id: errorMessageId, className: this._classNames.errorMessage }, errorMessage)
      );
    };
    ComboBoxInternal2.prototype._getPendingString = function(currentPendingValue, currentOptions, index2) {
      return currentPendingValue !== null && currentPendingValue !== void 0 ? currentPendingValue : indexWithinBounds(currentOptions, index2) ? getPreviewText(currentOptions[index2]) : "";
    };
    ComboBoxInternal2.prototype._getMultiselectDisplayString = function(selectedIndices, currentOptions, suggestedDisplayValue) {
      var displayValues = [];
      for (var idx = 0; selectedIndices && idx < selectedIndices.length; idx++) {
        var index2 = selectedIndices[idx];
        if (currentOptions[index2].itemType !== SelectableOptionMenuItemType.SelectAll) {
          displayValues.push(indexWithinBounds(currentOptions, index2) ? currentOptions[index2].text : normalizeToString(suggestedDisplayValue));
        }
      }
      var _a2 = this.props.multiSelectDelimiter, multiSelectDelimiter = _a2 === void 0 ? ", " : _a2;
      return displayValues.join(multiSelectDelimiter);
    };
    ComboBoxInternal2.prototype._processInputChangeWithFreeform = function(updatedValue) {
      var currentOptions = this.props.hoisted.currentOptions;
      var newCurrentPendingValueValidIndex = -1;
      if (updatedValue === "") {
        var items = currentOptions.map(function(item, index2) {
          return __assign$1(__assign$1({}, item), { index: index2 });
        }).filter(function(option) {
          return isNormalOption(option) && !option.disabled && getPreviewText(option) === updatedValue;
        });
        if (items.length === 1) {
          newCurrentPendingValueValidIndex = items[0].index;
        }
        this._setPendingInfo(updatedValue, newCurrentPendingValueValidIndex, updatedValue);
        return newCurrentPendingValueValidIndex;
      }
      var originalUpdatedValue = updatedValue;
      updatedValue = updatedValue.toLocaleLowerCase();
      var newSuggestedDisplayValue = "";
      if (this.props.autoComplete === "on") {
        var items = currentOptions.map(function(item, index2) {
          return __assign$1(__assign$1({}, item), { index: index2 });
        }).filter(function(option) {
          return isNormalOption(option) && !option.disabled && getPreviewText(option).toLocaleLowerCase().indexOf(updatedValue) === 0;
        });
        if (items.length > 0) {
          var text = getPreviewText(items[0]);
          newSuggestedDisplayValue = text.toLocaleLowerCase() !== updatedValue ? text : "";
          newCurrentPendingValueValidIndex = items[0].index;
        }
      } else {
        var items = currentOptions.map(function(item, index2) {
          return __assign$1(__assign$1({}, item), { index: index2 });
        }).filter(function(option) {
          return isNormalOption(option) && !option.disabled && getPreviewText(option).toLocaleLowerCase() === updatedValue;
        });
        if (items.length === 1) {
          newCurrentPendingValueValidIndex = items[0].index;
        }
      }
      this._setPendingInfo(originalUpdatedValue, newCurrentPendingValueValidIndex, newSuggestedDisplayValue);
      return newCurrentPendingValueValidIndex;
    };
    ComboBoxInternal2.prototype._processInputChangeWithoutFreeform = function(updatedValue) {
      var _this = this;
      var _a2 = this.state, currentPendingValue = _a2.currentPendingValue, currentPendingValueValidIndex = _a2.currentPendingValueValidIndex;
      if (this.props.autoComplete === "on") {
        if (updatedValue !== "") {
          if (this._autoCompleteTimeout) {
            this._async.clearTimeout(this._autoCompleteTimeout);
            this._autoCompleteTimeout = void 0;
            updatedValue = normalizeToString(currentPendingValue) + updatedValue;
          }
          var matchingIndex = this._updateAutocompleteIndexWithoutFreeform(updatedValue);
          this._autoCompleteTimeout = this._async.setTimeout(function() {
            _this._autoCompleteTimeout = void 0;
          }, ReadOnlyPendingAutoCompleteTimeout);
          return matchingIndex;
        }
      }
      var index2 = currentPendingValueValidIndex >= 0 ? currentPendingValueValidIndex : this._getFirstSelectedIndex();
      this._setPendingInfoFromIndex(index2);
      return index2;
    };
    ComboBoxInternal2.prototype._updateAutocompleteIndexWithoutFreeform = function(updatedValue) {
      var currentOptions = this.props.hoisted.currentOptions;
      var originalUpdatedValue = updatedValue;
      updatedValue = updatedValue.toLocaleLowerCase();
      var items = currentOptions.map(function(item, i) {
        return __assign$1(__assign$1({}, item), { index: i });
      }).filter(function(option) {
        return isNormalOption(option) && !option.disabled && option.text.toLocaleLowerCase().indexOf(updatedValue) === 0;
      });
      if (items.length > 0) {
        this._setPendingInfo(originalUpdatedValue, items[0].index, getPreviewText(items[0]));
        return items[0].index;
      }
      return -1;
    };
    ComboBoxInternal2.prototype._getFirstSelectedIndex = function() {
      var selectedIndices = this.props.hoisted.selectedIndices;
      return (selectedIndices === null || selectedIndices === void 0 ? void 0 : selectedIndices.length) ? selectedIndices[0] : -1;
    };
    ComboBoxInternal2.prototype._getNextSelectableIndex = function(index2, searchDirection) {
      var currentOptions = this.props.hoisted.currentOptions;
      var newIndex = index2 + searchDirection;
      newIndex = Math.max(0, Math.min(currentOptions.length - 1, newIndex));
      if (!indexWithinBounds(currentOptions, newIndex)) {
        return -1;
      }
      var option = currentOptions[newIndex];
      if (!isSelectableOption(option) || option.hidden === true) {
        if (searchDirection !== SearchDirection.none && (newIndex > 0 && searchDirection < SearchDirection.none || newIndex >= 0 && newIndex < currentOptions.length && searchDirection > SearchDirection.none)) {
          newIndex = this._getNextSelectableIndex(newIndex, searchDirection);
        } else {
          return index2;
        }
      }
      return newIndex;
    };
    ComboBoxInternal2.prototype._setSelectedIndex = function(index2, submitPendingValueEvent, searchDirection) {
      if (searchDirection === void 0) {
        searchDirection = SearchDirection.none;
      }
      var _a2 = this.props, onChange2 = _a2.onChange, onPendingValueChanged = _a2.onPendingValueChanged, _b2 = _a2.hoisted, initialIndices = _b2.selectedIndices, currentOptions = _b2.currentOptions;
      var selectedIndices = initialIndices ? initialIndices.slice() : [];
      var changedOptions = currentOptions.slice();
      index2 = this._getNextSelectableIndex(index2, searchDirection);
      if (!indexWithinBounds(currentOptions, index2)) {
        return;
      }
      if (this.props.multiSelect || selectedIndices.length < 1 || selectedIndices.length === 1 && selectedIndices[0] !== index2) {
        var option = __assign$1({}, currentOptions[index2]);
        if (!option || option.disabled) {
          return;
        }
        if (this.props.multiSelect) {
          option.selected = option.selected !== void 0 ? !option.selected : selectedIndices.indexOf(index2) < 0;
          if (option.itemType === SelectableOptionMenuItemType.SelectAll) {
            selectedIndices = [];
            if (option.selected) {
              currentOptions.forEach(function(currentOption, i) {
                if (!currentOption.disabled && isSelectableOption(currentOption)) {
                  selectedIndices.push(i);
                  changedOptions[i] = __assign$1(__assign$1({}, currentOption), { selected: true });
                }
              });
            } else {
              changedOptions = currentOptions.map(function(currentOption) {
                return __assign$1(__assign$1({}, currentOption), { selected: false });
              });
            }
          } else {
            if (option.selected && selectedIndices.indexOf(index2) < 0) {
              selectedIndices.push(index2);
            } else if (!option.selected && selectedIndices.indexOf(index2) >= 0) {
              selectedIndices = selectedIndices.filter(function(value) {
                return value !== index2;
              });
            }
            changedOptions[index2] = option;
            var selectAllOption = changedOptions.filter(function(o) {
              return o.itemType === SelectableOptionMenuItemType.SelectAll;
            })[0];
            if (selectAllOption) {
              var selectAllState = this._isSelectAllChecked(selectedIndices);
              var selectAllIndex_1 = changedOptions.indexOf(selectAllOption);
              if (selectAllState) {
                selectedIndices.push(selectAllIndex_1);
                changedOptions[selectAllIndex_1] = __assign$1(__assign$1({}, selectAllOption), { selected: true });
              } else {
                selectedIndices = selectedIndices.filter(function(value) {
                  return value !== selectAllIndex_1;
                });
                changedOptions[selectAllIndex_1] = __assign$1(__assign$1({}, selectAllOption), { selected: false });
              }
            }
          }
        } else {
          selectedIndices[0] = index2;
        }
        submitPendingValueEvent.persist();
        if (this.props.selectedKey || this.props.selectedKey === null) {
          if (this._hasPendingValue && onPendingValueChanged) {
            onPendingValueChanged();
            this._hasPendingValue = false;
          }
        } else {
          this.props.hoisted.setSelectedIndices(selectedIndices);
          this.props.hoisted.setCurrentOptions(changedOptions);
          if (this._hasPendingValue && onPendingValueChanged) {
            onPendingValueChanged();
            this._hasPendingValue = false;
          }
        }
        if (onChange2) {
          onChange2(submitPendingValueEvent, option, index2, getPreviewText(option));
        }
      }
      if (this.props.multiSelect && this.state.isOpen) {
        return;
      }
      this._clearPendingInfo();
    };
    ComboBoxInternal2.prototype._submitPendingValue = function(submitPendingValueEvent) {
      var _a2;
      var _b2 = this.props, onChange2 = _b2.onChange, allowFreeform = _b2.allowFreeform, autoComplete = _b2.autoComplete, multiSelect = _b2.multiSelect, hoisted = _b2.hoisted;
      var currentOptions = hoisted.currentOptions;
      var _c2 = this.state, currentPendingValue = _c2.currentPendingValue, currentPendingValueValidIndex = _c2.currentPendingValueValidIndex, currentPendingValueValidIndexOnHover = _c2.currentPendingValueValidIndexOnHover;
      var selectedIndices = this.props.hoisted.selectedIndices;
      if (this._processingClearPendingInfo) {
        return;
      }
      if (allowFreeform) {
        if (currentPendingValue === null || currentPendingValue === void 0) {
          if (currentPendingValueValidIndexOnHover >= 0) {
            this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);
            this._clearPendingInfo();
          }
          return;
        }
        if (indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {
          var pendingOptionText = getPreviewText(currentOptions[currentPendingValueValidIndex]).toLocaleLowerCase();
          var autofill = this._autofill.current;
          if (currentPendingValue.toLocaleLowerCase() === pendingOptionText || autoComplete && pendingOptionText.indexOf(currentPendingValue.toLocaleLowerCase()) === 0 && (autofill === null || autofill === void 0 ? void 0 : autofill.isValueSelected) && currentPendingValue.length + (autofill.selectionEnd - autofill.selectionStart) === pendingOptionText.length || ((_a2 = autofill === null || autofill === void 0 ? void 0 : autofill.inputElement) === null || _a2 === void 0 ? void 0 : _a2.value.toLocaleLowerCase()) === pendingOptionText) {
            this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);
            if (multiSelect && this.state.isOpen) {
              return;
            }
            this._clearPendingInfo();
            return;
          }
        }
        if (onChange2) {
          if (onChange2) {
            onChange2(submitPendingValueEvent, void 0, void 0, currentPendingValue);
          }
        } else {
          var newOption = {
            key: currentPendingValue || getId(),
            text: normalizeToString(currentPendingValue)
          };
          if (multiSelect) {
            newOption.selected = true;
          }
          var newOptions = currentOptions.concat([newOption]);
          if (selectedIndices) {
            if (!multiSelect) {
              selectedIndices = [];
            }
            selectedIndices.push(newOptions.length - 1);
          }
          hoisted.setCurrentOptions(newOptions);
          hoisted.setSelectedIndices(selectedIndices);
        }
      } else if (currentPendingValueValidIndex >= 0) {
        this._setSelectedIndex(currentPendingValueValidIndex, submitPendingValueEvent);
      } else if (currentPendingValueValidIndexOnHover >= 0) {
        this._setSelectedIndex(currentPendingValueValidIndexOnHover, submitPendingValueEvent);
      }
      this._clearPendingInfo();
    };
    ComboBoxInternal2.prototype._onCalloutLayerMounted = function() {
      this._gotMouseMove = false;
    };
    ComboBoxInternal2.prototype._renderSeparator = function(item) {
      var index2 = item.index, key = item.key;
      if (index2 && index2 > 0) {
        return React__namespace.createElement("div", { role: "separator", key, className: this._classNames.divider });
      }
      return null;
    };
    ComboBoxInternal2.prototype._renderHeader = function(item) {
      var _a2 = this.props.onRenderOption, onRenderOption = _a2 === void 0 ? this._onRenderOptionContent : _a2;
      return React__namespace.createElement("div", { id: item.id, key: item.key, className: this._classNames.header }, onRenderOption(item, this._onRenderOptionContent));
    };
    ComboBoxInternal2.prototype._renderCheckboxLabel = function(item) {
      var _a2 = this.props.onRenderOption, onRenderOption = _a2 === void 0 ? this._onRenderMultiselectOptionContent : _a2;
      return onRenderOption(item, this._onRenderMultiselectOptionContent);
    };
    ComboBoxInternal2.prototype._isOptionHighlighted = function(index2) {
      var currentPendingValueValidIndexOnHover = this.state.currentPendingValueValidIndexOnHover;
      if (currentPendingValueValidIndexOnHover === HoverStatus.clearAll) {
        return false;
      }
      return currentPendingValueValidIndexOnHover >= 0 ? currentPendingValueValidIndexOnHover === index2 : this._isOptionSelected(index2);
    };
    ComboBoxInternal2.prototype._isOptionSelected = function(index2) {
      return this._getPendingSelectedIndex(
        true
        /* includePendingValue */
      ) === index2;
    };
    ComboBoxInternal2.prototype._isOptionChecked = function(index2) {
      if (this.props.multiSelect && index2 !== void 0 && this.props.hoisted.selectedIndices) {
        var idxOfSelectedIndex = -1;
        idxOfSelectedIndex = this.props.hoisted.selectedIndices.indexOf(index2);
        return idxOfSelectedIndex >= 0;
      }
      return false;
    };
    ComboBoxInternal2.prototype._isOptionIndeterminate = function(index2) {
      var _a2 = this.props, multiSelect = _a2.multiSelect, hoisted = _a2.hoisted;
      if (multiSelect && index2 !== void 0 && hoisted.selectedIndices && hoisted.currentOptions) {
        var option = hoisted.currentOptions[index2];
        if (option && option.itemType === SelectableOptionMenuItemType.SelectAll) {
          return hoisted.selectedIndices.length > 0 && !this._isSelectAllChecked();
        }
      }
      return false;
    };
    ComboBoxInternal2.prototype._isSelectAllChecked = function(testIndices) {
      var _a2 = this.props, multiSelect = _a2.multiSelect, hoisted = _a2.hoisted;
      var selectAllOption = hoisted.currentOptions.find(function(option) {
        return option.itemType === SelectableOptionMenuItemType.SelectAll;
      });
      var selectedIndices = testIndices || hoisted.selectedIndices;
      if (!multiSelect || !selectedIndices || !selectAllOption) {
        return false;
      }
      var selectAllIndex = hoisted.currentOptions.indexOf(selectAllOption);
      var compareSelectedIndices = selectedIndices.filter(function(value) {
        return value !== selectAllIndex;
      });
      var selectableOptions = hoisted.currentOptions.filter(function(option) {
        return !option.disabled && option.itemType !== SelectableOptionMenuItemType.SelectAll && isSelectableOption(option);
      });
      return compareSelectedIndices.length === selectableOptions.length;
    };
    ComboBoxInternal2.prototype._getPendingSelectedIndex = function(includeCurrentPendingValue) {
      var _a2 = this.state, currentPendingValueValidIndex = _a2.currentPendingValueValidIndex, currentPendingValue = _a2.currentPendingValue;
      return currentPendingValueValidIndex >= 0 || includeCurrentPendingValue && currentPendingValue !== null && currentPendingValue !== void 0 ? currentPendingValueValidIndex : this.props.multiSelect ? -1 : this._getFirstSelectedIndex();
    };
    ComboBoxInternal2.prototype._scrollIntoView = function() {
      var _a2 = this.props, onScrollToItem = _a2.onScrollToItem, scrollSelectedToTop = _a2.scrollSelectedToTop;
      var currentPendingSelectedIndex = this._getPendingSelectedIndex(true);
      if (onScrollToItem) {
        onScrollToItem(currentPendingSelectedIndex >= 0 ? currentPendingSelectedIndex : this._getFirstSelectedIndex());
        return;
      }
      var scrollToElement = this._selectedElement.current;
      if (this.props.multiSelect && this._comboBoxMenu.current) {
        scrollToElement = findFirstDescendant(this._comboBoxMenu.current, function(element) {
          var _a3;
          return ((_a3 = element.dataset) === null || _a3 === void 0 ? void 0 : _a3.index) === currentPendingSelectedIndex.toString();
        });
      }
      if (scrollToElement && scrollToElement.offsetParent) {
        var alignToTop = true;
        if (this._comboBoxMenu.current && this._comboBoxMenu.current.offsetParent) {
          var scrollableParent = this._comboBoxMenu.current.offsetParent;
          var selectedElement = scrollToElement.offsetParent;
          var _b2 = selectedElement, offsetHeight = _b2.offsetHeight, offsetTop = _b2.offsetTop;
          var _c2 = scrollableParent, parentOffsetHeight = _c2.offsetHeight, scrollTop = _c2.scrollTop;
          var isAbove = offsetTop < scrollTop;
          var isBelow = offsetTop + offsetHeight > scrollTop + parentOffsetHeight;
          if (isAbove || scrollSelectedToTop) {
            alignToTop = false;
            scrollableParent.scrollTo(0, offsetTop);
          } else if (isBelow) {
            scrollableParent.scrollTo(0, offsetTop - parentOffsetHeight + offsetHeight);
          }
        } else {
          scrollToElement.offsetParent.scrollIntoView(alignToTop);
        }
      }
    };
    ComboBoxInternal2.prototype._onItemClick = function(item) {
      var _this = this;
      var onItemClick = this.props.onItemClick;
      var index2 = item.index;
      return function(ev) {
        if (!_this.props.multiSelect) {
          _this._autofill.current && _this._autofill.current.focus();
          _this.setState({
            isOpen: false
          });
        }
        onItemClick && onItemClick(ev, item, index2);
        _this._setSelectedIndex(index2, ev);
      };
    };
    ComboBoxInternal2.prototype._resetSelectedIndex = function() {
      var currentOptions = this.props.hoisted.currentOptions;
      this._clearPendingInfo();
      var selectedIndex = this._getFirstSelectedIndex();
      if (selectedIndex > 0 && selectedIndex < currentOptions.length) {
        this.props.hoisted.setSuggestedDisplayValue(currentOptions[selectedIndex].text);
      } else if (this.props.text) {
        this.props.hoisted.setSuggestedDisplayValue(this.props.text);
      }
    };
    ComboBoxInternal2.prototype._clearPendingInfo = function() {
      this._processingClearPendingInfo = true;
      this.props.hoisted.setSuggestedDisplayValue(void 0);
      this.setState({
        currentPendingValue: void 0,
        currentPendingValueValidIndex: -1,
        currentPendingValueValidIndexOnHover: HoverStatus.default
      }, this._onAfterClearPendingInfo);
    };
    ComboBoxInternal2.prototype._setPendingInfo = function(currentPendingValue, currentPendingValueValidIndex, suggestedDisplayValue) {
      if (currentPendingValueValidIndex === void 0) {
        currentPendingValueValidIndex = -1;
      }
      if (this._processingClearPendingInfo) {
        return;
      }
      this.props.hoisted.setSuggestedDisplayValue(suggestedDisplayValue);
      this.setState({
        currentPendingValue: normalizeToString(currentPendingValue),
        currentPendingValueValidIndex,
        currentPendingValueValidIndexOnHover: HoverStatus.default
      });
    };
    ComboBoxInternal2.prototype._setPendingInfoFromIndex = function(index2) {
      var currentOptions = this.props.hoisted.currentOptions;
      if (index2 >= 0 && index2 < currentOptions.length) {
        var option = currentOptions[index2];
        this._setPendingInfo(getPreviewText(option), index2, getPreviewText(option));
      } else {
        this._clearPendingInfo();
      }
    };
    ComboBoxInternal2.prototype._setPendingInfoFromIndexAndDirection = function(index2, searchDirection) {
      var currentOptions = this.props.hoisted.currentOptions;
      if (searchDirection === SearchDirection.forward && index2 >= currentOptions.length - 1) {
        index2 = -1;
      } else if (searchDirection === SearchDirection.backward && index2 <= 0) {
        index2 = currentOptions.length;
      }
      var indexUpdate = this._getNextSelectableIndex(index2, searchDirection);
      if (index2 === indexUpdate) {
        if (searchDirection === SearchDirection.forward) {
          index2 = this._getNextSelectableIndex(-1, searchDirection);
        } else if (searchDirection === SearchDirection.backward) {
          index2 = this._getNextSelectableIndex(currentOptions.length, searchDirection);
        }
      } else {
        index2 = indexUpdate;
      }
      if (indexWithinBounds(currentOptions, index2)) {
        this._setPendingInfoFromIndex(index2);
      }
    };
    ComboBoxInternal2.prototype._notifyPendingValueChanged = function(prevState) {
      var onPendingValueChanged = this.props.onPendingValueChanged;
      if (!onPendingValueChanged) {
        return;
      }
      var currentOptions = this.props.hoisted.currentOptions;
      var _a2 = this.state, currentPendingValue = _a2.currentPendingValue, currentPendingValueValidIndex = _a2.currentPendingValueValidIndex, currentPendingValueValidIndexOnHover = _a2.currentPendingValueValidIndexOnHover;
      var newPendingIndex = void 0;
      var newPendingValue = void 0;
      if (currentPendingValueValidIndexOnHover !== prevState.currentPendingValueValidIndexOnHover && indexWithinBounds(currentOptions, currentPendingValueValidIndexOnHover)) {
        newPendingIndex = currentPendingValueValidIndexOnHover;
      } else if (currentPendingValueValidIndex !== prevState.currentPendingValueValidIndex && indexWithinBounds(currentOptions, currentPendingValueValidIndex)) {
        newPendingIndex = currentPendingValueValidIndex;
      } else if (currentPendingValue !== prevState.currentPendingValue) {
        newPendingValue = currentPendingValue;
      }
      if (newPendingIndex !== void 0 || newPendingValue !== void 0 || this._hasPendingValue) {
        onPendingValueChanged(newPendingIndex !== void 0 ? currentOptions[newPendingIndex] : void 0, newPendingIndex, newPendingValue);
        this._hasPendingValue = newPendingIndex !== void 0 || newPendingValue !== void 0;
      }
    };
    ComboBoxInternal2.prototype._setOpenStateAndFocusOnClose = function(isOpen, focusInputAfterClose) {
      this._focusInputAfterClose = focusInputAfterClose;
      this.setState({ isOpen });
    };
    ComboBoxInternal2.prototype._onOptionMouseEnter = function(index2) {
      if (this._shouldIgnoreMouseEvent()) {
        return;
      }
      this.setState({
        currentPendingValueValidIndexOnHover: index2
      });
    };
    ComboBoxInternal2.prototype._onOptionMouseMove = function(index2) {
      this._gotMouseMove = true;
      if (!this._isScrollIdle || this.state.currentPendingValueValidIndexOnHover === index2) {
        return;
      }
      this.setState({
        currentPendingValueValidIndexOnHover: index2
      });
    };
    ComboBoxInternal2.prototype._shouldIgnoreMouseEvent = function() {
      return !this._isScrollIdle || !this._gotMouseMove;
    };
    ComboBoxInternal2.prototype._handleInputWhenDisabled = function(ev) {
      if (this.props.disabled) {
        if (this.state.isOpen) {
          this.setState({ isOpen: false });
        }
        if (ev !== null && // eslint-disable-next-line deprecation/deprecation
        ev.which !== KeyCodes.tab && // eslint-disable-next-line deprecation/deprecation
        ev.which !== KeyCodes.escape && // eslint-disable-next-line deprecation/deprecation
        (ev.which < 112 || ev.which > 123)) {
          ev.stopPropagation();
          ev.preventDefault();
        }
      }
    };
    ComboBoxInternal2.prototype._handleTouchAndPointerEvent = function() {
      var _this = this;
      if (this._lastTouchTimeoutId !== void 0) {
        this._async.clearTimeout(this._lastTouchTimeoutId);
        this._lastTouchTimeoutId = void 0;
      }
      this._processingTouch = true;
      this._lastTouchTimeoutId = this._async.setTimeout(function() {
        _this._processingTouch = false;
        _this._lastTouchTimeoutId = void 0;
      }, TouchIdleDelay);
    };
    ComboBoxInternal2.prototype._getCaretButtonStyles = function() {
      var customCaretDownButtonStyles = this.props.caretDownButtonStyles;
      return getCaretDownButtonStyles(this.props.theme, customCaretDownButtonStyles);
    };
    ComboBoxInternal2.prototype._getCurrentOptionStyles = function(item) {
      var customStylesForAllOptions = this.props.comboBoxOptionStyles;
      var customStylesForCurrentOption = item.styles;
      return getOptionStyles(this.props.theme, customStylesForAllOptions, customStylesForCurrentOption, this._isPendingOption(item), item.hidden, this._isOptionHighlighted(item.index));
    };
    ComboBoxInternal2.prototype._getAriaAutoCompleteValue = function() {
      var autoComplete = !this.props.disabled && this.props.autoComplete === "on";
      return autoComplete ? this.props.allowFreeform ? "inline" : "both" : "list";
    };
    ComboBoxInternal2.prototype._isPendingOption = function(item) {
      return item && item.index === this.state.currentPendingValueValidIndex;
    };
    ComboBoxInternal2.prototype._hasFocus = function() {
      return this.state.focusState !== "none";
    };
    ComboBoxInternal2 = __decorate([
      customizable("ComboBox", ["theme", "styles"], true)
    ], ComboBoxInternal2);
    return ComboBoxInternal2;
  }(React__namespace.Component)
);
function getSelectedIndices(options2, selectedKeys) {
  if (!options2 || !selectedKeys) {
    return [];
  }
  var selectedIndices = {};
  options2.forEach(function(option, index2) {
    if (option.selected) {
      selectedIndices[index2] = true;
    }
  });
  var _loop_1 = function(selectedKey2) {
    var index2 = findIndex(options2, function(option) {
      return option.key === selectedKey2;
    });
    if (index2 > -1) {
      selectedIndices[index2] = true;
    }
  };
  for (var _i = 0, selectedKeys_1 = selectedKeys; _i < selectedKeys_1.length; _i++) {
    var selectedKey = selectedKeys_1[_i];
    _loop_1(selectedKey);
  }
  return Object.keys(selectedIndices).map(Number).sort();
}
function buildDefaultSelectedKeys(defaultSelectedKey, selectedKey) {
  var selectedKeys = buildSelectedKeys(defaultSelectedKey);
  if (selectedKeys.length) {
    return selectedKeys;
  }
  return buildSelectedKeys(selectedKey);
}
function buildSelectedKeys(selectedKey) {
  if (selectedKey === void 0) {
    return [];
  }
  return selectedKey instanceof Array ? selectedKey : [selectedKey];
}
function normalizeToString(value) {
  return value || "";
}
function indexWithinBounds(options2, index2) {
  return !!options2 && index2 >= 0 && index2 < options2.length;
}
function isNormalOption(option) {
  return option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider && option.itemType !== SelectableOptionMenuItemType.SelectAll;
}
function isSelectableOption(option) {
  return option.itemType !== SelectableOptionMenuItemType.Header && option.itemType !== SelectableOptionMenuItemType.Divider;
}
function getPreviewText(item) {
  return item.useAriaLabelAsText && item.ariaLabel ? item.ariaLabel : item.text;
}
function isAltOrMeta(ev) {
  return ev.which === KeyCodes.alt || ev.key === "Meta";
}
var ScrollToMode = {
  /**
   * Does not make any consideration to where in the viewport the item should align to.
   */
  auto: 0,
  /**
   * Attempts to scroll the list so the top of the desired item is aligned with the top of the viewport.
   */
  top: 1,
  /**
   * Attempts to scroll the list so the bottom of the desired item is aligned with the bottom of the viewport.
   */
  bottom: 2,
  /**
   * Attempts to scroll the list so the desired item is in the exact center of the viewport.
   */
  center: 3
};
var getScrollHeight = function(el) {
  if (el === void 0) {
    return 0;
  }
  var scrollHeight = 0;
  if ("scrollHeight" in el) {
    scrollHeight = el.scrollHeight;
  } else if ("document" in el) {
    scrollHeight = el.document.documentElement.scrollHeight;
  }
  return scrollHeight;
};
var getScrollYPosition = function(el) {
  if (el === void 0) {
    return 0;
  }
  var scrollPos = 0;
  if ("scrollTop" in el) {
    scrollPos = el.scrollTop;
  } else if ("scrollY" in el) {
    scrollPos = el.scrollY;
  }
  return Math.ceil(scrollPos);
};
var setScrollYPosition = function(el, pos) {
  if ("scrollTop" in el) {
    el.scrollTop = pos;
  } else if ("scrollY" in el) {
    el.scrollTo(el.scrollX, pos);
  }
};
var RESIZE_DELAY$1 = 16;
var MIN_SCROLL_UPDATE_DELAY = 100;
var MAX_SCROLL_UPDATE_DELAY = 500;
var IDLE_DEBOUNCE_DELAY = 200;
var DONE_SCROLLING_WAIT = 500;
var DEFAULT_ITEMS_PER_PAGE = 10;
var DEFAULT_PAGE_HEIGHT = 30;
var DEFAULT_RENDERED_WINDOWS_BEHIND$1 = 2;
var DEFAULT_RENDERED_WINDOWS_AHEAD$1 = 2;
var PAGE_KEY_PREFIX = "page-";
var SPACER_KEY_PREFIX = "spacer-";
var EMPTY_RECT = {
  top: -1,
  bottom: -1,
  left: -1,
  right: -1,
  width: 0,
  height: 0
};
var _measurePageRect = function(element) {
  return element.getBoundingClientRect();
};
var _measureSurfaceRect = _measurePageRect;
var _measureScrollRect = _measurePageRect;
var List = (
  /** @class */
  function(_super) {
    __extends(List2, _super);
    function List2(props) {
      var _this = _super.call(this, props) || this;
      _this._root = React__namespace.createRef();
      _this._surface = React__namespace.createRef();
      _this._pageRefs = {};
      _this._getDerivedStateFromProps = function(nextProps, previousState) {
        if (nextProps.items !== _this.props.items || nextProps.renderCount !== _this.props.renderCount || nextProps.startIndex !== _this.props.startIndex || nextProps.version !== _this.props.version || !previousState.hasMounted && _this.props.renderEarly && canUseDOM$1()) {
          _this._resetRequiredWindows();
          _this._requiredRect = null;
          _this._measureVersion++;
          _this._invalidatePageCache();
          return _this._updatePages(nextProps, previousState);
        }
        return previousState;
      };
      _this._onRenderRoot = function(props2) {
        var rootRef = props2.rootRef, surfaceElement = props2.surfaceElement, divProps = props2.divProps;
        return React__namespace.createElement("div", __assign$1({ ref: rootRef }, divProps), surfaceElement);
      };
      _this._onRenderSurface = function(props2) {
        var surfaceRef = props2.surfaceRef, pageElements = props2.pageElements, divProps = props2.divProps;
        return React__namespace.createElement("div", __assign$1({ ref: surfaceRef }, divProps), pageElements);
      };
      _this._onRenderPage = function(pageProps, defaultRender) {
        var _a2;
        var _b2 = _this.props, onRenderCell = _b2.onRenderCell, onRenderCellConditional = _b2.onRenderCellConditional, role = _b2.role;
        var _c2 = pageProps.page, _d2 = _c2.items, items = _d2 === void 0 ? [] : _d2, startIndex = _c2.startIndex, divProps = __rest$1(pageProps, ["page"]);
        var cellRole = role === void 0 ? "listitem" : "presentation";
        var cells = [];
        for (var i = 0; i < items.length; i++) {
          var index2 = startIndex + i;
          var item = items[i];
          var itemKey = _this.props.getKey ? _this.props.getKey(item, index2) : item && item.key;
          if (itemKey === null || itemKey === void 0) {
            itemKey = index2;
          }
          var renderCell = onRenderCellConditional !== null && onRenderCellConditional !== void 0 ? onRenderCellConditional : onRenderCell;
          var cell = (_a2 = renderCell === null || renderCell === void 0 ? void 0 : renderCell(item, index2, !_this.props.ignoreScrollingState ? _this.state.isScrolling : void 0)) !== null && _a2 !== void 0 ? _a2 : null;
          if (!onRenderCellConditional || cell) {
            cells.push(React__namespace.createElement("div", { role: cellRole, className: "ms-List-cell", key: itemKey, "data-list-index": index2, "data-automationid": "ListCell" }, cell));
          }
        }
        return React__namespace.createElement("div", __assign$1({}, divProps), cells);
      };
      initializeComponentRef(_this);
      _this.state = {
        pages: [],
        isScrolling: false,
        getDerivedStateFromProps: _this._getDerivedStateFromProps,
        hasMounted: false
      };
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      _this._estimatedPageHeight = 0;
      _this._totalEstimates = 0;
      _this._requiredWindowsAhead = 0;
      _this._requiredWindowsBehind = 0;
      _this._measureVersion = 0;
      _this._onAsyncScroll = _this._async.debounce(_this._onAsyncScroll, MIN_SCROLL_UPDATE_DELAY, {
        leading: false,
        maxWait: MAX_SCROLL_UPDATE_DELAY
      });
      _this._onAsyncIdle = _this._async.debounce(_this._onAsyncIdle, IDLE_DEBOUNCE_DELAY, {
        leading: false
      });
      _this._onAsyncResize = _this._async.debounce(_this._onAsyncResize, RESIZE_DELAY$1, {
        leading: false
      });
      _this._onScrollingDone = _this._async.debounce(_this._onScrollingDone, DONE_SCROLLING_WAIT, {
        leading: false
      });
      _this._cachedPageHeights = {};
      _this._estimatedPageHeight = 0;
      _this._focusedIndex = -1;
      _this._pageCache = {};
      return _this;
    }
    List2.getDerivedStateFromProps = function(nextProps, previousState) {
      return previousState.getDerivedStateFromProps(nextProps, previousState);
    };
    Object.defineProperty(List2.prototype, "pageRefs", {
      get: function() {
        return this._pageRefs;
      },
      enumerable: false,
      configurable: true
    });
    List2.prototype.scrollToIndex = function(index2, measureItem, scrollToMode) {
      if (scrollToMode === void 0) {
        scrollToMode = ScrollToMode.auto;
      }
      var startIndex = this.props.startIndex;
      var renderCount = this._getRenderCount();
      var endIndex = startIndex + renderCount;
      var allowedRect = this._allowedRect;
      var scrollTop = 0;
      var itemsPerPage = 1;
      for (var itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {
        var pageSpecification = this._getPageSpecification(this.props, itemIndex, allowedRect);
        var pageHeight = pageSpecification.height;
        itemsPerPage = pageSpecification.itemCount;
        var requestedIndexIsInPage = itemIndex <= index2 && itemIndex + itemsPerPage > index2;
        if (requestedIndexIsInPage) {
          if (measureItem && this._scrollElement) {
            var scrollRect = _measureScrollRect(this._scrollElement);
            var scrollPosition = getScrollYPosition(this._scrollElement);
            var scrollWindow = {
              top: scrollPosition,
              bottom: scrollPosition + scrollRect.height
            };
            var itemPositionWithinPage = index2 - itemIndex;
            for (var itemIndexInPage = 0; itemIndexInPage < itemPositionWithinPage; ++itemIndexInPage) {
              scrollTop += measureItem(itemIndex + itemIndexInPage);
            }
            var scrollBottom = scrollTop + measureItem(index2);
            switch (scrollToMode) {
              case ScrollToMode.top:
                setScrollYPosition(this._scrollElement, scrollTop);
                return;
              case ScrollToMode.bottom:
                setScrollYPosition(this._scrollElement, scrollBottom - scrollRect.height);
                return;
              case ScrollToMode.center:
                setScrollYPosition(this._scrollElement, (scrollTop + scrollBottom - scrollRect.height) / 2);
                return;
            }
            var itemIsFullyVisible = scrollTop >= scrollWindow.top && scrollBottom <= scrollWindow.bottom;
            if (itemIsFullyVisible) {
              return;
            }
            var itemIsPartiallyAbove = scrollTop < scrollWindow.top;
            var itemIsPartiallyBelow = scrollBottom > scrollWindow.bottom;
            if (itemIsPartiallyAbove)
              ;
            else if (itemIsPartiallyBelow) {
              scrollTop = scrollBottom - scrollRect.height;
            }
          }
          if (this._scrollElement) {
            setScrollYPosition(this._scrollElement, scrollTop);
          }
          return;
        }
        scrollTop += pageHeight;
      }
    };
    List2.prototype.getStartItemIndexInView = function(measureItem) {
      var pages = this.state.pages || [];
      for (var _i = 0, pages_1 = pages; _i < pages_1.length; _i++) {
        var page = pages_1[_i];
        var isPageVisible = !page.isSpacer && (this._scrollTop || 0) >= page.top && (this._scrollTop || 0) <= page.top + page.height;
        if (isPageVisible) {
          if (!measureItem) {
            var rowHeight = Math.floor(page.height / page.itemCount);
            return page.startIndex + Math.floor((this._scrollTop - page.top) / rowHeight);
          } else {
            var totalRowHeight = 0;
            for (var itemIndex = page.startIndex; itemIndex < page.startIndex + page.itemCount; itemIndex++) {
              var rowHeight = measureItem(itemIndex);
              if (page.top + totalRowHeight <= this._scrollTop && this._scrollTop < page.top + totalRowHeight + rowHeight) {
                return itemIndex;
              } else {
                totalRowHeight += rowHeight;
              }
            }
          }
        }
      }
      return 0;
    };
    List2.prototype.componentDidMount = function() {
      this._scrollElement = findScrollableParent(this._root.current);
      this._scrollTop = 0;
      this.setState(__assign$1(__assign$1({}, this._updatePages(this.props, this.state)), { hasMounted: true }));
      this._measureVersion++;
      this._events.on(window, "resize", this._onAsyncResize);
      if (this._root.current) {
        this._events.on(this._root.current, "focus", this._onFocus, true);
      }
      if (this._scrollElement) {
        this._events.on(this._scrollElement, "scroll", this._onScroll);
        this._events.on(this._scrollElement, "scroll", this._onAsyncScroll);
      }
    };
    List2.prototype.componentDidUpdate = function(previousProps, previousState) {
      var finalProps = this.props;
      var finalState = this.state;
      if (this.state.pagesVersion !== previousState.pagesVersion) {
        if (!finalProps.getPageHeight) {
          var heightsChanged = this._updatePageMeasurements(finalState.pages);
          if (heightsChanged) {
            this._materializedRect = null;
            if (!this._hasCompletedFirstRender) {
              this._hasCompletedFirstRender = true;
              this.setState(this._updatePages(finalProps, finalState));
            } else {
              this._onAsyncScroll();
            }
          } else {
            this._onAsyncIdle();
          }
        } else {
          this._onAsyncIdle();
        }
        if (finalProps.onPagesUpdated) {
          finalProps.onPagesUpdated(finalState.pages);
        }
      }
    };
    List2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
      delete this._scrollElement;
    };
    List2.prototype.shouldComponentUpdate = function(newProps, newState) {
      var oldPages = this.state.pages;
      var newPages = newState.pages;
      var shouldComponentUpdate = false;
      if (!newState.isScrolling && this.state.isScrolling) {
        return true;
      }
      if (newProps.version !== this.props.version) {
        return true;
      }
      if (newProps.className !== this.props.className) {
        return true;
      }
      if (newProps.items === this.props.items && oldPages.length === newPages.length) {
        for (var i = 0; i < oldPages.length; i++) {
          var oldPage = oldPages[i];
          var newPage = newPages[i];
          if (oldPage.key !== newPage.key || oldPage.itemCount !== newPage.itemCount) {
            shouldComponentUpdate = true;
            break;
          }
        }
      } else {
        shouldComponentUpdate = true;
      }
      return shouldComponentUpdate;
    };
    List2.prototype.forceUpdate = function() {
      this._invalidatePageCache();
      this._updateRenderRects(this.props, this.state, true);
      this.setState(this._updatePages(this.props, this.state));
      this._measureVersion++;
      _super.prototype.forceUpdate.call(this);
    };
    List2.prototype.getTotalListHeight = function() {
      return this._surfaceRect.height;
    };
    List2.prototype.render = function() {
      var _a2 = this.props, className = _a2.className, _b2 = _a2.role, role = _b2 === void 0 ? "list" : _b2, onRenderSurface = _a2.onRenderSurface, onRenderRoot = _a2.onRenderRoot;
      var _c2 = this.state.pages, pages = _c2 === void 0 ? [] : _c2;
      var pageElements = [];
      var divProps = getNativeProps(this.props, divProperties);
      for (var _i = 0, pages_2 = pages; _i < pages_2.length; _i++) {
        var page = pages_2[_i];
        pageElements.push(this._renderPage(page));
      }
      var finalOnRenderSurface = onRenderSurface ? composeRenderFunction(onRenderSurface, this._onRenderSurface) : this._onRenderSurface;
      var finalOnRenderRoot = onRenderRoot ? composeRenderFunction(onRenderRoot, this._onRenderRoot) : this._onRenderRoot;
      return finalOnRenderRoot({
        rootRef: this._root,
        pages,
        surfaceElement: finalOnRenderSurface({
          surfaceRef: this._surface,
          pages,
          pageElements,
          divProps: {
            role: "presentation",
            className: "ms-List-surface"
          }
        }),
        divProps: __assign$1(__assign$1({}, divProps), { className: css$3("ms-List", className), role: pageElements.length > 0 ? role : void 0, "aria-label": pageElements.length > 0 ? divProps["aria-label"] : void 0 })
      });
    };
    List2.prototype._shouldVirtualize = function(props) {
      if (props === void 0) {
        props = this.props;
      }
      var onShouldVirtualize = props.onShouldVirtualize;
      return !onShouldVirtualize || onShouldVirtualize(props);
    };
    List2.prototype._invalidatePageCache = function() {
      this._pageCache = {};
    };
    List2.prototype._renderPage = function(page) {
      var _this = this;
      var usePageCache = this.props.usePageCache;
      var cachedPage;
      if (usePageCache) {
        cachedPage = this._pageCache[page.key];
        if (cachedPage && cachedPage.pageElement) {
          return cachedPage.pageElement;
        }
      }
      var pageStyle = this._getPageStyle(page);
      var _a2 = this.props.onRenderPage, onRenderPage = _a2 === void 0 ? this._onRenderPage : _a2;
      var pageElement = onRenderPage({
        page,
        className: "ms-List-page",
        key: page.key,
        ref: function(newRef) {
          _this._pageRefs[page.key] = newRef;
        },
        style: pageStyle,
        role: "presentation"
      }, this._onRenderPage);
      if (usePageCache && page.startIndex === 0) {
        this._pageCache[page.key] = {
          page,
          pageElement
        };
      }
      return pageElement;
    };
    List2.prototype._getPageStyle = function(page) {
      var getPageStyle = this.props.getPageStyle;
      return __assign$1(__assign$1({}, getPageStyle ? getPageStyle(page) : {}), !page.items ? {
        height: page.height
      } : {});
    };
    List2.prototype._onFocus = function(ev) {
      var target = ev.target;
      while (target !== this._surface.current) {
        var indexString = target.getAttribute("data-list-index");
        if (indexString) {
          this._focusedIndex = Number(indexString);
          break;
        }
        target = getParent(target);
      }
    };
    List2.prototype._onScroll = function() {
      if (!this.state.isScrolling && !this.props.ignoreScrollingState) {
        this.setState({ isScrolling: true });
      }
      this._resetRequiredWindows();
      this._onScrollingDone();
    };
    List2.prototype._resetRequiredWindows = function() {
      this._requiredWindowsAhead = 0;
      this._requiredWindowsBehind = 0;
    };
    List2.prototype._onAsyncScroll = function() {
      this._updateRenderRects(this.props, this.state);
      if (!this._materializedRect || !_isContainedWithin(this._requiredRect, this._materializedRect)) {
        this.setState(this._updatePages(this.props, this.state));
      }
    };
    List2.prototype._onAsyncIdle = function() {
      var _a2 = this.props, renderedWindowsAhead = _a2.renderedWindowsAhead, renderedWindowsBehind = _a2.renderedWindowsBehind;
      var _b2 = this, requiredWindowsAhead = _b2._requiredWindowsAhead, requiredWindowsBehind = _b2._requiredWindowsBehind;
      var windowsAhead = Math.min(renderedWindowsAhead, requiredWindowsAhead + 1);
      var windowsBehind = Math.min(renderedWindowsBehind, requiredWindowsBehind + 1);
      if (windowsAhead !== requiredWindowsAhead || windowsBehind !== requiredWindowsBehind) {
        this._requiredWindowsAhead = windowsAhead;
        this._requiredWindowsBehind = windowsBehind;
        this._updateRenderRects(this.props, this.state);
        this.setState(this._updatePages(this.props, this.state));
      }
      if (renderedWindowsAhead > windowsAhead || renderedWindowsBehind > windowsBehind) {
        this._onAsyncIdle();
      }
    };
    List2.prototype._onScrollingDone = function() {
      if (!this.props.ignoreScrollingState) {
        this.setState({ isScrolling: false });
      }
    };
    List2.prototype._onAsyncResize = function() {
      this.forceUpdate();
    };
    List2.prototype._updatePages = function(nextProps, previousState) {
      if (!this._requiredRect) {
        this._updateRenderRects(nextProps, previousState);
      }
      var newListState = this._buildPages(nextProps, previousState);
      var oldListPages = previousState.pages;
      this._notifyPageChanges(oldListPages, newListState.pages, this.props);
      return __assign$1(__assign$1(__assign$1({}, previousState), newListState), { pagesVersion: {} });
    };
    List2.prototype._notifyPageChanges = function(oldPages, newPages, props) {
      var onPageAdded = props.onPageAdded, onPageRemoved = props.onPageRemoved;
      if (onPageAdded || onPageRemoved) {
        var renderedIndexes = {};
        for (var _i = 0, oldPages_1 = oldPages; _i < oldPages_1.length; _i++) {
          var page = oldPages_1[_i];
          if (page.items) {
            renderedIndexes[page.startIndex] = page;
          }
        }
        for (var _a2 = 0, newPages_1 = newPages; _a2 < newPages_1.length; _a2++) {
          var page = newPages_1[_a2];
          if (page.items) {
            if (!renderedIndexes[page.startIndex]) {
              this._onPageAdded(page);
            } else {
              delete renderedIndexes[page.startIndex];
            }
          }
        }
        for (var index2 in renderedIndexes) {
          if (renderedIndexes.hasOwnProperty(index2)) {
            this._onPageRemoved(renderedIndexes[index2]);
          }
        }
      }
    };
    List2.prototype._updatePageMeasurements = function(pages) {
      var heightChanged = false;
      if (!this._shouldVirtualize()) {
        return heightChanged;
      }
      for (var i = 0; i < pages.length; i++) {
        var page = pages[i];
        if (page.items) {
          heightChanged = this._measurePage(page) || heightChanged;
        }
      }
      return heightChanged;
    };
    List2.prototype._measurePage = function(page) {
      var hasChangedHeight = false;
      var pageElement = this._pageRefs[page.key];
      var cachedHeight = this._cachedPageHeights[page.startIndex];
      if (pageElement && this._shouldVirtualize() && (!cachedHeight || cachedHeight.measureVersion !== this._measureVersion)) {
        var newClientRect = {
          width: pageElement.clientWidth,
          height: pageElement.clientHeight
        };
        if (newClientRect.height || newClientRect.width) {
          hasChangedHeight = page.height !== newClientRect.height;
          page.height = newClientRect.height;
          this._cachedPageHeights[page.startIndex] = {
            height: newClientRect.height,
            measureVersion: this._measureVersion
          };
          this._estimatedPageHeight = Math.round((this._estimatedPageHeight * this._totalEstimates + newClientRect.height) / (this._totalEstimates + 1));
          this._totalEstimates++;
        }
      }
      return hasChangedHeight;
    };
    List2.prototype._onPageAdded = function(page) {
      var onPageAdded = this.props.onPageAdded;
      if (onPageAdded) {
        onPageAdded(page);
      }
    };
    List2.prototype._onPageRemoved = function(page) {
      var onPageRemoved = this.props.onPageRemoved;
      if (onPageRemoved) {
        onPageRemoved(page);
      }
    };
    List2.prototype._buildPages = function(props, state) {
      var renderCount = props.renderCount;
      var items = props.items, startIndex = props.startIndex, getPageHeight = props.getPageHeight;
      renderCount = this._getRenderCount(props);
      var materializedRect = __assign$1({}, EMPTY_RECT);
      var pages = [];
      var itemsPerPage = 1;
      var pageTop = 0;
      var currentSpacer = null;
      var focusedIndex = this._focusedIndex;
      var endIndex = startIndex + renderCount;
      var shouldVirtualize = this._shouldVirtualize(props);
      var isFirstRender = this._estimatedPageHeight === 0 && !getPageHeight;
      var allowedRect = this._allowedRect;
      var _loop_1 = function(itemIndex2) {
        var pageSpecification = this_1._getPageSpecification(props, itemIndex2, allowedRect);
        var pageHeight = pageSpecification.height;
        var pageData = pageSpecification.data;
        var key = pageSpecification.key;
        itemsPerPage = pageSpecification.itemCount;
        var pageBottom = pageTop + pageHeight - 1;
        var isPageRendered = findIndex(state.pages, function(page) {
          return !!page.items && page.startIndex === itemIndex2;
        }) > -1;
        var isPageInAllowedRange = !allowedRect || pageBottom >= allowedRect.top && pageTop <= allowedRect.bottom;
        var isPageInRequiredRange = !this_1._requiredRect || pageBottom >= this_1._requiredRect.top && pageTop <= this_1._requiredRect.bottom;
        var isPageVisible = !isFirstRender && (isPageInRequiredRange || isPageInAllowedRange && isPageRendered) || !shouldVirtualize;
        var isPageFocused = focusedIndex >= itemIndex2 && focusedIndex < itemIndex2 + itemsPerPage;
        var isFirstPage = itemIndex2 === startIndex;
        if (isPageVisible || isPageFocused || isFirstPage) {
          if (currentSpacer) {
            pages.push(currentSpacer);
            currentSpacer = null;
          }
          var itemsInPage = Math.min(itemsPerPage, endIndex - itemIndex2);
          var newPage = this_1._createPage(key, items.slice(itemIndex2, itemIndex2 + itemsInPage), itemIndex2, void 0, void 0, pageData);
          newPage.top = pageTop;
          newPage.height = pageHeight;
          if (this_1._visibleRect && this_1._visibleRect.bottom) {
            newPage.isVisible = pageBottom >= this_1._visibleRect.top && pageTop <= this_1._visibleRect.bottom;
          }
          pages.push(newPage);
          if (isPageInRequiredRange && this_1._allowedRect) {
            _mergeRect(materializedRect, {
              top: pageTop,
              bottom: pageBottom,
              height: pageHeight,
              left: allowedRect.left,
              right: allowedRect.right,
              width: allowedRect.width
            });
          }
        } else {
          if (!currentSpacer) {
            currentSpacer = this_1._createPage(
              SPACER_KEY_PREFIX + itemIndex2,
              void 0,
              itemIndex2,
              0,
              void 0,
              pageData,
              true
              /*isSpacer*/
            );
          }
          currentSpacer.height = (currentSpacer.height || 0) + (pageBottom - pageTop) + 1;
          currentSpacer.itemCount += itemsPerPage;
        }
        pageTop += pageBottom - pageTop + 1;
        if (isFirstRender && shouldVirtualize) {
          return "break";
        }
      };
      var this_1 = this;
      for (var itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {
        var state_1 = _loop_1(itemIndex);
        if (state_1 === "break")
          break;
      }
      if (currentSpacer) {
        currentSpacer.key = SPACER_KEY_PREFIX + "end";
        pages.push(currentSpacer);
      }
      this._materializedRect = materializedRect;
      return __assign$1(__assign$1({}, state), { pages, measureVersion: this._measureVersion });
    };
    List2.prototype._getPageSpecification = function(props, itemIndex, visibleRect) {
      var getPageSpecification = props.getPageSpecification;
      if (getPageSpecification) {
        var pageData = getPageSpecification(itemIndex, visibleRect);
        var _a2 = pageData.itemCount, itemCount = _a2 === void 0 ? this._getItemCountForPage(itemIndex, visibleRect) : _a2;
        var _b2 = pageData.height, height = _b2 === void 0 ? this._getPageHeight(itemIndex, visibleRect, itemCount) : _b2;
        return {
          itemCount,
          height,
          data: pageData.data,
          key: pageData.key
        };
      } else {
        var itemCount = this._getItemCountForPage(itemIndex, visibleRect);
        return {
          itemCount,
          height: this._getPageHeight(itemIndex, visibleRect, itemCount)
        };
      }
    };
    List2.prototype._getPageHeight = function(itemIndex, visibleRect, itemsPerPage) {
      if (this.props.getPageHeight) {
        return this.props.getPageHeight(itemIndex, visibleRect, itemsPerPage);
      } else {
        var cachedHeight = this._cachedPageHeights[itemIndex];
        return cachedHeight ? cachedHeight.height : this._estimatedPageHeight || DEFAULT_PAGE_HEIGHT;
      }
    };
    List2.prototype._getItemCountForPage = function(itemIndex, visibileRect) {
      var itemsPerPage = this.props.getItemCountForPage ? this.props.getItemCountForPage(itemIndex, visibileRect) : DEFAULT_ITEMS_PER_PAGE;
      return itemsPerPage ? itemsPerPage : DEFAULT_ITEMS_PER_PAGE;
    };
    List2.prototype._createPage = function(pageKey, items, startIndex, count, style, data, isSpacer) {
      if (startIndex === void 0) {
        startIndex = -1;
      }
      if (count === void 0) {
        count = items ? items.length : 0;
      }
      if (style === void 0) {
        style = {};
      }
      pageKey = pageKey || PAGE_KEY_PREFIX + startIndex;
      var cachedPage = this._pageCache[pageKey];
      if (cachedPage && cachedPage.page) {
        return cachedPage.page;
      }
      return {
        key: pageKey,
        startIndex,
        itemCount: count,
        items,
        style,
        top: 0,
        height: 0,
        data,
        isSpacer: isSpacer || false
      };
    };
    List2.prototype._getRenderCount = function(props) {
      var _a2 = props || this.props, items = _a2.items, startIndex = _a2.startIndex, renderCount = _a2.renderCount;
      return renderCount === void 0 ? items ? items.length - startIndex : 0 : renderCount;
    };
    List2.prototype._updateRenderRects = function(props, state, forceUpdate) {
      var renderedWindowsAhead = props.renderedWindowsAhead, renderedWindowsBehind = props.renderedWindowsBehind;
      var pages = state.pages;
      if (!this._shouldVirtualize(props)) {
        return;
      }
      var surfaceRect = this._surfaceRect || __assign$1({}, EMPTY_RECT);
      var scrollHeight = getScrollHeight(this._scrollElement);
      var scrollTop = getScrollYPosition(this._scrollElement);
      if (this._surface.current && (forceUpdate || !pages || !this._surfaceRect || !scrollHeight || scrollHeight !== this._scrollHeight || Math.abs(this._scrollTop - scrollTop) > this._estimatedPageHeight / 3)) {
        surfaceRect = this._surfaceRect = _measureSurfaceRect(this._surface.current);
        this._scrollTop = scrollTop;
      }
      if (forceUpdate || !scrollHeight || scrollHeight !== this._scrollHeight) {
        this._measureVersion++;
      }
      this._scrollHeight = scrollHeight || 0;
      var visibleTop = Math.max(0, -surfaceRect.top);
      var win2 = getWindow$1(this._root.current);
      var visibleRect = {
        top: visibleTop,
        left: surfaceRect.left,
        bottom: visibleTop + win2.innerHeight,
        right: surfaceRect.right,
        width: surfaceRect.width,
        height: win2.innerHeight
      };
      this._requiredRect = _expandRect(visibleRect, this._requiredWindowsBehind, this._requiredWindowsAhead);
      this._allowedRect = _expandRect(visibleRect, renderedWindowsBehind, renderedWindowsAhead);
      this._visibleRect = visibleRect;
    };
    List2.defaultProps = {
      startIndex: 0,
      onRenderCell: function(item, index2, containsFocus) {
        return React__namespace.createElement(React__namespace.Fragment, null, item && item.name || "");
      },
      onRenderCellConditional: void 0,
      renderedWindowsAhead: DEFAULT_RENDERED_WINDOWS_AHEAD$1,
      renderedWindowsBehind: DEFAULT_RENDERED_WINDOWS_BEHIND$1
    };
    return List2;
  }(React__namespace.Component)
);
function _expandRect(rect, pagesBefore, pagesAfter) {
  var top = rect.top - pagesBefore * rect.height;
  var height = rect.height + (pagesBefore + pagesAfter) * rect.height;
  return {
    top,
    bottom: top + height,
    height,
    left: rect.left,
    right: rect.right,
    width: rect.width
  };
}
function _isContainedWithin(innerRect, outerRect) {
  return innerRect.top >= outerRect.top && innerRect.left >= outerRect.left && innerRect.bottom <= outerRect.bottom && innerRect.right <= outerRect.right;
}
function _mergeRect(targetRect, newRect) {
  targetRect.top = newRect.top < targetRect.top || targetRect.top === -1 ? newRect.top : targetRect.top;
  targetRect.left = newRect.left < targetRect.left || targetRect.left === -1 ? newRect.left : targetRect.left;
  targetRect.bottom = newRect.bottom > targetRect.bottom || targetRect.bottom === -1 ? newRect.bottom : targetRect.bottom;
  targetRect.right = newRect.right > targetRect.right || targetRect.right === -1 ? newRect.right : targetRect.right;
  targetRect.width = targetRect.right - targetRect.left + 1;
  targetRect.height = targetRect.bottom - targetRect.top + 1;
  return targetRect;
}
var VirtualizedComboBox = (
  /** @class */
  function(_super) {
    __extends(VirtualizedComboBox2, _super);
    function VirtualizedComboBox2(props) {
      var _this = _super.call(this, props) || this;
      _this._comboBox = React__namespace.createRef();
      _this._list = React__namespace.createRef();
      _this._onRenderList = function(props2) {
        var id = props2.id, onRenderItem = props2.onRenderItem;
        return React__namespace.createElement(List, {
          componentRef: _this._list,
          role: "listbox",
          id: id + "-list",
          "aria-labelledby": id + "-label",
          items: props2.options,
          // eslint-disable-next-line react/jsx-no-bind
          onRenderCell: onRenderItem ? function(item) {
            return onRenderItem(item);
          } : function() {
            return null;
          }
        });
      };
      _this._onScrollToItem = function(itemIndex) {
        _this._list.current && _this._list.current.scrollToIndex(itemIndex);
      };
      initializeComponentRef(_this);
      return _this;
    }
    Object.defineProperty(VirtualizedComboBox2.prototype, "selectedOptions", {
      /**
       * All selected options
       */
      get: function() {
        if (this._comboBox.current) {
          return this._comboBox.current.selectedOptions;
        }
        return [];
      },
      enumerable: false,
      configurable: true
    });
    VirtualizedComboBox2.prototype.dismissMenu = function() {
      if (this._comboBox.current) {
        return this._comboBox.current.dismissMenu();
      }
    };
    VirtualizedComboBox2.prototype.focus = function(shouldOpenOnFocus, useFocusAsync) {
      if (this._comboBox.current) {
        this._comboBox.current.focus(shouldOpenOnFocus, useFocusAsync);
        return true;
      }
      return false;
    };
    VirtualizedComboBox2.prototype.render = function() {
      return React__namespace.createElement(ComboBox, __assign$1({}, this.props, { componentRef: this._comboBox, onRenderList: this._onRenderList, onScrollToItem: this._onScrollToItem }));
    };
    return VirtualizedComboBox2;
  }(React__namespace.Component)
);
var COMMAND_BAR_HEIGHT = 44;
var getStyles$p = function(props) {
  var className = props.className, theme = props.theme;
  var semanticColors = theme.semanticColors;
  return {
    root: [
      theme.fonts.medium,
      "ms-CommandBar",
      {
        display: "flex",
        backgroundColor: semanticColors.bodyBackground,
        padding: "0 14px 0 24px",
        height: COMMAND_BAR_HEIGHT
      },
      className
    ],
    primarySet: [
      "ms-CommandBar-primaryCommand",
      {
        flexGrow: "1",
        display: "flex",
        alignItems: "stretch"
      }
    ],
    secondarySet: [
      "ms-CommandBar-secondaryCommand",
      {
        flexShrink: "0",
        display: "flex",
        alignItems: "stretch"
      }
    ]
  };
};
var getCommandButtonStyles = memoizeFunction(function(customStyles) {
  var rootStyles = {
    height: "100%"
  };
  var labelStyles = {
    whiteSpace: "nowrap"
  };
  var _a2 = customStyles || {}, root2 = _a2.root, label = _a2.label, restCustomStyles = __rest$1(_a2, ["root", "label"]);
  return __assign$1(__assign$1({}, restCustomStyles), { root: root2 ? [rootStyles, root2] : rootStyles, label: label ? [labelStyles, label] : labelStyles });
});
var registerPersistedKeytips = function(keytipsToRegister, keytipManager, registeredPersistedKeytips) {
  for (var _i = 0, keytipsToRegister_1 = keytipsToRegister; _i < keytipsToRegister_1.length; _i++) {
    var keytip = keytipsToRegister_1[_i];
    var uniqueID = keytipManager.register(keytip, true);
    registeredPersistedKeytips[uniqueID] = keytip;
  }
};
var unregisterPersistedKeytips = function(keytipManager, registeredPersistedKeytips) {
  for (var _i = 0, _a2 = Object.keys(registeredPersistedKeytips); _i < _a2.length; _i++) {
    var uniqueID = _a2[_i];
    keytipManager.unregister(registeredPersistedKeytips[uniqueID], uniqueID, true);
    delete registeredPersistedKeytips[uniqueID];
  }
};
var useKeytipRegistrations = function(registeredPersistedKeytips, keytipsToRegister, keytipManager) {
  var prevPersistedKeytips = usePrevious(registeredPersistedKeytips);
  React__namespace.useEffect(function() {
    if (prevPersistedKeytips) {
      unregisterPersistedKeytips(keytipManager, prevPersistedKeytips);
      registerPersistedKeytips(keytipsToRegister, keytipManager, registeredPersistedKeytips);
    }
  });
  React__namespace.useEffect(function() {
    registerPersistedKeytips(keytipsToRegister, keytipManager, registeredPersistedKeytips);
    return function() {
      unregisterPersistedKeytips(keytipManager, registeredPersistedKeytips);
    };
  }, []);
};
var OverflowButton = function(props) {
  var keytipManager = KeytipManager.getInstance();
  var className = props.className, overflowItems = props.overflowItems, keytipSequences = props.keytipSequences, itemSubMenuProvider = props.itemSubMenuProvider, onRenderOverflowButton = props.onRenderOverflowButton;
  var persistedKeytips = useConst({});
  var getSubMenuForItem = React__namespace.useCallback(function(item) {
    if (itemSubMenuProvider) {
      return itemSubMenuProvider(item);
    }
    if (item.subMenuProps) {
      return item.subMenuProps.items;
    }
    return void 0;
  }, [itemSubMenuProvider]);
  var _a2 = React__namespace.useMemo(function() {
    var newKeytipsToRegister = [];
    var newOverflowItems = [];
    if (keytipSequences) {
      overflowItems === null || overflowItems === void 0 ? void 0 : overflowItems.forEach(function(overflowItem) {
        var _a3;
        var keytip = overflowItem.keytipProps;
        if (keytip) {
          var persistedKeytip = {
            content: keytip.content,
            keySequences: keytip.keySequences,
            disabled: keytip.disabled || !!(overflowItem.disabled || overflowItem.isDisabled),
            hasDynamicChildren: keytip.hasDynamicChildren,
            hasMenu: keytip.hasMenu
          };
          if (keytip.hasDynamicChildren || getSubMenuForItem(overflowItem)) {
            persistedKeytip.onExecute = keytipManager.menuExecute.bind(keytipManager, keytipSequences, (_a3 = overflowItem === null || overflowItem === void 0 ? void 0 : overflowItem.keytipProps) === null || _a3 === void 0 ? void 0 : _a3.keySequences);
            persistedKeytip.hasOverflowSubMenu = true;
          } else {
            persistedKeytip.onExecute = keytip.onExecute;
          }
          newKeytipsToRegister.push(persistedKeytip);
          var newOverflowItem = __assign$1(__assign$1({}, overflowItem), { keytipProps: __assign$1(__assign$1({}, keytip), { overflowSetSequence: keytipSequences }) });
          newOverflowItems === null || newOverflowItems === void 0 ? void 0 : newOverflowItems.push(newOverflowItem);
        } else {
          newOverflowItems === null || newOverflowItems === void 0 ? void 0 : newOverflowItems.push(overflowItem);
        }
      });
    } else {
      newOverflowItems = overflowItems;
    }
    return { modifiedOverflowItems: newOverflowItems, keytipsToRegister: newKeytipsToRegister };
  }, [overflowItems, getSubMenuForItem, keytipManager, keytipSequences]), modifiedOverflowItems = _a2.modifiedOverflowItems, keytipsToRegister = _a2.keytipsToRegister;
  useKeytipRegistrations(persistedKeytips, keytipsToRegister, keytipManager);
  return React__namespace.createElement("div", { className }, onRenderOverflowButton(modifiedOverflowItems));
};
var getClassNames$w = classNamesFunction();
var COMPONENT_NAME$6 = "OverflowSet";
var useComponentRef$2 = function(props, divContainer) {
  React__namespace.useImperativeHandle(props.componentRef, function() {
    return {
      focus: function(_forceIntoFirstElement, bypassHiddenElements) {
        var focusSucceeded = false;
        if (divContainer.current) {
          focusSucceeded = focusFirstChild(divContainer.current, bypassHiddenElements);
        }
        return focusSucceeded;
      },
      focusElement: function(childElement) {
        var focusSucceeded = false;
        if (!childElement) {
          return false;
        }
        if (divContainer.current && elementContains(divContainer.current, childElement)) {
          childElement.focus();
          focusSucceeded = document.activeElement === childElement;
        }
        return focusSucceeded;
      }
    };
  }, [divContainer]);
};
var OverflowSetBase = React__namespace.forwardRef(function(props, forwardedRef) {
  var divContainer = React__namespace.useRef(null);
  var mergedRef = useMergedRefs(divContainer, forwardedRef);
  useComponentRef$2(props, divContainer);
  var items = props.items, overflowItems = props.overflowItems, className = props.className, styles2 = props.styles, vertical = props.vertical, role = props.role, _a2 = props.overflowSide, overflowSide = _a2 === void 0 ? "end" : _a2, onRenderItem = props.onRenderItem;
  var classNames2 = getClassNames$w(styles2, { className, vertical });
  var showOverflow = !!overflowItems && overflowItems.length > 0;
  return React__namespace.createElement(
    "div",
    __assign$1({}, getNativeProps(props, divProperties), { role: role || "group", "aria-orientation": role === "menubar" ? vertical === true ? "vertical" : "horizontal" : void 0, className: classNames2.root, ref: mergedRef }),
    overflowSide === "start" && showOverflow && React__namespace.createElement(OverflowButton, __assign$1({}, props, { className: classNames2.overflowButton })),
    items && items.map(function(item, i) {
      return React__namespace.createElement("div", { className: classNames2.item, key: item.key, role: "none" }, onRenderItem(item));
    }),
    overflowSide === "end" && showOverflow && React__namespace.createElement(OverflowButton, __assign$1({}, props, { className: classNames2.overflowButton }))
  );
});
OverflowSetBase.displayName = COMPONENT_NAME$6;
var overflowItemStyle = {
  flexShrink: 0,
  display: "inherit"
};
var getStyles$o = function(props) {
  var className = props.className, vertical = props.vertical;
  return {
    root: [
      "ms-OverflowSet",
      {
        position: "relative",
        display: "flex",
        flexWrap: "nowrap"
      },
      vertical && { flexDirection: "column" },
      className
    ],
    item: ["ms-OverflowSet-item", overflowItemStyle],
    overflowButton: ["ms-OverflowSet-overflowButton", overflowItemStyle]
  };
};
var OverflowSet = styled(OverflowSetBase, getStyles$o, void 0, {
  scope: "OverflowSet"
});
var getClassNames$v = classNamesFunction();
var CommandBarBase = (
  /** @class */
  function(_super) {
    __extends(CommandBarBase2, _super);
    function CommandBarBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._overflowSet = React__namespace.createRef();
      _this._resizeGroup = React__namespace.createRef();
      _this._onRenderData = function(data) {
        var _a2 = _this.props, ariaLabel = _a2.ariaLabel, primaryGroupAriaLabel = _a2.primaryGroupAriaLabel, farItemsGroupAriaLabel = _a2.farItemsGroupAriaLabel;
        var hasSecondSet = data.farItems && data.farItems.length > 0;
        return React__namespace.createElement(
          FocusZone,
          { className: css$3(_this._classNames.root), direction: FocusZoneDirection.horizontal, role: "menubar", "aria-label": ariaLabel },
          React__namespace.createElement(OverflowSet, { role: hasSecondSet ? "group" : "none", "aria-label": hasSecondSet ? primaryGroupAriaLabel : void 0, componentRef: _this._overflowSet, className: css$3(_this._classNames.primarySet), items: data.primaryItems, overflowItems: data.overflowItems.length ? data.overflowItems : void 0, onRenderItem: _this._onRenderItem, onRenderOverflowButton: _this._onRenderOverflowButton }),
          hasSecondSet && React__namespace.createElement(OverflowSet, { role: "group", "aria-label": farItemsGroupAriaLabel, className: css$3(_this._classNames.secondarySet), items: data.farItems, onRenderItem: _this._onRenderItem, onRenderOverflowButton: nullRender })
        );
      };
      _this._onRenderItem = function(item) {
        if (item.onRender) {
          return item.onRender(item, function() {
            return void 0;
          });
        }
        var itemText = item.text || item.name;
        var commandButtonProps = __assign$1(__assign$1({ allowDisabledFocus: true, role: "menuitem" }, item), { styles: getCommandButtonStyles(item.buttonStyles), className: css$3("ms-CommandBarItem-link", item.className), text: !item.iconOnly ? itemText : void 0, menuProps: item.subMenuProps, onClick: _this._onButtonClick(item) });
        if (item.iconOnly && (itemText !== void 0 || item.tooltipHostProps)) {
          return React__namespace.createElement(TooltipHost, __assign$1({ role: "none", content: itemText, setAriaDescribedBy: false }, item.tooltipHostProps), _this._commandButton(item, commandButtonProps));
        }
        return _this._commandButton(item, commandButtonProps);
      };
      _this._commandButton = function(item, props2) {
        var ButtonAs = _this.props.buttonAs;
        var CommandBarButtonAs = item.commandBarButtonAs;
        var DefaultButtonAs = CommandBarButton;
        var Type = DefaultButtonAs;
        if (CommandBarButtonAs) {
          Type = composeComponentAs(CommandBarButtonAs, Type);
        }
        if (ButtonAs) {
          Type = composeComponentAs(ButtonAs, Type);
        }
        return React__namespace.createElement(Type, __assign$1({}, props2));
      };
      _this._onRenderOverflowButton = function(overflowItems) {
        var _a2 = _this.props.overflowButtonProps, overflowButtonProps = _a2 === void 0 ? {} : _a2;
        var combinedOverflowItems = __spreadArray(__spreadArray([], overflowButtonProps.menuProps ? overflowButtonProps.menuProps.items : []), overflowItems);
        var overflowProps = __assign$1(__assign$1({ role: "menuitem" }, overflowButtonProps), { styles: __assign$1({ menuIcon: { fontSize: "17px" } }, overflowButtonProps.styles), className: css$3("ms-CommandBar-overflowButton", overflowButtonProps.className), menuProps: __assign$1(__assign$1({}, overflowButtonProps.menuProps), { items: combinedOverflowItems }), menuIconProps: __assign$1({ iconName: "More" }, overflowButtonProps.menuIconProps) });
        var OverflowButtonType = _this.props.overflowButtonAs ? composeComponentAs(_this.props.overflowButtonAs, CommandBarButton) : CommandBarButton;
        return React__namespace.createElement(OverflowButtonType, __assign$1({}, overflowProps));
      };
      _this._onReduceData = function(data) {
        var _a2 = _this.props, shiftOnReduce = _a2.shiftOnReduce, onDataReduced = _a2.onDataReduced;
        var primaryItems = data.primaryItems, overflowItems = data.overflowItems, cacheKey = data.cacheKey;
        var farItems = data.farItems;
        var movedItem = primaryItems[shiftOnReduce ? 0 : primaryItems.length - 1];
        if (movedItem !== void 0) {
          movedItem.renderedInOverflow = true;
          overflowItems = __spreadArray([movedItem], overflowItems);
          primaryItems = shiftOnReduce ? primaryItems.slice(1) : primaryItems.slice(0, -1);
          var newData = __assign$1(__assign$1({}, data), { primaryItems, overflowItems });
          cacheKey = _this._computeCacheKey({ primaryItems, overflow: overflowItems.length > 0, farItems });
          if (onDataReduced) {
            onDataReduced(movedItem);
          }
          newData.cacheKey = cacheKey;
          return newData;
        }
        return void 0;
      };
      _this._onGrowData = function(data) {
        var _a2 = _this.props, shiftOnReduce = _a2.shiftOnReduce, onDataGrown = _a2.onDataGrown;
        var minimumOverflowItems = data.minimumOverflowItems;
        var primaryItems = data.primaryItems, overflowItems = data.overflowItems, cacheKey = data.cacheKey;
        var farItems = data.farItems;
        var movedItem = overflowItems[0];
        if (movedItem !== void 0 && overflowItems.length > minimumOverflowItems) {
          movedItem.renderedInOverflow = false;
          overflowItems = overflowItems.slice(1);
          primaryItems = shiftOnReduce ? __spreadArray([movedItem], primaryItems) : __spreadArray(__spreadArray([], primaryItems), [movedItem]);
          var newData = __assign$1(__assign$1({}, data), { primaryItems, overflowItems });
          cacheKey = _this._computeCacheKey({ primaryItems, overflow: overflowItems.length > 0, farItems });
          if (onDataGrown) {
            onDataGrown(movedItem);
          }
          newData.cacheKey = cacheKey;
          return newData;
        }
        return void 0;
      };
      initializeComponentRef(_this);
      return _this;
    }
    CommandBarBase2.prototype.render = function() {
      var _a2 = this.props, items = _a2.items, overflowItems = _a2.overflowItems, farItems = _a2.farItems, styles2 = _a2.styles, theme = _a2.theme, dataDidRender = _a2.dataDidRender, _b2 = _a2.onReduceData, onReduceData = _b2 === void 0 ? this._onReduceData : _b2, _c2 = _a2.onGrowData, onGrowData = _c2 === void 0 ? this._onGrowData : _c2, _d2 = _a2.resizeGroupAs, ResizeGroupAs = _d2 === void 0 ? ResizeGroup : _d2;
      var commandBarData = {
        primaryItems: __spreadArray([], items),
        overflowItems: __spreadArray([], overflowItems),
        minimumOverflowItems: __spreadArray([], overflowItems).length,
        farItems,
        cacheKey: this._computeCacheKey({
          primaryItems: __spreadArray([], items),
          overflow: overflowItems && overflowItems.length > 0,
          farItems
        })
      };
      this._classNames = getClassNames$v(styles2, { theme });
      var nativeProps = getNativeProps(this.props, divProperties);
      return React__namespace.createElement(ResizeGroupAs, __assign$1({}, nativeProps, { componentRef: this._resizeGroup, data: commandBarData, onReduceData, onGrowData, onRenderData: this._onRenderData, dataDidRender }));
    };
    CommandBarBase2.prototype.focus = function() {
      var overflowSet = this._overflowSet.current;
      overflowSet && overflowSet.focus();
    };
    CommandBarBase2.prototype.remeasure = function() {
      this._resizeGroup.current && this._resizeGroup.current.remeasure();
    };
    CommandBarBase2.prototype._onButtonClick = function(item) {
      return function(ev) {
        if (item.inactive) {
          return;
        }
        if (item.onClick) {
          item.onClick(ev, item);
        }
      };
    };
    CommandBarBase2.prototype._computeCacheKey = function(data) {
      var primaryItems = data.primaryItems, overflow = data.overflow, farItems = data.farItems;
      var returnKey = function(acc, current) {
        var _a2 = current.cacheKey, cacheKey = _a2 === void 0 ? current.key : _a2;
        return acc + cacheKey;
      };
      var primaryKey = primaryItems && primaryItems.reduce(returnKey, "");
      var overflowKey = overflow ? "overflow" : "";
      var farKey = farItems && farItems.reduce(returnKey, "");
      return [primaryKey, overflowKey, farKey].join("");
    };
    CommandBarBase2.defaultProps = {
      items: [],
      overflowItems: []
    };
    return CommandBarBase2;
  }(React__namespace.Component)
);
var CommandBar = styled(CommandBarBase, getStyles$p, void 0, {
  scope: "CommandBar"
});
var defaultDatePickerStrings = __assign$1(__assign$1({}, defaultCalendarStrings), { prevMonthAriaLabel: "Go to previous month", nextMonthAriaLabel: "Go to next month", prevYearAriaLabel: "Go to previous year", nextYearAriaLabel: "Go to next year", closeButtonAriaLabel: "Close date picker", isRequiredErrorMessage: "Field is required", invalidInputErrorMessage: "Invalid date format", isResetStatusMessage: 'Invalid entry "{0}", date reset to "{1}"' });
var getClassNames$u = classNamesFunction();
var DEFAULT_PROPS$3 = {
  allowTextInput: false,
  formatDate: function(date) {
    return date ? date.toDateString() : "";
  },
  parseDateFromString: function(dateStr) {
    if (dateStr.match(/^\d{4}(-\d{2}){2}$/)) {
      dateStr += "T12:00";
    }
    var date = Date.parse(dateStr);
    return date ? new Date(date) : null;
  },
  firstDayOfWeek: DayOfWeek.Sunday,
  initialPickerDate: /* @__PURE__ */ new Date(),
  isRequired: false,
  isMonthPickerVisible: true,
  showMonthPickerAsOverlay: false,
  strings: defaultDatePickerStrings,
  highlightCurrentMonth: false,
  highlightSelectedMonth: false,
  borderless: false,
  pickerAriaLabel: "Calendar",
  showWeekNumbers: false,
  firstWeekOfYear: FirstWeekOfYear.FirstDay,
  showGoToToday: true,
  showCloseButton: false,
  underlined: false,
  allFocusable: false
};
function useFocusLogic() {
  var textFieldRef = React__namespace.useRef(null);
  var preventFocusOpeningPicker = React__namespace.useRef(false);
  var focus = function() {
    var _a2, _b2;
    (_b2 = (_a2 = textFieldRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
  };
  var preventNextFocusOpeningPicker = function() {
    preventFocusOpeningPicker.current = true;
  };
  return [textFieldRef, focus, preventFocusOpeningPicker, preventNextFocusOpeningPicker];
}
function useCalendarVisibility(_a2, focus) {
  var allowTextInput = _a2.allowTextInput, onAfterMenuDismiss = _a2.onAfterMenuDismiss;
  var _b2 = React__namespace.useState(false), isCalendarShown = _b2[0], setIsCalendarShown = _b2[1];
  var isMounted = React__namespace.useRef(false);
  var async = useAsync();
  React__namespace.useEffect(function() {
    if (isMounted.current && !isCalendarShown) {
      if (allowTextInput) {
        async.requestAnimationFrame(focus);
      }
      onAfterMenuDismiss === null || onAfterMenuDismiss === void 0 ? void 0 : onAfterMenuDismiss();
    }
    isMounted.current = true;
  }, [isCalendarShown]);
  return [isCalendarShown, setIsCalendarShown];
}
function useSelectedDate(_a2) {
  var formatDate = _a2.formatDate, value = _a2.value, onSelectDate = _a2.onSelectDate;
  var _b2 = useControllableValue(value, void 0, function(ev, newValue) {
    return onSelectDate === null || onSelectDate === void 0 ? void 0 : onSelectDate(newValue);
  }), selectedDate = _b2[0], setSelectedDateState = _b2[1];
  var _c2 = React__namespace.useState(function() {
    return value && formatDate ? formatDate(value) : "";
  }), formattedDate = _c2[0], setFormattedDate = _c2[1];
  var setSelectedDate = function(newDate) {
    setSelectedDateState(newDate);
    setFormattedDate(newDate && formatDate ? formatDate(newDate) : "");
  };
  React__namespace.useEffect(function() {
    setFormattedDate(value && formatDate ? formatDate(value) : "");
  }, [formatDate, value]);
  return [selectedDate, formattedDate, setSelectedDate, setFormattedDate];
}
function useErrorMessage(_a2, selectedDate, setSelectedDate, inputValue, isCalendarShown) {
  var _b2;
  var isRequired = _a2.isRequired, allowTextInput = _a2.allowTextInput, strings = _a2.strings, parseDateFromString = _a2.parseDateFromString, onSelectDate = _a2.onSelectDate, formatDate = _a2.formatDate, minDate = _a2.minDate, maxDate = _a2.maxDate, textField = _a2.textField;
  var _c2 = React__namespace.useState(), errorMessage = _c2[0], setErrorMessage = _c2[1];
  var _d2 = React__namespace.useState(), statusMessage = _d2[0], setStatusMessage = _d2[1];
  var isFirstLoadRef = React__namespace.useRef(true);
  var validateOnLoad = (_b2 = textField === null || textField === void 0 ? void 0 : textField.validateOnLoad) !== null && _b2 !== void 0 ? _b2 : true;
  var validateTextInput = function(date) {
    if (date === void 0) {
      date = null;
    }
    if (allowTextInput) {
      if (inputValue || date) {
        if (selectedDate && !errorMessage && formatDate && formatDate(date !== null && date !== void 0 ? date : selectedDate) === inputValue) {
          return;
        }
        date = date || parseDateFromString(inputValue);
        if (!date || isNaN(date.getTime())) {
          setSelectedDate(selectedDate);
          var selectedText = formatDate ? formatDate(selectedDate) : "";
          var statusText = strings.isResetStatusMessage ? format$1(strings.isResetStatusMessage, inputValue, selectedText) : strings.invalidInputErrorMessage || "";
          setStatusMessage(statusText);
        } else {
          if (isDateOutOfBounds(date, minDate, maxDate)) {
            setErrorMessage(strings.isOutOfBoundsErrorMessage || " ");
          } else {
            setSelectedDate(date);
            setErrorMessage(void 0);
            setStatusMessage(void 0);
          }
        }
      } else {
        setErrorMessage(isRequired ? strings.isRequiredErrorMessage || " " : void 0);
        onSelectDate === null || onSelectDate === void 0 ? void 0 : onSelectDate(date);
      }
    } else if (isRequired && !inputValue) {
      setErrorMessage(strings.isRequiredErrorMessage || " ");
    } else {
      setErrorMessage(void 0);
      setStatusMessage(void 0);
    }
  };
  React__namespace.useEffect(function() {
    if (isFirstLoadRef.current) {
      isFirstLoadRef.current = false;
      if (!validateOnLoad) {
        return;
      }
    }
    if (isRequired && !selectedDate) {
      setErrorMessage(strings.isRequiredErrorMessage || " ");
    } else if (selectedDate && isDateOutOfBounds(selectedDate, minDate, maxDate)) {
      setErrorMessage(strings.isOutOfBoundsErrorMessage || " ");
    } else {
      setErrorMessage(void 0);
    }
  }, [
    // We don't want to compare the date itself, since two instances of date at the same time are not equal
    // eslint-disable-next-line react-hooks/exhaustive-deps
    minDate && getDatePartHashValue(minDate),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    maxDate && getDatePartHashValue(maxDate),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    selectedDate && getDatePartHashValue(selectedDate),
    isRequired,
    validateOnLoad
  ]);
  return [
    isCalendarShown ? void 0 : errorMessage,
    validateTextInput,
    setErrorMessage,
    isCalendarShown ? void 0 : statusMessage,
    setStatusMessage
  ];
}
var DatePickerBase = React__namespace.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var _a2, _b2, _c2;
  var props = getPropsWithDefaults(DEFAULT_PROPS$3, propsWithoutDefaults);
  var firstDayOfWeek = props.firstDayOfWeek, strings = props.strings, label = props.label, theme = props.theme, className = props.className, styles2 = props.styles, initialPickerDate = props.initialPickerDate, isRequired = props.isRequired, disabled = props.disabled, ariaLabel = props.ariaLabel, pickerAriaLabel = props.pickerAriaLabel, placeholder = props.placeholder, allowTextInput = props.allowTextInput, borderless = props.borderless, minDate = props.minDate, maxDate = props.maxDate, showCloseButton = props.showCloseButton, calendarProps = props.calendarProps, calloutProps = props.calloutProps, textFieldProps = props.textField, underlined = props.underlined, allFocusable = props.allFocusable, _d2 = props.calendarAs, CalendarType = _d2 === void 0 ? Calendar : _d2, tabIndex = props.tabIndex, _e2 = props.disableAutoFocus, disableAutoFocus = _e2 === void 0 ? true : _e2;
  var id = useId("DatePicker", props.id);
  var calloutId = useId("DatePicker-Callout");
  var calendar = React__namespace.useRef(null);
  var datePickerDiv = React__namespace.useRef(null);
  var _f = useFocusLogic(), textFieldRef = _f[0], focus = _f[1], preventFocusOpeningPicker = _f[2], preventNextFocusOpeningPicker = _f[3];
  var _g = useCalendarVisibility(props, focus), isCalendarShown = _g[0], setIsCalendarShown = _g[1];
  var _h = useSelectedDate(props), selectedDate = _h[0], formattedDate = _h[1], setSelectedDate = _h[2], setFormattedDate = _h[3];
  var _j = useErrorMessage(props, selectedDate, setSelectedDate, formattedDate, isCalendarShown), errorMessage = _j[0], validateTextInput = _j[1], setErrorMessage = _j[2], statusMessage = _j[3], setStatusMessage = _j[4];
  var showDatePickerPopup = React__namespace.useCallback(function() {
    if (!isCalendarShown) {
      preventNextFocusOpeningPicker();
      setIsCalendarShown(true);
    }
  }, [isCalendarShown, preventNextFocusOpeningPicker, setIsCalendarShown]);
  React__namespace.useImperativeHandle(props.componentRef, function() {
    return {
      focus,
      reset: function() {
        setIsCalendarShown(false);
        setSelectedDate(void 0);
        setErrorMessage(void 0);
        setStatusMessage(void 0);
      },
      showDatePickerPopup
    };
  }, [focus, setErrorMessage, setIsCalendarShown, setSelectedDate, setStatusMessage, showDatePickerPopup]);
  var onTextFieldFocus = function() {
    if (disableAutoFocus) {
      return;
    }
    if (!allowTextInput) {
      if (!preventFocusOpeningPicker.current) {
        showDatePickerPopup();
      }
      preventFocusOpeningPicker.current = false;
    }
  };
  var onSelectDate = function(date) {
    if (props.calendarProps && props.calendarProps.onSelectDate) {
      props.calendarProps.onSelectDate(date);
    }
    calendarDismissed(date);
  };
  var onCalloutPositioned = function() {
    var shouldFocus = true;
    if (props.calloutProps && props.calloutProps.setInitialFocus !== void 0) {
      shouldFocus = props.calloutProps.setInitialFocus;
    }
    if (calendar.current && shouldFocus) {
      calendar.current.focus();
    }
  };
  var onTextFieldBlur = function(ev) {
    validateTextInput();
  };
  var onTextFieldChanged = function(ev, newValue) {
    var _a3;
    var textField = props.textField;
    if (allowTextInput) {
      if (isCalendarShown) {
        dismissDatePickerPopup();
      }
      setFormattedDate(newValue);
    }
    (_a3 = textField === null || textField === void 0 ? void 0 : textField.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(textField, ev, newValue);
  };
  var onTextFieldKeyDown = function(ev) {
    switch (ev.which) {
      case KeyCodes.enter:
        ev.preventDefault();
        ev.stopPropagation();
        if (!isCalendarShown) {
          validateTextInput();
          showDatePickerPopup();
        } else {
          if (props.allowTextInput) {
            dismissDatePickerPopup();
          }
        }
        break;
      case KeyCodes.escape:
        handleEscKey(ev);
        break;
      case KeyCodes.down:
        if (ev.altKey && !isCalendarShown) {
          showDatePickerPopup();
        }
        break;
    }
  };
  var onTextFieldClick = function(ev) {
    var openOnClick = props.openOnClick || !props.disableAutoFocus;
    if (openOnClick && !isCalendarShown && !props.disabled) {
      showDatePickerPopup();
      return;
    }
    if (props.allowTextInput) {
      dismissDatePickerPopup();
    }
  };
  var onIconClick = function(ev) {
    ev.stopPropagation();
    if (!isCalendarShown && !props.disabled) {
      showDatePickerPopup();
    } else if (props.allowTextInput) {
      dismissDatePickerPopup();
    }
  };
  var dismissDatePickerPopup = function(newlySelectedDate) {
    if (isCalendarShown) {
      setIsCalendarShown(false);
      validateTextInput(newlySelectedDate);
      if (!allowTextInput && newlySelectedDate) {
        setSelectedDate(newlySelectedDate);
      }
    }
  };
  var renderTextfieldDescription = function(inputProps, defaultRender) {
    return React__namespace.createElement(
      React__namespace.Fragment,
      null,
      inputProps.description ? defaultRender(inputProps) : null,
      React__namespace.createElement("div", { "aria-live": "assertive", className: classNames2.statusMessage }, statusMessage)
    );
  };
  var renderReadOnlyInput = function(inputProps) {
    var divProps = getNativeProps(inputProps, divProperties);
    return React__namespace.createElement("div", __assign$1({}, divProps, { className: css$3(divProps.className, classNames2.readOnlyTextField), tabIndex: tabIndex || 0 }), formattedDate || // Putting the placeholder in a separate span fixes specificity issues for the text color
    React__namespace.createElement("span", { className: classNames2.readOnlyPlaceholder }, placeholder));
  };
  var calendarDismissed = function(newlySelectedDate) {
    preventNextFocusOpeningPicker();
    dismissDatePickerPopup(newlySelectedDate);
  };
  var calloutDismissed = function(ev) {
    calendarDismissed();
  };
  var handleEscKey = function(ev) {
    if (isCalendarShown) {
      ev.stopPropagation();
      calendarDismissed();
    }
  };
  var onCalendarDismissed = function(ev) {
    calendarDismissed();
  };
  var classNames2 = getClassNames$u(styles2, {
    theme,
    className,
    disabled,
    underlined,
    label: !!label,
    isDatePickerShown: isCalendarShown
  });
  var nativeProps = getNativeProps(props, divProperties, ["value"]);
  var iconProps = textFieldProps && textFieldProps.iconProps;
  var textFieldId = textFieldProps && textFieldProps.id && textFieldProps.id !== id ? textFieldProps.id : id + "-label";
  var readOnly = !allowTextInput && !disabled;
  var dataIsFocusable = (_c2 = (_b2 = (_a2 = textFieldProps) === null || _a2 === void 0 ? void 0 : _a2["data-is-focusable"]) !== null && _b2 !== void 0 ? _b2 : props["data-is-focusable"]) !== null && _c2 !== void 0 ? _c2 : true;
  return React__namespace.createElement(
    "div",
    __assign$1({}, nativeProps, { className: classNames2.root, ref: forwardedRef }),
    React__namespace.createElement(
      "div",
      { ref: datePickerDiv, "aria-owns": isCalendarShown ? calloutId : void 0, className: classNames2.wrapper },
      React__namespace.createElement(TextField, __assign$1({ role: "combobox", label, "aria-expanded": isCalendarShown, ariaLabel, "aria-haspopup": "dialog", "aria-controls": isCalendarShown ? calloutId : void 0, required: isRequired, disabled, errorMessage, placeholder, borderless, value: formattedDate, componentRef: textFieldRef, underlined, tabIndex, readOnly: !allowTextInput }, textFieldProps, {
        "data-is-focusable": dataIsFocusable,
        id: textFieldId,
        className: css$3(classNames2.textField, textFieldProps && textFieldProps.className),
        iconProps: __assign$1(__assign$1({ iconName: "Calendar" }, iconProps), { className: css$3(classNames2.icon, iconProps && iconProps.className), onClick: onIconClick }),
        // eslint-disable-next-line react/jsx-no-bind
        onRenderDescription: renderTextfieldDescription,
        // eslint-disable-next-line react/jsx-no-bind
        onKeyDown: onTextFieldKeyDown,
        // eslint-disable-next-line react/jsx-no-bind
        onFocus: onTextFieldFocus,
        // eslint-disable-next-line react/jsx-no-bind
        onBlur: onTextFieldBlur,
        // eslint-disable-next-line react/jsx-no-bind
        onClick: onTextFieldClick,
        // eslint-disable-next-line react/jsx-no-bind
        onChange: onTextFieldChanged,
        onRenderInput: readOnly ? renderReadOnlyInput : void 0
      }))
    ),
    isCalendarShown && React__namespace.createElement(
      Callout,
      __assign$1({ id: calloutId, role: "dialog", ariaLabel: pickerAriaLabel, isBeakVisible: false, gapSpace: 0, doNotLayer: false, target: datePickerDiv.current, directionalHint: DirectionalHint.bottomLeftEdge }, calloutProps, {
        className: css$3(classNames2.callout, calloutProps && calloutProps.className),
        // eslint-disable-next-line react/jsx-no-bind
        onDismiss: calloutDismissed,
        // eslint-disable-next-line react/jsx-no-bind
        onPositioned: onCalloutPositioned
      }),
      React__namespace.createElement(
        FocusTrapZone,
        { isClickableOutsideFocusTrap: true, disableFirstFocus: disableAutoFocus },
        React__namespace.createElement(CalendarType, __assign$1({}, calendarProps, {
          // eslint-disable-next-line react/jsx-no-bind
          onSelectDate,
          // eslint-disable-next-line react/jsx-no-bind
          onDismiss: onCalendarDismissed,
          isMonthPickerVisible: props.isMonthPickerVisible,
          showMonthPickerAsOverlay: props.showMonthPickerAsOverlay,
          today: props.today,
          value: selectedDate || initialPickerDate,
          firstDayOfWeek,
          strings,
          highlightCurrentMonth: props.highlightCurrentMonth,
          highlightSelectedMonth: props.highlightSelectedMonth,
          showWeekNumbers: props.showWeekNumbers,
          firstWeekOfYear: props.firstWeekOfYear,
          showGoToToday: props.showGoToToday,
          dateTimeFormatter: props.dateTimeFormatter,
          minDate,
          maxDate,
          componentRef: calendar,
          showCloseButton,
          allFocusable
        }))
      )
    )
  );
});
DatePickerBase.displayName = "DatePickerBase";
function isDateOutOfBounds(date, minDate, maxDate) {
  return !!minDate && compareDatePart(minDate, date) > 0 || !!maxDate && compareDatePart(maxDate, date) < 0;
}
var GlobalClassNames$q = {
  root: "ms-DatePicker",
  callout: "ms-DatePicker-callout",
  withLabel: "ms-DatePicker-event--with-label",
  withoutLabel: "ms-DatePicker-event--without-label",
  disabled: "msDatePickerDisabled "
};
var TEXTFIELD_HEIGHT = 32;
var styles$3 = function(props) {
  var _a2;
  var className = props.className, theme = props.theme, disabled = props.disabled, underlined = props.underlined, label = props.label, isDatePickerShown = props.isDatePickerShown;
  var palette = theme.palette, semanticColors = theme.semanticColors, fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(GlobalClassNames$q, theme);
  var DatePickerIcon = {
    color: palette.neutralSecondary,
    fontSize: FontSizes.icon,
    lineHeight: "18px",
    pointerEvents: "none",
    position: "absolute",
    right: "4px",
    padding: "5px"
  };
  return {
    root: [classNames2.root, theme.fonts.large, isDatePickerShown && "is-open", normalize, className],
    textField: [
      {
        position: "relative",
        selectors: {
          "& input[readonly]": {
            cursor: "pointer"
          },
          input: {
            selectors: {
              "::-ms-clear": {
                display: "none"
              }
            }
          }
        }
      },
      disabled && {
        selectors: {
          "& input[readonly]": {
            cursor: "default"
          }
        }
      }
    ],
    callout: [classNames2.callout],
    icon: [
      DatePickerIcon,
      label ? classNames2.withLabel : classNames2.withoutLabel,
      { paddingTop: "7px" },
      !disabled && [
        classNames2.disabled,
        {
          pointerEvents: "initial",
          cursor: "pointer"
        }
      ],
      disabled && {
        color: semanticColors.disabledText,
        cursor: "default"
      }
    ],
    statusMessage: [
      fonts.small,
      {
        color: semanticColors.errorText,
        marginTop: 5
      }
    ],
    readOnlyTextField: [
      {
        cursor: "pointer",
        height: TEXTFIELD_HEIGHT,
        lineHeight: TEXTFIELD_HEIGHT - 2,
        overflow: "hidden",
        textOverflow: "ellipsis"
      },
      underlined && {
        lineHeight: TEXTFIELD_HEIGHT + 2
      }
    ],
    readOnlyPlaceholder: (_a2 = {
      color: semanticColors.inputPlaceholderText
    }, _a2[HighContrastSelector] = {
      color: "GrayText"
    }, _a2)
  };
};
var DatePicker = styled(DatePickerBase, styles$3, void 0, {
  scope: "DatePicker"
});
var SELECTION_DISABLED_ATTRIBUTE_NAME = "data-selection-disabled";
var SELECTION_INDEX_ATTRIBUTE_NAME = "data-selection-index";
var SELECTION_SPAN_ATTRIBUTE_NAME = "data-selection-span";
var SELECTION_TOGGLE_ATTRIBUTE_NAME = "data-selection-toggle";
var SELECTION_INVOKE_ATTRIBUTE_NAME = "data-selection-invoke";
var SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME = "data-selection-touch-invoke";
var SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME = "data-selection-all-toggle";
var SELECTION_SELECT_ATTRIBUTE_NAME = "data-selection-select";
var SelectionZone = (
  /** @class */
  function(_super) {
    __extends(SelectionZone2, _super);
    function SelectionZone2(props) {
      var _this = _super.call(this, props) || this;
      _this._root = React__namespace.createRef();
      _this.ignoreNextFocus = function() {
        _this._handleNextFocus(false);
      };
      _this._onSelectionChange = function() {
        var selection2 = _this.props.selection;
        var isModal2 = selection2.isModal && selection2.isModal();
        _this.setState({
          isModal: isModal2
        });
      };
      _this._onMouseDownCapture = function(ev) {
        var target = ev.target;
        if (document.activeElement !== target && !elementContains(document.activeElement, target)) {
          _this.ignoreNextFocus();
          return;
        }
        if (!elementContains(target, _this._root.current)) {
          return;
        }
        while (target !== _this._root.current) {
          if (_this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {
            _this.ignoreNextFocus();
            break;
          }
          target = getParent(target);
        }
      };
      _this._onFocus = function(ev) {
        var target = ev.target;
        var selection2 = _this.props.selection;
        var isToggleModifierPressed = _this._isCtrlPressed || _this._isMetaPressed;
        var selectionMode = _this._getSelectionMode();
        if (_this._shouldHandleFocus && selectionMode !== SelectionMode.none) {
          var isToggle = _this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME);
          var itemRoot = _this._findItemRoot(target);
          if (!isToggle && itemRoot) {
            var index2 = _this._getItemIndex(itemRoot);
            var span = _this._getItemSpan(itemRoot);
            if (span === void 0) {
              if (isToggleModifierPressed) {
                selection2.setIndexSelected(index2, selection2.isIndexSelected(index2), true);
                if (_this.props.enterModalOnTouch && _this._isTouch && selection2.setModal) {
                  selection2.setModal(true);
                  _this._setIsTouch(false);
                }
              } else {
                if (_this.props.isSelectedOnFocus) {
                  _this._onItemSurfaceClick("focus", index2);
                }
              }
            }
          }
        }
        _this._handleNextFocus(false);
      };
      _this._onMouseDown = function(ev) {
        _this._updateModifiers(ev);
        var toggleWithoutModifierPressed = _this.props.toggleWithoutModifierPressed;
        var target = ev.target;
        var itemRoot = _this._findItemRoot(target);
        if (_this._isSelectionDisabled(target)) {
          return;
        }
        while (target !== _this._root.current) {
          if (_this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {
            break;
          } else if (itemRoot) {
            if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {
              break;
            } else if (_this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {
              break;
            } else if ((target === itemRoot || _this._shouldAutoSelect(target)) && !_this._isShiftPressed && !_this._isCtrlPressed && !_this._isMetaPressed && !toggleWithoutModifierPressed) {
              _this._onInvokeMouseDown(ev, _this._getItemIndex(itemRoot), _this._getItemSpan(itemRoot));
              break;
            } else if (_this.props.disableAutoSelectOnInputElements && (target.tagName === "A" || target.tagName === "BUTTON" || target.tagName === "INPUT")) {
              return;
            }
          }
          target = getParent(target);
        }
      };
      _this._onTouchStartCapture = function(ev) {
        _this._setIsTouch(true);
      };
      _this._onClick = function(ev) {
        var _a2 = _this.props.enableTouchInvocationTarget, enableTouchInvocationTarget = _a2 === void 0 ? false : _a2;
        _this._updateModifiers(ev);
        var target = ev.target;
        var itemRoot = _this._findItemRoot(target);
        var isSelectionDisabled = _this._isSelectionDisabled(target);
        while (target !== _this._root.current) {
          if (_this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {
            if (!isSelectionDisabled) {
              _this._onToggleAllClick(ev);
            }
            break;
          } else if (itemRoot) {
            var index2 = _this._getItemIndex(itemRoot);
            var span = _this._getItemSpan(itemRoot);
            if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {
              if (!isSelectionDisabled) {
                if (_this._isShiftPressed) {
                  _this._onItemSurfaceClick("click", index2, span);
                } else {
                  _this._onToggleClick(ev, index2, span);
                }
              }
              break;
            } else if (_this._isTouch && enableTouchInvocationTarget && _this._hasAttribute(target, SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME) || _this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {
              if (span === void 0) {
                _this._onInvokeClick(ev, index2);
              }
              break;
            } else if (target === itemRoot) {
              if (!isSelectionDisabled) {
                _this._onItemSurfaceClick("click", index2, span);
              }
              break;
            } else if (target.tagName === "A" || target.tagName === "BUTTON" || target.tagName === "INPUT") {
              return;
            }
          }
          target = getParent(target);
        }
      };
      _this._onContextMenu = function(ev) {
        var target = ev.target;
        var _a2 = _this.props, onItemContextMenu = _a2.onItemContextMenu, selection2 = _a2.selection;
        if (onItemContextMenu) {
          var itemRoot = _this._findItemRoot(target);
          if (itemRoot) {
            var index2 = _this._getItemIndex(itemRoot);
            _this._onInvokeMouseDown(ev, index2);
            var skipPreventDefault = onItemContextMenu(selection2.getItems()[index2], index2, ev.nativeEvent);
            if (!skipPreventDefault) {
              ev.preventDefault();
            }
          }
        }
      };
      _this._onDoubleClick = function(ev) {
        var target = ev.target;
        var onItemInvoked = _this.props.onItemInvoked;
        var itemRoot = _this._findItemRoot(target);
        if (itemRoot && onItemInvoked && !_this._isInputElement(target)) {
          var index2 = _this._getItemIndex(itemRoot);
          while (target !== _this._root.current) {
            if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME) || _this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {
              break;
            } else if (target === itemRoot) {
              _this._onInvokeClick(ev, index2);
              break;
            }
            target = getParent(target);
          }
          target = getParent(target);
        }
      };
      _this._onKeyDownCapture = function(ev) {
        _this._updateModifiers(ev);
        _this._handleNextFocus(true);
      };
      _this._onKeyDown = function(ev) {
        _this._updateModifiers(ev);
        var target = ev.target;
        var isSelectionDisabled = _this._isSelectionDisabled(target);
        var _a2 = _this.props, selection2 = _a2.selection, selectionClearedOnEscapePress = _a2.selectionClearedOnEscapePress;
        var isSelectAllKey = ev.which === KeyCodes.a && (_this._isCtrlPressed || _this._isMetaPressed);
        var isClearSelectionKey = ev.which === KeyCodes.escape;
        if (_this._isInputElement(target)) {
          return;
        }
        var selectionMode = _this._getSelectionMode();
        if (isSelectAllKey && selectionMode === SelectionMode.multiple && !selection2.isAllSelected()) {
          if (!isSelectionDisabled) {
            selection2.setAllSelected(true);
          }
          ev.stopPropagation();
          ev.preventDefault();
          return;
        }
        if (selectionClearedOnEscapePress && isClearSelectionKey && selection2.getSelectedCount() > 0) {
          if (!isSelectionDisabled) {
            selection2.setAllSelected(false);
          }
          ev.stopPropagation();
          ev.preventDefault();
          return;
        }
        var itemRoot = _this._findItemRoot(target);
        if (itemRoot) {
          var index2 = _this._getItemIndex(itemRoot);
          var span = _this._getItemSpan(itemRoot);
          while (target !== _this._root.current) {
            if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {
              break;
            } else if (_this._shouldAutoSelect(target)) {
              if (!isSelectionDisabled && span === void 0) {
                _this._onInvokeMouseDown(ev, index2, span);
              }
              break;
            } else if (
              // eslint-disable-next-line deprecation/deprecation
              (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) && (target.tagName === "BUTTON" || target.tagName === "A" || target.tagName === "INPUT" || target.tagName === "SUMMARY")
            ) {
              return false;
            } else if (target === itemRoot) {
              if (ev.which === KeyCodes.enter) {
                if (span === void 0) {
                  _this._onInvokeClick(ev, index2);
                  ev.preventDefault();
                }
                return;
              } else if (ev.which === KeyCodes.space) {
                if (!isSelectionDisabled) {
                  _this._onToggleClick(ev, index2, span);
                }
                ev.preventDefault();
                return;
              }
              break;
            }
            target = getParent(target);
          }
        }
      };
      _this._events = new EventGroup(_this);
      _this._async = new Async(_this);
      initializeComponentRef(_this);
      var selection = _this.props.selection;
      var isModal = selection.isModal && selection.isModal();
      _this.state = {
        isModal
      };
      return _this;
    }
    SelectionZone2.getDerivedStateFromProps = function(nextProps, prevState) {
      var isModal = nextProps.selection.isModal && nextProps.selection.isModal();
      return __assign$1(__assign$1({}, prevState), { isModal });
    };
    SelectionZone2.prototype.componentDidMount = function() {
      var win2 = getWindow$1(this._root.current);
      this._events.on(win2, "keydown, keyup", this._updateModifiers, true);
      this._events.on(document, "click", this._findScrollParentAndTryClearOnEmptyClick);
      this._events.on(document.body, "touchstart", this._onTouchStartCapture, true);
      this._events.on(document.body, "touchend", this._onTouchStartCapture, true);
      this._events.on(this.props.selection, "change", this._onSelectionChange);
    };
    SelectionZone2.prototype.render = function() {
      var isModal = this.state.isModal;
      return React__namespace.createElement(
        "div",
        { className: css$3("ms-SelectionZone", this.props.className, {
          "ms-SelectionZone--modal": !!isModal
        }), ref: this._root, onKeyDown: this._onKeyDown, onMouseDown: this._onMouseDown, onKeyDownCapture: this._onKeyDownCapture, onClick: this._onClick, role: "presentation", onDoubleClick: this._onDoubleClick, onContextMenu: this._onContextMenu, onMouseDownCapture: this._onMouseDownCapture, onFocusCapture: this._onFocus, "data-selection-is-modal": isModal ? true : void 0 },
        this.props.children,
        React__namespace.createElement(FocusRects, null)
      );
    };
    SelectionZone2.prototype.componentDidUpdate = function(previousProps) {
      var selection = this.props.selection;
      if (selection !== previousProps.selection) {
        this._events.off(previousProps.selection);
        this._events.on(selection, "change", this._onSelectionChange);
      }
    };
    SelectionZone2.prototype.componentWillUnmount = function() {
      this._events.dispose();
      this._async.dispose();
    };
    SelectionZone2.prototype._isSelectionDisabled = function(target) {
      if (this._getSelectionMode() === SelectionMode.none) {
        return true;
      }
      while (target !== this._root.current) {
        if (this._hasAttribute(target, SELECTION_DISABLED_ATTRIBUTE_NAME)) {
          return true;
        }
        target = getParent(target);
      }
      return false;
    };
    SelectionZone2.prototype._onToggleAllClick = function(ev) {
      var selection = this.props.selection;
      var selectionMode = this._getSelectionMode();
      if (selectionMode === SelectionMode.multiple) {
        selection.toggleAllSelected();
        ev.stopPropagation();
        ev.preventDefault();
      }
    };
    SelectionZone2.prototype._onToggleClick = function(ev, index2, span) {
      var selection = this.props.selection;
      var selectionMode = this._getSelectionMode();
      selection.setChangeEvents(false);
      if (this.props.enterModalOnTouch && this._isTouch && (span !== void 0 ? !selection.isRangeSelected(index2, span) : !selection.isIndexSelected(index2)) && selection.setModal) {
        selection.setModal(true);
        this._setIsTouch(false);
      }
      if (selectionMode === SelectionMode.multiple) {
        if (span !== void 0) {
          selection.toggleRangeSelected(index2, span);
        } else {
          selection.toggleIndexSelected(index2);
        }
      } else if (selectionMode === SelectionMode.single) {
        if (span === void 0 || span === 1) {
          var isSelected = selection.isIndexSelected(index2);
          var isModal = selection.isModal && selection.isModal();
          selection.setAllSelected(false);
          selection.setIndexSelected(index2, !isSelected, true);
          if (isModal && selection.setModal) {
            selection.setModal(true);
          }
        }
      } else {
        selection.setChangeEvents(true);
        return;
      }
      selection.setChangeEvents(true);
      ev.stopPropagation();
    };
    SelectionZone2.prototype._onInvokeClick = function(ev, index2) {
      var _a2 = this.props, selection = _a2.selection, onItemInvoked = _a2.onItemInvoked;
      if (onItemInvoked) {
        onItemInvoked(selection.getItems()[index2], index2, ev.nativeEvent);
        ev.preventDefault();
        ev.stopPropagation();
      }
    };
    SelectionZone2.prototype._onItemSurfaceClick = function(type, index2, span) {
      var _a2;
      var _b2 = this.props, selection = _b2.selection, toggleWithoutModifierPressed = _b2.toggleWithoutModifierPressed;
      var isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;
      var selectionMode = this._getSelectionMode();
      if (selectionMode === SelectionMode.multiple) {
        if (this._isShiftPressed && !this._isTabPressed) {
          if (span !== void 0) {
            (_a2 = selection.selectToRange) === null || _a2 === void 0 ? void 0 : _a2.call(selection, index2, span, !isToggleModifierPressed);
          } else {
            selection.selectToIndex(index2, !isToggleModifierPressed);
          }
        } else if (type === "click" && (isToggleModifierPressed || toggleWithoutModifierPressed)) {
          if (span !== void 0) {
            selection.toggleRangeSelected(index2, span);
          } else {
            selection.toggleIndexSelected(index2);
          }
        } else {
          this._clearAndSelectIndex(index2, span);
        }
      } else if (selectionMode === SelectionMode.single) {
        this._clearAndSelectIndex(index2, span);
      }
    };
    SelectionZone2.prototype._onInvokeMouseDown = function(ev, index2, span) {
      var selection = this.props.selection;
      if (span !== void 0) {
        if (selection.isRangeSelected(index2, span)) {
          return;
        }
      } else {
        if (selection.isIndexSelected(index2)) {
          return;
        }
      }
      this._clearAndSelectIndex(index2, span);
    };
    SelectionZone2.prototype._findScrollParentAndTryClearOnEmptyClick = function(ev) {
      var scrollParent = findScrollableParent(this._root.current);
      this._events.off(document, "click", this._findScrollParentAndTryClearOnEmptyClick);
      this._events.on(scrollParent, "click", this._tryClearOnEmptyClick);
      if (scrollParent && ev.target instanceof Node && scrollParent.contains(ev.target) || scrollParent === ev.target) {
        this._tryClearOnEmptyClick(ev);
      }
    };
    SelectionZone2.prototype._tryClearOnEmptyClick = function(ev) {
      if (!this.props.selectionPreservedOnEmptyClick && this._isNonHandledClick(ev.target)) {
        this.props.selection.setAllSelected(false);
      }
    };
    SelectionZone2.prototype._clearAndSelectIndex = function(index2, span) {
      var _a2;
      var _b2 = this.props, selection = _b2.selection, _c2 = _b2.selectionClearedOnSurfaceClick, selectionClearedOnSurfaceClick = _c2 === void 0 ? true : _c2;
      var isAlreadySingleSelected = (span === void 0 || span === 1) && selection.getSelectedCount() === 1 && selection.isIndexSelected(index2);
      if (!isAlreadySingleSelected && selectionClearedOnSurfaceClick) {
        var isModal = selection.isModal && selection.isModal();
        selection.setChangeEvents(false);
        selection.setAllSelected(false);
        if (span !== void 0) {
          (_a2 = selection.setRangeSelected) === null || _a2 === void 0 ? void 0 : _a2.call(selection, index2, span, true, true);
        } else {
          selection.setIndexSelected(index2, true, true);
        }
        if (isModal || this.props.enterModalOnTouch && this._isTouch) {
          if (selection.setModal) {
            selection.setModal(true);
          }
          if (this._isTouch) {
            this._setIsTouch(false);
          }
        }
        selection.setChangeEvents(true);
      }
    };
    SelectionZone2.prototype._updateModifiers = function(ev) {
      this._isShiftPressed = ev.shiftKey;
      this._isCtrlPressed = ev.ctrlKey;
      this._isMetaPressed = ev.metaKey;
      var keyCode = ev.keyCode;
      this._isTabPressed = keyCode ? keyCode === KeyCodes.tab : false;
    };
    SelectionZone2.prototype._findItemRoot = function(target) {
      var selection = this.props.selection;
      while (target !== this._root.current) {
        var indexValue = target.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME);
        var index2 = Number(indexValue);
        if (indexValue !== null && index2 >= 0 && index2 < selection.getItems().length) {
          break;
        }
        target = getParent(target);
      }
      if (target === this._root.current) {
        return void 0;
      }
      return target;
    };
    SelectionZone2.prototype._getItemIndex = function(itemRoot) {
      var _a2;
      var indexValue = parseInt((_a2 = itemRoot.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME)) !== null && _a2 !== void 0 ? _a2 : "", 10);
      return isNaN(indexValue) ? -1 : indexValue;
    };
    SelectionZone2.prototype._getItemSpan = function(itemRoot) {
      var _a2;
      var spanValue = parseInt((_a2 = itemRoot.getAttribute(SELECTION_SPAN_ATTRIBUTE_NAME)) !== null && _a2 !== void 0 ? _a2 : "", 10);
      return isNaN(spanValue) ? void 0 : spanValue;
    };
    SelectionZone2.prototype._shouldAutoSelect = function(element) {
      return this._hasAttribute(element, SELECTION_SELECT_ATTRIBUTE_NAME);
    };
    SelectionZone2.prototype._hasAttribute = function(element, attributeName) {
      var isToggle = false;
      while (!isToggle && element !== this._root.current) {
        var value = element.getAttribute(attributeName);
        if (value === "false") {
          isToggle = false;
          break;
        }
        isToggle = value === "true";
        element = getParent(element);
      }
      return isToggle;
    };
    SelectionZone2.prototype._isInputElement = function(element) {
      return element.tagName === "INPUT" || element.tagName === "TEXTAREA" || element.getAttribute("contenteditable") === "true" || element.getAttribute("contenteditable") === "";
    };
    SelectionZone2.prototype._isNonHandledClick = function(element) {
      var doc = getDocument();
      if (doc && element) {
        while (element && element !== doc.documentElement) {
          if (isElementTabbable(element) || element.hasAttribute("data-selection-index")) {
            return false;
          }
          element = getParent(element);
        }
      }
      return true;
    };
    SelectionZone2.prototype._handleNextFocus = function(handleFocus) {
      var _this = this;
      if (this._shouldHandleFocusTimeoutId) {
        this._async.clearTimeout(this._shouldHandleFocusTimeoutId);
        this._shouldHandleFocusTimeoutId = void 0;
      }
      this._shouldHandleFocus = handleFocus;
      if (handleFocus) {
        this._async.setTimeout(function() {
          _this._shouldHandleFocus = false;
        }, 100);
      }
    };
    SelectionZone2.prototype._setIsTouch = function(isTouch) {
      var _this = this;
      if (this._isTouchTimeoutId) {
        this._async.clearTimeout(this._isTouchTimeoutId);
        this._isTouchTimeoutId = void 0;
      }
      this._isTouch = true;
      if (isTouch) {
        this._async.setTimeout(function() {
          _this._isTouch = false;
        }, 300);
      }
    };
    SelectionZone2.prototype._getSelectionMode = function() {
      var selection = this.props.selection;
      var _a2 = this.props.selectionMode, selectionMode = _a2 === void 0 ? selection ? selection.mode : SelectionMode.none : _a2;
      return selectionMode;
    };
    SelectionZone2.defaultProps = {
      isSelectedOnFocus: true,
      toggleWithoutModifierPressed: false,
      selectionMode: SelectionMode.multiple,
      selectionClearedOnEscapePress: true
    };
    return SelectionZone2;
  }(React__namespace.Component)
);
var CollapseAllVisibility;
(function(CollapseAllVisibility2) {
  CollapseAllVisibility2[CollapseAllVisibility2["hidden"] = 0] = "hidden";
  CollapseAllVisibility2[CollapseAllVisibility2["visible"] = 1] = "visible";
})(CollapseAllVisibility || (CollapseAllVisibility = {}));
var ColumnActionsMode;
(function(ColumnActionsMode2) {
  ColumnActionsMode2[ColumnActionsMode2["disabled"] = 0] = "disabled";
  ColumnActionsMode2[ColumnActionsMode2["clickable"] = 1] = "clickable";
  ColumnActionsMode2[ColumnActionsMode2["hasDropdown"] = 2] = "hasDropdown";
})(ColumnActionsMode || (ColumnActionsMode = {}));
var ConstrainMode;
(function(ConstrainMode2) {
  ConstrainMode2[ConstrainMode2["unconstrained"] = 0] = "unconstrained";
  ConstrainMode2[ConstrainMode2["horizontalConstrained"] = 1] = "horizontalConstrained";
})(ConstrainMode || (ConstrainMode = {}));
var ColumnDragEndLocation;
(function(ColumnDragEndLocation2) {
  ColumnDragEndLocation2[ColumnDragEndLocation2["outside"] = 0] = "outside";
  ColumnDragEndLocation2[ColumnDragEndLocation2["surface"] = 1] = "surface";
  ColumnDragEndLocation2[ColumnDragEndLocation2["header"] = 2] = "header";
})(ColumnDragEndLocation || (ColumnDragEndLocation = {}));
var DetailsListLayoutMode;
(function(DetailsListLayoutMode2) {
  DetailsListLayoutMode2[DetailsListLayoutMode2["fixedColumns"] = 0] = "fixedColumns";
  DetailsListLayoutMode2[DetailsListLayoutMode2["justified"] = 1] = "justified";
})(DetailsListLayoutMode || (DetailsListLayoutMode = {}));
var CheckboxVisibility;
(function(CheckboxVisibility2) {
  CheckboxVisibility2[CheckboxVisibility2["onHover"] = 0] = "onHover";
  CheckboxVisibility2[CheckboxVisibility2["always"] = 1] = "always";
  CheckboxVisibility2[CheckboxVisibility2["hidden"] = 2] = "hidden";
})(CheckboxVisibility || (CheckboxVisibility = {}));
var SPACER_WIDTH = 36;
var GroupSpacer = function(props) {
  var count = props.count, _a2 = props.indentWidth, indentWidth = _a2 === void 0 ? SPACER_WIDTH : _a2, _b2 = props.role, role = _b2 === void 0 ? "presentation" : _b2;
  var width = count * indentWidth;
  return count > 0 ? React__namespace.createElement("span", { className: "ms-GroupSpacer", style: { display: "inline-block", width }, role }) : null;
};
var GlobalClassNames$p = {
  root: "ms-GroupedList",
  compact: "ms-GroupedList--Compact",
  group: "ms-GroupedList-group",
  link: "ms-Link",
  listCell: "ms-List-cell"
};
var beziers$1 = {
  easeInOutSine: "cubic-bezier(0.445, 0.050, 0.550, 0.950)"
};
var getStyles$n = function(props) {
  var _a2, _b2;
  var theme = props.theme, className = props.className, compact = props.compact;
  var palette = theme.palette;
  var classNames2 = getGlobalClassNames(GlobalClassNames$p, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.small,
      {
        position: "relative",
        selectors: (_a2 = {}, _a2["." + classNames2.listCell] = {
          minHeight: 38
          // be consistent with DetailsList styles
        }, _a2)
      },
      compact && [
        classNames2.compact,
        {
          selectors: (_b2 = {}, _b2["." + classNames2.listCell] = {
            minHeight: 32
            // be consistent with DetailsList styles
          }, _b2)
        }
      ],
      className
    ],
    group: [
      classNames2.group,
      {
        transition: "background-color " + AnimationVariables.durationValue2 + " " + beziers$1.easeInOutSine
      }
    ],
    groupIsDropping: {
      backgroundColor: palette.neutralLight
    }
  };
};
var DetailsRowGlobalClassNames = {
  root: "ms-DetailsRow",
  // TODO: in Fabric 7.0 lowercase the 'Compact' for consistency across other components.
  compact: "ms-DetailsList--Compact",
  cell: "ms-DetailsRow-cell",
  cellAnimation: "ms-DetailsRow-cellAnimation",
  cellCheck: "ms-DetailsRow-cellCheck",
  check: "ms-DetailsRow-check",
  cellMeasurer: "ms-DetailsRow-cellMeasurer",
  listCellFirstChild: "ms-List-cell:first-child",
  isContentUnselectable: "is-contentUnselectable",
  isSelected: "is-selected",
  isCheckVisible: "is-check-visible",
  isRowHeader: "is-row-header",
  fields: "ms-DetailsRow-fields"
};
var IsFocusableSelector = "[data-is-focusable='true']";
var DEFAULT_CELL_STYLE_PROPS = {
  cellLeftPadding: 12,
  cellRightPadding: 8,
  cellExtraRightPadding: 24
};
var DEFAULT_ROW_HEIGHTS = {
  rowHeight: 42,
  compactRowHeight: 32
};
var values = __assign$1(__assign$1({}, DEFAULT_ROW_HEIGHTS), { rowVerticalPadding: 11, compactRowVerticalPadding: 6 });
var getDetailsRowStyles = function(props) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p;
  var theme = props.theme, isSelected = props.isSelected, canSelect = props.canSelect, droppingClassName = props.droppingClassName, isCheckVisible = props.isCheckVisible, checkboxCellClassName = props.checkboxCellClassName, compact = props.compact, className = props.className, _q = props.cellStyleProps, cellStyleProps = _q === void 0 ? DEFAULT_CELL_STYLE_PROPS : _q, enableUpdateAnimations = props.enableUpdateAnimations, disabled = props.disabled;
  var palette = theme.palette, fonts = theme.fonts;
  var neutralPrimary = palette.neutralPrimary, white = palette.white, neutralSecondary = palette.neutralSecondary, neutralLighter = palette.neutralLighter, neutralLight = palette.neutralLight, neutralDark = palette.neutralDark, neutralQuaternaryAlt = palette.neutralQuaternaryAlt;
  var _r = theme.semanticColors, focusBorder = _r.focusBorder, focusedLinkColor = _r.linkHovered;
  var classNames2 = getGlobalClassNames(DetailsRowGlobalClassNames, theme);
  var colors2 = {
    // Default
    defaultHeaderText: neutralPrimary,
    defaultMetaText: neutralSecondary,
    defaultBackground: white,
    // Default Hover
    defaultHoverHeaderText: neutralDark,
    defaultHoverMetaText: neutralPrimary,
    defaultHoverBackground: neutralLighter,
    // Selected
    selectedHeaderText: neutralDark,
    selectedMetaText: neutralPrimary,
    selectedBackground: neutralLight,
    // Selected Hover
    selectedHoverHeaderText: neutralDark,
    selectedHoverMetaText: neutralPrimary,
    selectedHoverBackground: neutralQuaternaryAlt,
    // Focus
    focusHeaderText: neutralDark,
    focusMetaText: neutralPrimary,
    focusBackground: neutralLight,
    focusHoverBackground: neutralQuaternaryAlt
  };
  var rowHighContrastFocus = {
    top: 2,
    right: 2,
    bottom: 2,
    left: 2
  };
  var selectedStyles = [
    getFocusStyle(theme, {
      inset: -1,
      borderColor: focusBorder,
      outlineColor: white,
      highContrastStyle: rowHighContrastFocus
    }),
    classNames2.isSelected,
    {
      color: colors2.selectedMetaText,
      background: colors2.selectedBackground,
      borderBottom: "1px solid " + white,
      selectors: (_a2 = {
        "&:before": {
          position: "absolute",
          display: "block",
          top: -1,
          height: 1,
          bottom: 0,
          left: 0,
          right: 0,
          content: "",
          borderTop: "1px solid " + white
        }
      }, _a2["." + classNames2.cell + " > ." + GlobalClassNames$v.root] = {
        color: focusedLinkColor,
        selectors: (_b2 = {}, _b2[HighContrastSelector] = {
          color: "HighlightText"
        }, _b2)
      }, // Selected State hover
      _a2["&:hover"] = {
        background: colors2.selectedHoverBackground,
        color: colors2.selectedHoverMetaText,
        selectors: (_c2 = {}, // Selected State hover meta cell
        _c2[HighContrastSelector] = {
          background: "Highlight",
          selectors: (_d2 = {}, _d2["." + classNames2.cell] = {
            color: "HighlightText"
          }, _d2["." + classNames2.cell + " > ." + GlobalClassNames$v.root] = {
            forcedColorAdjust: "none",
            color: "HighlightText"
          }, _d2)
        }, // Selected State hover Header cell
        _c2["." + classNames2.isRowHeader] = {
          color: colors2.selectedHoverHeaderText,
          selectors: (_e2 = {}, _e2[HighContrastSelector] = {
            color: "HighlightText"
          }, _e2)
        }, _c2)
      }, // Focus state
      _a2["&:focus"] = {
        background: colors2.focusBackground,
        selectors: (_f = {}, // Selected State hover meta cell
        _f["." + classNames2.cell] = {
          color: colors2.focusMetaText,
          selectors: (_g = {}, _g[HighContrastSelector] = {
            color: "HighlightText",
            selectors: {
              "> a": {
                color: "HighlightText"
              }
            }
          }, _g)
        }, // Row header cell
        _f["." + classNames2.isRowHeader] = {
          color: colors2.focusHeaderText,
          selectors: (_h = {}, _h[HighContrastSelector] = {
            color: "HighlightText"
          }, _h)
        }, // Ensure high-contrast mode overrides default focus background
        _f[HighContrastSelector] = {
          background: "Highlight"
        }, _f)
      }, _a2[HighContrastSelector] = __assign$1(__assign$1({ background: "Highlight", color: "HighlightText" }, getHighContrastNoAdjustStyle()), { selectors: {
        a: {
          color: "HighlightText"
        }
      } }), // Focus and hover state
      _a2["&:focus:hover"] = {
        background: colors2.focusHoverBackground
      }, _a2)
    }
  ];
  var cannotSelectStyles = [
    classNames2.isContentUnselectable,
    {
      userSelect: "none",
      cursor: "default"
    }
  ];
  var rootCompactStyles = {
    minHeight: values.compactRowHeight,
    border: 0
  };
  var cellCompactStyles = {
    minHeight: values.compactRowHeight,
    paddingTop: values.compactRowVerticalPadding,
    paddingBottom: values.compactRowVerticalPadding,
    paddingLeft: cellStyleProps.cellLeftPadding + "px"
  };
  var defaultCellStyles = [
    getFocusStyle(theme, { inset: -1 }),
    classNames2.cell,
    {
      display: "inline-block",
      position: "relative",
      boxSizing: "border-box",
      minHeight: values.rowHeight,
      verticalAlign: "top",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis",
      paddingTop: values.rowVerticalPadding,
      paddingBottom: values.rowVerticalPadding,
      paddingLeft: cellStyleProps.cellLeftPadding + "px",
      selectors: (_j = {
        "& > button": {
          maxWidth: "100%"
        }
      }, _j[IsFocusableSelector] = getFocusStyle(theme, { inset: -1, borderColor: neutralSecondary, outlineColor: white }), _j)
    },
    isSelected && {
      selectors: (_k = {}, _k[HighContrastSelector] = __assign$1({ background: "Highlight", color: "HighlightText" }, getHighContrastNoAdjustStyle()), _k)
    },
    compact && cellCompactStyles,
    disabled && { opacity: 0.5 }
  ];
  return {
    root: [
      classNames2.root,
      AnimationClassNames.fadeIn400,
      droppingClassName,
      theme.fonts.small,
      isCheckVisible && classNames2.isCheckVisible,
      getFocusStyle(theme, { borderColor: focusBorder, outlineColor: white }),
      {
        borderBottom: "1px solid " + neutralLighter,
        background: colors2.defaultBackground,
        color: colors2.defaultMetaText,
        // This ensures that the row always tries to consume is minimum width and does not compress.
        display: "inline-flex",
        minWidth: "100%",
        minHeight: values.rowHeight,
        whiteSpace: "nowrap",
        padding: 0,
        boxSizing: "border-box",
        verticalAlign: "top",
        textAlign: "left",
        selectors: (_l = {}, _l["." + classNames2.listCellFirstChild + " &:before"] = {
          display: "none"
        }, _l["&:hover"] = {
          background: colors2.defaultHoverBackground,
          color: colors2.defaultHoverMetaText,
          selectors: (_m = {}, _m["." + classNames2.isRowHeader] = {
            color: colors2.defaultHoverHeaderText
          }, _m["." + classNames2.cell + " > ." + GlobalClassNames$v.root] = {
            color: focusedLinkColor
          }, _m)
        }, _l["&:hover ." + classNames2.check] = {
          opacity: 1
        }, _l["." + IsFocusVisibleClassName + " &:focus ." + classNames2.check] = {
          opacity: 1
        }, _l[".ms-GroupSpacer"] = {
          flexShrink: 0,
          flexGrow: 0
        }, _l)
      },
      isSelected && selectedStyles,
      !canSelect && cannotSelectStyles,
      compact && rootCompactStyles,
      className
    ],
    cellUnpadded: {
      paddingRight: cellStyleProps.cellRightPadding + "px"
    },
    cellPadded: {
      paddingRight: cellStyleProps.cellExtraRightPadding + cellStyleProps.cellRightPadding + "px",
      selectors: (_o = {}, _o["&." + classNames2.cellCheck] = {
        paddingRight: 0
      }, _o)
    },
    cell: defaultCellStyles,
    cellAnimation: enableUpdateAnimations && AnimationStyles.slideLeftIn40,
    cellMeasurer: [
      classNames2.cellMeasurer,
      {
        overflow: "visible",
        whiteSpace: "nowrap"
      }
    ],
    checkCell: [
      defaultCellStyles,
      classNames2.cellCheck,
      checkboxCellClassName,
      {
        padding: 0,
        // Ensure that the check cell covers the top border of the cell.
        // This ensures the click target does not leave a spot which would
        // cause other items to be deselected.
        paddingTop: 1,
        marginTop: -1,
        flexShrink: 0
      }
    ],
    fields: [
      classNames2.fields,
      {
        display: "flex",
        alignItems: "stretch"
      }
    ],
    isRowHeader: [
      classNames2.isRowHeader,
      {
        color: colors2.defaultHeaderText,
        fontSize: fonts.medium.fontSize
      },
      isSelected && {
        color: colors2.selectedHeaderText,
        fontWeight: FontWeights.semibold,
        selectors: (_p = {}, _p[HighContrastSelector] = {
          color: "HighlightText"
        }, _p)
      }
    ],
    isMultiline: [
      defaultCellStyles,
      {
        whiteSpace: "normal",
        wordBreak: "break-word",
        textOverflow: "clip"
      }
    ],
    check: [classNames2.check]
  };
};
var GlobalClassNames$o = {
  tooltipHost: "ms-TooltipHost",
  root: "ms-DetailsHeader",
  cell: "ms-DetailsHeader-cell",
  cellIsCheck: "ms-DetailsHeader-cellIsCheck",
  collapseButton: "ms-DetailsHeader-collapseButton",
  isCollapsed: "is-collapsed",
  isAllSelected: "is-allSelected",
  isSelectAllHidden: "is-selectAllHidden",
  isResizingColumn: "is-resizingColumn",
  cellSizer: "ms-DetailsHeader-cellSizer",
  isResizing: "is-resizing",
  dropHintCircleStyle: "ms-DetailsHeader-dropHintCircleStyle",
  dropHintCaretStyle: "ms-DetailsHeader-dropHintCaretStyle",
  dropHintLineStyle: "ms-DetailsHeader-dropHintLineStyle",
  cellTitle: "ms-DetailsHeader-cellTitle",
  cellName: "ms-DetailsHeader-cellName",
  filterChevron: "ms-DetailsHeader-filterChevron",
  gripperBarVertical: "ms-DetailsColumn-gripperBarVertical",
  checkTooltip: "ms-DetailsHeader-checkTooltip",
  check: "ms-DetailsHeader-check"
};
var HEADER_HEIGHT = 42;
var getCellStyles = function(props) {
  var theme = props.theme, _a2 = props.cellStyleProps, cellStyleProps = _a2 === void 0 ? DEFAULT_CELL_STYLE_PROPS : _a2;
  var semanticColors = theme.semanticColors;
  var classNames2 = getGlobalClassNames(GlobalClassNames$o, theme);
  return [
    classNames2.cell,
    getFocusStyle(theme),
    {
      color: semanticColors.bodyText,
      position: "relative",
      display: "inline-block",
      boxSizing: "border-box",
      padding: "0 " + cellStyleProps.cellRightPadding + "px 0 " + cellStyleProps.cellLeftPadding + "px",
      lineHeight: "inherit",
      margin: "0",
      height: HEADER_HEIGHT,
      verticalAlign: "top",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      textAlign: "left"
    }
  ];
};
var getDetailsHeaderStyles = function(props) {
  var _a2, _b2, _c2, _d2;
  var theme = props.theme, className = props.className, isAllSelected = props.isAllSelected, isResizingColumn = props.isResizingColumn, isSizing = props.isSizing, isAllCollapsed = props.isAllCollapsed, _e2 = props.cellStyleProps, cellStyleProps = _e2 === void 0 ? DEFAULT_CELL_STYLE_PROPS : _e2;
  var semanticColors = theme.semanticColors, palette = theme.palette, fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(GlobalClassNames$o, theme);
  var colors2 = {
    iconForegroundColor: semanticColors.bodySubtext,
    headerForegroundColor: semanticColors.bodyText,
    headerBackgroundColor: semanticColors.bodyBackground,
    resizerColor: palette.neutralTertiaryAlt
  };
  var cellSizerFadeInStyles = {
    opacity: 1,
    transition: "opacity 0.3s linear"
  };
  var cellStyles = getCellStyles(props);
  return {
    root: [
      classNames2.root,
      fonts.small,
      {
        display: "inline-block",
        background: colors2.headerBackgroundColor,
        position: "relative",
        minWidth: "100%",
        verticalAlign: "top",
        height: HEADER_HEIGHT,
        lineHeight: HEADER_HEIGHT,
        whiteSpace: "nowrap",
        boxSizing: "content-box",
        paddingBottom: "1px",
        paddingTop: "16px",
        borderBottom: "1px solid " + semanticColors.bodyDivider,
        cursor: "default",
        userSelect: "none",
        selectors: (_a2 = {}, _a2["&:hover ." + classNames2.check] = {
          opacity: 1
        }, _a2["& ." + classNames2.tooltipHost + " ." + classNames2.checkTooltip] = {
          display: "block"
        }, _a2)
      },
      isAllSelected && classNames2.isAllSelected,
      isResizingColumn && classNames2.isResizingColumn,
      className
    ],
    check: [
      classNames2.check,
      {
        height: HEADER_HEIGHT
      },
      {
        selectors: (_b2 = {}, _b2["." + IsFocusVisibleClassName + " &:focus"] = {
          opacity: 1
        }, _b2)
      }
    ],
    cellWrapperPadded: {
      paddingRight: cellStyleProps.cellExtraRightPadding + cellStyleProps.cellRightPadding
    },
    cellIsCheck: [
      cellStyles,
      classNames2.cellIsCheck,
      {
        position: "relative",
        padding: 0,
        margin: 0,
        display: "inline-flex",
        alignItems: "center",
        border: "none"
      },
      isAllSelected && {
        opacity: 1
      }
    ],
    cellIsGroupExpander: [
      cellStyles,
      {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        fontSize: fonts.small.fontSize,
        padding: 0,
        border: "none",
        width: SPACER_WIDTH,
        color: palette.neutralSecondary,
        selectors: {
          ":hover": {
            backgroundColor: palette.neutralLighter
          },
          ":active": {
            backgroundColor: palette.neutralLight
          }
        }
      }
    ],
    cellIsActionable: {
      selectors: {
        ":hover": {
          color: semanticColors.bodyText,
          background: semanticColors.listHeaderBackgroundHovered
        },
        ":active": {
          background: semanticColors.listHeaderBackgroundPressed
        }
      }
    },
    cellIsEmpty: {
      textOverflow: "clip"
    },
    cellSizer: [
      classNames2.cellSizer,
      focusClear(),
      {
        display: "inline-block",
        position: "relative",
        cursor: "ew-resize",
        bottom: 0,
        top: 0,
        overflow: "hidden",
        height: "inherit",
        background: "transparent",
        zIndex: 1,
        width: 16,
        selectors: (_c2 = {
          ":after": {
            content: '""',
            position: "absolute",
            top: 0,
            bottom: 0,
            width: 1,
            background: colors2.resizerColor,
            opacity: 0,
            left: "50%"
          },
          ":focus:after": cellSizerFadeInStyles,
          ":hover:after": cellSizerFadeInStyles
        }, _c2["&." + classNames2.isResizing + ":after"] = [
          cellSizerFadeInStyles,
          {
            boxShadow: "0 0 5px 0 rgba(0, 0, 0, 0.4)"
          }
        ], _c2)
      }
    ],
    cellIsResizing: classNames2.isResizing,
    cellSizerStart: {
      margin: "0 -8px"
    },
    cellSizerEnd: {
      margin: 0,
      marginLeft: -16
    },
    collapseButton: [
      classNames2.collapseButton,
      {
        transformOrigin: "50% 50%",
        transition: "transform .1s linear"
      },
      isAllCollapsed ? [
        classNames2.isCollapsed,
        {
          transform: "rotate(0deg)"
        }
      ] : {
        transform: getRTL(theme) ? "rotate(-90deg)" : "rotate(90deg)"
      }
    ],
    checkTooltip: classNames2.checkTooltip,
    sizingOverlay: isSizing && {
      position: "absolute",
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      cursor: "ew-resize",
      background: "rgba(255, 255, 255, 0)",
      selectors: (_d2 = {}, _d2[HighContrastSelector] = __assign$1({ background: "transparent" }, getHighContrastNoAdjustStyle()), _d2)
    },
    accessibleLabel: hiddenContentStyle,
    dropHintCircleStyle: [
      classNames2.dropHintCircleStyle,
      {
        display: "inline-block",
        visibility: "hidden",
        position: "absolute",
        bottom: 0,
        height: 9,
        width: 9,
        borderRadius: "50%",
        marginLeft: -5,
        top: 34,
        overflow: "visible",
        zIndex: 10,
        border: "1px solid " + palette.themePrimary,
        background: palette.white
      }
    ],
    dropHintCaretStyle: [
      classNames2.dropHintCaretStyle,
      {
        display: "none",
        position: "absolute",
        top: -28,
        left: -6.5,
        fontSize: fonts.medium.fontSize,
        color: palette.themePrimary,
        overflow: "visible",
        zIndex: 10
      }
    ],
    dropHintLineStyle: [
      classNames2.dropHintLineStyle,
      {
        display: "none",
        position: "absolute",
        bottom: 0,
        top: 0,
        overflow: "hidden",
        height: 42,
        width: 1,
        background: palette.themePrimary,
        zIndex: 10
      }
    ],
    dropHintStyle: {
      display: "inline-block",
      position: "absolute"
    }
  };
};
var GlobalClassNames$n = {
  root: "ms-DetailsRow-check",
  isDisabled: "ms-DetailsRow-check--isDisabled",
  isHeader: "ms-DetailsRow-check--isHeader"
};
var CHECK_CELL_WIDTH = 48;
var getDetailsRowCheckStyles = function(props) {
  var theme = props.theme, className = props.className, isHeader = props.isHeader, selected = props.selected, anySelected = props.anySelected, canSelect = props.canSelect, compact = props.compact, isVisible = props.isVisible;
  var classNames2 = getGlobalClassNames(GlobalClassNames$n, theme);
  var rowHeight = DEFAULT_ROW_HEIGHTS.rowHeight, compactRowHeight = DEFAULT_ROW_HEIGHTS.compactRowHeight;
  var height = isHeader ? HEADER_HEIGHT : compact ? compactRowHeight : rowHeight;
  var isCheckVisible = isVisible || selected || anySelected;
  return {
    root: [classNames2.root, className],
    check: [
      !canSelect && classNames2.isDisabled,
      isHeader && classNames2.isHeader,
      getFocusStyle(theme),
      theme.fonts.small,
      CheckGlobalClassNames.checkHost,
      {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        cursor: "default",
        boxSizing: "border-box",
        verticalAlign: "top",
        background: "none",
        backgroundColor: "transparent",
        border: "none",
        opacity: isCheckVisible ? 1 : 0,
        height,
        width: CHECK_CELL_WIDTH,
        padding: 0,
        margin: 0
      }
    ],
    isDisabled: []
  };
};
var GlobalClassNames$m = {
  root: "ms-GroupHeader",
  compact: "ms-GroupHeader--compact",
  check: "ms-GroupHeader-check",
  dropIcon: "ms-GroupHeader-dropIcon",
  expand: "ms-GroupHeader-expand",
  isCollapsed: "is-collapsed",
  title: "ms-GroupHeader-title",
  isSelected: "is-selected",
  iconTag: "ms-Icon--Tag",
  group: "ms-GroupedList-group",
  isDropping: "is-dropping"
};
var beziers = {
  easeOutCirc: "cubic-bezier(0.075, 0.820, 0.165, 1.000)",
  easeOutSine: "cubic-bezier(0.390, 0.575, 0.565, 1.000)",
  easeInBack: "cubic-bezier(0.600, -0.280, 0.735, 0.045)"
};
var DEFAULT_GROUP_HEADER_HEIGHT = 48;
var COMPACT_GROUP_HEADER_HEIGHT = 40;
var getStyles$m = function(props) {
  var _a2, _b2, _c2, _d2, _e2;
  var theme = props.theme, className = props.className, selected = props.selected, isCollapsed = props.isCollapsed, compact = props.compact;
  var cellLeftPadding = DEFAULT_CELL_STYLE_PROPS.cellLeftPadding;
  var finalRowHeight = compact ? COMPACT_GROUP_HEADER_HEIGHT : DEFAULT_GROUP_HEADER_HEIGHT;
  var semanticColors = theme.semanticColors, palette = theme.palette, fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(GlobalClassNames$m, theme);
  var checkExpandResetStyles = [
    getFocusStyle(theme),
    {
      cursor: "default",
      background: "none",
      backgroundColor: "transparent",
      border: "none",
      padding: 0
      // cancel default <button> padding
    }
  ];
  return {
    root: [
      classNames2.root,
      getFocusStyle(theme),
      theme.fonts.medium,
      {
        // keep the border for height but color it so it's invisible.
        borderBottom: "1px solid " + semanticColors.listBackground,
        cursor: "default",
        userSelect: "none",
        selectors: (_a2 = {
          ":hover": {
            background: semanticColors.listItemBackgroundHovered,
            color: semanticColors.actionLinkHovered
          }
        }, _a2["&:hover ." + classNames2.check] = {
          opacity: 1
        }, _a2["." + IsFocusVisibleClassName + " &:focus ." + classNames2.check] = {
          opacity: 1
        }, _a2[":global(." + classNames2.group + "." + classNames2.isDropping + ")"] = {
          selectors: (_b2 = {}, _b2["& > ." + classNames2.root + " ." + classNames2.dropIcon] = {
            transition: "transform " + AnimationVariables.durationValue4 + " " + beziers.easeOutCirc + " " + ("opacity " + AnimationVariables.durationValue1 + " " + beziers.easeOutSine),
            transitionDelay: AnimationVariables.durationValue3,
            opacity: 1,
            transform: "rotate(0.2deg) scale(1);"
            // rotation prevents jittery motion in IE
          }, _b2["." + classNames2.check] = {
            opacity: 0
          }, _b2)
        }, _a2)
      },
      selected && [
        classNames2.isSelected,
        {
          background: semanticColors.listItemBackgroundChecked,
          selectors: (_c2 = {
            ":hover": {
              background: semanticColors.listItemBackgroundCheckedHovered
            }
          }, _c2["" + classNames2.check] = {
            opacity: 1
          }, _c2)
        }
      ],
      compact && [classNames2.compact, { border: "none" }],
      className
    ],
    groupHeaderContainer: [
      {
        display: "flex",
        alignItems: "center",
        height: finalRowHeight
      }
    ],
    headerCount: [
      {
        padding: "0px 4px"
      }
    ],
    check: [
      classNames2.check,
      checkExpandResetStyles,
      {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        // paddingTop and marginTop brought from the DetailsRow.styles.ts with explanation below.
        // Ensure that the check cell covers the top border of the cell.
        // This ensures the click target does not leave a spot which would
        // cause other items to be deselected.
        paddingTop: 1,
        marginTop: -1,
        opacity: 0,
        width: CHECK_CELL_WIDTH,
        height: finalRowHeight,
        selectors: (_d2 = {}, _d2["." + IsFocusVisibleClassName + " &:focus"] = {
          opacity: 1
        }, _d2)
      }
    ],
    expand: [
      classNames2.expand,
      checkExpandResetStyles,
      {
        display: "flex",
        flexShrink: 0,
        alignItems: "center",
        justifyContent: "center",
        fontSize: fonts.small.fontSize,
        width: SPACER_WIDTH,
        height: finalRowHeight,
        color: selected ? palette.neutralPrimary : palette.neutralSecondary,
        selectors: {
          ":hover": {
            backgroundColor: selected ? palette.neutralQuaternary : palette.neutralLight
          },
          ":active": {
            backgroundColor: selected ? palette.neutralTertiaryAlt : palette.neutralQuaternaryAlt
          }
        }
      }
    ],
    expandIsCollapsed: [
      isCollapsed ? [
        classNames2.isCollapsed,
        {
          transform: "rotate(0deg)",
          transformOrigin: "50% 50%",
          transition: "transform .1s linear"
        }
      ] : {
        transform: getRTL(theme) ? "rotate(-90deg)" : "rotate(90deg)",
        transformOrigin: "50% 50%",
        transition: "transform .1s linear"
      }
    ],
    title: [
      classNames2.title,
      {
        paddingLeft: cellLeftPadding,
        fontSize: compact ? fonts.medium.fontSize : fonts.mediumPlus.fontSize,
        fontWeight: isCollapsed ? FontWeights.regular : FontWeights.semibold,
        cursor: "pointer",
        outline: 0,
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden"
      }
    ],
    dropIcon: [
      classNames2.dropIcon,
      {
        position: "absolute",
        left: -26,
        fontSize: IconFontSizes.large,
        color: palette.neutralSecondary,
        transition: "transform " + AnimationVariables.durationValue2 + " " + beziers.easeInBack + ", " + ("opacity " + AnimationVariables.durationValue4 + " " + beziers.easeOutSine),
        opacity: 0,
        transform: "rotate(0.2deg) scale(0.65)",
        transformOrigin: "10px 10px",
        selectors: (_e2 = {}, _e2[":global(." + classNames2.iconTag + ")"] = {
          position: "absolute"
        }, _e2)
      }
    ]
  };
};
var SpinnerSize;
(function(SpinnerSize2) {
  SpinnerSize2[SpinnerSize2["xSmall"] = 0] = "xSmall";
  SpinnerSize2[SpinnerSize2["small"] = 1] = "small";
  SpinnerSize2[SpinnerSize2["medium"] = 2] = "medium";
  SpinnerSize2[SpinnerSize2["large"] = 3] = "large";
})(SpinnerSize || (SpinnerSize = {}));
var SpinnerType;
(function(SpinnerType2) {
  SpinnerType2[SpinnerType2["normal"] = 0] = "normal";
  SpinnerType2[SpinnerType2["large"] = 1] = "large";
})(SpinnerType || (SpinnerType = {}));
var getClassNames$t = classNamesFunction();
var SpinnerBase = (
  /** @class */
  function(_super) {
    __extends(SpinnerBase2, _super);
    function SpinnerBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SpinnerBase2.prototype.render = function() {
      var _a2 = this.props, type = _a2.type, size = _a2.size, ariaLabel = _a2.ariaLabel, ariaLive = _a2.ariaLive, styles2 = _a2.styles, label = _a2.label, theme = _a2.theme, className = _a2.className, labelPosition = _a2.labelPosition;
      var statusMessage = ariaLabel;
      var nativeProps = getNativeProps(this.props, divProperties, ["size"]);
      var styleSize = size;
      if (styleSize === void 0 && type !== void 0) {
        styleSize = type === SpinnerType.large ? SpinnerSize.large : SpinnerSize.medium;
      }
      var classNames2 = getClassNames$t(styles2, {
        theme,
        size: styleSize,
        className,
        labelPosition
      });
      return React__namespace.createElement(
        "div",
        __assign$1({}, nativeProps, { className: classNames2.root }),
        React__namespace.createElement("div", { className: classNames2.circle }),
        label && React__namespace.createElement("div", { className: classNames2.label }, label),
        statusMessage && React__namespace.createElement(
          "div",
          { role: "status", "aria-live": ariaLive },
          React__namespace.createElement(
            DelayedRender,
            null,
            React__namespace.createElement("div", { className: classNames2.screenReaderText }, statusMessage)
          )
        )
      );
    };
    SpinnerBase2.defaultProps = {
      size: SpinnerSize.medium,
      ariaLive: "polite",
      labelPosition: "bottom"
    };
    return SpinnerBase2;
  }(React__namespace.Component)
);
var GlobalClassNames$l = {
  root: "ms-Spinner",
  circle: "ms-Spinner-circle",
  label: "ms-Spinner-label"
};
var spinAnimation = memoizeFunction(function() {
  return keyframes$1({
    "0%": {
      transform: "rotate(0deg)"
    },
    "100%": {
      transform: "rotate(360deg)"
    }
  });
});
var getStyles$l = function(props) {
  var _a2;
  var theme = props.theme, size = props.size, className = props.className, labelPosition = props.labelPosition;
  var palette = theme.palette;
  var classNames2 = getGlobalClassNames(GlobalClassNames$l, theme);
  return {
    root: [
      classNames2.root,
      {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center"
      },
      labelPosition === "top" && {
        flexDirection: "column-reverse"
      },
      labelPosition === "right" && {
        flexDirection: "row"
      },
      labelPosition === "left" && {
        flexDirection: "row-reverse"
      },
      className
    ],
    circle: [
      classNames2.circle,
      {
        boxSizing: "border-box",
        borderRadius: "50%",
        border: "1.5px solid " + palette.themeLight,
        borderTopColor: palette.themePrimary,
        animationName: spinAnimation(),
        animationDuration: "1.3s",
        animationIterationCount: "infinite",
        animationTimingFunction: "cubic-bezier(.53,.21,.29,.67)",
        selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign$1({ borderTopColor: "Highlight" }, getHighContrastNoAdjustStyle()), _a2)
      },
      size === SpinnerSize.xSmall && [
        "ms-Spinner--xSmall",
        {
          width: 12,
          height: 12
        }
      ],
      size === SpinnerSize.small && [
        "ms-Spinner--small",
        {
          width: 16,
          height: 16
        }
      ],
      size === SpinnerSize.medium && [
        "ms-Spinner--medium",
        {
          width: 20,
          height: 20
        }
      ],
      size === SpinnerSize.large && [
        "ms-Spinner--large",
        {
          width: 28,
          height: 28
        }
      ]
    ],
    label: [
      classNames2.label,
      theme.fonts.small,
      {
        color: palette.themePrimary,
        margin: "8px 0 0",
        textAlign: "center"
      },
      labelPosition === "top" && {
        margin: "0 0 8px"
      },
      labelPosition === "right" && {
        margin: "0 0 0 8px"
      },
      labelPosition === "left" && {
        margin: "0 8px 0 0"
      }
    ],
    screenReaderText: hiddenContentStyle
  };
};
var Spinner = styled(SpinnerBase, getStyles$l, void 0, { scope: "Spinner" });
var getClassNames$s = classNamesFunction();
var GroupHeaderBase = (
  /** @class */
  function(_super) {
    __extends(GroupHeaderBase2, _super);
    function GroupHeaderBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._toggleCollapse = function() {
        var _a2 = _this.props, group = _a2.group, onToggleCollapse = _a2.onToggleCollapse, isGroupLoading = _a2.isGroupLoading;
        var isCollapsed = _this.state.isCollapsed;
        var newCollapsed = !isCollapsed;
        var newLoadingVisible = !newCollapsed && isGroupLoading && isGroupLoading(group);
        _this.setState({
          isCollapsed: newCollapsed,
          isLoadingVisible: newLoadingVisible
        });
        if (onToggleCollapse) {
          onToggleCollapse(group);
        }
      };
      _this._onKeyUp = function(ev) {
        var _a2 = _this.props, group = _a2.group, onGroupHeaderKeyUp = _a2.onGroupHeaderKeyUp;
        if (onGroupHeaderKeyUp) {
          onGroupHeaderKeyUp(ev, group);
        }
        if (!ev.defaultPrevented) {
          var shouldOpen = _this.state.isCollapsed && ev.which === getRTLSafeKeyCode(KeyCodes.right, _this.props.theme);
          var shouldClose = !_this.state.isCollapsed && ev.which === getRTLSafeKeyCode(KeyCodes.left, _this.props.theme);
          if (shouldClose || shouldOpen) {
            _this._toggleCollapse();
            ev.stopPropagation();
            ev.preventDefault();
          }
        }
      };
      _this._onToggleClick = function(ev) {
        _this._toggleCollapse();
        ev.stopPropagation();
        ev.preventDefault();
      };
      _this._onHeaderClick = function() {
        var _a2 = _this.props, group = _a2.group, onGroupHeaderClick = _a2.onGroupHeaderClick;
        if (onGroupHeaderClick) {
          onGroupHeaderClick(group);
        }
      };
      _this._onRenderTitle = function(props2) {
        var group = props2.group;
        if (!group) {
          return null;
        }
        var onRenderName = props2.onRenderName ? composeRenderFunction(props2.onRenderName, _this._onRenderName) : _this._onRenderName;
        return React__namespace.createElement("div", { className: _this._classNames.title, id: _this._id, onClick: _this._onHeaderClick, role: "gridcell", "aria-colspan": _this.props.ariaColSpan, "data-selection-invoke": true }, onRenderName(props2));
      };
      _this._onRenderName = function(props2) {
        var group = props2.group;
        if (!group) {
          return null;
        }
        return React__namespace.createElement(
          React__namespace.Fragment,
          null,
          React__namespace.createElement("span", null, group.name),
          React__namespace.createElement(
            "span",
            { className: _this._classNames.headerCount },
            "(",
            group.count,
            group.hasMoreData && "+",
            ")"
          )
        );
      };
      _this._id = getId("GroupHeader");
      _this.state = {
        isCollapsed: _this.props.group && _this.props.group.isCollapsed,
        isLoadingVisible: false
      };
      return _this;
    }
    GroupHeaderBase2.getDerivedStateFromProps = function(nextProps, previousState) {
      if (nextProps.group) {
        var newCollapsed = nextProps.group.isCollapsed;
        var isGroupLoading = nextProps.isGroupLoading;
        var newLoadingVisible = !newCollapsed && isGroupLoading && isGroupLoading(nextProps.group);
        return __assign$1(__assign$1({}, previousState), { isCollapsed: newCollapsed || false, isLoadingVisible: newLoadingVisible || false });
      }
      return previousState;
    };
    GroupHeaderBase2.prototype.render = function() {
      var _a2 = this.props, group = _a2.group, _b2 = _a2.groupLevel, groupLevel = _b2 === void 0 ? 0 : _b2, viewport = _a2.viewport, selectionMode = _a2.selectionMode, loadingText = _a2.loadingText, _c2 = _a2.isSelected, isSelected = _c2 === void 0 ? false : _c2, _d2 = _a2.selected, selected = _d2 === void 0 ? false : _d2, indentWidth = _a2.indentWidth, onRenderGroupHeaderCheckbox = _a2.onRenderGroupHeaderCheckbox, _e2 = _a2.isCollapsedGroupSelectVisible, isCollapsedGroupSelectVisible = _e2 === void 0 ? true : _e2, expandButtonProps = _a2.expandButtonProps, expandButtonIcon = _a2.expandButtonIcon, selectAllButtonProps = _a2.selectAllButtonProps, theme = _a2.theme, styles2 = _a2.styles, className = _a2.className, compact = _a2.compact, ariaLevel = _a2.ariaLevel, ariaPosInSet = _a2.ariaPosInSet, ariaSetSize = _a2.ariaSetSize, ariaRowIndex = _a2.ariaRowIndex, useFastIcons = _a2.useFastIcons;
      var onRenderTitle = this.props.onRenderTitle ? composeRenderFunction(this.props.onRenderTitle, this._onRenderTitle) : this._onRenderTitle;
      var defaultCheckboxRender = useFastIcons ? this._fastDefaultCheckboxRender : this._defaultCheckboxRender;
      var onRenderCheckbox = onRenderGroupHeaderCheckbox ? composeRenderFunction(onRenderGroupHeaderCheckbox, defaultCheckboxRender) : defaultCheckboxRender;
      var _f = this.state, isCollapsed = _f.isCollapsed, isLoadingVisible = _f.isLoadingVisible;
      var canSelectGroup = selectionMode === SelectionMode.multiple;
      var isSelectionCheckVisible = canSelectGroup && (isCollapsedGroupSelectVisible || !(group && group.isCollapsed));
      var currentlySelected = selected || isSelected;
      var isRTL = getRTL(theme);
      this._classNames = getClassNames$s(styles2, {
        theme,
        className,
        selected: currentlySelected,
        isCollapsed,
        compact
      });
      if (!group) {
        return null;
      }
      return React__namespace.createElement(
        "div",
        { className: this._classNames.root, style: viewport ? { minWidth: viewport.width } : {}, role: "row", "aria-level": ariaLevel, "aria-setsize": ariaSetSize, "aria-posinset": ariaPosInSet, "aria-rowindex": ariaRowIndex, "data-is-focusable": true, onKeyUp: this._onKeyUp, "aria-label": group.ariaLabel, "aria-labelledby": group.ariaLabel ? void 0 : this._id, "aria-expanded": !this.state.isCollapsed, "aria-selected": canSelectGroup ? currentlySelected : void 0, "data-selection-index": group.startIndex, "data-selection-span": group.count },
        React__namespace.createElement(
          "div",
          { className: this._classNames.groupHeaderContainer, role: "presentation" },
          isSelectionCheckVisible ? React__namespace.createElement(
            "div",
            { role: "gridcell" },
            React__namespace.createElement("button", __assign$1({ "data-is-focusable": false, type: "button", className: this._classNames.check, role: "checkbox", id: this._id + "-check", "aria-checked": currentlySelected, "aria-labelledby": this._id + "-check " + this._id, "data-selection-toggle": true }, selectAllButtonProps), onRenderCheckbox({ checked: currentlySelected, theme }, onRenderCheckbox))
          ) : (
            // To make the group header align properly with the column headers, this spacer
            // needs to be the same width as the check cell in the column header.
            selectionMode !== SelectionMode.none && React__namespace.createElement(GroupSpacer, { indentWidth: CHECK_CELL_WIDTH, count: 1 })
          ),
          React__namespace.createElement(GroupSpacer, { indentWidth, count: groupLevel }),
          React__namespace.createElement(
            "div",
            { className: this._classNames.dropIcon, role: "presentation" },
            React__namespace.createElement(Icon, { iconName: "Tag" })
          ),
          React__namespace.createElement(
            "div",
            { role: "gridcell" },
            React__namespace.createElement(
              "button",
              __assign$1({ "data-is-focusable": false, "data-selection-disabled": true, type: "button", className: this._classNames.expand, onClick: this._onToggleClick, "aria-expanded": !this.state.isCollapsed }, expandButtonProps),
              React__namespace.createElement(Icon, { className: this._classNames.expandIsCollapsed, iconName: expandButtonIcon || (isRTL ? "ChevronLeftMed" : "ChevronRightMed") })
            )
          ),
          onRenderTitle(this.props),
          isLoadingVisible && React__namespace.createElement(Spinner, { label: loadingText })
        )
      );
    };
    GroupHeaderBase2.prototype._defaultCheckboxRender = function(checkboxProps) {
      return React__namespace.createElement(Check, { checked: checkboxProps.checked });
    };
    GroupHeaderBase2.prototype._fastDefaultCheckboxRender = function(checkboxProps) {
      return React__namespace.createElement(FastCheck$1, { theme: checkboxProps.theme, checked: checkboxProps.checked });
    };
    GroupHeaderBase2.defaultProps = {
      expandButtonProps: { "aria-label": "expand collapse group" }
    };
    return GroupHeaderBase2;
  }(React__namespace.Component)
);
var FastCheck$1 = React__namespace.memo(function(props) {
  return React__namespace.createElement(Check, { theme: props.theme, checked: props.checked, className: props.className, useFastIcons: true });
});
var GroupHeader = styled(GroupHeaderBase, getStyles$m, void 0, {
  scope: "GroupHeader"
});
var GlobalClassNames$k = {
  root: "ms-GroupShowAll",
  link: "ms-Link"
};
var getStyles$k = function(props) {
  var _a2;
  var theme = props.theme;
  var fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(GlobalClassNames$k, theme);
  return {
    root: [
      classNames2.root,
      {
        position: "relative",
        padding: "10px 84px",
        cursor: "pointer",
        selectors: (_a2 = {}, _a2["." + classNames2.link] = {
          fontSize: fonts.small.fontSize
        }, _a2)
      }
    ]
  };
};
var getClassNames$r = classNamesFunction();
var GroupShowAllBase = function(props) {
  var group = props.group, groupLevel = props.groupLevel, _a2 = props.showAllLinkText, showAllLinkText = _a2 === void 0 ? "Show All" : _a2, styles2 = props.styles, theme = props.theme, onToggleSummarize = props.onToggleSummarize;
  var classNames2 = getClassNames$r(styles2, { theme });
  var memoizedOnClick = React.useCallback(function(ev) {
    onToggleSummarize(group);
    ev.stopPropagation();
    ev.preventDefault();
  }, [onToggleSummarize, group]);
  if (group) {
    return React__namespace.createElement(
      "div",
      { className: classNames2.root },
      React__namespace.createElement(GroupSpacer, { count: groupLevel }),
      React__namespace.createElement(Link, { onClick: memoizedOnClick }, showAllLinkText)
    );
  }
  return null;
};
var GroupShowAll = styled(GroupShowAllBase, getStyles$k, void 0, { scope: "GroupShowAll" });
var GlobalClassNames$j = {
  root: "ms-groupFooter"
};
var getStyles$j = function(props) {
  var theme = props.theme, className = props.className;
  var classNames2 = getGlobalClassNames(GlobalClassNames$j, theme);
  return {
    root: [
      theme.fonts.medium,
      classNames2.root,
      {
        position: "relative",
        padding: "5px 38px"
      },
      className
    ]
  };
};
var getClassNames$q = classNamesFunction();
var GroupFooterBase = function(props) {
  var group = props.group, groupLevel = props.groupLevel, footerText = props.footerText, indentWidth = props.indentWidth, styles2 = props.styles, theme = props.theme;
  var classNames2 = getClassNames$q(styles2, { theme });
  if (group && footerText) {
    return React__namespace.createElement(
      "div",
      { className: classNames2.root },
      React__namespace.createElement(GroupSpacer, { indentWidth, count: groupLevel }),
      footerText
    );
  }
  return null;
};
var GroupFooter = styled(GroupFooterBase, getStyles$j, void 0, {
  scope: "GroupFooter"
});
var DEFAULT_DROPPING_CSS_CLASS$1 = "is-dropping";
var GroupedListSection = (
  /** @class */
  function(_super) {
    __extends(GroupedListSection2, _super);
    function GroupedListSection2(props) {
      var _this = _super.call(this, props) || this;
      _this._root = React__namespace.createRef();
      _this._list = React__namespace.createRef();
      _this._subGroupRefs = {};
      _this._droppingClassName = "";
      _this._onRenderGroupHeader = function(props2) {
        return React__namespace.createElement(GroupHeader, __assign$1({}, props2));
      };
      _this._onRenderGroupShowAll = function(props2) {
        return React__namespace.createElement(GroupShowAll, __assign$1({}, props2));
      };
      _this._onRenderGroupFooter = function(props2) {
        return React__namespace.createElement(GroupFooter, __assign$1({}, props2));
      };
      _this._renderSubGroup = function(subGroup, subGroupIndex) {
        var _a2 = _this.props, dragDropEvents = _a2.dragDropEvents, dragDropHelper = _a2.dragDropHelper, eventsToRegister = _a2.eventsToRegister, getGroupItemLimit = _a2.getGroupItemLimit, groupNestingDepth = _a2.groupNestingDepth, groupProps = _a2.groupProps, items = _a2.items, headerProps = _a2.headerProps, showAllProps = _a2.showAllProps, footerProps = _a2.footerProps, listProps = _a2.listProps, onRenderCell = _a2.onRenderCell, selection2 = _a2.selection, selectionMode = _a2.selectionMode, viewport = _a2.viewport, onRenderGroupHeader = _a2.onRenderGroupHeader, onRenderGroupShowAll = _a2.onRenderGroupShowAll, onRenderGroupFooter = _a2.onRenderGroupFooter, onShouldVirtualize = _a2.onShouldVirtualize, group2 = _a2.group, compact = _a2.compact;
        var nestingDepth = subGroup.level ? subGroup.level + 1 : groupNestingDepth;
        return !subGroup || subGroup.count > 0 || groupProps && groupProps.showEmptyGroups ? React__namespace.createElement(GroupedListSection2, { ref: function(ref) {
          return _this._subGroupRefs["subGroup_" + subGroupIndex] = ref;
        }, key: _this._getGroupKey(subGroup, subGroupIndex), dragDropEvents, dragDropHelper, eventsToRegister, footerProps, getGroupItemLimit, group: subGroup, groupIndex: subGroupIndex, groupNestingDepth: nestingDepth, groupProps, headerProps, items, listProps, onRenderCell, selection: selection2, selectionMode, showAllProps, viewport, onRenderGroupHeader, onRenderGroupShowAll, onRenderGroupFooter, onShouldVirtualize, groups: group2 ? group2.children : [], compact }) : null;
      };
      _this._getGroupDragDropOptions = function() {
        var _a2 = _this.props, group2 = _a2.group, groupIndex = _a2.groupIndex, dragDropEvents = _a2.dragDropEvents, eventsToRegister = _a2.eventsToRegister;
        var options2 = {
          eventMap: eventsToRegister,
          selectionIndex: -1,
          context: { data: group2, index: groupIndex, isGroup: true },
          updateDropState: _this._updateDroppingState,
          canDrag: dragDropEvents.canDrag,
          canDrop: dragDropEvents.canDrop,
          onDrop: dragDropEvents.onDrop,
          onDragStart: dragDropEvents.onDragStart,
          onDragEnter: dragDropEvents.onDragEnter,
          onDragLeave: dragDropEvents.onDragLeave,
          onDragEnd: dragDropEvents.onDragEnd,
          onDragOver: dragDropEvents.onDragOver
        };
        return options2;
      };
      _this._updateDroppingState = function(newIsDropping, event) {
        var isDropping = _this.state.isDropping;
        var _a2 = _this.props, dragDropEvents = _a2.dragDropEvents, group2 = _a2.group;
        if (isDropping !== newIsDropping) {
          if (isDropping) {
            if (dragDropEvents && dragDropEvents.onDragLeave) {
              dragDropEvents.onDragLeave(group2, event);
            }
          } else {
            if (dragDropEvents && dragDropEvents.onDragEnter) {
              _this._droppingClassName = dragDropEvents.onDragEnter(group2, event);
            }
          }
          _this.setState({ isDropping: newIsDropping });
        }
      };
      var selection = props.selection, group = props.group;
      initializeComponentRef(_this);
      _this._id = getId("GroupedListSection");
      _this.state = {
        isDropping: false,
        isSelected: selection && group ? selection.isRangeSelected(group.startIndex, group.count) : false
      };
      _this._events = new EventGroup(_this);
      return _this;
    }
    GroupedListSection2.prototype.componentDidMount = function() {
      var _a2 = this.props, dragDropHelper = _a2.dragDropHelper, selection = _a2.selection;
      if (dragDropHelper && this._root.current) {
        this._dragDropSubscription = dragDropHelper.subscribe(this._root.current, this._events, this._getGroupDragDropOptions());
      }
      if (selection) {
        this._events.on(selection, SELECTION_CHANGE, this._onSelectionChange);
      }
    };
    GroupedListSection2.prototype.componentWillUnmount = function() {
      this._events.dispose();
      if (this._dragDropSubscription) {
        this._dragDropSubscription.dispose();
      }
    };
    GroupedListSection2.prototype.componentDidUpdate = function(previousProps) {
      if (this.props.group !== previousProps.group || this.props.groupIndex !== previousProps.groupIndex || this.props.dragDropHelper !== previousProps.dragDropHelper) {
        if (this._dragDropSubscription) {
          this._dragDropSubscription.dispose();
          delete this._dragDropSubscription;
        }
        if (this.props.dragDropHelper && this._root.current) {
          this._dragDropSubscription = this.props.dragDropHelper.subscribe(this._root.current, this._events, this._getGroupDragDropOptions());
        }
      }
    };
    GroupedListSection2.prototype.render = function() {
      var _a2 = this.props, getGroupItemLimit = _a2.getGroupItemLimit, group = _a2.group, groupIndex = _a2.groupIndex, headerProps = _a2.headerProps, showAllProps = _a2.showAllProps, footerProps = _a2.footerProps, viewport = _a2.viewport, selectionMode = _a2.selectionMode, _b2 = _a2.onRenderGroupHeader, onRenderGroupHeader = _b2 === void 0 ? this._onRenderGroupHeader : _b2, _c2 = _a2.onRenderGroupShowAll, onRenderGroupShowAll = _c2 === void 0 ? this._onRenderGroupShowAll : _c2, _d2 = _a2.onRenderGroupFooter, onRenderGroupFooter = _d2 === void 0 ? this._onRenderGroupFooter : _d2, onShouldVirtualize = _a2.onShouldVirtualize, groupedListClassNames = _a2.groupedListClassNames, groups = _a2.groups, compact = _a2.compact, _e2 = _a2.listProps, listProps = _e2 === void 0 ? {} : _e2;
      var isSelected = this.state.isSelected;
      var renderCount = group && getGroupItemLimit ? getGroupItemLimit(group) : Infinity;
      var isShowAllVisible = group && !group.children && !group.isCollapsed && !group.isShowingAll && (group.count > renderCount || group.hasMoreData);
      var hasNestedGroups = group && group.children && group.children.length > 0;
      var version = listProps.version;
      var dividerProps = {
        group,
        groupIndex,
        groupLevel: group ? group.level : 0,
        isSelected,
        selected: isSelected,
        viewport,
        selectionMode,
        groups,
        compact
      };
      var ariaControlsProps = {
        groupedListId: this._id,
        ariaLevel: (group === null || group === void 0 ? void 0 : group.level) ? group.level + 1 : 1,
        ariaSetSize: groups ? groups.length : void 0,
        ariaPosInSet: groupIndex !== void 0 ? groupIndex + 1 : void 0
      };
      var groupHeaderProps = __assign$1(__assign$1(__assign$1({}, headerProps), dividerProps), ariaControlsProps);
      var groupShowAllProps = __assign$1(__assign$1({}, showAllProps), dividerProps);
      var groupFooterProps = __assign$1(__assign$1({}, footerProps), dividerProps);
      var isDraggable = !!this.props.dragDropHelper && this._getGroupDragDropOptions().canDrag(group) && !!this.props.dragDropEvents.canDragGroups;
      return React__namespace.createElement(
        "div",
        __assign$1({ ref: this._root }, isDraggable && { draggable: true }, { className: css$3(groupedListClassNames && groupedListClassNames.group, this._getDroppingClassName()), role: "presentation" }),
        onRenderGroupHeader(groupHeaderProps, this._onRenderGroupHeader),
        group && group.isCollapsed ? null : hasNestedGroups ? React__namespace.createElement(List, { role: "presentation", ref: this._list, items: group ? group.children : [], onRenderCell: this._renderSubGroup, getItemCountForPage: this._returnOne, onShouldVirtualize, version, id: this._id }) : this._onRenderGroup(renderCount),
        group && group.isCollapsed ? null : isShowAllVisible && onRenderGroupShowAll(groupShowAllProps, this._onRenderGroupShowAll),
        onRenderGroupFooter(groupFooterProps, this._onRenderGroupFooter)
      );
    };
    GroupedListSection2.prototype.forceUpdate = function() {
      _super.prototype.forceUpdate.call(this);
      this.forceListUpdate();
    };
    GroupedListSection2.prototype.forceListUpdate = function() {
      var group = this.props.group;
      if (this._list.current) {
        this._list.current.forceUpdate();
        if (group && group.children && group.children.length > 0) {
          var subGroupCount = group.children.length;
          for (var i = 0; i < subGroupCount; i++) {
            var subGroup = this._list.current.pageRefs["subGroup_" + String(i)];
            if (subGroup) {
              subGroup.forceListUpdate();
            }
          }
        }
      } else {
        var subGroup = this._subGroupRefs["subGroup_" + String(0)];
        if (subGroup) {
          subGroup.forceListUpdate();
        }
      }
    };
    GroupedListSection2.prototype._onSelectionChange = function() {
      var _a2 = this.props, group = _a2.group, selection = _a2.selection;
      if (selection && group) {
        var isSelected = selection.isRangeSelected(group.startIndex, group.count);
        if (isSelected !== this.state.isSelected) {
          this.setState({ isSelected });
        }
      }
    };
    GroupedListSection2.prototype._onRenderGroupCell = function(onRenderCell, groupNestingDepth, group) {
      return function(item, itemIndex) {
        return onRenderCell(groupNestingDepth, item, itemIndex, group);
      };
    };
    GroupedListSection2.prototype._onRenderGroup = function(renderCount) {
      var _a2 = this.props, group = _a2.group, items = _a2.items, onRenderCell = _a2.onRenderCell, listProps = _a2.listProps, groupNestingDepth = _a2.groupNestingDepth, onShouldVirtualize = _a2.onShouldVirtualize, groupProps = _a2.groupProps;
      var count = group && !group.isShowingAll ? group.count : items.length;
      var startIndex = group ? group.startIndex : 0;
      return React__namespace.createElement(List, __assign$1({ role: groupProps && groupProps.role ? groupProps.role : "rowgroup", "aria-label": group === null || group === void 0 ? void 0 : group.name, items, onRenderCell: this._onRenderGroupCell(onRenderCell, groupNestingDepth, group), ref: this._list, renderCount: Math.min(count, renderCount), startIndex, onShouldVirtualize, id: this._id }, listProps));
    };
    GroupedListSection2.prototype._returnOne = function() {
      return 1;
    };
    GroupedListSection2.prototype._getGroupKey = function(group, index2) {
      return "group-" + (group && group.key ? group.key : String(group.level) + String(index2));
    };
    GroupedListSection2.prototype._getDroppingClassName = function() {
      var isDropping = this.state.isDropping;
      var _a2 = this.props, group = _a2.group, groupedListClassNames = _a2.groupedListClassNames;
      isDropping = !!(group && isDropping);
      return css$3(isDropping && this._droppingClassName, isDropping && DEFAULT_DROPPING_CSS_CLASS$1, isDropping && groupedListClassNames && groupedListClassNames.groupIsDropping);
    };
    return GroupedListSection2;
  }(React__namespace.Component)
);
var getClassNames$p = classNamesFunction();
var ROW_HEIGHT = DEFAULT_ROW_HEIGHTS.rowHeight, COMPACT_ROW_HEIGHT = DEFAULT_ROW_HEIGHTS.compactRowHeight;
var GroupedListBase = (
  /** @class */
  function(_super) {
    __extends(GroupedListBase2, _super);
    function GroupedListBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._list = React__namespace.createRef();
      _this._renderGroup = function(group, groupIndex) {
        var _a3 = _this.props, dragDropEvents = _a3.dragDropEvents, dragDropHelper = _a3.dragDropHelper, eventsToRegister = _a3.eventsToRegister, groupProps = _a3.groupProps, items = _a3.items, listProps = _a3.listProps, onRenderCell = _a3.onRenderCell, selectionMode = _a3.selectionMode, selection = _a3.selection, viewport = _a3.viewport, onShouldVirtualize = _a3.onShouldVirtualize, groups = _a3.groups, compact = _a3.compact;
        var dividerProps = {
          onToggleSelectGroup: _this._onToggleSelectGroup,
          onToggleCollapse: _this._onToggleCollapse,
          onToggleSummarize: _this._onToggleSummarize
        };
        var headerProps = __assign$1(__assign$1({}, groupProps.headerProps), dividerProps);
        var showAllProps = __assign$1(__assign$1({}, groupProps.showAllProps), dividerProps);
        var footerProps = __assign$1(__assign$1({}, groupProps.footerProps), dividerProps);
        var groupNestingDepth = _this._getGroupNestingDepth();
        if (!groupProps.showEmptyGroups && group && group.count === 0) {
          return null;
        }
        var finalListProps = __assign$1(__assign$1({}, listProps || {}), { version: _this.state.version });
        return React__namespace.createElement(GroupedListSection, { key: _this._getGroupKey(group, groupIndex), dragDropEvents, dragDropHelper, eventsToRegister, footerProps, getGroupItemLimit: groupProps && groupProps.getGroupItemLimit, group, groupIndex, groupNestingDepth, groupProps, headerProps, listProps: finalListProps, items, onRenderCell, onRenderGroupHeader: groupProps.onRenderHeader, onRenderGroupShowAll: groupProps.onRenderShowAll, onRenderGroupFooter: groupProps.onRenderFooter, selectionMode, selection, showAllProps, viewport, onShouldVirtualize, groupedListClassNames: _this._classNames, groups, compact });
      };
      _this._getDefaultGroupItemLimit = function(group) {
        return group.children && group.children.length > 0 ? group.children.length : group.count;
      };
      _this._getGroupItemLimit = function(group) {
        var groupProps = _this.props.groupProps;
        var getGroupItemLimit = groupProps && groupProps.getGroupItemLimit ? groupProps.getGroupItemLimit : _this._getDefaultGroupItemLimit;
        return getGroupItemLimit(group);
      };
      _this._getGroupHeight = function(group) {
        var rowHeight = _this.props.compact ? COMPACT_ROW_HEIGHT : ROW_HEIGHT;
        return rowHeight + (group.isCollapsed ? 0 : rowHeight * _this._getGroupItemLimit(group));
      };
      _this._getPageHeight = function(itemIndex) {
        var groups = _this.state.groups;
        var _a3 = _this.props.getGroupHeight, getGroupHeight = _a3 === void 0 ? _this._getGroupHeight : _a3;
        var pageGroup = groups && groups[itemIndex];
        if (pageGroup) {
          return getGroupHeight(pageGroup, itemIndex);
        } else {
          return 0;
        }
      };
      _this._onToggleCollapse = function(group) {
        var groupProps = _this.props.groupProps;
        var onToggleCollapse = groupProps && groupProps.headerProps && groupProps.headerProps.onToggleCollapse;
        if (group) {
          if (onToggleCollapse) {
            onToggleCollapse(group);
          }
          group.isCollapsed = !group.isCollapsed;
          _this._updateIsSomeGroupExpanded();
          _this.forceUpdate();
        }
      };
      _this._onToggleSelectGroup = function(group) {
        var _a3 = _this.props, selection = _a3.selection, selectionMode = _a3.selectionMode;
        if (group && selection && selectionMode === SelectionMode.multiple) {
          selection.toggleRangeSelected(group.startIndex, group.count);
        }
      };
      _this._isInnerZoneKeystroke = function(ev) {
        return ev.which === getRTLSafeKeyCode(KeyCodes.right);
      };
      _this._onToggleSummarize = function(group) {
        var groupProps = _this.props.groupProps;
        var onToggleSummarize = groupProps && groupProps.showAllProps && groupProps.showAllProps.onToggleSummarize;
        if (onToggleSummarize) {
          onToggleSummarize(group);
        } else {
          if (group) {
            group.isShowingAll = !group.isShowingAll;
          }
          _this.forceUpdate();
        }
      };
      _this._getPageSpecification = function(itemIndex) {
        var groups = _this.state.groups;
        var pageGroup = groups && groups[itemIndex];
        return {
          key: pageGroup && pageGroup.key
        };
      };
      initializeComponentRef(_this);
      _this._isSomeGroupExpanded = _this._computeIsSomeGroupExpanded(props.groups);
      var _a2 = props.listProps, _b2 = _a2 === void 0 ? {} : _a2, _c2 = _b2.version, version = _c2 === void 0 ? {} : _c2;
      _this.state = {
        groups: props.groups,
        items: props.items,
        listProps: props.listProps,
        version
      };
      return _this;
    }
    GroupedListBase2.getDerivedStateFromProps = function(nextProps, previousState) {
      var groups = nextProps.groups, selectionMode = nextProps.selectionMode, compact = nextProps.compact, items = nextProps.items, listProps = nextProps.listProps;
      var listVersion = listProps && listProps.version;
      var nextState = __assign$1(__assign$1({}, previousState), { selectionMode, compact, groups, listProps, items });
      var shouldForceUpdates = false;
      var previousListVersion = previousState.listProps && previousState.listProps.version;
      if (listVersion !== previousListVersion || items !== previousState.items || groups !== previousState.groups || selectionMode !== previousState.selectionMode || compact !== previousState.compact) {
        shouldForceUpdates = true;
      }
      if (shouldForceUpdates) {
        nextState = __assign$1(__assign$1({}, nextState), { version: {} });
      }
      return nextState;
    };
    GroupedListBase2.prototype.scrollToIndex = function(index2, measureItem, scrollToMode) {
      if (this._list.current) {
        this._list.current.scrollToIndex(index2, measureItem, scrollToMode);
      }
    };
    GroupedListBase2.prototype.getStartItemIndexInView = function() {
      return this._list.current.getStartItemIndexInView() || 0;
    };
    GroupedListBase2.prototype.componentDidMount = function() {
      var _a2 = this.props, groupProps = _a2.groupProps, _b2 = _a2.groups, groups = _b2 === void 0 ? [] : _b2;
      if (groupProps && groupProps.isAllGroupsCollapsed) {
        this._setGroupsCollapsedState(groups, groupProps.isAllGroupsCollapsed);
      }
    };
    GroupedListBase2.prototype.render = function() {
      var _a2 = this.props, className = _a2.className, usePageCache = _a2.usePageCache, onShouldVirtualize = _a2.onShouldVirtualize, theme = _a2.theme, _b2 = _a2.role, role = _b2 === void 0 ? "treegrid" : _b2, styles2 = _a2.styles, compact = _a2.compact, _c2 = _a2.focusZoneProps, focusZoneProps = _c2 === void 0 ? {} : _c2, _d2 = _a2.rootListProps, rootListProps = _d2 === void 0 ? {} : _d2;
      var _e2 = this.state, groups = _e2.groups, version = _e2.version;
      this._classNames = getClassNames$p(styles2, {
        theme,
        className,
        compact
      });
      var _f = focusZoneProps.shouldEnterInnerZone, shouldEnterInnerZone = _f === void 0 ? this._isInnerZoneKeystroke : _f;
      return React__namespace.createElement(FocusZone, __assign$1({ direction: FocusZoneDirection.vertical, "data-automationid": "GroupedList", "data-is-scrollable": "false", role: "presentation" }, focusZoneProps, { shouldEnterInnerZone, className: css$3(this._classNames.root, focusZoneProps.className) }), !groups ? this._renderGroup(void 0, 0) : React__namespace.createElement(List, __assign$1({ ref: this._list, role, items: groups, onRenderCell: this._renderGroup, getItemCountForPage: this._returnOne, getPageHeight: this._getPageHeight, getPageSpecification: this._getPageSpecification, usePageCache, onShouldVirtualize, version }, rootListProps)));
    };
    GroupedListBase2.prototype.forceUpdate = function() {
      _super.prototype.forceUpdate.call(this);
      this._forceListUpdates();
    };
    GroupedListBase2.prototype.toggleCollapseAll = function(allCollapsed) {
      var _a2 = this.state.groups, groups = _a2 === void 0 ? [] : _a2;
      var groupProps = this.props.groupProps;
      var onToggleCollapseAll = groupProps && groupProps.onToggleCollapseAll;
      if (groups.length > 0) {
        if (onToggleCollapseAll) {
          onToggleCollapseAll(allCollapsed);
        }
        this._setGroupsCollapsedState(groups, allCollapsed);
        this._updateIsSomeGroupExpanded();
        this.forceUpdate();
      }
    };
    GroupedListBase2.prototype._setGroupsCollapsedState = function(groups, isCollapsed) {
      for (var groupIndex = 0; groupIndex < groups.length; groupIndex++) {
        groups[groupIndex].isCollapsed = isCollapsed;
      }
    };
    GroupedListBase2.prototype._returnOne = function() {
      return 1;
    };
    GroupedListBase2.prototype._getGroupKey = function(group, index2) {
      return "group-" + (group && group.key ? group.key : String(index2));
    };
    GroupedListBase2.prototype._getGroupNestingDepth = function() {
      var groups = this.state.groups;
      var level = 0;
      var groupsInLevel = groups;
      while (groupsInLevel && groupsInLevel.length > 0) {
        level++;
        groupsInLevel = groupsInLevel[0].children;
      }
      return level;
    };
    GroupedListBase2.prototype._forceListUpdates = function(groups) {
      this.setState({
        version: {}
      });
    };
    GroupedListBase2.prototype._computeIsSomeGroupExpanded = function(groups) {
      var _this = this;
      return !!(groups && groups.some(function(group) {
        return group.children ? _this._computeIsSomeGroupExpanded(group.children) : !group.isCollapsed;
      }));
    };
    GroupedListBase2.prototype._updateIsSomeGroupExpanded = function() {
      var groups = this.state.groups;
      var onGroupExpandStateChanged = this.props.onGroupExpandStateChanged;
      var newIsSomeGroupExpanded = this._computeIsSomeGroupExpanded(groups);
      if (this._isSomeGroupExpanded !== newIsSomeGroupExpanded) {
        if (onGroupExpandStateChanged) {
          onGroupExpandStateChanged(newIsSomeGroupExpanded);
        }
        this._isSomeGroupExpanded = newIsSomeGroupExpanded;
      }
    };
    GroupedListBase2.defaultProps = {
      selectionMode: SelectionMode.multiple,
      isHeaderVisible: true,
      groupProps: {},
      compact: false
    };
    return GroupedListBase2;
  }(React__namespace.Component)
);
var GroupedList = styled(GroupedListBase, getStyles$n, void 0, {
  scope: "GroupedList"
});
var GetGroupCount = function(groups) {
  var total = 0;
  if (groups) {
    var remainingGroups = __spreadArray([], groups);
    var currentGroup = void 0;
    while (remainingGroups && remainingGroups.length > 0) {
      ++total;
      currentGroup = remainingGroups.pop();
      if (currentGroup && currentGroup.children) {
        remainingGroups.push.apply(remainingGroups, currentGroup.children);
      }
    }
  }
  return total;
};
var getClassNames$o = classNamesFunction();
var DetailsRowCheckBase = function(props) {
  var _a2 = props.isVisible, isVisible = _a2 === void 0 ? false : _a2, _b2 = props.canSelect, canSelect = _b2 === void 0 ? false : _b2, _c2 = props.anySelected, anySelected = _c2 === void 0 ? false : _c2, _d2 = props.selected, selected = _d2 === void 0 ? false : _d2, selectionMode = props.selectionMode, _e2 = props.isHeader, isHeader = _e2 === void 0 ? false : _e2, className = props.className;
  props.checkClassName;
  var styles2 = props.styles, theme = props.theme, compact = props.compact, onRenderDetailsCheckbox = props.onRenderDetailsCheckbox, _f = props.useFastIcons, useFastIcons = _f === void 0 ? true : _f, buttonProps = __rest$1(props, ["isVisible", "canSelect", "anySelected", "selected", "selectionMode", "isHeader", "className", "checkClassName", "styles", "theme", "compact", "onRenderDetailsCheckbox", "useFastIcons"]);
  var defaultCheckboxRender = useFastIcons ? _fastDefaultCheckboxRender : _defaultCheckboxRender;
  var onRenderCheckbox = onRenderDetailsCheckbox ? composeRenderFunction(onRenderDetailsCheckbox, defaultCheckboxRender) : defaultCheckboxRender;
  var classNames2 = getClassNames$o(styles2, {
    theme,
    canSelect,
    selected,
    anySelected,
    className,
    isHeader,
    isVisible,
    compact
  });
  var detailsCheckboxProps = {
    checked: selected,
    theme
  };
  var divProps = getNativeElementProps("div", buttonProps, ["aria-label", "aria-labelledby", "aria-describedby"]);
  var checkRole = selectionMode === SelectionMode.single ? "radio" : "checkbox";
  return canSelect ? React__namespace.createElement("div", __assign$1({}, buttonProps, {
    role: checkRole,
    // eslint-disable-next-line deprecation/deprecation
    className: css$3(classNames2.root, classNames2.check),
    "aria-checked": selected,
    "data-selection-toggle": true,
    "data-automationid": "DetailsRowCheck",
    tabIndex: -1
  }), onRenderCheckbox(detailsCheckboxProps)) : (
    // eslint-disable-next-line deprecation/deprecation
    React__namespace.createElement("div", __assign$1({}, divProps, { className: css$3(classNames2.root, classNames2.check) }))
  );
};
var FastCheck = React__namespace.memo(function(props) {
  return React__namespace.createElement(Check, { theme: props.theme, checked: props.checked, className: props.className, useFastIcons: true });
});
function _defaultCheckboxRender(checkboxProps) {
  return React__namespace.createElement(Check, { checked: checkboxProps.checked });
}
function _fastDefaultCheckboxRender(checkboxProps) {
  return React__namespace.createElement(FastCheck, { theme: checkboxProps.theme, checked: checkboxProps.checked });
}
var DetailsRowCheck = styled(DetailsRowCheckBase, getDetailsRowCheckStyles, void 0, { scope: "DetailsRowCheck" }, true);
var MOUSEDOWN_PRIMARY_BUTTON$2 = 0;
var MOUSEMOVE_PRIMARY_BUTTON$1 = 1;
var DragDropHelper = (
  /** @class */
  function() {
    function DragDropHelper2(params) {
      this._selection = params.selection;
      this._dragEnterCounts = {};
      this._activeTargets = {};
      this._lastId = 0;
      this._initialized = false;
    }
    DragDropHelper2.prototype.dispose = function() {
      if (this._events) {
        this._events.dispose();
      }
    };
    DragDropHelper2.prototype.subscribe = function(root2, events, dragDropOptions) {
      var _this = this;
      if (!this._initialized) {
        this._events = new EventGroup(this);
        var doc = getDocument();
        if (doc) {
          this._events.on(doc.body, "mouseup", this._onMouseUp.bind(this), true);
          this._events.on(doc, "mouseup", this._onDocumentMouseUp.bind(this), true);
        }
        this._initialized = true;
      }
      var _a2 = dragDropOptions.key, key = _a2 === void 0 ? "" + ++this._lastId : _a2;
      var handlers = [];
      var onDragStart;
      var onDragLeave;
      var onDragEnter;
      var onDragEnd;
      var onDrop;
      var onDragOver;
      var onMouseDown;
      var isDraggable;
      var isDroppable;
      var activeTarget;
      if (dragDropOptions && root2) {
        var eventMap = dragDropOptions.eventMap, context = dragDropOptions.context, updateDropState_1 = dragDropOptions.updateDropState;
        var dragDropTarget = {
          root: root2,
          options: dragDropOptions,
          key
        };
        isDraggable = this._isDraggable(dragDropTarget);
        isDroppable = this._isDroppable(dragDropTarget);
        if (isDraggable || isDroppable) {
          if (eventMap) {
            for (var _i = 0, eventMap_1 = eventMap; _i < eventMap_1.length; _i++) {
              var event_1 = eventMap_1[_i];
              var handler = {
                callback: event_1.callback.bind(null, context),
                eventName: event_1.eventName
              };
              handlers.push(handler);
              this._events.on(root2, handler.eventName, handler.callback);
            }
          }
        }
        if (isDroppable) {
          onDragLeave = function(event) {
            if (!event.isHandled) {
              event.isHandled = true;
              _this._dragEnterCounts[key]--;
              if (_this._dragEnterCounts[key] === 0) {
                updateDropState_1(false, event);
              }
            }
          };
          onDragEnter = function(event) {
            event.preventDefault();
            if (!event.isHandled) {
              event.isHandled = true;
              _this._dragEnterCounts[key]++;
              if (_this._dragEnterCounts[key] === 1) {
                updateDropState_1(true, event);
              }
            }
          };
          onDragEnd = function(event) {
            _this._dragEnterCounts[key] = 0;
            updateDropState_1(false, event);
          };
          onDrop = function(event) {
            _this._dragEnterCounts[key] = 0;
            updateDropState_1(false, event);
            if (dragDropOptions.onDrop) {
              dragDropOptions.onDrop(dragDropOptions.context.data, event);
            }
          };
          onDragOver = function(event) {
            event.preventDefault();
            if (dragDropOptions.onDragOver) {
              dragDropOptions.onDragOver(dragDropOptions.context.data, event);
            }
          };
          this._dragEnterCounts[key] = 0;
          events.on(root2, "dragenter", onDragEnter);
          events.on(root2, "dragleave", onDragLeave);
          events.on(root2, "dragend", onDragEnd);
          events.on(root2, "drop", onDrop);
          events.on(root2, "dragover", onDragOver);
        }
        if (isDraggable) {
          onMouseDown = this._onMouseDown.bind(this, dragDropTarget);
          onDragEnd = this._onDragEnd.bind(this, dragDropTarget);
          onDragStart = function(event) {
            var options2 = dragDropOptions;
            if (options2 && options2.onDragStart) {
              options2.onDragStart(options2.context.data, options2.context.index, _this._selection.getSelection(), event);
            }
            _this._isDragging = true;
            if (event.dataTransfer) {
              event.dataTransfer.setData("id", root2.id);
            }
          };
          events.on(root2, "dragstart", onDragStart);
          events.on(root2, "mousedown", onMouseDown);
          events.on(root2, "dragend", onDragEnd);
        }
        activeTarget = {
          target: dragDropTarget,
          dispose: function() {
            if (_this._activeTargets[key] === activeTarget) {
              delete _this._activeTargets[key];
            }
            if (root2) {
              for (var _i2 = 0, handlers_1 = handlers; _i2 < handlers_1.length; _i2++) {
                var handler2 = handlers_1[_i2];
                _this._events.off(root2, handler2.eventName, handler2.callback);
              }
              if (isDroppable) {
                events.off(root2, "dragenter", onDragEnter);
                events.off(root2, "dragleave", onDragLeave);
                events.off(root2, "dragend", onDragEnd);
                events.off(root2, "dragover", onDragOver);
                events.off(root2, "drop", onDrop);
              }
              if (isDraggable) {
                events.off(root2, "dragstart", onDragStart);
                events.off(root2, "mousedown", onMouseDown);
                events.off(root2, "dragend", onDragEnd);
              }
            }
          }
        };
        this._activeTargets[key] = activeTarget;
      }
      return {
        key,
        dispose: function() {
          if (activeTarget) {
            activeTarget.dispose();
          }
        }
      };
    };
    DragDropHelper2.prototype.unsubscribe = function(root2, key) {
      var activeTarget = this._activeTargets[key];
      if (activeTarget) {
        activeTarget.dispose();
      }
    };
    DragDropHelper2.prototype._onDragEnd = function(target, event) {
      var options2 = target.options;
      if (options2.onDragEnd) {
        options2.onDragEnd(options2.context.data, event);
      }
    };
    DragDropHelper2.prototype._onMouseUp = function(event) {
      this._isDragging = false;
      if (this._dragData) {
        for (var _i = 0, _a2 = Object.keys(this._activeTargets); _i < _a2.length; _i++) {
          var key = _a2[_i];
          var activeTarget = this._activeTargets[key];
          if (activeTarget.target.root) {
            this._events.off(activeTarget.target.root, "mousemove");
            this._events.off(activeTarget.target.root, "mouseleave");
          }
        }
        if (this._dragData.dropTarget) {
          EventGroup.raise(this._dragData.dropTarget.root, "dragleave");
          EventGroup.raise(this._dragData.dropTarget.root, "drop");
        }
      }
      this._dragData = null;
    };
    DragDropHelper2.prototype._onDocumentMouseUp = function(event) {
      var doc = getDocument();
      if (doc && event.target === doc.documentElement) {
        this._onMouseUp(event);
      }
    };
    DragDropHelper2.prototype._onMouseMove = function(target, event) {
      var _a2 = event.buttons, buttons = _a2 === void 0 ? MOUSEMOVE_PRIMARY_BUTTON$1 : _a2;
      if (this._dragData && buttons !== MOUSEMOVE_PRIMARY_BUTTON$1) {
        this._onMouseUp(event);
        return;
      }
      var root2 = target.root, key = target.key;
      if (this._isDragging) {
        if (this._isDroppable(target)) {
          if (this._dragData) {
            if (this._dragData.dropTarget && this._dragData.dropTarget.key !== key && !this._isChild(root2, this._dragData.dropTarget.root)) {
              if (this._dragEnterCounts[this._dragData.dropTarget.key] > 0) {
                EventGroup.raise(this._dragData.dropTarget.root, "dragleave");
                EventGroup.raise(root2, "dragenter");
                this._dragData.dropTarget = target;
              }
            }
          }
        }
      }
    };
    DragDropHelper2.prototype._onMouseLeave = function(target, event) {
      if (this._isDragging) {
        if (this._dragData && this._dragData.dropTarget && this._dragData.dropTarget.key === target.key) {
          EventGroup.raise(target.root, "dragleave");
          this._dragData.dropTarget = void 0;
        }
      }
    };
    DragDropHelper2.prototype._onMouseDown = function(target, event) {
      if (event.button !== MOUSEDOWN_PRIMARY_BUTTON$2) {
        return;
      }
      if (this._isDraggable(target)) {
        this._dragData = {
          clientX: event.clientX,
          clientY: event.clientY,
          eventTarget: event.target,
          dragTarget: target
        };
        for (var _i = 0, _a2 = Object.keys(this._activeTargets); _i < _a2.length; _i++) {
          var key = _a2[_i];
          var activeTarget = this._activeTargets[key];
          if (activeTarget.target.root) {
            this._events.on(activeTarget.target.root, "mousemove", this._onMouseMove.bind(this, activeTarget.target));
            this._events.on(activeTarget.target.root, "mouseleave", this._onMouseLeave.bind(this, activeTarget.target));
          }
        }
      } else {
        this._dragData = null;
      }
    };
    DragDropHelper2.prototype._isChild = function(parentElement, childElement) {
      while (childElement && childElement.parentElement) {
        if (childElement.parentElement === parentElement) {
          return true;
        }
        childElement = childElement.parentElement;
      }
      return false;
    };
    DragDropHelper2.prototype._isDraggable = function(target) {
      var options2 = target.options;
      return !!(options2.canDrag && options2.canDrag(options2.context.data));
    };
    DragDropHelper2.prototype._isDroppable = function(target) {
      var options2 = target.options;
      var dragContext = this._dragData && this._dragData.dragTarget ? this._dragData.dragTarget.options.context : void 0;
      return !!(options2.canDrop && options2.canDrop(options2.context, dragContext));
    };
    return DragDropHelper2;
  }()
);
var MOUSEDOWN_PRIMARY_BUTTON$1 = 0;
var getClassNames$n = classNamesFunction();
var TRANSITION_DURATION_DRAG = 200;
var TRANSITION_DURATION_DROP = 1500;
var CLASSNAME_ADD_INTERVAL = 20;
var defaultOnRenderHeader = function(classNames2) {
  return function(props) {
    if (!props) {
      return null;
    }
    if (props.column.isIconOnly) {
      return React__namespace.createElement("span", { className: classNames2.accessibleLabel }, props.column.name);
    }
    return React__namespace.createElement(React__namespace.Fragment, null, props.column.name);
  };
};
var DetailsColumnBase = (
  /** @class */
  function(_super) {
    __extends(DetailsColumnBase2, _super);
    function DetailsColumnBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._root = React__namespace.createRef();
      _this._onRenderFilterIcon = function(classNames2) {
        return function(props2) {
          var columnProps = props2.columnProps, iconProps = __rest$1(props2, ["columnProps"]);
          var IconComponent = (columnProps === null || columnProps === void 0 ? void 0 : columnProps.useFastIcons) ? FontIcon : Icon;
          return React__namespace.createElement(IconComponent, __assign$1({}, iconProps));
        };
      };
      _this._onRenderColumnHeaderTooltip = function(tooltipHostProps) {
        return React__namespace.createElement("span", { className: tooltipHostProps.hostClassName }, tooltipHostProps.children);
      };
      _this._onColumnClick = function(ev) {
        var _a2 = _this.props, onColumnClick = _a2.onColumnClick, column2 = _a2.column;
        if (column2.columnActionsMode === ColumnActionsMode.disabled) {
          return;
        }
        if (column2.onColumnClick) {
          column2.onColumnClick(ev, column2);
        }
        if (onColumnClick) {
          onColumnClick(ev, column2);
        }
      };
      _this._onDragStart = function(item, itemIndex, selectedItems, event) {
        var classNames2 = _this._classNames;
        if (itemIndex) {
          _this._updateHeaderDragInfo(itemIndex);
          _this._root.current.classList.add(classNames2.borderWhileDragging);
          _this._async.setTimeout(function() {
            if (_this._root.current) {
              _this._root.current.classList.add(classNames2.noBorderWhileDragging);
            }
          }, CLASSNAME_ADD_INTERVAL);
        }
      };
      _this._onDragEnd = function(item, event) {
        var classNames2 = _this._classNames;
        if (event) {
          _this._updateHeaderDragInfo(-1, event);
        }
        _this._root.current.classList.remove(classNames2.borderWhileDragging);
        _this._root.current.classList.remove(classNames2.noBorderWhileDragging);
      };
      _this._updateHeaderDragInfo = function(itemIndex, event) {
        if (_this.props.setDraggedItemIndex) {
          _this.props.setDraggedItemIndex(itemIndex);
        }
        if (_this.props.updateDragInfo) {
          _this.props.updateDragInfo({ itemIndex }, event);
        }
      };
      _this._onColumnContextMenu = function(ev) {
        var _a2 = _this.props, onColumnContextMenu = _a2.onColumnContextMenu, column2 = _a2.column;
        if (column2.onColumnContextMenu) {
          column2.onColumnContextMenu(column2, ev);
          ev.preventDefault();
        }
        if (onColumnContextMenu) {
          onColumnContextMenu(column2, ev);
          ev.preventDefault();
        }
      };
      _this._onRootMouseDown = function(ev) {
        var isDraggable = _this.props.isDraggable;
        if (isDraggable && ev.button === MOUSEDOWN_PRIMARY_BUTTON$1) {
          ev.stopPropagation();
        }
      };
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      return _this;
    }
    DetailsColumnBase2.prototype.render = function() {
      var _a2 = this.props, column2 = _a2.column, parentId = _a2.parentId, isDraggable = _a2.isDraggable, styles2 = _a2.styles, theme = _a2.theme, _b2 = _a2.cellStyleProps, cellStyleProps = _b2 === void 0 ? DEFAULT_CELL_STYLE_PROPS : _b2, _c2 = _a2.useFastIcons, useFastIcons = _c2 === void 0 ? true : _c2;
      var _d2 = this.props.onRenderColumnHeaderTooltip, onRenderColumnHeaderTooltip = _d2 === void 0 ? this._onRenderColumnHeaderTooltip : _d2;
      this._classNames = getClassNames$n(styles2, {
        theme,
        headerClassName: column2.headerClassName,
        iconClassName: column2.iconClassName,
        isActionable: column2.columnActionsMode !== ColumnActionsMode.disabled,
        isEmpty: !column2.name,
        isIconVisible: column2.isSorted || column2.isGrouped || column2.isFiltered,
        isPadded: column2.isPadded,
        isIconOnly: column2.isIconOnly,
        cellStyleProps,
        transitionDurationDrag: TRANSITION_DURATION_DRAG,
        transitionDurationDrop: TRANSITION_DURATION_DROP
      });
      var classNames2 = this._classNames;
      var IconComponent = useFastIcons ? FontIcon : Icon;
      var onRenderFilterIcon = column2.onRenderFilterIcon ? composeRenderFunction(column2.onRenderFilterIcon, this._onRenderFilterIcon(this._classNames)) : this._onRenderFilterIcon(this._classNames);
      var onRenderHeader = column2.onRenderHeader ? composeRenderFunction(column2.onRenderHeader, defaultOnRenderHeader(this._classNames)) : defaultOnRenderHeader(this._classNames);
      var hasInnerButton = column2.columnActionsMode !== ColumnActionsMode.disabled && (column2.onColumnClick !== void 0 || this.props.onColumnClick !== void 0);
      var accNameDescription = {
        "aria-label": column2.ariaLabel ? column2.ariaLabel : column2.isIconOnly ? column2.name : void 0,
        "aria-labelledby": column2.ariaLabel || column2.isIconOnly ? void 0 : parentId + "-" + column2.key + "-name",
        "aria-describedby": !this.props.onRenderColumnHeaderTooltip && this._hasAccessibleDescription() ? parentId + "-" + column2.key + "-tooltip" : void 0
      };
      return React__namespace.createElement(
        React__namespace.Fragment,
        null,
        React__namespace.createElement(
          "div",
          __assign$1({ key: column2.key, ref: this._root, role: "columnheader" }, !hasInnerButton && accNameDescription, { "aria-sort": column2.isSorted ? column2.isSortedDescending ? "descending" : "ascending" : "none", "data-is-focusable": !hasInnerButton && column2.columnActionsMode !== ColumnActionsMode.disabled ? "true" : void 0, className: classNames2.root, "data-is-draggable": isDraggable, draggable: isDraggable, style: {
            width: column2.calculatedWidth + cellStyleProps.cellLeftPadding + cellStyleProps.cellRightPadding + (column2.isPadded ? cellStyleProps.cellExtraRightPadding : 0)
          }, "data-automationid": "ColumnsHeaderColumn", "data-item-key": column2.key }),
          isDraggable && React__namespace.createElement(IconComponent, { iconName: "GripperBarVertical", className: classNames2.gripperBarVerticalStyle }),
          onRenderColumnHeaderTooltip({
            hostClassName: classNames2.cellTooltip,
            id: parentId + "-" + column2.key + "-tooltip",
            setAriaDescribedBy: false,
            column: column2,
            content: column2.columnActionsMode !== ColumnActionsMode.disabled ? column2.ariaLabel : "",
            children: React__namespace.createElement(
              "span",
              __assign$1({ id: parentId + "-" + column2.key, className: classNames2.cellTitle, "data-is-focusable": hasInnerButton && column2.columnActionsMode !== ColumnActionsMode.disabled ? "true" : void 0, role: hasInnerButton ? "button" : void 0 }, hasInnerButton && accNameDescription, { onContextMenu: this._onColumnContextMenu, onClick: this._onColumnClick, "aria-haspopup": column2.columnActionsMode === ColumnActionsMode.hasDropdown ? "menu" : void 0, "aria-expanded": column2.columnActionsMode === ColumnActionsMode.hasDropdown ? !!column2.isMenuOpen : void 0 }),
              React__namespace.createElement(
                "span",
                { id: parentId + "-" + column2.key + "-name", className: classNames2.cellName },
                (column2.iconName || column2.iconClassName) && React__namespace.createElement(IconComponent, { className: classNames2.iconClassName, iconName: column2.iconName }),
                onRenderHeader(this.props)
              ),
              column2.isFiltered && React__namespace.createElement(IconComponent, { className: classNames2.nearIcon, iconName: "Filter" }),
              (column2.isSorted || column2.showSortIconWhenUnsorted) && React__namespace.createElement(IconComponent, { className: classNames2.sortIcon, iconName: column2.isSorted ? column2.isSortedDescending ? "SortDown" : "SortUp" : "Sort" }),
              column2.isGrouped && React__namespace.createElement(IconComponent, { className: classNames2.nearIcon, iconName: "GroupedDescending" }),
              column2.columnActionsMode === ColumnActionsMode.hasDropdown && !column2.isIconOnly && onRenderFilterIcon({
                "aria-hidden": true,
                columnProps: this.props,
                className: classNames2.filterChevron,
                iconName: "ChevronDown"
              })
            )
          }, this._onRenderColumnHeaderTooltip)
        ),
        !this.props.onRenderColumnHeaderTooltip ? this._renderAccessibleDescription() : null
      );
    };
    DetailsColumnBase2.prototype.componentDidMount = function() {
      var _this = this;
      if (this.props.dragDropHelper && this.props.isDraggable) {
        this._addDragDropHandling();
      }
      var classNames2 = this._classNames;
      if (this.props.isDropped) {
        if (this._root.current) {
          this._root.current.classList.add(classNames2.borderAfterDropping);
          this._async.setTimeout(function() {
            if (_this._root.current) {
              _this._root.current.classList.add(classNames2.noBorderAfterDropping);
            }
          }, CLASSNAME_ADD_INTERVAL);
        }
        this._async.setTimeout(function() {
          if (_this._root.current) {
            _this._root.current.classList.remove(classNames2.borderAfterDropping);
            _this._root.current.classList.remove(classNames2.noBorderAfterDropping);
          }
        }, TRANSITION_DURATION_DROP + CLASSNAME_ADD_INTERVAL);
      }
    };
    DetailsColumnBase2.prototype.componentWillUnmount = function() {
      if (this._dragDropSubscription) {
        this._dragDropSubscription.dispose();
        delete this._dragDropSubscription;
      }
      this._async.dispose();
      this._events.dispose();
    };
    DetailsColumnBase2.prototype.componentDidUpdate = function() {
      if (!this._dragDropSubscription && this.props.dragDropHelper && this.props.isDraggable) {
        this._addDragDropHandling();
      }
      if (this._dragDropSubscription && !this.props.isDraggable) {
        this._dragDropSubscription.dispose();
        this._events.off(this._root.current, "mousedown");
        delete this._dragDropSubscription;
      }
    };
    DetailsColumnBase2.prototype._getColumnDragDropOptions = function() {
      var _this = this;
      var columnIndex = this.props.columnIndex;
      var options2 = {
        selectionIndex: columnIndex,
        context: { data: columnIndex, index: columnIndex },
        canDrag: function() {
          return _this.props.isDraggable;
        },
        canDrop: function() {
          return false;
        },
        onDragStart: this._onDragStart,
        updateDropState: function() {
          return void 0;
        },
        onDrop: function() {
          return void 0;
        },
        onDragEnd: this._onDragEnd
      };
      return options2;
    };
    DetailsColumnBase2.prototype._hasAccessibleDescription = function() {
      var column2 = this.props.column;
      return !!(column2.filterAriaLabel || column2.sortAscendingAriaLabel || column2.sortDescendingAriaLabel || column2.groupAriaLabel || column2.sortableAriaLabel);
    };
    DetailsColumnBase2.prototype._renderAccessibleDescription = function() {
      var _a2 = this.props, column2 = _a2.column, parentId = _a2.parentId;
      var classNames2 = this._classNames;
      return this._hasAccessibleDescription() && !this.props.onRenderColumnHeaderTooltip ? React__namespace.createElement(
        "label",
        { key: column2.key + "_label", id: parentId + "-" + column2.key + "-tooltip", className: classNames2.accessibleLabel, hidden: true },
        column2.isFiltered && column2.filterAriaLabel || null,
        (column2.isSorted || column2.showSortIconWhenUnsorted) && (column2.isSorted ? column2.isSortedDescending ? column2.sortDescendingAriaLabel : column2.sortAscendingAriaLabel : column2.sortableAriaLabel) || null,
        column2.isGrouped && column2.groupAriaLabel || null
      ) : null;
    };
    DetailsColumnBase2.prototype._addDragDropHandling = function() {
      this._dragDropSubscription = this.props.dragDropHelper.subscribe(this._root.current, this._events, this._getColumnDragDropOptions());
      this._events.on(this._root.current, "mousedown", this._onRootMouseDown);
    };
    return DetailsColumnBase2;
  }(React__namespace.Component)
);
var GlobalClassNames$i = {
  isActionable: "is-actionable",
  cellIsCheck: "ms-DetailsHeader-cellIsCheck",
  collapseButton: "ms-DetailsHeader-collapseButton",
  isCollapsed: "is-collapsed",
  isAllSelected: "is-allSelected",
  isSelectAllHidden: "is-selectAllHidden",
  isResizingColumn: "is-resizingColumn",
  isEmpty: "is-empty",
  isIconVisible: "is-icon-visible",
  cellSizer: "ms-DetailsHeader-cellSizer",
  isResizing: "is-resizing",
  dropHintCircleStyle: "ms-DetailsHeader-dropHintCircleStyle",
  dropHintLineStyle: "ms-DetailsHeader-dropHintLineStyle",
  cellTitle: "ms-DetailsHeader-cellTitle",
  cellName: "ms-DetailsHeader-cellName",
  filterChevron: "ms-DetailsHeader-filterChevron",
  gripperBarVerticalStyle: "ms-DetailsColumn-gripperBar",
  nearIcon: "ms-DetailsColumn-nearIcon"
};
var getDetailsColumnStyles = function(props) {
  var _a2;
  var theme = props.theme, headerClassName = props.headerClassName, iconClassName = props.iconClassName, isActionable = props.isActionable, isEmpty = props.isEmpty, isIconVisible = props.isIconVisible, isPadded = props.isPadded, isIconOnly = props.isIconOnly, _b2 = props.cellStyleProps, cellStyleProps = _b2 === void 0 ? DEFAULT_CELL_STYLE_PROPS : _b2, transitionDurationDrag = props.transitionDurationDrag, transitionDurationDrop = props.transitionDurationDrop;
  var semanticColors = theme.semanticColors, palette = theme.palette, fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(GlobalClassNames$i, theme);
  var colors2 = {
    iconForegroundColor: semanticColors.bodySubtext,
    headerForegroundColor: semanticColors.bodyText,
    headerBackgroundColor: semanticColors.bodyBackground,
    dropdownChevronForegroundColor: palette.neutralSecondary,
    resizerColor: palette.neutralTertiaryAlt
  };
  var nearIconStyle = {
    color: colors2.iconForegroundColor,
    opacity: 1,
    paddingLeft: 8
  };
  var borderWhileDragging = {
    outline: "1px solid " + palette.themePrimary
  };
  var borderAfterDragOrDrop = {
    outlineColor: "transparent"
  };
  return {
    root: [
      getCellStyles(props),
      fonts.small,
      isActionable && [
        classNames2.isActionable,
        {
          selectors: {
            ":hover": {
              color: semanticColors.bodyText,
              background: semanticColors.listHeaderBackgroundHovered
            },
            ":active": {
              background: semanticColors.listHeaderBackgroundPressed
            }
          }
        }
      ],
      isEmpty && [
        classNames2.isEmpty,
        {
          textOverflow: "clip"
        }
      ],
      isIconVisible && classNames2.isIconVisible,
      isPadded && {
        paddingRight: cellStyleProps.cellExtraRightPadding + cellStyleProps.cellRightPadding
      },
      {
        selectors: {
          ':hover i[data-icon-name="GripperBarVertical"]': {
            display: "block"
          }
        }
      },
      headerClassName
    ],
    gripperBarVerticalStyle: {
      display: "none",
      position: "absolute",
      textAlign: "left",
      color: palette.neutralTertiary,
      left: 1
    },
    nearIcon: [classNames2.nearIcon, nearIconStyle],
    sortIcon: [
      nearIconStyle,
      {
        paddingLeft: 4,
        position: "relative",
        top: 1
      }
    ],
    iconClassName: [
      {
        color: colors2.iconForegroundColor,
        opacity: 1
      },
      iconClassName
    ],
    filterChevron: [
      classNames2.filterChevron,
      {
        color: colors2.dropdownChevronForegroundColor,
        paddingLeft: 6,
        verticalAlign: "middle",
        fontSize: fonts.small.fontSize
      }
    ],
    cellTitle: [
      classNames2.cellTitle,
      getFocusStyle(theme),
      __assign$1({ display: "flex", flexDirection: "row", justifyContent: "flex-start", alignItems: "stretch", boxSizing: "border-box", overflow: "hidden", padding: "0 " + cellStyleProps.cellRightPadding + "px 0 " + cellStyleProps.cellLeftPadding + "px" }, isIconOnly ? {
        alignContent: "flex-end",
        maxHeight: "100%",
        flexWrap: "wrap-reverse"
      } : {})
    ],
    cellName: [
      classNames2.cellName,
      {
        flex: "0 1 auto",
        overflow: "hidden",
        textOverflow: "ellipsis",
        fontWeight: FontWeights.semibold,
        fontSize: fonts.medium.fontSize
      },
      isIconOnly && {
        selectors: (_a2 = {}, _a2["." + classNames2.nearIcon] = {
          paddingLeft: 0
        }, _a2)
      }
    ],
    cellTooltip: {
      display: "block",
      position: "absolute",
      top: 0,
      left: 0,
      bottom: 0,
      right: 0
    },
    accessibleLabel: hiddenContentStyle,
    borderWhileDragging,
    noBorderWhileDragging: [borderAfterDragOrDrop, { transition: "outline " + transitionDurationDrag + "ms ease" }],
    borderAfterDropping: borderWhileDragging,
    noBorderAfterDropping: [borderAfterDragOrDrop, { transition: "outline  " + transitionDurationDrop + "ms ease" }]
  };
};
var DetailsColumn = styled(DetailsColumnBase, getDetailsColumnStyles, void 0, { scope: "DetailsColumn" });
var SelectAllVisibility;
(function(SelectAllVisibility2) {
  SelectAllVisibility2[SelectAllVisibility2["none"] = 0] = "none";
  SelectAllVisibility2[SelectAllVisibility2["hidden"] = 1] = "hidden";
  SelectAllVisibility2[SelectAllVisibility2["visible"] = 2] = "visible";
})(SelectAllVisibility || (SelectAllVisibility = {}));
var getClassNames$m = classNamesFunction();
var MOUSEDOWN_PRIMARY_BUTTON = 0;
var MOUSEMOVE_PRIMARY_BUTTON = 1;
var NO_COLUMNS$1 = [];
var DetailsHeaderBase = (
  /** @class */
  function(_super) {
    __extends(DetailsHeaderBase2, _super);
    function DetailsHeaderBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._rootElement = React__namespace.createRef();
      _this._rootComponent = React__namespace.createRef();
      _this._draggedColumnIndex = -1;
      _this._dropHintDetails = {};
      _this._updateDroppingState = function(newValue, event) {
        if (_this._draggedColumnIndex >= 0 && event.type !== "drop" && !newValue) {
          _this._resetDropHints();
        }
      };
      _this._onDragOver = function(item, event) {
        if (_this._draggedColumnIndex >= 0) {
          event.stopPropagation();
          _this._computeDropHintToBeShown(event.clientX);
        }
      };
      _this._onDrop = function(item, event) {
        var columnReorderProps = _this._getColumnReorderProps();
        if (_this._draggedColumnIndex >= 0 && event) {
          var targetIndex = _this._draggedColumnIndex > _this._currentDropHintIndex ? _this._currentDropHintIndex : _this._currentDropHintIndex - 1;
          var isValidDrop = _this._isValidCurrentDropHintIndex();
          event.stopPropagation();
          if (isValidDrop) {
            _this._onDropIndexInfo.sourceIndex = _this._draggedColumnIndex;
            _this._onDropIndexInfo.targetIndex = targetIndex;
            if (columnReorderProps.onColumnDrop) {
              var dragDropDetails = {
                draggedIndex: _this._draggedColumnIndex,
                targetIndex
              };
              columnReorderProps.onColumnDrop(dragDropDetails);
            } else if (columnReorderProps.handleColumnReorder) {
              columnReorderProps.handleColumnReorder(_this._draggedColumnIndex, targetIndex);
            }
          }
        }
        _this._resetDropHints();
        _this._dropHintDetails = {};
        _this._draggedColumnIndex = -1;
      };
      _this._computeColumnIndexOffset = function(showCheckbox) {
        var hasGroupExpander = _this.props.groupNestingDepth && _this.props.groupNestingDepth > 0;
        var offset = 1;
        if (showCheckbox) {
          offset += 1;
        }
        if (hasGroupExpander) {
          offset += 1;
        }
        return offset;
      };
      _this._updateDragInfo = function(props2, event) {
        var columnReorderProps = _this._getColumnReorderProps();
        var itemIndex = props2.itemIndex;
        if (itemIndex >= 0) {
          _this._draggedColumnIndex = itemIndex - _this._computeColumnIndexOffset(!_this._isCheckboxColumnHidden());
          _this._getDropHintPositions();
          if (columnReorderProps.onColumnDragStart) {
            columnReorderProps.onColumnDragStart(true);
          }
        } else if (event && _this._draggedColumnIndex >= 0) {
          _this._resetDropHints();
          _this._draggedColumnIndex = -1;
          _this._dropHintDetails = {};
          if (columnReorderProps.onColumnDragEnd) {
            var columnDragEndLocation = _this._isEventOnHeader(event);
            columnReorderProps.onColumnDragEnd({ dropLocation: columnDragEndLocation }, event);
          }
        }
      };
      _this._getDropHintPositions = function() {
        var _a2 = _this.props.columns, columns = _a2 === void 0 ? NO_COLUMNS$1 : _a2;
        var columnReorderProps = _this._getColumnReorderProps();
        var prevX = 0;
        var prevMid = 0;
        var prevRef;
        var frozenColumnCountFromStart = columnReorderProps.frozenColumnCountFromStart || 0;
        var frozenColumnCountFromEnd = columnReorderProps.frozenColumnCountFromEnd || 0;
        for (var i = frozenColumnCountFromStart; i < columns.length - frozenColumnCountFromEnd + 1; i++) {
          if (_this._rootElement.current) {
            var dropHintElement = _this._rootElement.current.querySelectorAll("#columnDropHint_" + i)[0];
            if (dropHintElement) {
              if (i === frozenColumnCountFromStart) {
                prevX = dropHintElement.offsetLeft;
                prevMid = dropHintElement.offsetLeft;
                prevRef = dropHintElement;
              } else {
                var newMid = (dropHintElement.offsetLeft + prevX) / 2;
                _this._dropHintDetails[i - 1] = {
                  originX: prevX,
                  startX: prevMid,
                  endX: newMid,
                  dropHintElementRef: prevRef
                };
                prevMid = newMid;
                prevRef = dropHintElement;
                prevX = dropHintElement.offsetLeft;
                if (i === columns.length - frozenColumnCountFromEnd) {
                  _this._dropHintDetails[i] = {
                    originX: prevX,
                    startX: prevMid,
                    endX: dropHintElement.offsetLeft,
                    dropHintElementRef: prevRef
                  };
                }
              }
            }
          }
        }
      };
      _this._computeDropHintToBeShown = function(clientX) {
        var isRtl = getRTL(_this.props.theme);
        if (_this._rootElement.current) {
          var clientRect = _this._rootElement.current.getBoundingClientRect();
          var headerOriginX = clientRect.left;
          var eventXRelativePosition = clientX - headerOriginX;
          var currentDropHintIndex = _this._currentDropHintIndex;
          if (_this._isValidCurrentDropHintIndex()) {
            if (_liesBetween(isRtl, eventXRelativePosition, _this._dropHintDetails[currentDropHintIndex].startX, _this._dropHintDetails[currentDropHintIndex].endX)) {
              return;
            }
          }
          var _a2 = _this.props.columns, columns = _a2 === void 0 ? NO_COLUMNS$1 : _a2;
          var columnReorderProps = _this._getColumnReorderProps();
          var frozenColumnCountFromStart = columnReorderProps.frozenColumnCountFromStart || 0;
          var frozenColumnCountFromEnd = columnReorderProps.frozenColumnCountFromEnd || 0;
          var currentIndex = frozenColumnCountFromStart;
          var lastValidColumn = columns.length - frozenColumnCountFromEnd;
          var indexToUpdate = -1;
          if (_isBefore(isRtl, eventXRelativePosition, _this._dropHintDetails[currentIndex].endX)) {
            indexToUpdate = currentIndex;
          } else if (_isAfter(isRtl, eventXRelativePosition, _this._dropHintDetails[lastValidColumn].startX)) {
            indexToUpdate = lastValidColumn;
          } else if (_this._isValidCurrentDropHintIndex()) {
            if (_this._dropHintDetails[currentDropHintIndex + 1] && _liesBetween(isRtl, eventXRelativePosition, _this._dropHintDetails[currentDropHintIndex + 1].startX, _this._dropHintDetails[currentDropHintIndex + 1].endX)) {
              indexToUpdate = currentDropHintIndex + 1;
            } else if (_this._dropHintDetails[currentDropHintIndex - 1] && _liesBetween(isRtl, eventXRelativePosition, _this._dropHintDetails[currentDropHintIndex - 1].startX, _this._dropHintDetails[currentDropHintIndex - 1].endX)) {
              indexToUpdate = currentDropHintIndex - 1;
            }
          }
          if (indexToUpdate === -1) {
            var startIndex = frozenColumnCountFromStart;
            var endIndex = lastValidColumn;
            while (startIndex < endIndex) {
              var middleIndex = Math.ceil((endIndex + startIndex) / 2);
              if (_liesBetween(isRtl, eventXRelativePosition, _this._dropHintDetails[middleIndex].startX, _this._dropHintDetails[middleIndex].endX)) {
                indexToUpdate = middleIndex;
                break;
              } else if (_isBefore(isRtl, eventXRelativePosition, _this._dropHintDetails[middleIndex].originX)) {
                endIndex = middleIndex;
              } else if (_isAfter(isRtl, eventXRelativePosition, _this._dropHintDetails[middleIndex].originX)) {
                startIndex = middleIndex;
              }
            }
          }
          if (indexToUpdate === _this._draggedColumnIndex || indexToUpdate === _this._draggedColumnIndex + 1) {
            if (_this._isValidCurrentDropHintIndex()) {
              _this._resetDropHints();
            }
          } else if (currentDropHintIndex !== indexToUpdate && indexToUpdate >= 0) {
            _this._resetDropHints();
            _this._updateDropHintElement(_this._dropHintDetails[indexToUpdate].dropHintElementRef, "inline-block");
            _this._currentDropHintIndex = indexToUpdate;
          }
        }
      };
      _this._renderColumnSizer = function(_a2) {
        var _b2;
        var columnIndex = _a2.columnIndex;
        var _c2 = _this.props.columns, columns = _c2 === void 0 ? NO_COLUMNS$1 : _c2;
        var column2 = columns[columnIndex];
        var columnResizeDetails = _this.state.columnResizeDetails;
        var classNames2 = _this._classNames;
        return column2.isResizable ? React__namespace.createElement("div", { key: column2.key + "_sizer", "aria-hidden": true, role: "button", "data-is-focusable": false, onClick: _stopPropagation, "data-sizer-index": columnIndex, onBlur: _this._onSizerBlur, className: css$3(classNames2.cellSizer, columnIndex < columns.length - 1 ? classNames2.cellSizerStart : classNames2.cellSizerEnd, (_b2 = {}, _b2[classNames2.cellIsResizing] = columnResizeDetails && columnResizeDetails.columnIndex === columnIndex, _b2)), onDoubleClick: _this._onSizerDoubleClick.bind(_this, columnIndex) }) : null;
      };
      _this._onRenderColumnHeaderTooltip = function(tooltipHostProps) {
        return React__namespace.createElement("span", { className: tooltipHostProps.hostClassName }, tooltipHostProps.children);
      };
      _this._onSelectAllClicked = function() {
        var selection = _this.props.selection;
        if (selection) {
          selection.toggleAllSelected();
        }
      };
      _this._onRootMouseDown = function(ev) {
        var columnIndexAttr = ev.target.getAttribute("data-sizer-index");
        var columnIndex = Number(columnIndexAttr);
        var _a2 = _this.props.columns, columns = _a2 === void 0 ? NO_COLUMNS$1 : _a2;
        if (columnIndexAttr === null || ev.button !== MOUSEDOWN_PRIMARY_BUTTON) {
          return;
        }
        _this.setState({
          columnResizeDetails: {
            columnIndex,
            columnMinWidth: columns[columnIndex].calculatedWidth,
            originX: ev.clientX
          }
        });
        ev.preventDefault();
        ev.stopPropagation();
      };
      _this._onRootMouseMove = function(ev) {
        var _a2 = _this.state, columnResizeDetails = _a2.columnResizeDetails, isSizing = _a2.isSizing;
        if (columnResizeDetails && !isSizing && ev.clientX !== columnResizeDetails.originX) {
          _this.setState({ isSizing: true });
        }
      };
      _this._onRootKeyDown = function(ev) {
        var _a2 = _this.state, columnResizeDetails = _a2.columnResizeDetails, isSizing = _a2.isSizing;
        var _b2 = _this.props, _c2 = _b2.columns, columns = _c2 === void 0 ? NO_COLUMNS$1 : _c2, onColumnResized = _b2.onColumnResized;
        var columnIndexAttr = ev.target.getAttribute("data-sizer-index");
        if (!columnIndexAttr || isSizing) {
          return;
        }
        var columnIndex = Number(columnIndexAttr);
        if (!columnResizeDetails) {
          if (ev.which === KeyCodes.enter) {
            _this.setState({
              columnResizeDetails: {
                columnIndex,
                columnMinWidth: columns[columnIndex].calculatedWidth
              }
            });
            ev.preventDefault();
            ev.stopPropagation();
          }
        } else {
          var increment = void 0;
          if (ev.which === KeyCodes.enter) {
            _this.setState({
              columnResizeDetails: void 0
            });
            ev.preventDefault();
            ev.stopPropagation();
          } else if (ev.which === KeyCodes.left) {
            increment = getRTL(_this.props.theme) ? 1 : -1;
          } else if (ev.which === KeyCodes.right) {
            increment = getRTL(_this.props.theme) ? -1 : 1;
          }
          if (increment) {
            if (!ev.shiftKey) {
              increment *= 10;
            }
            _this.setState({
              columnResizeDetails: __assign$1(__assign$1({}, columnResizeDetails), { columnMinWidth: columnResizeDetails.columnMinWidth + increment })
            });
            if (onColumnResized) {
              onColumnResized(columns[columnIndex], columnResizeDetails.columnMinWidth + increment, columnIndex);
            }
            ev.preventDefault();
            ev.stopPropagation();
          }
        }
      };
      _this._onSizerMouseMove = function(ev) {
        var buttons = ev.buttons;
        var _a2 = _this.props, onColumnIsSizingChanged = _a2.onColumnIsSizingChanged, onColumnResized = _a2.onColumnResized, _b2 = _a2.columns, columns = _b2 === void 0 ? NO_COLUMNS$1 : _b2;
        var columnResizeDetails = _this.state.columnResizeDetails;
        if (buttons !== void 0 && buttons !== MOUSEMOVE_PRIMARY_BUTTON) {
          _this._onSizerMouseUp(ev);
          return;
        }
        if (ev.clientX !== columnResizeDetails.originX) {
          if (onColumnIsSizingChanged) {
            onColumnIsSizingChanged(columns[columnResizeDetails.columnIndex], true);
          }
        }
        if (onColumnResized) {
          var movement = ev.clientX - columnResizeDetails.originX;
          if (getRTL(_this.props.theme)) {
            movement = -movement;
          }
          onColumnResized(columns[columnResizeDetails.columnIndex], columnResizeDetails.columnMinWidth + movement, columnResizeDetails.columnIndex);
        }
      };
      _this._onSizerBlur = function(ev) {
        var columnResizeDetails = _this.state.columnResizeDetails;
        if (columnResizeDetails) {
          _this.setState({
            columnResizeDetails: void 0,
            isSizing: false
          });
        }
      };
      _this._onSizerMouseUp = function(ev) {
        var _a2 = _this.props, _b2 = _a2.columns, columns = _b2 === void 0 ? NO_COLUMNS$1 : _b2, onColumnIsSizingChanged = _a2.onColumnIsSizingChanged;
        var columnResizeDetails = _this.state.columnResizeDetails;
        _this.setState({
          columnResizeDetails: void 0,
          isSizing: false
        });
        if (onColumnIsSizingChanged) {
          onColumnIsSizingChanged(columns[columnResizeDetails.columnIndex], false);
        }
      };
      _this._onToggleCollapseAll = function() {
        var onToggleCollapseAll = _this.props.onToggleCollapseAll;
        var newCollapsed = !_this.state.isAllCollapsed;
        _this.setState({
          isAllCollapsed: newCollapsed
        });
        if (onToggleCollapseAll) {
          onToggleCollapseAll(newCollapsed);
        }
      };
      initializeComponentRef(_this);
      _this._events = new EventGroup(_this);
      _this.state = {
        columnResizeDetails: void 0,
        isAllCollapsed: _this.props.isAllCollapsed,
        isAllSelected: !!_this.props.selection && _this.props.selection.isAllSelected()
      };
      _this._onDropIndexInfo = {
        sourceIndex: -1,
        targetIndex: -1
      };
      _this._id = getId("header");
      _this._currentDropHintIndex = -1;
      _this._dragDropHelper = new DragDropHelper({
        selection: {
          getSelection: function() {
            return;
          }
        },
        minimumPixelsForDrag: _this.props.minimumPixelsForDrag
      });
      return _this;
    }
    DetailsHeaderBase2.prototype.componentDidMount = function() {
      var selection = this.props.selection;
      this._events.on(selection, SELECTION_CHANGE, this._onSelectionChanged);
      if (this._rootElement.current) {
        this._events.on(this._rootElement.current, "mousedown", this._onRootMouseDown);
        this._events.on(this._rootElement.current, "keydown", this._onRootKeyDown);
        if (this._getColumnReorderProps()) {
          this._subscriptionObject = this._dragDropHelper.subscribe(this._rootElement.current, this._events, this._getHeaderDragDropOptions());
        }
      }
    };
    DetailsHeaderBase2.prototype.componentDidUpdate = function(prevProps) {
      if (this._getColumnReorderProps()) {
        if (!this._subscriptionObject && this._rootElement.current) {
          this._subscriptionObject = this._dragDropHelper.subscribe(this._rootElement.current, this._events, this._getHeaderDragDropOptions());
        }
      } else if (this._subscriptionObject) {
        this._subscriptionObject.dispose();
        delete this._subscriptionObject;
      }
      if (this.props !== prevProps && this._onDropIndexInfo.sourceIndex >= 0 && this._onDropIndexInfo.targetIndex >= 0) {
        var _a2 = prevProps.columns, previousColumns = _a2 === void 0 ? NO_COLUMNS$1 : _a2;
        var _b2 = this.props.columns, columns = _b2 === void 0 ? NO_COLUMNS$1 : _b2;
        if (previousColumns[this._onDropIndexInfo.sourceIndex].key === columns[this._onDropIndexInfo.targetIndex].key) {
          this._onDropIndexInfo = {
            sourceIndex: -1,
            targetIndex: -1
          };
        }
      }
      if (this.props.isAllCollapsed !== prevProps.isAllCollapsed) {
        this.setState({ isAllCollapsed: this.props.isAllCollapsed });
      }
    };
    DetailsHeaderBase2.prototype.componentWillUnmount = function() {
      if (this._subscriptionObject) {
        this._subscriptionObject.dispose();
        delete this._subscriptionObject;
      }
      this._dragDropHelper.dispose();
      this._events.dispose();
    };
    DetailsHeaderBase2.prototype.render = function() {
      var _this = this;
      var _a2 = this.props, _b2 = _a2.columns, columns = _b2 === void 0 ? NO_COLUMNS$1 : _b2, ariaLabel = _a2.ariaLabel, ariaLabelForToggleAllGroupsButton = _a2.ariaLabelForToggleAllGroupsButton, ariaLabelForSelectAllCheckbox = _a2.ariaLabelForSelectAllCheckbox, selectAllVisibility = _a2.selectAllVisibility, ariaLabelForSelectionColumn = _a2.ariaLabelForSelectionColumn, indentWidth = _a2.indentWidth, onColumnClick = _a2.onColumnClick, onColumnContextMenu = _a2.onColumnContextMenu, _c2 = _a2.onRenderColumnHeaderTooltip, onRenderColumnHeaderTooltip = _c2 === void 0 ? this._onRenderColumnHeaderTooltip : _c2, styles2 = _a2.styles, selectionMode = _a2.selectionMode, theme = _a2.theme, onRenderDetailsCheckbox = _a2.onRenderDetailsCheckbox, groupNestingDepth = _a2.groupNestingDepth, useFastIcons = _a2.useFastIcons, checkboxVisibility = _a2.checkboxVisibility, className = _a2.className;
      var _d2 = this.state, isAllSelected = _d2.isAllSelected, columnResizeDetails = _d2.columnResizeDetails, isSizing = _d2.isSizing, isAllCollapsed = _d2.isAllCollapsed;
      var showCheckbox = selectAllVisibility !== SelectAllVisibility.none;
      var isCheckboxHidden = selectAllVisibility === SelectAllVisibility.hidden;
      var isCheckboxAlwaysVisible = checkboxVisibility === CheckboxVisibility.always;
      var columnReorderProps = this._getColumnReorderProps();
      var frozenColumnCountFromStart = columnReorderProps && columnReorderProps.frozenColumnCountFromStart ? columnReorderProps.frozenColumnCountFromStart : 0;
      var frozenColumnCountFromEnd = columnReorderProps && columnReorderProps.frozenColumnCountFromEnd ? columnReorderProps.frozenColumnCountFromEnd : 0;
      this._classNames = getClassNames$m(styles2, {
        theme,
        isAllSelected,
        isSelectAllHidden: selectAllVisibility === SelectAllVisibility.hidden,
        isResizingColumn: !!columnResizeDetails && isSizing,
        isSizing,
        isAllCollapsed,
        isCheckboxHidden,
        className
      });
      var classNames2 = this._classNames;
      var IconComponent = useFastIcons ? FontIcon : Icon;
      var hasGroupExpander = groupNestingDepth > 0;
      var showGroupExpander = hasGroupExpander && this.props.collapseAllVisibility === CollapseAllVisibility.visible;
      var columnIndexOffset = this._computeColumnIndexOffset(showCheckbox);
      var isRTL = getRTL(theme);
      return React__namespace.createElement(
        FocusZone,
        { role: "row", "aria-label": ariaLabel, className: classNames2.root, componentRef: this._rootComponent, elementRef: this._rootElement, onMouseMove: this._onRootMouseMove, "data-automationid": "DetailsHeader", direction: FocusZoneDirection.horizontal },
        showCheckbox ? [
          React__namespace.createElement("div", { key: "__checkbox", className: classNames2.cellIsCheck, "aria-labelledby": this._id + "-checkTooltip", onClick: !isCheckboxHidden ? this._onSelectAllClicked : void 0, role: "columnheader" }, onRenderColumnHeaderTooltip({
            hostClassName: classNames2.checkTooltip,
            id: this._id + "-checkTooltip",
            setAriaDescribedBy: false,
            content: ariaLabelForSelectAllCheckbox,
            children: React__namespace.createElement(DetailsRowCheck, { id: this._id + "-check", "aria-label": selectionMode === SelectionMode.multiple ? ariaLabelForSelectAllCheckbox : ariaLabelForSelectionColumn, "data-is-focusable": !isCheckboxHidden || void 0, isHeader: true, selected: isAllSelected, anySelected: false, canSelect: !isCheckboxHidden, className: classNames2.check, onRenderDetailsCheckbox, useFastIcons, isVisible: isCheckboxAlwaysVisible })
          }, this._onRenderColumnHeaderTooltip)),
          !this.props.onRenderColumnHeaderTooltip ? ariaLabelForSelectAllCheckbox && !isCheckboxHidden ? React__namespace.createElement("label", { key: "__checkboxLabel", id: this._id + "-checkTooltip", className: classNames2.accessibleLabel, "aria-hidden": true }, ariaLabelForSelectAllCheckbox) : ariaLabelForSelectionColumn && isCheckboxHidden ? React__namespace.createElement("label", { key: "__checkboxLabel", id: this._id + "-checkTooltip", className: classNames2.accessibleLabel, "aria-hidden": true }, ariaLabelForSelectionColumn) : null : null
        ] : null,
        showGroupExpander ? React__namespace.createElement(
          "div",
          { className: classNames2.cellIsGroupExpander, onClick: this._onToggleCollapseAll, "data-is-focusable": true, "aria-label": ariaLabelForToggleAllGroupsButton, "aria-expanded": !isAllCollapsed, role: "columnheader" },
          React__namespace.createElement(IconComponent, { className: classNames2.collapseButton, iconName: isRTL ? "ChevronLeftMed" : "ChevronRightMed" }),
          React__namespace.createElement("span", { className: classNames2.accessibleLabel }, ariaLabelForToggleAllGroupsButton)
        ) : hasGroupExpander ? React__namespace.createElement("div", { className: classNames2.cellIsGroupExpander, "data-is-focusable": false, role: "columnheader" }) : null,
        React__namespace.createElement(GroupSpacer, { indentWidth, role: "gridcell", count: groupNestingDepth - 1 }),
        columns.map(function(column2, columnIndex) {
          var _isDraggable = columnReorderProps ? columnIndex >= frozenColumnCountFromStart && columnIndex < columns.length - frozenColumnCountFromEnd : false;
          return [
            columnReorderProps && (_isDraggable || columnIndex === columns.length - frozenColumnCountFromEnd) && _this._renderDropHint(columnIndex),
            React__namespace.createElement(DetailsColumn, {
              column: column2,
              styles: column2.styles,
              key: column2.key,
              columnIndex: columnIndexOffset + columnIndex,
              parentId: _this._id,
              isDraggable: _isDraggable,
              updateDragInfo: _this._updateDragInfo,
              dragDropHelper: _this._dragDropHelper,
              onColumnClick,
              onColumnContextMenu,
              // Do not render tooltips by default, but allow for override via props.
              onRenderColumnHeaderTooltip: _this.props.onRenderColumnHeaderTooltip,
              isDropped: _this._onDropIndexInfo.targetIndex === columnIndex,
              cellStyleProps: _this.props.cellStyleProps,
              useFastIcons
            }),
            _this._renderColumnDivider(columnIndex)
          ];
        }),
        columnReorderProps && frozenColumnCountFromEnd === 0 && this._renderDropHint(columns.length),
        isSizing && React__namespace.createElement(
          Layer,
          null,
          React__namespace.createElement("div", { className: classNames2.sizingOverlay, onMouseMove: this._onSizerMouseMove, onMouseUp: this._onSizerMouseUp })
        )
      );
    };
    DetailsHeaderBase2.prototype.focus = function() {
      var _a2;
      return !!((_a2 = this._rootComponent.current) === null || _a2 === void 0 ? void 0 : _a2.focus());
    };
    DetailsHeaderBase2.prototype._getColumnReorderProps = function() {
      var _a2 = this.props, columnReorderOptions = _a2.columnReorderOptions, columnReorderProps = _a2.columnReorderProps;
      return columnReorderProps || columnReorderOptions && __assign$1(__assign$1({}, columnReorderOptions), { onColumnDragEnd: void 0 });
    };
    DetailsHeaderBase2.prototype._getHeaderDragDropOptions = function() {
      var options2 = {
        selectionIndex: 1,
        context: { data: this, index: 0 },
        canDrag: function() {
          return false;
        },
        canDrop: function() {
          return true;
        },
        onDragStart: function() {
          return void 0;
        },
        updateDropState: this._updateDroppingState,
        onDrop: this._onDrop,
        onDragEnd: function() {
          return void 0;
        },
        onDragOver: this._onDragOver
      };
      return options2;
    };
    DetailsHeaderBase2.prototype._isValidCurrentDropHintIndex = function() {
      return this._currentDropHintIndex >= 0;
    };
    DetailsHeaderBase2.prototype._isCheckboxColumnHidden = function() {
      var _a2 = this.props, selectionMode = _a2.selectionMode, checkboxVisibility = _a2.checkboxVisibility;
      return selectionMode === SelectionMode.none || checkboxVisibility === CheckboxVisibility.hidden;
    };
    DetailsHeaderBase2.prototype._resetDropHints = function() {
      if (this._currentDropHintIndex >= 0) {
        this._updateDropHintElement(this._dropHintDetails[this._currentDropHintIndex].dropHintElementRef, "none");
        this._currentDropHintIndex = -1;
      }
    };
    DetailsHeaderBase2.prototype._updateDropHintElement = function(element, displayProperty) {
      element.childNodes[1].style.display = displayProperty;
      element.childNodes[0].style.display = displayProperty;
    };
    DetailsHeaderBase2.prototype._isEventOnHeader = function(event) {
      if (this._rootElement.current) {
        var clientRect = this._rootElement.current.getBoundingClientRect();
        if (event.clientX > clientRect.left && event.clientX < clientRect.right && event.clientY > clientRect.top && event.clientY < clientRect.bottom) {
          return ColumnDragEndLocation.header;
        }
      }
    };
    DetailsHeaderBase2.prototype._renderColumnDivider = function(columnIndex) {
      var _a2 = this.props.columns, columns = _a2 === void 0 ? NO_COLUMNS$1 : _a2;
      var column2 = columns[columnIndex];
      var onRenderDivider = column2.onRenderDivider;
      return onRenderDivider ? onRenderDivider({ column: column2, columnIndex }, this._renderColumnSizer) : this._renderColumnSizer({ column: column2, columnIndex });
    };
    DetailsHeaderBase2.prototype._renderDropHint = function(dropHintIndex) {
      var classNames2 = this._classNames;
      var IconComponent = this.props.useFastIcons ? FontIcon : Icon;
      return React__namespace.createElement(
        "div",
        { key: "dropHintKey", className: classNames2.dropHintStyle, id: "columnDropHint_" + dropHintIndex },
        React__namespace.createElement(
          "div",
          { role: "presentation", key: "dropHintCircleKey", className: classNames2.dropHintCaretStyle, "data-is-focusable": false, "data-sizer-index": dropHintIndex, "aria-hidden": true },
          React__namespace.createElement(IconComponent, { iconName: "CircleShapeSolid" })
        ),
        React__namespace.createElement("div", { key: "dropHintLineKey", "aria-hidden": true, "data-is-focusable": false, "data-sizer-index": dropHintIndex, className: classNames2.dropHintLineStyle })
      );
    };
    DetailsHeaderBase2.prototype._onSizerDoubleClick = function(columnIndex, ev) {
      var _a2 = this.props, onColumnAutoResized = _a2.onColumnAutoResized, _b2 = _a2.columns, columns = _b2 === void 0 ? NO_COLUMNS$1 : _b2;
      if (onColumnAutoResized) {
        onColumnAutoResized(columns[columnIndex], columnIndex);
      }
    };
    DetailsHeaderBase2.prototype._onSelectionChanged = function() {
      var isAllSelected = !!this.props.selection && this.props.selection.isAllSelected();
      if (this.state.isAllSelected !== isAllSelected) {
        this.setState({
          isAllSelected
        });
      }
    };
    DetailsHeaderBase2.defaultProps = {
      selectAllVisibility: SelectAllVisibility.visible,
      collapseAllVisibility: CollapseAllVisibility.visible,
      useFastIcons: true
    };
    return DetailsHeaderBase2;
  }(React__namespace.Component)
);
function _liesBetween(rtl, target, left, right) {
  return rtl ? target <= left && target >= right : target >= left && target <= right;
}
function _isBefore(rtl, a, b) {
  return rtl ? a >= b : a <= b;
}
function _isAfter(rtl, a, b) {
  return rtl ? a <= b : a >= b;
}
function _stopPropagation(ev) {
  ev.stopPropagation();
}
var DetailsHeader = styled(DetailsHeaderBase, getDetailsHeaderStyles, void 0, { scope: "DetailsHeader" });
var getCellText = function(item, column2) {
  var value = item && column2 && column2.fieldName ? item[column2.fieldName] : "";
  if (value === null || value === void 0) {
    value = "";
  }
  if (typeof value === "boolean") {
    return value.toString();
  }
  return value;
};
var DetailsRowFields = function(props) {
  var columns = props.columns, rowClassNames = props.rowClassNames, _a2 = props.cellStyleProps, cellStyleProps = _a2 === void 0 ? DEFAULT_CELL_STYLE_PROPS : _a2, item = props.item, itemIndex = props.itemIndex, isSelected = props.isSelected, onRenderItemColumn = props.onRenderItemColumn, getCellValueKey = props.getCellValueKey, propsOnRenderField = props.onRenderField, cellsByColumn = props.cellsByColumn, enableUpdateAnimations = props.enableUpdateAnimations, rowHeaderId = props.rowHeaderId;
  var cellValueKeysRef = React__namespace.useRef();
  var cellValueKeys = cellValueKeysRef.current || (cellValueKeysRef.current = {});
  var defaultOnRenderField = React__namespace.useCallback(function(fieldProps) {
    var column2 = fieldProps.column, cellValueKey = fieldProps.cellValueKey, className = fieldProps.className, onRender = fieldProps.onRender, fieldItem = fieldProps.item, fieldItemIndex = fieldProps.itemIndex;
    var width = typeof column2.calculatedWidth === "undefined" ? "auto" : column2.calculatedWidth + cellStyleProps.cellLeftPadding + cellStyleProps.cellRightPadding + (column2.isPadded ? cellStyleProps.cellExtraRightPadding : 0);
    var key = "" + column2.key + (cellValueKey !== void 0 ? "-" + cellValueKey : "");
    return React__namespace.createElement("div", { key, id: column2.isRowHeader ? rowHeaderId : void 0, role: column2.isRowHeader ? "rowheader" : "gridcell", className: css$3(column2.className, column2.isMultiline && rowClassNames.isMultiline, column2.isRowHeader && rowClassNames.isRowHeader, rowClassNames.cell, column2.isPadded ? rowClassNames.cellPadded : rowClassNames.cellUnpadded, className), style: { width }, "data-automationid": "DetailsRowCell", "data-automation-key": column2.key }, onRender(fieldItem, fieldItemIndex, column2));
  }, [rowClassNames, cellStyleProps, rowHeaderId]);
  return React__namespace.createElement("div", { className: rowClassNames.fields, "data-automationid": "DetailsRowFields", role: "presentation" }, columns.map(function(column2) {
    var _a3 = column2.getValueKey, getValueKey = _a3 === void 0 ? getCellValueKey : _a3;
    var onRender = cellsByColumn && column2.key in cellsByColumn && function() {
      return cellsByColumn[column2.key];
    } || column2.onRender || onRenderItemColumn || defaultOnRender;
    var onRenderField = defaultOnRenderField;
    if (column2.onRenderField) {
      onRenderField = composeRenderFunction(column2.onRenderField, onRenderField);
    }
    if (propsOnRenderField) {
      onRenderField = composeRenderFunction(propsOnRenderField, onRenderField);
    }
    var previousValueKey = cellValueKeys[column2.key];
    var cellValueKey = enableUpdateAnimations && getValueKey ? getValueKey(item, itemIndex, column2) : void 0;
    var showAnimation = false;
    if (cellValueKey !== void 0 && previousValueKey !== void 0 && cellValueKey !== previousValueKey) {
      showAnimation = true;
    }
    cellValueKeys[column2.key] = cellValueKey;
    return onRenderField({
      item,
      itemIndex,
      isSelected,
      column: column2,
      cellValueKey,
      className: showAnimation ? rowClassNames.cellAnimation : void 0,
      onRender
    });
  }));
};
function defaultOnRender(item, index2, column2) {
  if (!item || !column2) {
    return null;
  }
  return getCellText(item, column2);
}
var getClassNames$l = classNamesFunction();
var DEFAULT_DROPPING_CSS_CLASS = "is-dropping";
var NO_COLUMNS = [];
var DetailsRowBase = (
  /** @class */
  function(_super) {
    __extends(DetailsRowBase2, _super);
    function DetailsRowBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._root = React__namespace.createRef();
      _this._cellMeasurer = React__namespace.createRef();
      _this._focusZone = React__namespace.createRef();
      _this._onSelectionChanged = function() {
        var selectionState = getSelectionState(_this.props);
        if (!shallowCompare(selectionState, _this.state.selectionState)) {
          _this.setState({ selectionState });
        }
      };
      _this._updateDroppingState = function(newValue, event) {
        var isDropping = _this.state.isDropping;
        var _a2 = _this.props, dragDropEvents = _a2.dragDropEvents, item = _a2.item;
        if (!newValue) {
          if (dragDropEvents.onDragLeave) {
            dragDropEvents.onDragLeave(item, event);
          }
        } else if (dragDropEvents.onDragEnter) {
          _this._droppingClassNames = dragDropEvents.onDragEnter(item, event);
        }
        if (isDropping !== newValue) {
          _this.setState({ isDropping: newValue });
        }
      };
      initializeComponentRef(_this);
      _this._events = new EventGroup(_this);
      _this.state = {
        selectionState: getSelectionState(props),
        columnMeasureInfo: void 0,
        isDropping: false
      };
      _this._droppingClassNames = "";
      return _this;
    }
    DetailsRowBase2.getDerivedStateFromProps = function(nextProps, previousState) {
      return __assign$1(__assign$1({}, previousState), { selectionState: getSelectionState(nextProps) });
    };
    DetailsRowBase2.prototype.componentDidMount = function() {
      var _a2 = this.props, dragDropHelper = _a2.dragDropHelper, selection = _a2.selection, item = _a2.item, onDidMount = _a2.onDidMount;
      if (dragDropHelper && this._root.current) {
        this._dragDropSubscription = dragDropHelper.subscribe(this._root.current, this._events, this._getRowDragDropOptions());
      }
      if (selection) {
        this._events.on(selection, SELECTION_CHANGE, this._onSelectionChanged);
      }
      if (onDidMount && item) {
        this._onDidMountCalled = true;
        onDidMount(this);
      }
    };
    DetailsRowBase2.prototype.componentDidUpdate = function(previousProps) {
      var state = this.state;
      var _a2 = this.props, item = _a2.item, onDidMount = _a2.onDidMount;
      var columnMeasureInfo = state.columnMeasureInfo;
      if (this.props.itemIndex !== previousProps.itemIndex || this.props.item !== previousProps.item || this.props.dragDropHelper !== previousProps.dragDropHelper) {
        if (this._dragDropSubscription) {
          this._dragDropSubscription.dispose();
          delete this._dragDropSubscription;
        }
        if (this.props.dragDropHelper && this._root.current) {
          this._dragDropSubscription = this.props.dragDropHelper.subscribe(this._root.current, this._events, this._getRowDragDropOptions());
        }
      }
      if (columnMeasureInfo && columnMeasureInfo.index >= 0 && this._cellMeasurer.current) {
        var newWidth = this._cellMeasurer.current.getBoundingClientRect().width;
        columnMeasureInfo.onMeasureDone(newWidth);
        this.setState({
          columnMeasureInfo: void 0
        });
      }
      if (item && onDidMount && !this._onDidMountCalled) {
        this._onDidMountCalled = true;
        onDidMount(this);
      }
    };
    DetailsRowBase2.prototype.componentWillUnmount = function() {
      var _a2 = this.props, item = _a2.item, onWillUnmount = _a2.onWillUnmount;
      if (onWillUnmount && item) {
        onWillUnmount(this);
      }
      if (this._dragDropSubscription) {
        this._dragDropSubscription.dispose();
        delete this._dragDropSubscription;
      }
      this._events.dispose();
    };
    DetailsRowBase2.prototype.shouldComponentUpdate = function(nextProps, nextState) {
      if (this.props.useReducedRowRenderer) {
        var newSelectionState = getSelectionState(nextProps);
        if (this.state.selectionState.isSelected !== newSelectionState.isSelected) {
          return true;
        }
        return !shallowCompare(this.props, nextProps);
      } else {
        return true;
      }
    };
    DetailsRowBase2.prototype.render = function() {
      var _a2;
      var _b2 = this.props, className = _b2.className, _c2 = _b2.columns, columns = _c2 === void 0 ? NO_COLUMNS : _c2, dragDropEvents = _b2.dragDropEvents, item = _b2.item, itemIndex = _b2.itemIndex, id = _b2.id, _d2 = _b2.flatIndexOffset, flatIndexOffset = _d2 === void 0 ? 2 : _d2, _e2 = _b2.onRenderCheck, onRenderCheck = _e2 === void 0 ? this._onRenderCheck : _e2, onRenderDetailsCheckbox = _b2.onRenderDetailsCheckbox, onRenderItemColumn = _b2.onRenderItemColumn, onRenderField = _b2.onRenderField, getCellValueKey = _b2.getCellValueKey, selectionMode = _b2.selectionMode, checkboxVisibility = _b2.checkboxVisibility, getRowAriaLabel = _b2.getRowAriaLabel, getRowAriaDescription = _b2.getRowAriaDescription, getRowAriaDescribedBy = _b2.getRowAriaDescribedBy, isGridRow = _b2.isGridRow, checkButtonAriaLabel = _b2.checkButtonAriaLabel, checkboxCellClassName = _b2.checkboxCellClassName, rowFieldsAs = _b2.rowFieldsAs, selection = _b2.selection, indentWidth = _b2.indentWidth, enableUpdateAnimations = _b2.enableUpdateAnimations, compact = _b2.compact, theme = _b2.theme, styles2 = _b2.styles, cellsByColumn = _b2.cellsByColumn, groupNestingDepth = _b2.groupNestingDepth, _f = _b2.useFastIcons, useFastIcons = _f === void 0 ? true : _f, cellStyleProps = _b2.cellStyleProps, group = _b2.group, focusZoneProps = _b2.focusZoneProps, _g = _b2.disabled, disabled = _g === void 0 ? false : _g;
      var _h = this.state, columnMeasureInfo = _h.columnMeasureInfo, isDropping = _h.isDropping;
      var _j = this.state.selectionState, _k = _j.isSelected, isSelected = _k === void 0 ? false : _k, _l = _j.isSelectionModal, isSelectionModal = _l === void 0 ? false : _l;
      var isDraggable = dragDropEvents ? !!(dragDropEvents.canDrag && dragDropEvents.canDrag(item)) : void 0;
      var droppingClassName = isDropping ? this._droppingClassNames || DEFAULT_DROPPING_CSS_CLASS : "";
      var ariaLabel = getRowAriaLabel ? getRowAriaLabel(item) : void 0;
      var ariaRowDescription = getRowAriaDescription ? getRowAriaDescription(item) : void 0;
      var ariaDescribedBy = getRowAriaDescribedBy ? getRowAriaDescribedBy(item) : void 0;
      var canSelect = !!selection && selection.canSelectItem(item, itemIndex) && !disabled;
      var isContentUnselectable = selectionMode === SelectionMode.multiple;
      var showCheckbox = selectionMode !== SelectionMode.none && checkboxVisibility !== CheckboxVisibility.hidden;
      var ariaSelected = selectionMode === SelectionMode.none ? void 0 : isSelected;
      var ariaPositionInSet = group ? itemIndex - group.startIndex + 1 : void 0;
      var ariaSetSize = group ? group.count : void 0;
      var focusZoneDirection = focusZoneProps ? focusZoneProps.direction : FocusZoneDirection.horizontal;
      this._classNames = __assign$1(__assign$1({}, this._classNames), getClassNames$l(styles2, {
        theme,
        isSelected,
        canSelect: !isContentUnselectable,
        anySelected: isSelectionModal,
        checkboxCellClassName,
        droppingClassName,
        className,
        compact,
        enableUpdateAnimations,
        cellStyleProps,
        disabled
      }));
      var rowClassNames = {
        isMultiline: this._classNames.isMultiline,
        isRowHeader: this._classNames.isRowHeader,
        cell: this._classNames.cell,
        cellAnimation: this._classNames.cellAnimation,
        cellPadded: this._classNames.cellPadded,
        cellUnpadded: this._classNames.cellUnpadded,
        fields: this._classNames.fields
      };
      if (!shallowCompare(this._rowClassNames || {}, rowClassNames)) {
        this._rowClassNames = rowClassNames;
      }
      var RowFields = rowFieldsAs ? composeComponentAs(rowFieldsAs, DetailsRowFields) : DetailsRowFields;
      var rowFields = React__namespace.createElement(RowFields, { rowClassNames: this._rowClassNames, rowHeaderId: id + "-header", cellsByColumn, columns, item, itemIndex, isSelected, columnStartIndex: (showCheckbox ? 1 : 0) + (groupNestingDepth ? 1 : 0), onRenderItemColumn, onRenderField, getCellValueKey, enableUpdateAnimations, cellStyleProps });
      var defaultRole = "row";
      var role = this.props.role ? this.props.role : defaultRole;
      this._ariaRowDescriptionId = getId("DetailsRow-description");
      var hasRowHeader = columns.some(function(column2) {
        return !!column2.isRowHeader;
      });
      var ariaLabelledby = id + "-checkbox" + (hasRowHeader ? " " + id + "-header" : "");
      var groupedListRowProps = isGridRow ? {} : {
        "aria-level": groupNestingDepth && groupNestingDepth + 1 || void 0,
        "aria-posinset": ariaPositionInSet,
        "aria-setsize": ariaSetSize
      };
      return React__namespace.createElement(
        FocusZone,
        __assign$1({ "data-is-focusable": true }, getNativeProps(this.props, divProperties), typeof isDraggable === "boolean" ? {
          "data-is-draggable": isDraggable,
          draggable: isDraggable
        } : {}, focusZoneProps, groupedListRowProps, { direction: focusZoneDirection, elementRef: this._root, componentRef: this._focusZone, role, "aria-label": ariaLabel, "aria-disabled": disabled || void 0, "aria-describedby": ariaRowDescription ? this._ariaRowDescriptionId : ariaDescribedBy, className: this._classNames.root, "data-selection-index": itemIndex, "data-selection-touch-invoke": true, "data-selection-disabled": (_a2 = this.props["data-selection-disabled"]) !== null && _a2 !== void 0 ? _a2 : disabled || void 0, "data-item-index": itemIndex, "aria-rowindex": ariaPositionInSet === void 0 ? itemIndex + flatIndexOffset : void 0, "data-automationid": "DetailsRow", "aria-selected": ariaSelected, allowFocusRoot: true }),
        ariaRowDescription ? React__namespace.createElement("span", { key: "description", role: "presentation", hidden: true, id: this._ariaRowDescriptionId }, ariaRowDescription) : null,
        showCheckbox && React__namespace.createElement("div", { role: "gridcell", "data-selection-toggle": true, className: this._classNames.checkCell }, onRenderCheck({
          id: id ? id + "-checkbox" : void 0,
          selected: isSelected,
          selectionMode,
          anySelected: isSelectionModal,
          "aria-label": checkButtonAriaLabel,
          "aria-labelledby": id ? ariaLabelledby : void 0,
          canSelect,
          compact,
          className: this._classNames.check,
          theme,
          isVisible: checkboxVisibility === CheckboxVisibility.always,
          onRenderDetailsCheckbox,
          useFastIcons
        })),
        React__namespace.createElement(GroupSpacer, { indentWidth, role: "gridcell", count: groupNestingDepth === 0 ? -1 : groupNestingDepth }),
        item && rowFields,
        columnMeasureInfo && React__namespace.createElement(
          "span",
          { role: "presentation", className: css$3(this._classNames.cellMeasurer, this._classNames.cell), ref: this._cellMeasurer },
          React__namespace.createElement(RowFields, { rowClassNames: this._rowClassNames, rowHeaderId: id + "-header", columns: [columnMeasureInfo.column], item, itemIndex, columnStartIndex: (showCheckbox ? 1 : 0) + (groupNestingDepth ? 1 : 0) + columns.length, onRenderItemColumn, getCellValueKey })
        )
      );
    };
    DetailsRowBase2.prototype.measureCell = function(index2, onMeasureDone) {
      var _a2 = this.props.columns, columns = _a2 === void 0 ? NO_COLUMNS : _a2;
      var column2 = __assign$1({}, columns[index2]);
      column2.minWidth = 0;
      column2.maxWidth = 999999;
      delete column2.calculatedWidth;
      this.setState({
        columnMeasureInfo: {
          index: index2,
          column: column2,
          onMeasureDone
        }
      });
    };
    DetailsRowBase2.prototype.focus = function(forceIntoFirstElement) {
      var _a2;
      if (forceIntoFirstElement === void 0) {
        forceIntoFirstElement = false;
      }
      return !!((_a2 = this._focusZone.current) === null || _a2 === void 0 ? void 0 : _a2.focus(forceIntoFirstElement));
    };
    DetailsRowBase2.prototype._onRenderCheck = function(props) {
      return React__namespace.createElement(DetailsRowCheck, __assign$1({}, props));
    };
    DetailsRowBase2.prototype._getRowDragDropOptions = function() {
      var _a2 = this.props, item = _a2.item, itemIndex = _a2.itemIndex, dragDropEvents = _a2.dragDropEvents, eventsToRegister = _a2.eventsToRegister;
      var options2 = {
        eventMap: eventsToRegister,
        selectionIndex: itemIndex,
        context: { data: item, index: itemIndex },
        canDrag: dragDropEvents.canDrag,
        canDrop: dragDropEvents.canDrop,
        onDragStart: dragDropEvents.onDragStart,
        updateDropState: this._updateDroppingState,
        onDrop: dragDropEvents.onDrop,
        onDragEnd: dragDropEvents.onDragEnd,
        onDragOver: dragDropEvents.onDragOver
      };
      return options2;
    };
    return DetailsRowBase2;
  }(React__namespace.Component)
);
function getSelectionState(props) {
  var _a2;
  var itemIndex = props.itemIndex, selection = props.selection;
  return {
    isSelected: !!(selection === null || selection === void 0 ? void 0 : selection.isIndexSelected(itemIndex)),
    isSelectionModal: !!((_a2 = selection === null || selection === void 0 ? void 0 : selection.isModal) === null || _a2 === void 0 ? void 0 : _a2.call(selection))
  };
}
var DetailsRow = styled(DetailsRowBase, getDetailsRowStyles, void 0, {
  scope: "DetailsRow"
});
var RESIZE_DELAY = 500;
var MAX_RESIZE_ATTEMPTS = 3;
function withViewport(ComposedComponent) {
  return (
    /** @class */
    function(_super) {
      __extends(WithViewportComponent, _super);
      function WithViewportComponent(props) {
        var _this = _super.call(this, props) || this;
        _this._root = React__namespace.createRef();
        _this._registerResizeObserver = function() {
          var win2 = getWindow$1(_this._root.current);
          _this._viewportResizeObserver = new win2.ResizeObserver(_this._onAsyncResize);
          _this._viewportResizeObserver.observe(_this._root.current);
        };
        _this._unregisterResizeObserver = function() {
          if (_this._viewportResizeObserver) {
            _this._viewportResizeObserver.disconnect();
            delete _this._viewportResizeObserver;
          }
        };
        _this._updateViewport = function(withForceUpdate) {
          var viewport = _this.state.viewport;
          var viewportElement = _this._root.current;
          var scrollElement = findScrollableParent(viewportElement);
          var scrollRect = getRect(scrollElement);
          var clientRect = getRect(viewportElement);
          var updateComponent = function() {
            if (withForceUpdate && _this._composedComponentInstance) {
              _this._composedComponentInstance.forceUpdate();
            }
          };
          var isSizeChanged = (clientRect && clientRect.width) !== viewport.width || (scrollRect && scrollRect.height) !== viewport.height;
          if (isSizeChanged && _this._resizeAttempts < MAX_RESIZE_ATTEMPTS && clientRect && scrollRect) {
            _this._resizeAttempts++;
            _this.setState({
              viewport: {
                width: clientRect.width,
                height: scrollRect.height
              }
            }, function() {
              _this._updateViewport(withForceUpdate);
            });
          } else {
            _this._resizeAttempts = 0;
            updateComponent();
          }
        };
        _this._async = new Async(_this);
        _this._events = new EventGroup(_this);
        _this._resizeAttempts = 0;
        _this.state = {
          viewport: {
            width: 0,
            height: 0
          }
        };
        return _this;
      }
      WithViewportComponent.prototype.componentDidMount = function() {
        var _this = this;
        var _a2 = this.props, delayFirstMeasure = _a2.delayFirstMeasure, disableResizeObserver = _a2.disableResizeObserver, skipViewportMeasures = _a2.skipViewportMeasures;
        var win2 = getWindow$1(this._root.current);
        this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {
          leading: false
        });
        if (!skipViewportMeasures) {
          if (!disableResizeObserver && this._isResizeObserverAvailable()) {
            this._registerResizeObserver();
          } else {
            this._events.on(win2, "resize", this._onAsyncResize);
          }
          if (delayFirstMeasure) {
            this._async.setTimeout(function() {
              _this._updateViewport();
            }, RESIZE_DELAY);
          } else {
            this._updateViewport();
          }
        }
      };
      WithViewportComponent.prototype.componentDidUpdate = function(previousProps) {
        var previousSkipViewportMeasures = previousProps.skipViewportMeasures;
        var _a2 = this.props, disableResizeObserver = _a2.disableResizeObserver, skipViewportMeasures = _a2.skipViewportMeasures;
        var win2 = getWindow$1(this._root.current);
        if (skipViewportMeasures !== previousSkipViewportMeasures) {
          if (!skipViewportMeasures) {
            if (!disableResizeObserver && this._isResizeObserverAvailable()) {
              if (!this._viewportResizeObserver) {
                this._registerResizeObserver();
              }
            } else {
              this._events.on(win2, "resize", this._onAsyncResize);
            }
            this._updateViewport();
          } else {
            this._unregisterResizeObserver();
            this._events.off(win2, "resize", this._onAsyncResize);
          }
        }
      };
      WithViewportComponent.prototype.componentWillUnmount = function() {
        this._events.dispose();
        this._async.dispose();
        this._unregisterResizeObserver();
      };
      WithViewportComponent.prototype.render = function() {
        var viewport = this.state.viewport;
        var newViewport = viewport.width > 0 && viewport.height > 0 ? viewport : void 0;
        return React__namespace.createElement(
          "div",
          { className: "ms-Viewport", ref: this._root, style: { minWidth: 1, minHeight: 1 } },
          React__namespace.createElement(ComposedComponent, __assign$1({ ref: this._updateComposedComponentRef, viewport: newViewport }, this.props))
        );
      };
      WithViewportComponent.prototype.forceUpdate = function() {
        this._updateViewport(true);
      };
      WithViewportComponent.prototype._onAsyncResize = function() {
        this._updateViewport();
      };
      WithViewportComponent.prototype._isResizeObserverAvailable = function() {
        var win2 = getWindow$1(this._root.current);
        return win2 && win2.ResizeObserver;
      };
      return WithViewportComponent;
    }(BaseDecorator)
  );
}
var getClassNames$k = classNamesFunction();
var COMPONENT_NAME$5 = "DetailsList";
var MIN_COLUMN_WIDTH = 100;
var DEFAULT_RENDERED_WINDOWS_AHEAD = 2;
var DEFAULT_RENDERED_WINDOWS_BEHIND = 2;
var rowFocusZoneAddTabIndexProps = { tabIndex: 0 };
var rowFocusZoneNoTabIndexProps = {};
var DetailsListInner = function(props) {
  var selection = props.selection;
  var ariaLabelForListHeader = props.ariaLabelForListHeader, ariaLabelForSelectAllCheckbox = props.ariaLabelForSelectAllCheckbox, ariaLabelForSelectionColumn = props.ariaLabelForSelectionColumn, className = props.className, checkboxVisibility = props.checkboxVisibility, compact = props.compact, constrainMode = props.constrainMode, dragDropEvents = props.dragDropEvents, groups = props.groups, groupProps = props.groupProps, indentWidth = props.indentWidth, items = props.items, isPlaceholderData = props.isPlaceholderData, isHeaderVisible = props.isHeaderVisible, layoutMode = props.layoutMode, onItemInvoked = props.onItemInvoked, onItemContextMenu = props.onItemContextMenu, onColumnHeaderClick = props.onColumnHeaderClick, onColumnHeaderContextMenu = props.onColumnHeaderContextMenu, _a2 = props.selectionMode, selectionMode = _a2 === void 0 ? selection.mode : _a2, selectionPreservedOnEmptyClick = props.selectionPreservedOnEmptyClick, selectionZoneProps = props.selectionZoneProps, ariaLabel = props.ariaLabel, ariaLabelForGrid = props.ariaLabelForGrid, rowElementEventMap = props.rowElementEventMap, _b2 = props.shouldApplyApplicationRole, shouldApplyApplicationRole = _b2 === void 0 ? false : _b2, getKey = props.getKey, listProps = props.listProps, usePageCache = props.usePageCache, onShouldVirtualize = props.onShouldVirtualize, viewport = props.viewport, minimumPixelsForDrag = props.minimumPixelsForDrag, getGroupHeight = props.getGroupHeight, styles2 = props.styles, theme = props.theme, _c2 = props.cellStyleProps, cellStyleProps = _c2 === void 0 ? DEFAULT_CELL_STYLE_PROPS : _c2, onRenderCheckbox = props.onRenderCheckbox, useFastIcons = props.useFastIcons, dragDropHelper = props.dragDropHelper, adjustedColumns = props.adjustedColumns, isCollapsed = props.isCollapsed, isSizing = props.isSizing, isSomeGroupExpanded = props.isSomeGroupExpanded, version = props.version, rootRef = props.rootRef, listRef = props.listRef, focusZoneRef = props.focusZoneRef, columnReorderOptions = props.columnReorderOptions, groupedListRef = props.groupedListRef, headerRef = props.headerRef, onGroupExpandStateChanged = props.onGroupExpandStateChanged, onColumnIsSizingChanged = props.onColumnIsSizingChanged, onRowDidMount = props.onRowDidMount, onRowWillUnmount = props.onRowWillUnmount, disableSelectionZone = props.disableSelectionZone, _d2 = props.isSelectedOnFocus, isSelectedOnFocus = _d2 === void 0 ? true : _d2, onColumnResized = props.onColumnResized, onColumnAutoResized = props.onColumnAutoResized, onToggleCollapse = props.onToggleCollapse, onActiveRowChanged = props.onActiveRowChanged, onBlur = props.onBlur, eventsToRegister = props.rowElementEventMap, onRenderMissingItem = props.onRenderMissingItem, onRenderItemColumn = props.onRenderItemColumn, onRenderField = props.onRenderField, getCellValueKey = props.getCellValueKey, getRowAriaLabel = props.getRowAriaLabel, getRowAriaDescribedBy = props.getRowAriaDescribedBy, checkButtonAriaLabel = props.checkButtonAriaLabel, checkButtonGroupAriaLabel = props.checkButtonGroupAriaLabel, checkboxCellClassName = props.checkboxCellClassName, useReducedRowRenderer = props.useReducedRowRenderer, enableUpdateAnimations = props.enableUpdateAnimations, enterModalSelectionOnTouch = props.enterModalSelectionOnTouch, onRenderDefaultRow = props.onRenderDefaultRow, selectionZoneRef = props.selectionZoneRef, focusZoneProps = props.focusZoneProps;
  var defaultRole = "grid";
  var role = props.role ? props.role : defaultRole;
  var rowId = getId("row");
  var groupNestingDepth = getGroupNestingDepth(groups);
  var groupedDetailsListIndexMap = useGroupedDetailsListIndexMap(groups);
  var additionalListProps = React__namespace.useMemo(function() {
    return __assign$1({ renderedWindowsAhead: isSizing ? 0 : DEFAULT_RENDERED_WINDOWS_AHEAD, renderedWindowsBehind: isSizing ? 0 : DEFAULT_RENDERED_WINDOWS_BEHIND, getKey, version }, listProps);
  }, [isSizing, getKey, version, listProps]);
  var selectAllVisibility = SelectAllVisibility.none;
  if (selectionMode === SelectionMode.single) {
    selectAllVisibility = SelectAllVisibility.hidden;
  }
  if (selectionMode === SelectionMode.multiple) {
    var isCollapsedGroupSelectVisible = groupProps && groupProps.headerProps && groupProps.headerProps.isCollapsedGroupSelectVisible;
    if (isCollapsedGroupSelectVisible === void 0) {
      isCollapsedGroupSelectVisible = true;
    }
    var isSelectAllVisible = isCollapsedGroupSelectVisible || !groups || isSomeGroupExpanded;
    selectAllVisibility = isSelectAllVisible ? SelectAllVisibility.visible : SelectAllVisibility.hidden;
  }
  if (checkboxVisibility === CheckboxVisibility.hidden) {
    selectAllVisibility = SelectAllVisibility.none;
  }
  var defaultOnRenderDetailsHeader = React__namespace.useCallback(function(detailsHeaderProps) {
    return React__namespace.createElement(DetailsHeader, __assign$1({}, detailsHeaderProps));
  }, []);
  var defaultOnRenderDetailsFooter = React__namespace.useCallback(function() {
    return null;
  }, []);
  var propsOnRenderDetailsHeader = props.onRenderDetailsHeader;
  var onRenderDetailsHeader = React__namespace.useMemo(function() {
    return propsOnRenderDetailsHeader ? composeRenderFunction(propsOnRenderDetailsHeader, defaultOnRenderDetailsHeader) : defaultOnRenderDetailsHeader;
  }, [propsOnRenderDetailsHeader, defaultOnRenderDetailsHeader]);
  var propsOnRenderDetailsFooter = props.onRenderDetailsFooter;
  var onRenderDetailsFooter = React__namespace.useMemo(function() {
    return propsOnRenderDetailsFooter ? composeRenderFunction(propsOnRenderDetailsFooter, defaultOnRenderDetailsFooter) : defaultOnRenderDetailsFooter;
  }, [propsOnRenderDetailsFooter, defaultOnRenderDetailsFooter]);
  var detailsFooterProps = React__namespace.useMemo(function() {
    return {
      columns: adjustedColumns,
      groupNestingDepth,
      selection,
      selectionMode,
      viewport,
      checkboxVisibility,
      indentWidth,
      cellStyleProps
    };
  }, [
    adjustedColumns,
    groupNestingDepth,
    selection,
    selectionMode,
    viewport,
    checkboxVisibility,
    indentWidth,
    cellStyleProps
  ]);
  var columnReorderOnDragEnd = columnReorderOptions && columnReorderOptions.onDragEnd;
  var onColumnDragEnd = React__namespace.useCallback(function(_a3, event) {
    var dropLocation = _a3.dropLocation;
    var finalDropLocation = ColumnDragEndLocation.outside;
    if (columnReorderOnDragEnd) {
      if (dropLocation && dropLocation !== ColumnDragEndLocation.header) {
        finalDropLocation = dropLocation;
      } else if (rootRef.current) {
        var clientRect = rootRef.current.getBoundingClientRect();
        if (event.clientX > clientRect.left && event.clientX < clientRect.right && event.clientY > clientRect.top && event.clientY < clientRect.bottom) {
          finalDropLocation = ColumnDragEndLocation.surface;
        }
      }
      columnReorderOnDragEnd(finalDropLocation);
    }
  }, [columnReorderOnDragEnd, rootRef]);
  var columnReorderProps = React__namespace.useMemo(function() {
    if (columnReorderOptions) {
      return __assign$1(__assign$1({}, columnReorderOptions), { onColumnDragEnd });
    }
  }, [columnReorderOptions, onColumnDragEnd]);
  var rowCount = (isHeaderVisible ? 1 : 0) + (props.onRenderDetailsFooter ? 1 : 0) + GetGroupCount(groups) + (items ? items.length : 0);
  var colCount = (selectAllVisibility !== SelectAllVisibility.none ? 1 : 0) + (adjustedColumns ? adjustedColumns.length : 0) + (groups ? 1 : 0);
  var classNames2 = React__namespace.useMemo(function() {
    return getClassNames$k(styles2, {
      theme,
      compact,
      isFixed: layoutMode === DetailsListLayoutMode.fixedColumns,
      isHorizontalConstrained: constrainMode === ConstrainMode.horizontalConstrained,
      className
    });
  }, [styles2, theme, compact, layoutMode, constrainMode, className]);
  var onRenderDetailsGroupFooter = groupProps && groupProps.onRenderFooter;
  var finalOnRenderDetailsGroupFooter = React__namespace.useMemo(function() {
    return onRenderDetailsGroupFooter ? function(groupFooterProps, defaultRender) {
      return onRenderDetailsGroupFooter(__assign$1(__assign$1({}, groupFooterProps), { columns: adjustedColumns, groupNestingDepth, indentWidth, selection, selectionMode, viewport, checkboxVisibility, cellStyleProps }), defaultRender);
    } : void 0;
  }, [
    onRenderDetailsGroupFooter,
    adjustedColumns,
    groupNestingDepth,
    indentWidth,
    selection,
    selectionMode,
    viewport,
    checkboxVisibility,
    cellStyleProps
  ]);
  var onRenderDetailsGroupHeader = groupProps && groupProps.onRenderHeader;
  var finalOnRenderDetailsGroupHeader = React__namespace.useMemo(function() {
    return onRenderDetailsGroupHeader ? function(groupHeaderProps, defaultRender) {
      var _a3, _b3;
      var groupIndex = groupHeaderProps.groupIndex;
      var groupKey = groupIndex !== void 0 ? (_b3 = (_a3 = groupHeaderProps.groups) === null || _a3 === void 0 ? void 0 : _a3[groupIndex]) === null || _b3 === void 0 ? void 0 : _b3.key : void 0;
      var totalRowCount = groupKey !== void 0 && groupedDetailsListIndexMap[groupKey] ? groupedDetailsListIndexMap[groupKey].totalRowCount : 0;
      return onRenderDetailsGroupHeader(__assign$1(__assign$1({}, groupHeaderProps), { columns: adjustedColumns, groupNestingDepth, indentWidth, selection, selectionMode: checkboxVisibility !== CheckboxVisibility.hidden ? selectionMode : SelectionMode.none, viewport, checkboxVisibility, cellStyleProps, ariaColSpan: adjustedColumns.length, ariaLevel: void 0, ariaPosInSet: void 0, ariaSetSize: void 0, ariaRowCount: void 0, ariaRowIndex: groupIndex !== void 0 ? totalRowCount + (isHeaderVisible ? 1 : 0) : void 0 }), defaultRender);
    } : function(groupHeaderProps, defaultRender) {
      var _a3, _b3;
      var groupIndex = groupHeaderProps.groupIndex;
      var groupKey = groupIndex !== void 0 ? (_b3 = (_a3 = groupHeaderProps.groups) === null || _a3 === void 0 ? void 0 : _a3[groupIndex]) === null || _b3 === void 0 ? void 0 : _b3.key : void 0;
      var totalRowCount = groupKey !== void 0 && groupedDetailsListIndexMap[groupKey] ? groupedDetailsListIndexMap[groupKey].totalRowCount : 0;
      return defaultRender(__assign$1(__assign$1({}, groupHeaderProps), { ariaColSpan: adjustedColumns.length, ariaLevel: void 0, ariaPosInSet: void 0, ariaSetSize: void 0, ariaRowCount: void 0, ariaRowIndex: groupIndex !== void 0 ? totalRowCount + (isHeaderVisible ? 1 : 0) : void 0 }));
    };
  }, [
    onRenderDetailsGroupHeader,
    adjustedColumns,
    groupNestingDepth,
    indentWidth,
    isHeaderVisible,
    selection,
    selectionMode,
    viewport,
    checkboxVisibility,
    cellStyleProps,
    groupedDetailsListIndexMap
  ]);
  var finalGroupProps = React__namespace.useMemo(function() {
    var _a3;
    return __assign$1(__assign$1({}, groupProps), {
      role: role === defaultRole ? "rowgroup" : "presentation",
      onRenderFooter: finalOnRenderDetailsGroupFooter,
      onRenderHeader: finalOnRenderDetailsGroupHeader,
      // pass through custom group header checkbox label
      headerProps: __assign$1(__assign$1({}, groupProps === null || groupProps === void 0 ? void 0 : groupProps.headerProps), { selectAllButtonProps: __assign$1({ "aria-label": checkButtonGroupAriaLabel }, (_a3 = groupProps === null || groupProps === void 0 ? void 0 : groupProps.headerProps) === null || _a3 === void 0 ? void 0 : _a3.selectAllButtonProps) })
    });
  }, [groupProps, finalOnRenderDetailsGroupFooter, finalOnRenderDetailsGroupHeader, checkButtonGroupAriaLabel, role]);
  var sumColumnWidths = useConst(function() {
    return memoizeFunction(function(columns) {
      var totalWidth = 0;
      columns.forEach(function(column2) {
        return totalWidth += column2.calculatedWidth || column2.minWidth;
      });
      return totalWidth;
    });
  });
  var collapseAllVisibility = groupProps && groupProps.collapseAllVisibility;
  var rowWidth = React__namespace.useMemo(function() {
    return sumColumnWidths(adjustedColumns);
  }, [adjustedColumns, sumColumnWidths]);
  var onRenderCell = React__namespace.useCallback(function(nestingDepth, item, index2, group) {
    var finalOnRenderRow = props.onRenderRow ? composeRenderFunction(props.onRenderRow, onRenderDefaultRow) : onRenderDefaultRow;
    var groupKey = group ? group.key : void 0;
    var numOfGroupHeadersBeforeItem = groupKey && groupedDetailsListIndexMap[groupKey] ? groupedDetailsListIndexMap[groupKey].numOfGroupHeadersBeforeItem : 0;
    var rowRole = role === defaultRole ? void 0 : "presentation";
    var rowFocusZoneProps = isHeaderVisible || index2 > 0 ? rowFocusZoneNoTabIndexProps : rowFocusZoneAddTabIndexProps;
    var rowProps = {
      item,
      itemIndex: index2,
      flatIndexOffset: (isHeaderVisible ? 2 : 1) + numOfGroupHeadersBeforeItem,
      compact,
      columns: adjustedColumns,
      groupNestingDepth: nestingDepth,
      id: rowId + "-" + index2,
      selectionMode,
      selection,
      onDidMount: onRowDidMount,
      onWillUnmount: onRowWillUnmount,
      onRenderItemColumn,
      onRenderField,
      getCellValueKey,
      eventsToRegister,
      dragDropEvents,
      dragDropHelper,
      viewport,
      checkboxVisibility,
      collapseAllVisibility,
      getRowAriaLabel,
      getRowAriaDescribedBy,
      checkButtonAriaLabel,
      checkboxCellClassName,
      useReducedRowRenderer,
      indentWidth,
      cellStyleProps,
      onRenderDetailsCheckbox: onRenderCheckbox,
      enableUpdateAnimations,
      rowWidth,
      useFastIcons,
      role: rowRole,
      isGridRow: true,
      focusZoneProps: rowFocusZoneProps
    };
    if (!item) {
      if (onRenderMissingItem) {
        return onRenderMissingItem(index2, rowProps);
      }
      return null;
    }
    return finalOnRenderRow(rowProps);
  }, [
    compact,
    adjustedColumns,
    selectionMode,
    selection,
    rowId,
    onRowDidMount,
    onRowWillUnmount,
    onRenderItemColumn,
    onRenderField,
    getCellValueKey,
    eventsToRegister,
    dragDropEvents,
    dragDropHelper,
    viewport,
    checkboxVisibility,
    collapseAllVisibility,
    getRowAriaLabel,
    getRowAriaDescribedBy,
    isHeaderVisible,
    checkButtonAriaLabel,
    checkboxCellClassName,
    useReducedRowRenderer,
    indentWidth,
    cellStyleProps,
    onRenderCheckbox,
    enableUpdateAnimations,
    useFastIcons,
    onRenderDefaultRow,
    onRenderMissingItem,
    props.onRenderRow,
    rowWidth,
    role,
    groupedDetailsListIndexMap
  ]);
  var onRenderListCell = React__namespace.useCallback(function(nestingDepth) {
    return function(item, itemIndex) {
      return onRenderCell(nestingDepth, item, itemIndex);
    };
  }, [onRenderCell]);
  var isRightArrow = React__namespace.useCallback(function(event) {
    return event.which === getRTLSafeKeyCode(KeyCodes.right, theme);
  }, [theme]);
  var focusZoneInnerProps = __assign$1(__assign$1({}, focusZoneProps), { componentRef: focusZoneProps && focusZoneProps.componentRef ? focusZoneProps.componentRef : focusZoneRef, className: focusZoneProps && focusZoneProps.className ? css$3(classNames2.focusZone, focusZoneProps.className) : classNames2.focusZone, direction: focusZoneProps ? focusZoneProps.direction : FocusZoneDirection.vertical, shouldEnterInnerZone: focusZoneProps && focusZoneProps.shouldEnterInnerZone ? focusZoneProps.shouldEnterInnerZone : isRightArrow, onActiveElementChanged: focusZoneProps && focusZoneProps.onActiveElementChanged ? focusZoneProps.onActiveElementChanged : onActiveRowChanged, shouldRaiseClicksOnEnter: false, onBlur: focusZoneProps && focusZoneProps.onBlur ? focusZoneProps.onBlur : onBlur });
  var FinalGroupedList = groups && (groupProps === null || groupProps === void 0 ? void 0 : groupProps.groupedListAs) ? composeComponentAs(groupProps.groupedListAs, GroupedList) : GroupedList;
  var list = groups ? React__namespace.createElement(FinalGroupedList, { focusZoneProps: focusZoneInnerProps, componentRef: groupedListRef, groups, groupProps: finalGroupProps, items, onRenderCell, role: "presentation", selection, selectionMode: checkboxVisibility !== CheckboxVisibility.hidden ? selectionMode : SelectionMode.none, dragDropEvents, dragDropHelper, eventsToRegister: rowElementEventMap, listProps: additionalListProps, onGroupExpandStateChanged, usePageCache, onShouldVirtualize, getGroupHeight, compact }) : React__namespace.createElement(
    FocusZone,
    __assign$1({}, focusZoneInnerProps),
    React__namespace.createElement(List, __assign$1({ ref: listRef, role: "presentation", items, onRenderCell: onRenderListCell(0), usePageCache, onShouldVirtualize }, additionalListProps))
  );
  var onHeaderKeyDown = React__namespace.useCallback(function(ev) {
    if (ev.which === KeyCodes.down) {
      if (focusZoneRef.current && focusZoneRef.current.focus()) {
        if (isSelectedOnFocus && selection.getSelectedIndices().length === 0) {
          selection.setIndexSelected(0, true, false);
        }
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  }, [selection, focusZoneRef, isSelectedOnFocus]);
  var onContentKeyDown = React__namespace.useCallback(function(ev) {
    if (ev.which === KeyCodes.up && !ev.altKey) {
      if (headerRef.current && headerRef.current.focus()) {
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  }, [headerRef]);
  return React__namespace.createElement(
    "div",
    __assign$1({ ref: rootRef, className: classNames2.root, "data-automationid": "DetailsList", "data-is-scrollable": "false" }, shouldApplyApplicationRole ? { role: "application" } : {}),
    React__namespace.createElement(FocusRects, null),
    React__namespace.createElement(
      "div",
      { role, "aria-label": ariaLabelForGrid || ariaLabel, "aria-rowcount": isPlaceholderData ? 0 : rowCount, "aria-colcount": colCount, "aria-busy": isPlaceholderData },
      React__namespace.createElement("div", { onKeyDown: onHeaderKeyDown, role: "presentation", className: classNames2.headerWrapper }, isHeaderVisible && onRenderDetailsHeader({
        componentRef: headerRef,
        selectionMode,
        layoutMode,
        selection,
        columns: adjustedColumns,
        onColumnClick: onColumnHeaderClick,
        onColumnContextMenu: onColumnHeaderContextMenu,
        onColumnResized,
        onColumnIsSizingChanged,
        onColumnAutoResized,
        groupNestingDepth,
        isAllCollapsed: isCollapsed,
        onToggleCollapseAll: onToggleCollapse,
        ariaLabel: ariaLabelForListHeader,
        ariaLabelForSelectAllCheckbox,
        ariaLabelForSelectionColumn,
        selectAllVisibility,
        collapseAllVisibility: groupProps && groupProps.collapseAllVisibility,
        viewport,
        columnReorderProps,
        minimumPixelsForDrag,
        cellStyleProps,
        checkboxVisibility,
        indentWidth,
        onRenderDetailsCheckbox: onRenderCheckbox,
        rowWidth: sumColumnWidths(adjustedColumns),
        useFastIcons
      }, onRenderDetailsHeader)),
      React__namespace.createElement("div", { onKeyDown: onContentKeyDown, role: "presentation", className: classNames2.contentWrapper }, !disableSelectionZone ? React__namespace.createElement(SelectionZone, __assign$1({ ref: selectionZoneRef, selection, selectionPreservedOnEmptyClick, selectionMode, isSelectedOnFocus, selectionClearedOnEscapePress: isSelectedOnFocus, toggleWithoutModifierPressed: !isSelectedOnFocus, onItemInvoked, onItemContextMenu, enterModalOnTouch: enterModalSelectionOnTouch }, selectionZoneProps || {}), list) : list),
      onRenderDetailsFooter(__assign$1({}, detailsFooterProps))
    )
  );
};
var DetailsListBase = (
  /** @class */
  function(_super) {
    __extends(DetailsListBase2, _super);
    function DetailsListBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._root = React__namespace.createRef();
      _this._header = React__namespace.createRef();
      _this._groupedList = React__namespace.createRef();
      _this._list = React__namespace.createRef();
      _this._focusZone = React__namespace.createRef();
      _this._selectionZone = React__namespace.createRef();
      _this._onRenderRow = function(props2, defaultRender) {
        return React__namespace.createElement(DetailsRow, __assign$1({}, props2));
      };
      _this._getDerivedStateFromProps = function(nextProps, previousState) {
        var _a2 = _this.props, checkboxVisibility = _a2.checkboxVisibility, items = _a2.items, setKey = _a2.setKey, _b2 = _a2.selectionMode, selectionMode = _b2 === void 0 ? _this._selection.mode : _b2, columns = _a2.columns, viewport = _a2.viewport, compact = _a2.compact, dragDropEvents = _a2.dragDropEvents;
        var _c2 = (_this.props.groupProps || {}).isAllGroupsCollapsed, isAllGroupsCollapsed = _c2 === void 0 ? void 0 : _c2;
        var newViewportWidth = nextProps.viewport && nextProps.viewport.width || 0;
        var oldViewportWidth = viewport && viewport.width || 0;
        var shouldResetSelection = nextProps.setKey !== setKey || nextProps.setKey === void 0;
        var shouldForceUpdates = false;
        if (nextProps.layoutMode !== _this.props.layoutMode) {
          shouldForceUpdates = true;
        }
        var nextState = previousState;
        if (shouldResetSelection) {
          _this._initialFocusedIndex = nextProps.initialFocusedIndex;
          nextState = __assign$1(__assign$1({}, nextState), { focusedItemIndex: _this._initialFocusedIndex !== void 0 ? _this._initialFocusedIndex : -1 });
        }
        if (!_this.props.disableSelectionZone && nextProps.items !== items) {
          _this._selection.setItems(nextProps.items, shouldResetSelection);
        }
        if (nextProps.checkboxVisibility !== checkboxVisibility || nextProps.columns !== columns || newViewportWidth !== oldViewportWidth || nextProps.compact !== compact) {
          shouldForceUpdates = true;
        }
        nextState = __assign$1(__assign$1({}, nextState), _this._adjustColumns(nextProps, nextState, true));
        if (nextProps.selectionMode !== selectionMode) {
          shouldForceUpdates = true;
        }
        if (isAllGroupsCollapsed === void 0 && nextProps.groupProps && nextProps.groupProps.isAllGroupsCollapsed !== void 0) {
          nextState = __assign$1(__assign$1({}, nextState), { isCollapsed: nextProps.groupProps.isAllGroupsCollapsed, isSomeGroupExpanded: !nextProps.groupProps.isAllGroupsCollapsed });
        }
        if (nextProps.dragDropEvents !== dragDropEvents) {
          _this._dragDropHelper && _this._dragDropHelper.dispose();
          _this._dragDropHelper = nextProps.dragDropEvents ? new DragDropHelper({
            selection: _this._selection,
            minimumPixelsForDrag: nextProps.minimumPixelsForDrag
          }) : void 0;
          shouldForceUpdates = true;
        }
        if (shouldForceUpdates) {
          nextState = __assign$1(__assign$1({}, nextState), { version: {} });
        }
        return nextState;
      };
      _this._onGroupExpandStateChanged = function(isSomeGroupExpanded) {
        _this.setState({ isSomeGroupExpanded });
      };
      _this._onColumnIsSizingChanged = function(column2, isSizing) {
        _this.setState({ isSizing });
      };
      _this._onRowDidMount = function(row) {
        var _a2 = row.props, item = _a2.item, itemIndex = _a2.itemIndex;
        var itemKey = _this._getItemKey(item, itemIndex);
        _this._activeRows[itemKey] = row;
        _this._setFocusToRowIfPending(row);
        var onRowDidMount = _this.props.onRowDidMount;
        if (onRowDidMount) {
          onRowDidMount(item, itemIndex);
        }
      };
      _this._onRowWillUnmount = function(row) {
        var onRowWillUnmount = _this.props.onRowWillUnmount;
        var _a2 = row.props, item = _a2.item, itemIndex = _a2.itemIndex;
        var itemKey = _this._getItemKey(item, itemIndex);
        delete _this._activeRows[itemKey];
        if (onRowWillUnmount) {
          onRowWillUnmount(item, itemIndex);
        }
      };
      _this._onToggleCollapse = function(collapsed) {
        _this.setState({
          isCollapsed: collapsed
        });
        if (_this._groupedList.current) {
          _this._groupedList.current.toggleCollapseAll(collapsed);
        }
      };
      _this._onColumnResized = function(resizingColumn, newWidth, resizingColumnIndex) {
        var newCalculatedWidth = Math.max(resizingColumn.minWidth || MIN_COLUMN_WIDTH, newWidth);
        if (_this.props.onColumnResize) {
          _this.props.onColumnResize(resizingColumn, newCalculatedWidth, resizingColumnIndex);
        }
        _this._rememberCalculatedWidth(resizingColumn, newCalculatedWidth);
        _this.setState(__assign$1(__assign$1({}, _this._adjustColumns(_this.props, _this.state, true, resizingColumnIndex)), { version: {} }));
      };
      _this._onColumnAutoResized = function(column2, columnIndex) {
        var max2 = 0;
        var count = 0;
        var totalCount = Object.keys(_this._activeRows).length;
        for (var key in _this._activeRows) {
          if (_this._activeRows.hasOwnProperty(key)) {
            var currentRow = _this._activeRows[key];
            currentRow.measureCell(columnIndex, function(width) {
              max2 = Math.max(max2, width);
              count++;
              if (count === totalCount) {
                _this._onColumnResized(column2, max2, columnIndex);
              }
            });
          }
        }
      };
      _this._onActiveRowChanged = function(el, ev) {
        var _a2 = _this.props, items = _a2.items, onActiveItemChanged = _a2.onActiveItemChanged;
        if (!el) {
          return;
        }
        if (el.getAttribute("data-item-index")) {
          var index2 = Number(el.getAttribute("data-item-index"));
          if (index2 >= 0) {
            if (onActiveItemChanged) {
              onActiveItemChanged(items[index2], index2, ev);
            }
            _this.setState({
              focusedItemIndex: index2
            });
          }
        }
      };
      _this._onBlur = function(event) {
        _this.setState({
          focusedItemIndex: -1
        });
      };
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      _this._activeRows = {};
      _this._columnOverrides = {};
      _this.state = {
        focusedItemIndex: -1,
        lastWidth: 0,
        adjustedColumns: _this._getAdjustedColumns(props, void 0),
        isSizing: false,
        isCollapsed: props.groupProps && props.groupProps.isAllGroupsCollapsed,
        isSomeGroupExpanded: props.groupProps && !props.groupProps.isAllGroupsCollapsed,
        version: {},
        getDerivedStateFromProps: _this._getDerivedStateFromProps
      };
      warnMutuallyExclusive(COMPONENT_NAME$5, props, {
        selection: "getKey"
      });
      _this._selection = props.selection || new Selection({
        onSelectionChanged: void 0,
        getKey: props.getKey,
        selectionMode: props.selectionMode
      });
      if (!_this.props.disableSelectionZone) {
        _this._selection.setItems(props.items, false);
      }
      _this._dragDropHelper = props.dragDropEvents ? new DragDropHelper({
        selection: _this._selection,
        minimumPixelsForDrag: props.minimumPixelsForDrag
      }) : void 0;
      _this._initialFocusedIndex = props.initialFocusedIndex;
      return _this;
    }
    DetailsListBase2.getDerivedStateFromProps = function(nextProps, previousState) {
      return previousState.getDerivedStateFromProps(nextProps, previousState);
    };
    DetailsListBase2.prototype.scrollToIndex = function(index2, measureItem, scrollToMode) {
      this._list.current && this._list.current.scrollToIndex(index2, measureItem, scrollToMode);
      this._groupedList.current && this._groupedList.current.scrollToIndex(index2, measureItem, scrollToMode);
    };
    DetailsListBase2.prototype.focusIndex = function(index2, forceIntoFirstElement, measureItem, scrollToMode) {
      if (forceIntoFirstElement === void 0) {
        forceIntoFirstElement = false;
      }
      var item = this.props.items[index2];
      if (item) {
        this.scrollToIndex(index2, measureItem, scrollToMode);
        var itemKey = this._getItemKey(item, index2);
        var row = this._activeRows[itemKey];
        if (row) {
          this._setFocusToRow(row, forceIntoFirstElement);
        }
      }
    };
    DetailsListBase2.prototype.getStartItemIndexInView = function() {
      if (this._list && this._list.current) {
        return this._list.current.getStartItemIndexInView();
      } else if (this._groupedList && this._groupedList.current) {
        return this._groupedList.current.getStartItemIndexInView();
      }
      return 0;
    };
    DetailsListBase2.prototype.updateColumn = function(column2, options2) {
      var _a2, _b2;
      var NO_COLUMNS2 = [];
      var _c2 = this.props, _d2 = _c2.columns, columns = _d2 === void 0 ? NO_COLUMNS2 : _d2, selectionMode = _c2.selectionMode, checkboxVisibility = _c2.checkboxVisibility, columnReorderOptions = _c2.columnReorderOptions;
      var width = options2.width, newColumnIndex = options2.newColumnIndex;
      var index2 = columns.findIndex(function(col) {
        return col.key === column2.key;
      });
      if (width) {
        this._onColumnResized(column2, width, index2);
      }
      if (newColumnIndex !== void 0 && columnReorderOptions) {
        var isCheckboxColumnHidden = selectionMode === SelectionMode.none || checkboxVisibility === CheckboxVisibility.hidden;
        var showCheckbox = checkboxVisibility !== CheckboxVisibility.hidden;
        var columnIndex = (showCheckbox ? 2 : 1) + index2;
        var draggedIndex = isCheckboxColumnHidden ? columnIndex - 1 : columnIndex - 2;
        var targetIndex = isCheckboxColumnHidden ? newColumnIndex - 1 : newColumnIndex - 2;
        var frozenColumnCountFromStart = (_a2 = columnReorderOptions.frozenColumnCountFromStart) !== null && _a2 !== void 0 ? _a2 : 0;
        var frozenColumnCountFromEnd = (_b2 = columnReorderOptions.frozenColumnCountFromEnd) !== null && _b2 !== void 0 ? _b2 : 0;
        var isValidTargetIndex = targetIndex >= frozenColumnCountFromStart && targetIndex < columns.length - frozenColumnCountFromEnd;
        if (isValidTargetIndex) {
          if (columnReorderOptions.onColumnDrop) {
            var dragDropDetails = {
              draggedIndex,
              targetIndex
            };
            columnReorderOptions.onColumnDrop(dragDropDetails);
          } else if (columnReorderOptions.handleColumnReorder) {
            columnReorderOptions.handleColumnReorder(draggedIndex, targetIndex);
          }
        }
      }
    };
    DetailsListBase2.prototype.componentWillUnmount = function() {
      if (this._dragDropHelper) {
        this._dragDropHelper.dispose();
      }
      this._async.dispose();
    };
    DetailsListBase2.prototype.componentDidUpdate = function(prevProps, prevState) {
      this._notifyColumnsResized();
      if (this._initialFocusedIndex !== void 0) {
        var item = this.props.items[this._initialFocusedIndex];
        if (item) {
          var itemKey = this._getItemKey(item, this._initialFocusedIndex);
          var row = this._activeRows[itemKey];
          if (row) {
            this._setFocusToRowIfPending(row);
          }
        }
      }
      if (this.props.items !== prevProps.items && this.props.items.length > 0 && this.state.focusedItemIndex !== -1 && !elementContains(this._root.current, document.activeElement, false)) {
        var index2 = this.state.focusedItemIndex < this.props.items.length ? this.state.focusedItemIndex : this.props.items.length - 1;
        var item = this.props.items[index2];
        var itemKey = this._getItemKey(item, this.state.focusedItemIndex);
        var row = this._activeRows[itemKey];
        if (row) {
          this._setFocusToRow(row);
        } else {
          this._initialFocusedIndex = index2;
        }
      }
      if (this.props.onDidUpdate) {
        this.props.onDidUpdate(this);
      }
    };
    DetailsListBase2.prototype.render = function() {
      return React__namespace.createElement(DetailsListInner, __assign$1({}, this.props, this.state, { selection: this._selection, dragDropHelper: this._dragDropHelper, rootRef: this._root, listRef: this._list, groupedListRef: this._groupedList, focusZoneRef: this._focusZone, headerRef: this._header, selectionZoneRef: this._selectionZone, onGroupExpandStateChanged: this._onGroupExpandStateChanged, onColumnIsSizingChanged: this._onColumnIsSizingChanged, onRowDidMount: this._onRowDidMount, onRowWillUnmount: this._onRowWillUnmount, onColumnResized: this._onColumnResized, onColumnAutoResized: this._onColumnAutoResized, onToggleCollapse: this._onToggleCollapse, onActiveRowChanged: this._onActiveRowChanged, onBlur: this._onBlur, onRenderDefaultRow: this._onRenderRow }));
    };
    DetailsListBase2.prototype.forceUpdate = function() {
      _super.prototype.forceUpdate.call(this);
      this._forceListUpdates();
    };
    DetailsListBase2.prototype._getGroupNestingDepth = function() {
      var groups = this.props.groups;
      var level = 0;
      var groupsInLevel = groups;
      while (groupsInLevel && groupsInLevel.length > 0) {
        level++;
        groupsInLevel = groupsInLevel[0].children;
      }
      return level;
    };
    DetailsListBase2.prototype._setFocusToRowIfPending = function(row) {
      var itemIndex = row.props.itemIndex;
      if (this._initialFocusedIndex !== void 0 && itemIndex === this._initialFocusedIndex) {
        this._setFocusToRow(row);
        delete this._initialFocusedIndex;
      }
    };
    DetailsListBase2.prototype._setFocusToRow = function(row, forceIntoFirstElement) {
      if (forceIntoFirstElement === void 0) {
        forceIntoFirstElement = false;
      }
      if (this._selectionZone.current) {
        this._selectionZone.current.ignoreNextFocus();
      }
      this._async.setTimeout(function() {
        row.focus(forceIntoFirstElement);
      }, 0);
    };
    DetailsListBase2.prototype._forceListUpdates = function() {
      if (this._groupedList.current) {
        this._groupedList.current.forceUpdate();
      }
      if (this._list.current) {
        this._list.current.forceUpdate();
      }
    };
    DetailsListBase2.prototype._notifyColumnsResized = function() {
      this.state.adjustedColumns.forEach(function(column2) {
        if (column2.onColumnResize) {
          column2.onColumnResize(column2.currentWidth);
        }
      });
    };
    DetailsListBase2.prototype._adjustColumns = function(newProps, previousState, forceUpdate, resizingColumnIndex) {
      var adjustedColumns = this._getAdjustedColumns(newProps, previousState, forceUpdate, resizingColumnIndex);
      var viewport = this.props.viewport;
      var viewportWidth = viewport && viewport.width ? viewport.width : 0;
      return __assign$1(__assign$1({}, previousState), { adjustedColumns, lastWidth: viewportWidth });
    };
    DetailsListBase2.prototype._getAdjustedColumns = function(newProps, previousState, forceUpdate, resizingColumnIndex) {
      var _this = this;
      var newItems = newProps.items, layoutMode = newProps.layoutMode, selectionMode = newProps.selectionMode, viewport = newProps.viewport;
      var viewportWidth = viewport && viewport.width ? viewport.width : 0;
      var newColumns = newProps.columns;
      var columns = this.props ? this.props.columns : [];
      var lastWidth = previousState ? previousState.lastWidth : -1;
      var lastSelectionMode = previousState ? previousState.lastSelectionMode : void 0;
      if (!forceUpdate && lastWidth === viewportWidth && lastSelectionMode === selectionMode && (!columns || newColumns === columns)) {
        return newColumns || [];
      }
      newColumns = newColumns || buildColumns(newItems, true);
      var adjustedColumns;
      if (layoutMode === DetailsListLayoutMode.fixedColumns) {
        adjustedColumns = this._getFixedColumns(newColumns, viewportWidth, newProps);
        adjustedColumns.forEach(function(column2) {
          _this._rememberCalculatedWidth(column2, column2.calculatedWidth);
        });
      } else {
        adjustedColumns = this._getJustifiedColumns(newColumns, viewportWidth, newProps);
        adjustedColumns.forEach(function(column2) {
          _this._getColumnOverride(column2.key).currentWidth = column2.calculatedWidth;
        });
      }
      return adjustedColumns;
    };
    DetailsListBase2.prototype._getFixedColumns = function(newColumns, viewportWidth, props) {
      var _this = this;
      var _a2 = this.props, _b2 = _a2.selectionMode, selectionMode = _b2 === void 0 ? this._selection.mode : _b2, checkboxVisibility = _a2.checkboxVisibility, flexMargin = _a2.flexMargin, skipViewportMeasures = _a2.skipViewportMeasures;
      var remainingWidth = viewportWidth - (flexMargin || 0);
      var sumProportionalWidth = 0;
      newColumns.forEach(function(col) {
        if (skipViewportMeasures || !col.flexGrow) {
          remainingWidth -= col.maxWidth || col.minWidth || MIN_COLUMN_WIDTH;
        } else {
          remainingWidth -= col.minWidth || MIN_COLUMN_WIDTH;
          sumProportionalWidth += col.flexGrow;
        }
        remainingWidth -= getPaddedWidth(col, props, true);
      });
      var rowCheckWidth = selectionMode !== SelectionMode.none && checkboxVisibility !== CheckboxVisibility.hidden ? CHECK_CELL_WIDTH : 0;
      var groupExpandWidth = this._getGroupNestingDepth() * SPACER_WIDTH;
      remainingWidth -= rowCheckWidth + groupExpandWidth;
      var widthFraction = remainingWidth / sumProportionalWidth;
      if (!skipViewportMeasures) {
        newColumns.forEach(function(column2) {
          var newColumn = __assign$1(__assign$1({}, column2), _this._columnOverrides[column2.key]);
          if (newColumn.flexGrow && newColumn.maxWidth) {
            var fullWidth = newColumn.flexGrow * widthFraction + newColumn.minWidth;
            var shrinkWidth = fullWidth - newColumn.maxWidth;
            if (shrinkWidth > 0) {
              remainingWidth += shrinkWidth;
              sumProportionalWidth -= shrinkWidth / (fullWidth - newColumn.minWidth) * newColumn.flexGrow;
            }
          }
        });
      }
      widthFraction = remainingWidth > 0 ? remainingWidth / sumProportionalWidth : 0;
      return newColumns.map(function(column2) {
        var newColumn = __assign$1(__assign$1({}, column2), _this._columnOverrides[column2.key]);
        if (!skipViewportMeasures && newColumn.flexGrow && remainingWidth <= 0) {
          return newColumn;
        }
        if (!newColumn.calculatedWidth) {
          if (!skipViewportMeasures && newColumn.flexGrow) {
            newColumn.calculatedWidth = newColumn.minWidth + newColumn.flexGrow * widthFraction;
            newColumn.calculatedWidth = Math.min(newColumn.calculatedWidth, newColumn.maxWidth || Number.MAX_VALUE);
          } else {
            newColumn.calculatedWidth = newColumn.maxWidth || newColumn.minWidth || MIN_COLUMN_WIDTH;
          }
        }
        return newColumn;
      });
    };
    DetailsListBase2.prototype._getJustifiedColumns = function(newColumns, viewportWidth, props) {
      var _this = this;
      var _a2 = props.selectionMode, selectionMode = _a2 === void 0 ? this._selection.mode : _a2, checkboxVisibility = props.checkboxVisibility, skipViewportMeasures = props.skipViewportMeasures;
      var rowCheckWidth = selectionMode !== SelectionMode.none && checkboxVisibility !== CheckboxVisibility.hidden ? CHECK_CELL_WIDTH : 0;
      var groupExpandWidth = this._getGroupNestingDepth() * SPACER_WIDTH;
      var totalWidth = 0;
      var availableWidth = viewportWidth - (rowCheckWidth + groupExpandWidth);
      var adjustedColumns = newColumns.map(function(column3, i2) {
        var baseColumn = __assign$1(__assign$1({}, column3), { calculatedWidth: column3.minWidth || MIN_COLUMN_WIDTH });
        var newColumn = __assign$1(__assign$1({}, baseColumn), _this._columnOverrides[column3.key]);
        totalWidth += getPaddedWidth(newColumn, props);
        return newColumn;
      });
      if (skipViewportMeasures) {
        return adjustedColumns;
      }
      var lastIndex = adjustedColumns.length - 1;
      while (lastIndex >= 0 && totalWidth > availableWidth) {
        var column2 = adjustedColumns[lastIndex];
        var minWidth = column2.minWidth || MIN_COLUMN_WIDTH;
        var overflowWidth = totalWidth - availableWidth;
        if (column2.calculatedWidth - minWidth >= overflowWidth || !(column2.isCollapsible || column2.isCollapsable)) {
          var originalWidth = column2.calculatedWidth;
          column2.calculatedWidth = Math.max(column2.calculatedWidth - overflowWidth, minWidth);
          totalWidth -= originalWidth - column2.calculatedWidth;
        } else {
          totalWidth -= getPaddedWidth(column2, props);
          adjustedColumns.splice(lastIndex, 1);
        }
        lastIndex--;
      }
      for (var i = 0; i < adjustedColumns.length && totalWidth < availableWidth; i++) {
        var column2 = adjustedColumns[i];
        var isLast = i === adjustedColumns.length - 1;
        var overrides = this._columnOverrides[column2.key];
        if (overrides && overrides.calculatedWidth && !isLast) {
          continue;
        }
        var spaceLeft = availableWidth - totalWidth;
        var increment = void 0;
        if (isLast) {
          increment = spaceLeft;
        } else {
          var maxWidth = column2.maxWidth;
          var minWidth = column2.minWidth || maxWidth || MIN_COLUMN_WIDTH;
          increment = maxWidth ? Math.min(spaceLeft, maxWidth - minWidth) : spaceLeft;
        }
        column2.calculatedWidth = column2.calculatedWidth + increment;
        totalWidth += increment;
      }
      return adjustedColumns;
    };
    DetailsListBase2.prototype._rememberCalculatedWidth = function(column2, newCalculatedWidth) {
      var overrides = this._getColumnOverride(column2.key);
      overrides.calculatedWidth = newCalculatedWidth;
      overrides.currentWidth = newCalculatedWidth;
    };
    DetailsListBase2.prototype._getColumnOverride = function(key) {
      return this._columnOverrides[key] = this._columnOverrides[key] || {};
    };
    DetailsListBase2.prototype._getItemKey = function(item, itemIndex) {
      var getKey = this.props.getKey;
      var itemKey = void 0;
      if (item) {
        itemKey = item.key;
      }
      if (getKey) {
        itemKey = getKey(item, itemIndex);
      }
      if (!itemKey) {
        itemKey = itemIndex;
      }
      return itemKey;
    };
    DetailsListBase2.defaultProps = {
      layoutMode: DetailsListLayoutMode.justified,
      selectionMode: SelectionMode.multiple,
      constrainMode: ConstrainMode.horizontalConstrained,
      checkboxVisibility: CheckboxVisibility.onHover,
      isHeaderVisible: true,
      compact: false,
      useFastIcons: true
    };
    DetailsListBase2 = __decorate([
      withViewport
    ], DetailsListBase2);
    return DetailsListBase2;
  }(React__namespace.Component)
);
function buildColumns(items, canResizeColumns, onColumnClick, sortedColumnKey, isSortedDescending, groupedColumnKey, isMultiline, columnActionsMode) {
  var columns = [];
  if (items && items.length) {
    var firstItem = items[0];
    for (var propName in firstItem) {
      if (firstItem.hasOwnProperty(propName)) {
        columns.push({
          key: propName,
          name: propName,
          fieldName: propName,
          minWidth: MIN_COLUMN_WIDTH,
          maxWidth: 300,
          isCollapsible: !!columns.length,
          isMultiline: isMultiline === void 0 ? false : isMultiline,
          isSorted: sortedColumnKey === propName,
          isSortedDescending: !!isSortedDescending,
          isRowHeader: false,
          columnActionsMode: columnActionsMode !== null && columnActionsMode !== void 0 ? columnActionsMode : ColumnActionsMode.clickable,
          isResizable: canResizeColumns,
          onColumnClick,
          isGrouped: groupedColumnKey === propName
        });
      }
    }
  }
  return columns;
}
function getPaddedWidth(column2, props, paddingOnly) {
  var _a2 = props.cellStyleProps, cellStyleProps = _a2 === void 0 ? DEFAULT_CELL_STYLE_PROPS : _a2;
  return (paddingOnly ? 0 : column2.calculatedWidth) + cellStyleProps.cellLeftPadding + cellStyleProps.cellRightPadding + (column2.isPadded ? cellStyleProps.cellExtraRightPadding : 0);
}
function getGroupNestingDepth(groups) {
  var level = 0;
  var groupsInLevel = groups;
  while (groupsInLevel && groupsInLevel.length > 0) {
    level++;
    groupsInLevel = groupsInLevel[0].children;
  }
  return level;
}
function useGroupedDetailsListIndexMap(groups) {
  return React__namespace.useMemo(function() {
    var indexMap = {};
    if (groups) {
      var rowCount = 1;
      var numGroupHeaders = 1;
      for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
        var group = groups_1[_i];
        var key = group.key;
        indexMap[key] = { numOfGroupHeadersBeforeItem: numGroupHeaders, totalRowCount: rowCount };
        numGroupHeaders++;
        rowCount += group.count + 1;
      }
    }
    return indexMap;
  }, [groups]);
}
var GlobalClassNames$h = {
  root: "ms-DetailsList",
  compact: "ms-DetailsList--Compact",
  contentWrapper: "ms-DetailsList-contentWrapper",
  headerWrapper: "ms-DetailsList-headerWrapper",
  isFixed: "is-fixed",
  isHorizontalConstrained: "is-horizontalConstrained",
  listCell: "ms-List-cell"
};
var getDetailsListStyles = function(props) {
  var _a2, _b2;
  var theme = props.theme, className = props.className, isHorizontalConstrained = props.isHorizontalConstrained, compact = props.compact, isFixed = props.isFixed;
  var semanticColors = theme.semanticColors;
  var classNames2 = getGlobalClassNames(GlobalClassNames$h, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.small,
      {
        position: "relative",
        color: semanticColors.listText,
        selectors: (_a2 = {}, _a2["& ." + classNames2.listCell] = {
          minHeight: 38,
          wordBreak: "break-word"
        }, _a2)
      },
      isFixed && classNames2.isFixed,
      compact && [
        classNames2.compact,
        {
          selectors: (_b2 = {}, _b2["." + classNames2.listCell] = {
            minHeight: 32
          }, _b2)
        }
      ],
      isHorizontalConstrained && [
        classNames2.isHorizontalConstrained,
        {
          overflowX: "auto",
          overflowY: "visible",
          WebkitOverflowScrolling: "touch"
        }
      ],
      className
    ],
    focusZone: [
      {
        display: "inline-block",
        minWidth: "100%",
        minHeight: 1
      }
    ],
    headerWrapper: classNames2.headerWrapper,
    contentWrapper: classNames2.contentWrapper
  };
};
var DetailsList = styled(DetailsListBase, getDetailsListStyles, void 0, {
  scope: "DetailsList"
});
var DialogType;
(function(DialogType2) {
  DialogType2[DialogType2["normal"] = 0] = "normal";
  DialogType2[DialogType2["largeHeader"] = 1] = "largeHeader";
  DialogType2[DialogType2["close"] = 2] = "close";
})(DialogType || (DialogType = {}));
var animationDuration = AnimationVariables.durationValue2;
var globalClassNames = {
  root: "ms-Modal",
  main: "ms-Dialog-main",
  scrollableContent: "ms-Modal-scrollableContent",
  isOpen: "is-open",
  layer: "ms-Modal-Layer"
};
var getStyles$i = function(props) {
  var _a2;
  var className = props.className, containerClassName = props.containerClassName, scrollableContentClassName = props.scrollableContentClassName, isOpen = props.isOpen, isVisible = props.isVisible, hasBeenOpened = props.hasBeenOpened, modalRectangleTop = props.modalRectangleTop, theme = props.theme, topOffsetFixed = props.topOffsetFixed, isModeless = props.isModeless, layerClassName = props.layerClassName, isDefaultDragHandle = props.isDefaultDragHandle, windowInnerHeight = props.windowInnerHeight;
  var palette = theme.palette, effects = theme.effects, fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(globalClassNames, theme);
  return {
    root: [
      classNames2.root,
      fonts.medium,
      {
        backgroundColor: "transparent",
        position: "fixed",
        height: "100%",
        width: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        opacity: 0,
        pointerEvents: "none",
        transition: "opacity " + animationDuration
      },
      topOffsetFixed && typeof modalRectangleTop === "number" && hasBeenOpened && {
        alignItems: "flex-start"
      },
      isOpen && classNames2.isOpen,
      isVisible && {
        opacity: 1
      },
      isVisible && !isModeless && {
        pointerEvents: "auto"
      },
      className
    ],
    main: [
      classNames2.main,
      {
        boxShadow: effects.elevation64,
        borderRadius: effects.roundedCorner2,
        backgroundColor: palette.white,
        boxSizing: "border-box",
        position: "relative",
        textAlign: "left",
        outline: "3px solid transparent",
        maxHeight: "calc(100% - 32px)",
        maxWidth: "calc(100% - 32px)",
        minHeight: "176px",
        minWidth: "288px",
        overflowY: "auto",
        zIndex: isModeless ? ZIndexes.Layer : void 0
      },
      isModeless && {
        pointerEvents: "auto"
      },
      topOffsetFixed && typeof modalRectangleTop === "number" && hasBeenOpened && {
        top: modalRectangleTop
      },
      isDefaultDragHandle && {
        cursor: "move"
      },
      containerClassName
    ],
    scrollableContent: [
      classNames2.scrollableContent,
      {
        overflowY: "auto",
        flexGrow: 1,
        maxHeight: "100vh",
        selectors: (_a2 = {}, _a2["@supports (-webkit-overflow-scrolling: touch)"] = {
          maxHeight: windowInnerHeight
        }, _a2)
      },
      scrollableContentClassName
    ],
    layer: isModeless && [layerClassName, classNames2.layer, { pointerEvents: "none" }],
    keyboardMoveIconContainer: {
      position: "absolute",
      display: "flex",
      justifyContent: "center",
      width: "100%",
      padding: "3px 0px"
    },
    keyboardMoveIcon: {
      // eslint-disable-next-line deprecation/deprecation
      fontSize: fonts.xLargePlus.fontSize,
      width: "24px"
    }
  };
};
var getClassNames$j = classNamesFunction();
var OverlayBase = (
  /** @class */
  function(_super) {
    __extends(OverlayBase2, _super);
    function OverlayBase2(props) {
      var _this = _super.call(this, props) || this;
      initializeComponentRef(_this);
      var _a2 = _this.props.allowTouchBodyScroll, allowTouchBodyScroll = _a2 === void 0 ? false : _a2;
      _this._allowTouchBodyScroll = allowTouchBodyScroll;
      return _this;
    }
    OverlayBase2.prototype.componentDidMount = function() {
      !this._allowTouchBodyScroll && disableBodyScroll();
    };
    OverlayBase2.prototype.componentWillUnmount = function() {
      !this._allowTouchBodyScroll && enableBodyScroll();
    };
    OverlayBase2.prototype.render = function() {
      var _a2 = this.props, isDark = _a2.isDarkThemed, className = _a2.className, theme = _a2.theme, styles2 = _a2.styles;
      var divProps = getNativeProps(this.props, divProperties);
      var classNames2 = getClassNames$j(styles2, {
        theme,
        className,
        isDark
      });
      return React__namespace.createElement("div", __assign$1({}, divProps, { className: classNames2.root }));
    };
    return OverlayBase2;
  }(React__namespace.Component)
);
var GlobalClassNames$g = {
  root: "ms-Overlay",
  rootDark: "ms-Overlay--dark"
};
var getStyles$h = function(props) {
  var _a2;
  var className = props.className, theme = props.theme, isNone = props.isNone, isDark = props.isDark;
  var palette = theme.palette;
  var classNames2 = getGlobalClassNames(GlobalClassNames$g, theme);
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      {
        backgroundColor: palette.whiteTranslucent40,
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        position: "absolute",
        selectors: (_a2 = {}, _a2[HighContrastSelector] = {
          border: "1px solid WindowText",
          opacity: 0
        }, _a2)
      },
      isNone && {
        visibility: "hidden"
      },
      isDark && [
        classNames2.rootDark,
        {
          backgroundColor: palette.blackTranslucent40
        }
      ],
      className
    ]
  };
};
var Overlay = styled(OverlayBase, getStyles$h, void 0, {
  scope: "Overlay"
});
var getClassNames$i = memoizeFunction(function(className, isDragging) {
  return {
    root: mergeStyles(className, isDragging && {
      touchAction: "none",
      selectors: {
        "& *": {
          userSelect: "none"
        }
      }
    })
  };
});
var eventMapping = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  }
};
var DraggableZone = (
  /** @class */
  function(_super) {
    __extends(DraggableZone2, _super);
    function DraggableZone2(props) {
      var _this = _super.call(this, props) || this;
      _this._currentEventType = eventMapping.mouse;
      _this._events = [];
      _this._onMouseDown = function(event) {
        var onMouseDown = React__namespace.Children.only(_this.props.children).props.onMouseDown;
        if (onMouseDown) {
          onMouseDown(event);
        }
        _this._currentEventType = eventMapping.mouse;
        return _this._onDragStart(event);
      };
      _this._onMouseUp = function(event) {
        var onMouseUp = React__namespace.Children.only(_this.props.children).props.onMouseUp;
        if (onMouseUp) {
          onMouseUp(event);
        }
        _this._currentEventType = eventMapping.mouse;
        return _this._onDragStop(event);
      };
      _this._onTouchStart = function(event) {
        var onTouchStart = React__namespace.Children.only(_this.props.children).props.onTouchStart;
        if (onTouchStart) {
          onTouchStart(event);
        }
        _this._currentEventType = eventMapping.touch;
        return _this._onDragStart(event);
      };
      _this._onTouchEnd = function(event) {
        var onTouchEnd = React__namespace.Children.only(_this.props.children).props.onTouchEnd;
        if (onTouchEnd) {
          onTouchEnd(event);
        }
        _this._currentEventType = eventMapping.touch;
        _this._onDragStop(event);
      };
      _this._onDragStart = function(event) {
        if (typeof event.button === "number" && event.button !== 0) {
          return false;
        }
        if (_this.props.handleSelector && !_this._matchesSelector(event.target, _this.props.handleSelector) || _this.props.preventDragSelector && _this._matchesSelector(event.target, _this.props.preventDragSelector)) {
          return;
        }
        _this._touchId = _this._getTouchId(event);
        var position2 = _this._getControlPosition(event);
        if (position2 === void 0) {
          return;
        }
        var dragData = _this._createDragDataFromPosition(position2);
        _this.props.onStart && _this.props.onStart(event, dragData);
        _this.setState({
          isDragging: true,
          lastPosition: position2
        });
        _this._events = [
          on(
            document.body,
            _this._currentEventType.move,
            _this._onDrag,
            true
            /* use capture phase */
          ),
          on(
            document.body,
            _this._currentEventType.stop,
            _this._onDragStop,
            true
            /* use capture phase */
          )
        ];
      };
      _this._onDrag = function(event) {
        if (event.type === "touchmove") {
          event.preventDefault();
        }
        var position2 = _this._getControlPosition(event);
        if (!position2) {
          return;
        }
        var updatedData = _this._createUpdatedDragData(_this._createDragDataFromPosition(position2));
        var updatedPosition = updatedData.position;
        _this.props.onDragChange && _this.props.onDragChange(event, updatedData);
        _this.setState({
          position: updatedPosition,
          lastPosition: position2
        });
      };
      _this._onDragStop = function(event) {
        if (!_this.state.isDragging) {
          return;
        }
        var position2 = _this._getControlPosition(event);
        if (!position2) {
          return;
        }
        var baseDragData = _this._createDragDataFromPosition(position2);
        _this.setState({
          isDragging: false,
          lastPosition: void 0
        });
        _this.props.onStop && _this.props.onStop(event, baseDragData);
        if (_this.props.position) {
          _this.setState({
            position: _this.props.position
          });
        }
        _this._events.forEach(function(dispose) {
          return dispose();
        });
      };
      _this.state = {
        isDragging: false,
        position: _this.props.position || { x: 0, y: 0 },
        lastPosition: void 0
      };
      return _this;
    }
    DraggableZone2.prototype.componentDidUpdate = function(prevProps) {
      if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {
        this.setState({ position: this.props.position });
      }
    };
    DraggableZone2.prototype.componentWillUnmount = function() {
      this._events.forEach(function(dispose) {
        return dispose();
      });
    };
    DraggableZone2.prototype.render = function() {
      var child = React__namespace.Children.only(this.props.children);
      var props = child.props;
      var position2 = this.props.position;
      var _a2 = this.state, statePosition = _a2.position, isDragging = _a2.isDragging;
      var x = statePosition.x;
      var y = statePosition.y;
      if (position2 && !isDragging) {
        x = position2.x;
        y = position2.y;
      }
      return React__namespace.cloneElement(child, {
        style: __assign$1(__assign$1({}, props.style), { transform: "translate(" + x + "px, " + y + "px)" }),
        className: getClassNames$i(props.className, this.state.isDragging).root,
        onMouseDown: this._onMouseDown,
        onMouseUp: this._onMouseUp,
        onTouchStart: this._onTouchStart,
        onTouchEnd: this._onTouchEnd
      });
    };
    DraggableZone2.prototype._getControlPosition = function(event) {
      var touchObj = this._getActiveTouch(event);
      if (this._touchId !== void 0 && !touchObj) {
        return void 0;
      }
      var eventToGetOffset = touchObj || event;
      return {
        x: eventToGetOffset.clientX,
        y: eventToGetOffset.clientY
      };
    };
    DraggableZone2.prototype._getActiveTouch = function(event) {
      return event.targetTouches && this._findTouchInTouchList(event.targetTouches) || event.changedTouches && this._findTouchInTouchList(event.changedTouches);
    };
    DraggableZone2.prototype._getTouchId = function(event) {
      var touch = event.targetTouches && event.targetTouches[0] || event.changedTouches && event.changedTouches[0];
      if (touch) {
        return touch.identifier;
      }
    };
    DraggableZone2.prototype._matchesSelector = function(element, selector) {
      if (!element || element === document.body) {
        return false;
      }
      var matchesSelectorFn = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
      if (!matchesSelectorFn) {
        return false;
      }
      return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);
    };
    DraggableZone2.prototype._findTouchInTouchList = function(touchList) {
      if (this._touchId === void 0) {
        return;
      }
      for (var i = 0; i < touchList.length; i++) {
        if (touchList[i].identifier === this._touchId) {
          return touchList[i];
        }
      }
      return void 0;
    };
    DraggableZone2.prototype._createDragDataFromPosition = function(position2) {
      var lastPosition = this.state.lastPosition;
      if (lastPosition === void 0) {
        return {
          delta: { x: 0, y: 0 },
          lastPosition: position2,
          position: position2
        };
      }
      return {
        delta: {
          x: position2.x - lastPosition.x,
          y: position2.y - lastPosition.y
        },
        lastPosition,
        position: position2
      };
    };
    DraggableZone2.prototype._createUpdatedDragData = function(baseDragData) {
      var position2 = this.state.position;
      return {
        position: {
          x: position2.x + baseDragData.delta.x,
          y: position2.y + baseDragData.delta.y
        },
        delta: baseDragData.delta,
        lastPosition: position2
      };
    };
    return DraggableZone2;
  }(React__namespace.Component)
);
var ZERO = { x: 0, y: 0 };
var DEFAULT_PROPS$2 = {
  isOpen: false,
  isDarkOverlay: true,
  className: "",
  containerClassName: "",
  enableAriaHiddenSiblings: true
};
var getClassNames$h = classNamesFunction();
var getMoveDelta = function(ev) {
  var delta = 10;
  if (ev.shiftKey) {
    if (!ev.ctrlKey) {
      delta = 50;
    }
  } else if (ev.ctrlKey) {
    delta = 1;
  }
  return delta;
};
var useComponentRef$1 = function(props, focusTrapZone) {
  React__namespace.useImperativeHandle(props.componentRef, function() {
    return {
      focus: function() {
        if (focusTrapZone.current) {
          focusTrapZone.current.focus();
        }
      }
    };
  }, [focusTrapZone]);
};
var ModalBase = React__namespace.forwardRef(function(propsWithoutDefaults, ref) {
  var _a2, _b2, _c2, _d2, _e2;
  var props = getPropsWithDefaults(DEFAULT_PROPS$2, propsWithoutDefaults);
  var allowTouchBodyScroll = props.allowTouchBodyScroll, className = props.className, children = props.children, containerClassName = props.containerClassName, scrollableContentClassName = props.scrollableContentClassName, elementToFocusOnDismiss = props.elementToFocusOnDismiss, firstFocusableSelector = props.firstFocusableSelector, focusTrapZoneProps = props.focusTrapZoneProps, forceFocusInsideTrap = props.forceFocusInsideTrap, _f = props.disableRestoreFocus, disableRestoreFocus = _f === void 0 ? props.ignoreExternalFocusing : _f, isBlocking = props.isBlocking, isAlert = props.isAlert, isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap, isDarkOverlay = props.isDarkOverlay, onDismiss = props.onDismiss, layerProps = props.layerProps, overlay = props.overlay, isOpen = props.isOpen, titleAriaId = props.titleAriaId, styles2 = props.styles, subtitleAriaId = props.subtitleAriaId, theme = props.theme, topOffsetFixed = props.topOffsetFixed, responsiveMode = props.responsiveMode, onLayerDidMount = props.onLayerDidMount, isModeless = props.isModeless, dragOptions = props.dragOptions, onDismissed = props.onDismissed, enableAriaHiddenSiblings = props.enableAriaHiddenSiblings, popupProps = props.popupProps;
  var rootRef = React__namespace.useRef(null);
  var focusTrapZone = React__namespace.useRef(null);
  var focusTrapZoneRef = useMergedRefs(focusTrapZone, focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.componentRef);
  var focusTrapZoneElm = React__namespace.useRef(null);
  var mergedRef = useMergedRefs(rootRef, ref);
  var modalResponsiveMode = useResponsiveMode(mergedRef);
  var focusTrapZoneId = useId("ModalFocusTrapZone", focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.id);
  var win2 = useWindow();
  var _g = useSetTimeout(), setTimeout2 = _g.setTimeout, clearTimeout2 = _g.clearTimeout;
  var _h = React__namespace.useState(isOpen), isModalOpen = _h[0], setIsModalOpen = _h[1];
  var _j = React__namespace.useState(isOpen), isVisible = _j[0], setIsVisible = _j[1];
  var _k = React__namespace.useState(ZERO), coordinates = _k[0], setCoordinates = _k[1];
  var _l = React__namespace.useState(), modalRectangleTop = _l[0], setModalRectangleTop = _l[1];
  var _m = useBoolean(false), isModalMenuOpen = _m[0], _o = _m[1], toggleModalMenuOpen = _o.toggle, setModalMenuClose = _o.setFalse;
  var internalState = useConst(function() {
    return {
      onModalCloseTimer: 0,
      allowTouchBodyScroll,
      scrollableContent: null,
      lastSetCoordinates: ZERO,
      events: new EventGroup({})
    };
  });
  var keepInBounds = (dragOptions || {}).keepInBounds;
  var isAlertRole = isAlert !== null && isAlert !== void 0 ? isAlert : isBlocking && !isModeless;
  var layerClassName = layerProps === void 0 ? "" : layerProps.className;
  var classNames2 = getClassNames$h(styles2, {
    theme,
    className,
    containerClassName,
    scrollableContentClassName,
    isOpen,
    isVisible,
    hasBeenOpened: internalState.hasBeenOpened,
    modalRectangleTop,
    topOffsetFixed,
    isModeless,
    layerClassName,
    windowInnerHeight: win2 === null || win2 === void 0 ? void 0 : win2.innerHeight,
    isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector
  });
  var mergedLayerProps = __assign$1(__assign$1({ eventBubblingEnabled: false }, layerProps), { onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount, insertFirst: (layerProps === null || layerProps === void 0 ? void 0 : layerProps.insertFirst) || isModeless, className: classNames2.layer });
  var allowScrollOnModal = React__namespace.useCallback(function(elt) {
    if (elt) {
      if (internalState.allowTouchBodyScroll) {
        allowOverscrollOnElement(elt, internalState.events);
      } else {
        allowScrollOnElement(elt, internalState.events);
      }
    } else {
      internalState.events.off(internalState.scrollableContent);
    }
    internalState.scrollableContent = elt;
  }, [internalState]);
  var registerInitialModalPosition = function() {
    var dialogMain = focusTrapZoneElm.current;
    var modalRectangle = dialogMain === null || dialogMain === void 0 ? void 0 : dialogMain.getBoundingClientRect();
    if (modalRectangle) {
      if (topOffsetFixed) {
        setModalRectangleTop(modalRectangle.top);
      }
      if (keepInBounds) {
        internalState.minPosition = { x: -modalRectangle.left, y: -modalRectangle.top };
        internalState.maxPosition = { x: modalRectangle.left, y: modalRectangle.top };
      }
    }
  };
  var getClampedAxis = React__namespace.useCallback(function(axis, position2) {
    var minPosition = internalState.minPosition, maxPosition = internalState.maxPosition;
    if (keepInBounds && minPosition && maxPosition) {
      position2 = Math.max(minPosition[axis], position2);
      position2 = Math.min(maxPosition[axis], position2);
    }
    return position2;
  }, [keepInBounds, internalState]);
  var handleModalClose = function() {
    var _a3;
    internalState.lastSetCoordinates = ZERO;
    setModalMenuClose();
    internalState.isInKeyboardMoveMode = false;
    setIsModalOpen(false);
    setCoordinates(ZERO);
    (_a3 = internalState.disposeOnKeyUp) === null || _a3 === void 0 ? void 0 : _a3.call(internalState);
    onDismissed === null || onDismissed === void 0 ? void 0 : onDismissed();
  };
  var handleDragStart = React__namespace.useCallback(function() {
    setModalMenuClose();
    internalState.isInKeyboardMoveMode = false;
  }, [internalState, setModalMenuClose]);
  var handleDrag = React__namespace.useCallback(function(ev, dragData) {
    setCoordinates(function(prevValue) {
      return {
        x: getClampedAxis("x", prevValue.x + dragData.delta.x),
        y: getClampedAxis("y", prevValue.y + dragData.delta.y)
      };
    });
  }, [getClampedAxis]);
  var handleDragStop = React__namespace.useCallback(function() {
    if (focusTrapZone.current) {
      focusTrapZone.current.focus();
    }
  }, []);
  var handleEnterKeyboardMoveMode = function() {
    var handleKeyDown = function(ev) {
      if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {
        ev.preventDefault();
        ev.stopPropagation();
        return;
      }
      var newLocal = ev.altKey || ev.keyCode === KeyCodes.escape;
      if (isModalMenuOpen && newLocal) {
        setModalMenuClose();
      }
      if (internalState.isInKeyboardMoveMode && (ev.keyCode === KeyCodes.escape || ev.keyCode === KeyCodes.enter)) {
        internalState.isInKeyboardMoveMode = false;
        ev.preventDefault();
        ev.stopPropagation();
      }
      if (internalState.isInKeyboardMoveMode) {
        var handledEvent = true;
        var delta_1 = getMoveDelta(ev);
        switch (ev.keyCode) {
          case KeyCodes.escape:
            setCoordinates(internalState.lastSetCoordinates);
          case KeyCodes.enter: {
            internalState.lastSetCoordinates = ZERO;
            break;
          }
          case KeyCodes.up: {
            setCoordinates(function(prevValue) {
              return { x: prevValue.x, y: getClampedAxis("y", prevValue.y - delta_1) };
            });
            break;
          }
          case KeyCodes.down: {
            setCoordinates(function(prevValue) {
              return { x: prevValue.x, y: getClampedAxis("y", prevValue.y + delta_1) };
            });
            break;
          }
          case KeyCodes.left: {
            setCoordinates(function(prevValue) {
              return { x: getClampedAxis("x", prevValue.x - delta_1), y: prevValue.y };
            });
            break;
          }
          case KeyCodes.right: {
            setCoordinates(function(prevValue) {
              return { x: getClampedAxis("x", prevValue.x + delta_1), y: prevValue.y };
            });
            break;
          }
          default: {
            handledEvent = false;
          }
        }
        if (handledEvent) {
          ev.preventDefault();
          ev.stopPropagation();
        }
      }
    };
    internalState.lastSetCoordinates = coordinates;
    setModalMenuClose();
    internalState.isInKeyboardMoveMode = true;
    internalState.events.on(
      win2,
      "keydown",
      handleKeyDown,
      true
      /* useCapture */
    );
    internalState.disposeOnKeyDown = function() {
      internalState.events.off(
        win2,
        "keydown",
        handleKeyDown,
        true
        /* useCapture */
      );
      internalState.disposeOnKeyDown = void 0;
    };
  };
  var handleExitKeyboardMoveMode = function(ev) {
    var _a3, _b3;
    (_a3 = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.onBlur) === null || _a3 === void 0 ? void 0 : _a3.call(focusTrapZoneProps, ev);
    internalState.lastSetCoordinates = ZERO;
    internalState.isInKeyboardMoveMode = false;
    (_b3 = internalState.disposeOnKeyDown) === null || _b3 === void 0 ? void 0 : _b3.call(internalState);
  };
  var registerForKeyUp = function() {
    var handleKeyUp = function(ev) {
      if (ev.altKey && ev.ctrlKey && ev.keyCode === KeyCodes.space) {
        if (elementContains(internalState.scrollableContent, ev.target)) {
          toggleModalMenuOpen();
          ev.preventDefault();
          ev.stopPropagation();
        }
      }
    };
    if (!internalState.disposeOnKeyUp) {
      internalState.events.on(
        win2,
        "keyup",
        handleKeyUp,
        true
        /* useCapture */
      );
      internalState.disposeOnKeyUp = function() {
        internalState.events.off(
          win2,
          "keyup",
          handleKeyUp,
          true
          /* useCapture */
        );
        internalState.disposeOnKeyUp = void 0;
      };
    }
  };
  React__namespace.useEffect(function() {
    clearTimeout2(internalState.onModalCloseTimer);
    if (isOpen) {
      requestAnimationFrame(function() {
        return setTimeout2(registerInitialModalPosition, 0);
      });
      setIsModalOpen(true);
      if (dragOptions) {
        registerForKeyUp();
      }
      internalState.hasBeenOpened = true;
      setIsVisible(true);
    }
    if (!isOpen && isModalOpen) {
      internalState.onModalCloseTimer = setTimeout2(handleModalClose, parseFloat(animationDuration) * 1e3);
      setIsVisible(false);
    }
  }, [isModalOpen, isOpen]);
  useUnmount(function() {
    internalState.events.dispose();
  });
  useComponentRef$1(props, focusTrapZone);
  useDebugWarnings$1(props);
  var modalContent = React__namespace.createElement(
    FocusTrapZone,
    __assign$1({}, focusTrapZoneProps, {
      id: focusTrapZoneId,
      ref: focusTrapZoneElm,
      componentRef: focusTrapZoneRef,
      className: css$3(classNames2.main, focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.className),
      elementToFocusOnDismiss: (_a2 = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.elementToFocusOnDismiss) !== null && _a2 !== void 0 ? _a2 : elementToFocusOnDismiss,
      isClickableOutsideFocusTrap: (_b2 = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.isClickableOutsideFocusTrap) !== null && _b2 !== void 0 ? _b2 : isModeless || isClickableOutsideFocusTrap || !isBlocking,
      disableRestoreFocus: (_c2 = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.disableRestoreFocus) !== null && _c2 !== void 0 ? _c2 : disableRestoreFocus,
      forceFocusInsideTrap: ((_d2 = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.forceFocusInsideTrap) !== null && _d2 !== void 0 ? _d2 : forceFocusInsideTrap) && !isModeless,
      // eslint-disable-next-line deprecation/deprecation
      firstFocusableSelector: (focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.firstFocusableSelector) || firstFocusableSelector,
      focusPreviouslyFocusedInnerElement: (_e2 = focusTrapZoneProps === null || focusTrapZoneProps === void 0 ? void 0 : focusTrapZoneProps.focusPreviouslyFocusedInnerElement) !== null && _e2 !== void 0 ? _e2 : true,
      onBlur: internalState.isInKeyboardMoveMode ? handleExitKeyboardMoveMode : void 0
    }),
    dragOptions && internalState.isInKeyboardMoveMode && React__namespace.createElement("div", { className: classNames2.keyboardMoveIconContainer }, dragOptions.keyboardMoveIconProps ? React__namespace.createElement(Icon, __assign$1({}, dragOptions.keyboardMoveIconProps)) : React__namespace.createElement(Icon, { iconName: "move", className: classNames2.keyboardMoveIcon })),
    React__namespace.createElement(
      "div",
      { ref: allowScrollOnModal, className: classNames2.scrollableContent, "data-is-scrollable": true },
      dragOptions && isModalMenuOpen && React__namespace.createElement(dragOptions.menu, { items: [
        { key: "move", text: dragOptions.moveMenuItemText, onClick: handleEnterKeyboardMoveMode },
        { key: "close", text: dragOptions.closeMenuItemText, onClick: handleModalClose }
      ], onDismiss: setModalMenuClose, alignTargetEdge: true, coverTarget: true, directionalHint: DirectionalHint.topLeftEdge, directionalHintFixed: true, shouldFocusOnMount: true, target: internalState.scrollableContent }),
      children
    )
  );
  return isModalOpen && modalResponsiveMode >= (responsiveMode || ResponsiveMode.small) && React__namespace.createElement(
    Layer,
    __assign$1({ ref: mergedRef }, mergedLayerProps),
    React__namespace.createElement(
      Popup,
      __assign$1({
        role: isAlertRole ? "alertdialog" : "dialog",
        ariaLabelledBy: titleAriaId,
        ariaDescribedBy: subtitleAriaId,
        onDismiss,
        shouldRestoreFocus: !disableRestoreFocus,
        // Modeless modals shouldn't hide siblings.
        // Popup will automatically handle this based on the aria-modal setting.
        enableAriaHiddenSiblings,
        "aria-modal": !isModeless
      }, popupProps),
      React__namespace.createElement(
        "div",
        { className: classNames2.root, role: !isModeless ? "document" : void 0 },
        !isModeless && React__namespace.createElement(Overlay, __assign$1({ "aria-hidden": true, isDarkThemed: isDarkOverlay, onClick: isBlocking ? void 0 : onDismiss, allowTouchBodyScroll }, overlay)),
        dragOptions ? React__namespace.createElement(DraggableZone, { handleSelector: dragOptions.dragHandleSelector || "#" + focusTrapZoneId, preventDragSelector: "button", onStart: handleDragStart, onDragChange: handleDrag, onStop: handleDragStop, position: coordinates }, modalContent) : modalContent
      )
    )
  ) || null;
});
ModalBase.displayName = "Modal";
function useDebugWarnings$1(props) {
  if (process.env.NODE_ENV !== "production") {
    useWarnings({
      name: "Modal",
      props,
      deprecations: { onLayerDidMount: "layerProps.onLayerDidMount" }
    });
  }
}
var Modal = styled(ModalBase, getStyles$i, void 0, {
  scope: "Modal",
  fields: ["theme", "styles", "enableAriaHiddenSiblings"]
});
Modal.displayName = "Modal";
var getClassNames$g = classNamesFunction();
var DialogFooterBase = (
  /** @class */
  function(_super) {
    __extends(DialogFooterBase2, _super);
    function DialogFooterBase2(props) {
      var _this = _super.call(this, props) || this;
      initializeComponentRef(_this);
      return _this;
    }
    DialogFooterBase2.prototype.render = function() {
      var _a2 = this.props, className = _a2.className, styles2 = _a2.styles, theme = _a2.theme;
      this._classNames = getClassNames$g(styles2, {
        theme,
        className
      });
      return React__namespace.createElement(
        "div",
        { className: this._classNames.actions },
        React__namespace.createElement("div", { className: this._classNames.actionsRight }, this._renderChildrenAsActions())
      );
    };
    DialogFooterBase2.prototype._renderChildrenAsActions = function() {
      var _this = this;
      return React__namespace.Children.map(this.props.children, function(child) {
        return child ? React__namespace.createElement("span", { className: _this._classNames.action }, child) : null;
      });
    };
    return DialogFooterBase2;
  }(React__namespace.Component)
);
var GlobalClassNames$f = {
  actions: "ms-Dialog-actions",
  action: "ms-Dialog-action",
  actionsRight: "ms-Dialog-actionsRight"
};
var getStyles$g = function(props) {
  var className = props.className, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames$f, theme);
  return {
    actions: [
      classNames2.actions,
      {
        position: "relative",
        width: "100%",
        minHeight: "24px",
        lineHeight: "24px",
        margin: "16px 0 0",
        fontSize: "0",
        selectors: {
          ".ms-Button": {
            lineHeight: "normal",
            verticalAlign: "middle"
          }
        }
      },
      className
    ],
    action: [
      classNames2.action,
      {
        margin: "0 4px"
      }
    ],
    actionsRight: [
      classNames2.actionsRight,
      {
        alignItems: "center",
        display: "flex",
        fontSize: "0",
        justifyContent: "flex-end",
        marginRight: "-4px"
      }
    ]
  };
};
var DialogFooter = styled(DialogFooterBase, getStyles$g, void 0, { scope: "DialogFooter" });
var getClassNames$f = classNamesFunction();
var DialogFooterType = React__namespace.createElement(DialogFooter, null).type;
var COMPONENT_NAME$4 = "DialogContent";
var DialogContentBase = (
  /** @class */
  function(_super) {
    __extends(DialogContentBase2, _super);
    function DialogContentBase2(props) {
      var _this = _super.call(this, props) || this;
      initializeComponentRef(_this);
      warnDeprecations(COMPONENT_NAME$4, props, {
        titleId: "titleProps.id"
      });
      return _this;
    }
    DialogContentBase2.prototype.render = function() {
      var _a2 = this.props, showCloseButton = _a2.showCloseButton, className = _a2.className, closeButtonAriaLabel = _a2.closeButtonAriaLabel, onDismiss = _a2.onDismiss, subTextId = _a2.subTextId, subText = _a2.subText, _b2 = _a2.titleProps, titleProps = _b2 === void 0 ? {} : _b2, titleId = _a2.titleId, title = _a2.title, type = _a2.type, styles2 = _a2.styles, theme = _a2.theme, draggableHeaderClassName = _a2.draggableHeaderClassName;
      var classNames2 = getClassNames$f(styles2, {
        theme,
        className,
        isLargeHeader: type === DialogType.largeHeader,
        isClose: type === DialogType.close,
        draggableHeaderClassName
      });
      var groupings = this._groupChildren();
      var subTextContent;
      if (subText) {
        subTextContent = React__namespace.createElement("p", { className: classNames2.subText, id: subTextId }, subText);
      }
      return React__namespace.createElement(
        "div",
        { className: classNames2.content },
        React__namespace.createElement(
          "div",
          { className: classNames2.header },
          React__namespace.createElement("div", __assign$1({ id: titleId, role: "heading", "aria-level": 1 }, titleProps, { className: css$3(classNames2.title, titleProps.className) }), title),
          React__namespace.createElement(
            "div",
            { className: classNames2.topButton },
            this.props.topButtonsProps.map(function(props, index2) {
              return React__namespace.createElement(IconButton, __assign$1({ key: props.uniqueId || index2 }, props));
            }),
            (type === DialogType.close || showCloseButton && type !== DialogType.largeHeader) && React__namespace.createElement(IconButton, { className: classNames2.button, iconProps: { iconName: "Cancel" }, ariaLabel: closeButtonAriaLabel, onClick: onDismiss })
          )
        ),
        React__namespace.createElement(
          "div",
          { className: classNames2.inner },
          React__namespace.createElement(
            "div",
            { className: classNames2.innerContent },
            subTextContent,
            groupings.contents
          ),
          groupings.footers
        )
      );
    };
    DialogContentBase2.prototype._groupChildren = function() {
      var groupings = {
        footers: [],
        contents: []
      };
      React__namespace.Children.map(this.props.children, function(child) {
        if (typeof child === "object" && child !== null && child.type === DialogFooterType) {
          groupings.footers.push(child);
        } else {
          groupings.contents.push(child);
        }
      });
      return groupings;
    };
    DialogContentBase2.defaultProps = {
      showCloseButton: false,
      className: "",
      topButtonsProps: [],
      closeButtonAriaLabel: "Close"
    };
    DialogContentBase2 = __decorate([
      withResponsiveMode
    ], DialogContentBase2);
    return DialogContentBase2;
  }(React__namespace.Component)
);
var GlobalClassNames$e = {
  contentLgHeader: "ms-Dialog-lgHeader",
  close: "ms-Dialog--close",
  subText: "ms-Dialog-subText",
  header: "ms-Dialog-header",
  headerLg: "ms-Dialog--lgHeader",
  button: "ms-Dialog-button ms-Dialog-button--close",
  inner: "ms-Dialog-inner",
  content: "ms-Dialog-content",
  title: "ms-Dialog-title"
};
var getStyles$f = function(props) {
  var _a2, _b2, _c2;
  var className = props.className, theme = props.theme, isLargeHeader = props.isLargeHeader, isClose = props.isClose, hidden = props.hidden, isMultiline = props.isMultiline, draggableHeaderClassName = props.draggableHeaderClassName;
  var palette = theme.palette, fonts = theme.fonts, effects = theme.effects, semanticColors = theme.semanticColors;
  var classNames2 = getGlobalClassNames(GlobalClassNames$e, theme);
  return {
    content: [
      isLargeHeader && [
        classNames2.contentLgHeader,
        {
          borderTop: "4px solid " + palette.themePrimary
        }
      ],
      isClose && classNames2.close,
      {
        flexGrow: 1,
        overflowY: "hidden"
        // required for allowScrollOnElement
      },
      className
    ],
    subText: [
      classNames2.subText,
      fonts.medium,
      {
        margin: "0 0 24px 0",
        color: semanticColors.bodySubtext,
        lineHeight: "1.5",
        wordWrap: "break-word",
        fontWeight: FontWeights.regular
      }
    ],
    header: [
      classNames2.header,
      {
        position: "relative",
        width: "100%",
        boxSizing: "border-box"
      },
      isClose && classNames2.close,
      draggableHeaderClassName && [
        draggableHeaderClassName,
        {
          cursor: "move"
        }
      ]
    ],
    button: [
      classNames2.button,
      hidden && {
        selectors: {
          ".ms-Icon.ms-Icon--Cancel": {
            color: semanticColors.buttonText,
            fontSize: IconFontSizes.medium
          }
        }
      }
    ],
    inner: [
      classNames2.inner,
      {
        padding: "0 24px 24px",
        selectors: (_a2 = {}, _a2["@media (min-width: " + ScreenWidthMinSmall + "px) and (max-width: " + ScreenWidthMaxSmall + "px)"] = {
          padding: "0 16px 16px"
        }, _a2)
      }
    ],
    innerContent: [
      classNames2.content,
      {
        position: "relative",
        width: "100%"
      }
    ],
    title: [
      classNames2.title,
      fonts.xLarge,
      {
        color: semanticColors.bodyText,
        margin: "0",
        minHeight: fonts.xLarge.fontSize,
        padding: "16px 46px 20px 24px",
        lineHeight: "normal",
        selectors: (_b2 = {}, _b2["@media (min-width: " + ScreenWidthMinSmall + "px) and (max-width: " + ScreenWidthMaxSmall + "px)"] = {
          padding: "16px 46px 16px 16px"
        }, _b2)
      },
      isLargeHeader && {
        color: semanticColors.menuHeader
      },
      isMultiline && { fontSize: fonts.xxLarge.fontSize }
    ],
    topButton: [
      {
        display: "flex",
        flexDirection: "row",
        flexWrap: "nowrap",
        position: "absolute",
        top: "0",
        right: "0",
        padding: "15px 15px 0 0",
        selectors: (_c2 = {
          "> *": {
            flex: "0 0 auto"
          },
          ".ms-Dialog-button": {
            color: semanticColors.buttonText
          },
          ".ms-Dialog-button:hover": {
            color: semanticColors.buttonTextHovered,
            borderRadius: effects.roundedCorner2
          }
        }, _c2["@media (min-width: " + ScreenWidthMinSmall + "px) and (max-width: " + ScreenWidthMaxSmall + "px)"] = {
          padding: "15px 8px 0 0"
        }, _c2)
      }
    ]
  };
};
var DialogContent = styled(DialogContentBase, getStyles$f, void 0, { scope: "DialogContent" });
var getClassNames$e = classNamesFunction();
var DefaultModalProps = {
  isDarkOverlay: false,
  isBlocking: false,
  className: "",
  containerClassName: "",
  topOffsetFixed: false,
  enableAriaHiddenSiblings: true
};
var DefaultDialogContentProps = {
  type: DialogType.normal,
  className: "",
  topButtonsProps: []
};
var DialogBase = (
  /** @class */
  function(_super) {
    __extends(DialogBase2, _super);
    function DialogBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._getSubTextId = function() {
        var _a2 = _this.props, ariaDescribedById = _a2.ariaDescribedById, modalProps = _a2.modalProps, dialogContentProps = _a2.dialogContentProps, subText = _a2.subText;
        var id = modalProps && modalProps.subtitleAriaId || ariaDescribedById;
        if (!id) {
          id = (dialogContentProps && dialogContentProps.subText || subText) && _this._defaultSubTextId;
        }
        return id;
      };
      _this._getTitleTextId = function() {
        var _a2 = _this.props, ariaLabelledById = _a2.ariaLabelledById, modalProps = _a2.modalProps, dialogContentProps = _a2.dialogContentProps, title = _a2.title;
        var id = modalProps && modalProps.titleAriaId || ariaLabelledById;
        if (!id) {
          id = (dialogContentProps && dialogContentProps.title || title) && _this._defaultTitleTextId;
        }
        return id;
      };
      _this._id = getId("Dialog");
      _this._defaultTitleTextId = _this._id + "-title";
      _this._defaultSubTextId = _this._id + "-subText";
      if (process.env.NODE_ENV !== "production") {
        warnDeprecations("Dialog", props, {
          isOpen: "hidden",
          type: "dialogContentProps.type",
          subText: "dialogContentProps.subText",
          contentClassName: "dialogContentProps.className",
          topButtonsProps: "dialogContentProps.topButtonsProps",
          className: "modalProps.className",
          isDarkOverlay: "modalProps.isDarkOverlay",
          isBlocking: "modalProps.isBlocking",
          containerClassName: "modalProps.containerClassName",
          onDismissed: "modalProps.onDismissed",
          onLayerDidMount: "modalProps.layerProps.onLayerDidMount",
          ariaDescribedById: "modalProps.subtitleAriaId",
          ariaLabelledById: "modalProps.titleAriaId"
        });
      }
      return _this;
    }
    DialogBase2.prototype.render = function() {
      var _a2, _b2, _c2;
      var props = this.props;
      var className = props.className, containerClassName = props.containerClassName, contentClassName = props.contentClassName, elementToFocusOnDismiss = props.elementToFocusOnDismiss, firstFocusableSelector = props.firstFocusableSelector, forceFocusInsideTrap = props.forceFocusInsideTrap, styles2 = props.styles, hidden = props.hidden, _d2 = props.disableRestoreFocus, disableRestoreFocus = _d2 === void 0 ? props.ignoreExternalFocusing : _d2, isBlocking = props.isBlocking, isClickableOutsideFocusTrap = props.isClickableOutsideFocusTrap, isDarkOverlay = props.isDarkOverlay, _e2 = props.isOpen, isOpen = _e2 === void 0 ? !hidden : _e2, onDismiss = props.onDismiss, onDismissed = props.onDismissed, onLayerDidMount = props.onLayerDidMount, responsiveMode = props.responsiveMode, subText = props.subText, theme = props.theme, title = props.title, topButtonsProps = props.topButtonsProps, type = props.type, minWidth = props.minWidth, maxWidth = props.maxWidth, modalProps = props.modalProps;
      var mergedLayerProps = __assign$1({ onLayerDidMount }, modalProps === null || modalProps === void 0 ? void 0 : modalProps.layerProps);
      var dialogDraggableClassName;
      var dragOptions;
      if ((modalProps === null || modalProps === void 0 ? void 0 : modalProps.dragOptions) && !((_a2 = modalProps.dragOptions) === null || _a2 === void 0 ? void 0 : _a2.dragHandleSelector)) {
        dragOptions = __assign$1({}, modalProps.dragOptions);
        dialogDraggableClassName = "ms-Dialog-draggable-header";
        dragOptions.dragHandleSelector = "." + dialogDraggableClassName;
      }
      var mergedModalProps = __assign$1(__assign$1(__assign$1(__assign$1({}, DefaultModalProps), { elementToFocusOnDismiss, firstFocusableSelector, forceFocusInsideTrap, disableRestoreFocus, isClickableOutsideFocusTrap, responsiveMode, className, containerClassName, isBlocking, isDarkOverlay, onDismissed }), modalProps), { dragOptions, layerProps: mergedLayerProps, isOpen });
      var dialogContentProps = __assign$1(__assign$1(__assign$1({ className: contentClassName, subText, title, topButtonsProps, type }, DefaultDialogContentProps), props.dialogContentProps), { draggableHeaderClassName: dialogDraggableClassName, titleProps: __assign$1({
        // eslint-disable-next-line deprecation/deprecation
        id: ((_b2 = props.dialogContentProps) === null || _b2 === void 0 ? void 0 : _b2.titleId) || this._defaultTitleTextId
      }, (_c2 = props.dialogContentProps) === null || _c2 === void 0 ? void 0 : _c2.titleProps) });
      var classNames2 = getClassNames$e(styles2, {
        theme,
        className: mergedModalProps.className,
        containerClassName: mergedModalProps.containerClassName,
        hidden,
        dialogDefaultMinWidth: minWidth,
        dialogDefaultMaxWidth: maxWidth
      });
      return React__namespace.createElement(
        Modal,
        __assign$1({}, mergedModalProps, { className: classNames2.root, containerClassName: classNames2.main, onDismiss: onDismiss || mergedModalProps.onDismiss, subtitleAriaId: this._getSubTextId(), titleAriaId: this._getTitleTextId() }),
        React__namespace.createElement(DialogContent, __assign$1({ subTextId: this._defaultSubTextId, showCloseButton: mergedModalProps.isBlocking, onDismiss }, dialogContentProps), props.children)
      );
    };
    DialogBase2.defaultProps = {
      hidden: true
    };
    DialogBase2 = __decorate([
      withResponsiveMode
    ], DialogBase2);
    return DialogBase2;
  }(React__namespace.Component)
);
var GlobalClassNames$d = {
  root: "ms-Dialog"
};
var getStyles$e = function(props) {
  var _a2;
  var className = props.className, containerClassName = props.containerClassName, _b2 = props.dialogDefaultMinWidth, dialogDefaultMinWidth = _b2 === void 0 ? "288px" : _b2, _c2 = props.dialogDefaultMaxWidth, dialogDefaultMaxWidth = _c2 === void 0 ? "340px" : _c2, hidden = props.hidden, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames$d, theme);
  return {
    root: [classNames2.root, theme.fonts.medium, className],
    main: [
      {
        width: dialogDefaultMinWidth,
        outline: "3px solid transparent",
        selectors: (_a2 = {}, _a2["@media (min-width: " + ScreenWidthMinMedium + "px)"] = {
          width: "auto",
          maxWidth: dialogDefaultMaxWidth,
          minWidth: dialogDefaultMinWidth
        }, _a2)
      },
      !hidden && { display: "flex" },
      containerClassName
    ]
  };
};
var Dialog = styled(DialogBase, getStyles$e, void 0, { scope: "Dialog" });
Dialog.displayName = "Dialog";
var DropdownSizePosCache = (
  /** @class */
  function() {
    function DropdownSizePosCache2() {
      this._size = 0;
    }
    DropdownSizePosCache2.prototype.updateOptions = function(options2) {
      var displayOnlyOptionsCache = [];
      var notSelectableOptionsCache = [];
      var size = 0;
      for (var i = 0; i < options2.length; i++) {
        var _a2 = options2[i], itemType = _a2.itemType, hidden = _a2.hidden;
        if (itemType === SelectableOptionMenuItemType.Divider || itemType === SelectableOptionMenuItemType.Header) {
          displayOnlyOptionsCache.push(i);
          notSelectableOptionsCache.push(i);
        } else if (hidden) {
          notSelectableOptionsCache.push(i);
        } else {
          size++;
        }
      }
      this._size = size;
      this._displayOnlyOptionsCache = displayOnlyOptionsCache;
      this._notSelectableOptionsCache = notSelectableOptionsCache;
      this._cachedOptions = __spreadArray([], options2);
    };
    Object.defineProperty(DropdownSizePosCache2.prototype, "optionSetSize", {
      /**
       * The size of all the selectable options.
       */
      get: function() {
        return this._size;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DropdownSizePosCache2.prototype, "cachedOptions", {
      /**
       * The chached options array.
       */
      get: function() {
        return this._cachedOptions;
      },
      enumerable: false,
      configurable: true
    });
    DropdownSizePosCache2.prototype.positionInSet = function(index2) {
      if (index2 === void 0) {
        return void 0;
      }
      var offset = 0;
      while (index2 > this._notSelectableOptionsCache[offset]) {
        offset++;
      }
      if (this._displayOnlyOptionsCache[offset] === index2) {
        throw new Error("Unexpected: Option at index " + index2 + " is not a selectable element.");
      }
      if (this._notSelectableOptionsCache[offset] === index2) {
        return void 0;
      }
      return index2 - offset + 1;
    };
    return DropdownSizePosCache2;
  }()
);
var PanelType;
(function(PanelType2) {
  PanelType2[PanelType2["smallFluid"] = 0] = "smallFluid";
  PanelType2[PanelType2["smallFixedFar"] = 1] = "smallFixedFar";
  PanelType2[PanelType2["smallFixedNear"] = 2] = "smallFixedNear";
  PanelType2[PanelType2["medium"] = 3] = "medium";
  PanelType2[PanelType2["large"] = 4] = "large";
  PanelType2[PanelType2["largeFixed"] = 5] = "largeFixed";
  PanelType2[PanelType2["extraLarge"] = 6] = "extraLarge";
  PanelType2[PanelType2["custom"] = 7] = "custom";
  PanelType2[PanelType2["customNear"] = 8] = "customNear";
})(PanelType || (PanelType = {}));
var getClassNames$d = classNamesFunction();
var COMPONENT_NAME$3 = "Panel";
var PanelVisibilityState;
(function(PanelVisibilityState2) {
  PanelVisibilityState2[PanelVisibilityState2["closed"] = 0] = "closed";
  PanelVisibilityState2[PanelVisibilityState2["animatingOpen"] = 1] = "animatingOpen";
  PanelVisibilityState2[PanelVisibilityState2["open"] = 2] = "open";
  PanelVisibilityState2[PanelVisibilityState2["animatingClosed"] = 3] = "animatingClosed";
})(PanelVisibilityState || (PanelVisibilityState = {}));
var PanelBase = (
  /** @class */
  function(_super) {
    __extends(PanelBase2, _super);
    function PanelBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._panel = React__namespace.createRef();
      _this._animationCallback = null;
      _this._hasCustomNavigation = !!(_this.props.onRenderNavigation || _this.props.onRenderNavigationContent);
      _this.dismiss = function(ev) {
        if (_this.props.onDismiss && _this.isActive) {
          _this.props.onDismiss(ev);
        }
        if (!ev || ev && !ev.defaultPrevented) {
          _this.close();
        }
      };
      _this._allowScrollOnPanel = function(elt) {
        if (elt) {
          if (_this._allowTouchBodyScroll) {
            allowOverscrollOnElement(elt, _this._events);
          } else {
            allowScrollOnElement(elt, _this._events);
          }
        } else {
          _this._events.off(_this._scrollableContent);
        }
        _this._scrollableContent = elt;
      };
      _this._onRenderNavigation = function(props2) {
        if (!_this.props.onRenderNavigationContent && !_this.props.onRenderNavigation && !_this.props.hasCloseButton) {
          return null;
        }
        var _a3 = _this.props.onRenderNavigationContent, onRenderNavigationContent = _a3 === void 0 ? _this._onRenderNavigationContent : _a3;
        return React__namespace.createElement("div", { className: _this._classNames.navigation }, onRenderNavigationContent(props2, _this._onRenderNavigationContent));
      };
      _this._onRenderNavigationContent = function(props2) {
        var _a3;
        var closeButtonAriaLabel = props2.closeButtonAriaLabel, hasCloseButton = props2.hasCloseButton, _b2 = props2.onRenderHeader, onRenderHeader = _b2 === void 0 ? _this._onRenderHeader : _b2;
        if (hasCloseButton) {
          var iconButtonStyles = (_a3 = _this._classNames.subComponentStyles) === null || _a3 === void 0 ? void 0 : _a3.closeButton();
          return React__namespace.createElement(
            React__namespace.Fragment,
            null,
            !_this._hasCustomNavigation && onRenderHeader(_this.props, _this._onRenderHeader, _this._headerTextId),
            React__namespace.createElement(IconButton, { styles: iconButtonStyles, className: _this._classNames.closeButton, onClick: _this._onPanelClick, ariaLabel: closeButtonAriaLabel, title: closeButtonAriaLabel, "data-is-visible": true, iconProps: { iconName: "Cancel" } })
          );
        }
        return null;
      };
      _this._onRenderHeader = function(props2, defaultRender, headerTextId) {
        var headerText = props2.headerText, _a3 = props2.headerTextProps, headerTextProps = _a3 === void 0 ? {} : _a3;
        if (headerText) {
          return React__namespace.createElement(
            "div",
            { className: _this._classNames.header },
            React__namespace.createElement("div", __assign$1({ id: headerTextId, role: "heading", "aria-level": 1 }, headerTextProps, { className: css$3(_this._classNames.headerText, headerTextProps.className) }), headerText)
          );
        }
        return null;
      };
      _this._onRenderBody = function(props2) {
        return React__namespace.createElement("div", { className: _this._classNames.content }, props2.children);
      };
      _this._onRenderFooter = function(props2) {
        var _a3 = _this.props.onRenderFooterContent, onRenderFooterContent = _a3 === void 0 ? null : _a3;
        if (onRenderFooterContent) {
          return React__namespace.createElement(
            "div",
            { className: _this._classNames.footer },
            React__namespace.createElement("div", { className: _this._classNames.footerInner }, onRenderFooterContent())
          );
        }
        return null;
      };
      _this._animateTo = function(newVisibilityState) {
        if (newVisibilityState === PanelVisibilityState.open && _this.props.onOpen) {
          _this.props.onOpen();
        }
        _this._animationCallback = _this._async.setTimeout(function() {
          _this.setState({ visibility: newVisibilityState });
          _this._onTransitionComplete(newVisibilityState);
        }, 200);
      };
      _this._clearExistingAnimationTimer = function() {
        if (_this._animationCallback !== null) {
          _this._async.clearTimeout(_this._animationCallback);
        }
      };
      _this._onPanelClick = function(ev) {
        _this.dismiss(ev);
      };
      _this._onTransitionComplete = function(newVisibilityState) {
        _this._updateFooterPosition();
        if (newVisibilityState === PanelVisibilityState.open && _this.props.onOpened) {
          _this.props.onOpened();
        }
        if (newVisibilityState === PanelVisibilityState.closed && _this.props.onDismissed) {
          _this.props.onDismissed();
        }
      };
      var _a2 = _this.props.allowTouchBodyScroll, allowTouchBodyScroll = _a2 === void 0 ? false : _a2;
      _this._allowTouchBodyScroll = allowTouchBodyScroll;
      initializeComponentRef(_this);
      warnDeprecations(COMPONENT_NAME$3, props, {
        ignoreExternalFocusing: "focusTrapZoneProps",
        forceFocusInsideTrap: "focusTrapZoneProps",
        firstFocusableSelector: "focusTrapZoneProps"
      });
      _this.state = {
        isFooterSticky: false,
        // intentionally ignore props so animation takes place during componentDidMount
        visibility: PanelVisibilityState.closed,
        id: getId("Panel")
      };
      return _this;
    }
    PanelBase2.getDerivedStateFromProps = function(nextProps, prevState) {
      if (nextProps.isOpen === void 0) {
        return null;
      }
      if (nextProps.isOpen && (prevState.visibility === PanelVisibilityState.closed || prevState.visibility === PanelVisibilityState.animatingClosed)) {
        return { visibility: PanelVisibilityState.animatingOpen };
      }
      if (!nextProps.isOpen && (prevState.visibility === PanelVisibilityState.open || prevState.visibility === PanelVisibilityState.animatingOpen)) {
        return { visibility: PanelVisibilityState.animatingClosed };
      }
      return null;
    };
    PanelBase2.prototype.componentDidMount = function() {
      this._async = new Async(this);
      this._events = new EventGroup(this);
      this._events.on(window, "resize", this._updateFooterPosition);
      if (this._shouldListenForOuterClick(this.props)) {
        this._events.on(document.body, "mousedown", this._dismissOnOuterClick, true);
      }
      if (this.props.isOpen) {
        this.setState({ visibility: PanelVisibilityState.animatingOpen });
      }
    };
    PanelBase2.prototype.componentDidUpdate = function(previousProps, previousState) {
      var shouldListenOnOuterClick = this._shouldListenForOuterClick(this.props);
      var previousShouldListenOnOuterClick = this._shouldListenForOuterClick(previousProps);
      if (this.state.visibility !== previousState.visibility) {
        this._clearExistingAnimationTimer();
        if (this.state.visibility === PanelVisibilityState.animatingOpen) {
          this._animateTo(PanelVisibilityState.open);
        } else if (this.state.visibility === PanelVisibilityState.animatingClosed) {
          this._animateTo(PanelVisibilityState.closed);
        }
      }
      if (shouldListenOnOuterClick && !previousShouldListenOnOuterClick) {
        this._events.on(document.body, "mousedown", this._dismissOnOuterClick, true);
      } else if (!shouldListenOnOuterClick && previousShouldListenOnOuterClick) {
        this._events.off(document.body, "mousedown", this._dismissOnOuterClick, true);
      }
    };
    PanelBase2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    PanelBase2.prototype.render = function() {
      var _a2 = this.props, _b2 = _a2.className, className = _b2 === void 0 ? "" : _b2, elementToFocusOnDismiss = _a2.elementToFocusOnDismiss, firstFocusableSelector = _a2.firstFocusableSelector, focusTrapZoneProps = _a2.focusTrapZoneProps, forceFocusInsideTrap = _a2.forceFocusInsideTrap, hasCloseButton = _a2.hasCloseButton, headerText = _a2.headerText, _c2 = _a2.headerClassName, headerClassName = _c2 === void 0 ? "" : _c2, ignoreExternalFocusing = _a2.ignoreExternalFocusing, isBlocking = _a2.isBlocking, isFooterAtBottom = _a2.isFooterAtBottom, isLightDismiss = _a2.isLightDismiss, isHiddenOnDismiss = _a2.isHiddenOnDismiss, layerProps = _a2.layerProps, overlayProps = _a2.overlayProps, popupProps = _a2.popupProps, type = _a2.type, styles2 = _a2.styles, theme = _a2.theme, customWidth = _a2.customWidth, _d2 = _a2.onLightDismissClick, onLightDismissClick = _d2 === void 0 ? this._onPanelClick : _d2, _e2 = _a2.onRenderNavigation, onRenderNavigation = _e2 === void 0 ? this._onRenderNavigation : _e2, _f = _a2.onRenderHeader, onRenderHeader = _f === void 0 ? this._onRenderHeader : _f, _g = _a2.onRenderBody, onRenderBody = _g === void 0 ? this._onRenderBody : _g, _h = _a2.onRenderFooter, onRenderFooter = _h === void 0 ? this._onRenderFooter : _h;
      var _j = this.state, isFooterSticky = _j.isFooterSticky, visibility = _j.visibility, id = _j.id;
      var isLeft = type === PanelType.smallFixedNear || type === PanelType.customNear ? true : false;
      var isRTL = getRTL(theme);
      var isOnRightSide = isRTL ? isLeft : !isLeft;
      var customWidthStyles = type === PanelType.custom || type === PanelType.customNear ? { width: customWidth } : {};
      var nativeProps = getNativeProps(this.props, divProperties);
      var isOpen = this.isActive;
      var isAnimating = visibility === PanelVisibilityState.animatingClosed || visibility === PanelVisibilityState.animatingOpen;
      this._headerTextId = headerText && id + "-headerText";
      if (!isOpen && !isAnimating && !isHiddenOnDismiss) {
        return null;
      }
      this._classNames = getClassNames$d(styles2, {
        theme,
        className,
        focusTrapZoneClassName: focusTrapZoneProps ? focusTrapZoneProps.className : void 0,
        hasCloseButton,
        headerClassName,
        isAnimating,
        isFooterSticky,
        isFooterAtBottom,
        isOnRightSide,
        isOpen,
        isHiddenOnDismiss,
        type,
        hasCustomNavigation: this._hasCustomNavigation
      });
      var _k = this, _classNames = _k._classNames, _allowTouchBodyScroll = _k._allowTouchBodyScroll;
      var overlay;
      if (isBlocking && isOpen) {
        overlay = React__namespace.createElement(Overlay, __assign$1({ className: _classNames.overlay, isDarkThemed: false, onClick: isLightDismiss ? onLightDismissClick : void 0, allowTouchBodyScroll: _allowTouchBodyScroll }, overlayProps));
      }
      return React__namespace.createElement(
        Layer,
        __assign$1({}, layerProps),
        React__namespace.createElement(
          Popup,
          __assign$1({ role: "dialog", "aria-modal": isBlocking ? "true" : void 0, ariaLabelledBy: this._headerTextId ? this._headerTextId : void 0, onDismiss: this.dismiss, className: _classNames.hiddenPanel, enableAriaHiddenSiblings: isOpen ? true : false }, popupProps),
          React__namespace.createElement(
            "div",
            __assign$1({ "aria-hidden": !isOpen && isAnimating }, nativeProps, { ref: this._panel, className: _classNames.root }),
            overlay,
            React__namespace.createElement(
              FocusTrapZone,
              __assign$1({ ignoreExternalFocusing, forceFocusInsideTrap: !isBlocking || isHiddenOnDismiss && !isOpen ? false : forceFocusInsideTrap, firstFocusableSelector, isClickableOutsideFocusTrap: true }, focusTrapZoneProps, { className: _classNames.main, style: customWidthStyles, elementToFocusOnDismiss }),
              React__namespace.createElement(
                "div",
                { className: _classNames.contentInner },
                React__namespace.createElement(
                  "div",
                  { ref: this._allowScrollOnPanel, className: _classNames.scrollableContent, "data-is-scrollable": true },
                  React__namespace.createElement("div", { className: _classNames.commands, "data-is-visible": true }, onRenderNavigation(this.props, this._onRenderNavigation)),
                  (this._hasCustomNavigation || !hasCloseButton) && onRenderHeader(this.props, this._onRenderHeader, this._headerTextId),
                  onRenderBody(this.props, this._onRenderBody),
                  onRenderFooter(this.props, this._onRenderFooter)
                )
              )
            )
          )
        )
      );
    };
    PanelBase2.prototype.open = function() {
      if (this.props.isOpen !== void 0) {
        return;
      }
      if (this.isActive) {
        return;
      }
      this.setState({ visibility: PanelVisibilityState.animatingOpen });
    };
    PanelBase2.prototype.close = function() {
      if (this.props.isOpen !== void 0) {
        return;
      }
      if (!this.isActive) {
        return;
      }
      this.setState({ visibility: PanelVisibilityState.animatingClosed });
    };
    Object.defineProperty(PanelBase2.prototype, "isActive", {
      /** isActive is true when panel is open or opening. */
      get: function() {
        return this.state.visibility === PanelVisibilityState.open || this.state.visibility === PanelVisibilityState.animatingOpen;
      },
      enumerable: false,
      configurable: true
    });
    PanelBase2.prototype._shouldListenForOuterClick = function(props) {
      return !!props.isBlocking && !!props.isOpen;
    };
    PanelBase2.prototype._updateFooterPosition = function() {
      var scrollableContent = this._scrollableContent;
      if (scrollableContent) {
        var height = scrollableContent.clientHeight;
        var innerHeight_1 = scrollableContent.scrollHeight;
        this.setState({
          isFooterSticky: height < innerHeight_1 ? true : false
        });
      }
    };
    PanelBase2.prototype._dismissOnOuterClick = function(ev) {
      var panel = this._panel.current;
      if (this.isActive && panel && !ev.defaultPrevented) {
        if (!elementContains(panel, ev.target)) {
          if (this.props.onOuterClick) {
            this.props.onOuterClick(ev);
          } else {
            this.dismiss(ev);
          }
        }
      }
    };
    PanelBase2.defaultProps = {
      isHiddenOnDismiss: false,
      isOpen: void 0,
      isBlocking: true,
      hasCloseButton: true,
      type: PanelType.smallFixedFar
    };
    return PanelBase2;
  }(React__namespace.Component)
);
var _a$3, _b$2, _c$2, _d$1, _e;
var GlobalClassNames$c = {
  root: "ms-Panel",
  main: "ms-Panel-main",
  commands: "ms-Panel-commands",
  contentInner: "ms-Panel-contentInner",
  scrollableContent: "ms-Panel-scrollableContent",
  navigation: "ms-Panel-navigation",
  closeButton: "ms-Panel-closeButton ms-PanelAction-close",
  header: "ms-Panel-header",
  headerText: "ms-Panel-headerText",
  content: "ms-Panel-content",
  footer: "ms-Panel-footer",
  footerInner: "ms-Panel-footerInner",
  isOpen: "is-open",
  hasCloseButton: "ms-Panel--hasCloseButton",
  smallFluid: "ms-Panel--smFluid",
  smallFixedNear: "ms-Panel--smLeft",
  smallFixedFar: "ms-Panel--sm",
  medium: "ms-Panel--md",
  large: "ms-Panel--lg",
  largeFixed: "ms-Panel--fixed",
  extraLarge: "ms-Panel--xl",
  custom: "ms-Panel--custom",
  customNear: "ms-Panel--customLeft"
};
var panelWidth = {
  full: "100%",
  auto: "auto",
  xs: 272,
  sm: 340,
  md1: 592,
  md2: 644,
  lg: 940
};
var panelMargin = {
  auto: "auto",
  none: 0,
  md: 48,
  lg: 428,
  xl: 176
};
var smallPanelSelectors = (_a$3 = {}, _a$3["@media (min-width: " + ScreenWidthMinMedium + "px)"] = {
  width: panelWidth.sm
}, _a$3);
var mediumPanelSelectors = (_b$2 = {}, _b$2["@media (min-width: " + ScreenWidthMinLarge + "px)"] = {
  width: panelWidth.md1
}, _b$2["@media (min-width: " + ScreenWidthMinXLarge + "px)"] = {
  width: panelWidth.md2
}, _b$2);
var largePanelSelectors = (_c$2 = {}, _c$2["@media (min-width: " + ScreenWidthMinUhfMobile + "px)"] = {
  left: panelMargin.md,
  width: panelWidth.auto
}, _c$2["@media (min-width: " + ScreenWidthMinXXLarge + "px)"] = {
  left: panelMargin.lg
}, _c$2);
var largeFixedPanelSelectors = (_d$1 = {}, _d$1["@media (min-width: " + ScreenWidthMinXXLarge + "px)"] = {
  left: panelMargin.auto,
  width: panelWidth.lg
}, _d$1);
var extraLargePanelSelectors = (_e = {}, _e["@media (min-width: " + ScreenWidthMinXXLarge + "px)"] = {
  left: panelMargin.xl
}, _e);
var getPanelBreakpoints = function(type) {
  var selectors;
  switch (type) {
    case PanelType.smallFixedFar:
      selectors = __assign$1({}, smallPanelSelectors);
      break;
    case PanelType.medium:
      selectors = __assign$1(__assign$1({}, smallPanelSelectors), mediumPanelSelectors);
      break;
    case PanelType.large:
      selectors = __assign$1(__assign$1(__assign$1({}, smallPanelSelectors), mediumPanelSelectors), largePanelSelectors);
      break;
    case PanelType.largeFixed:
      selectors = __assign$1(__assign$1(__assign$1(__assign$1({}, smallPanelSelectors), mediumPanelSelectors), largePanelSelectors), largeFixedPanelSelectors);
      break;
    case PanelType.extraLarge:
      selectors = __assign$1(__assign$1(__assign$1(__assign$1({}, smallPanelSelectors), mediumPanelSelectors), largePanelSelectors), extraLargePanelSelectors);
      break;
  }
  return selectors;
};
var commandBarHeight = "44px";
var sharedPaddingStyles = {
  paddingLeft: "24px",
  paddingRight: "24px"
};
var getStyles$d = function(props) {
  var _a2, _b2, _c2, _d2;
  var className = props.className, focusTrapZoneClassName = props.focusTrapZoneClassName, hasCloseButton = props.hasCloseButton, headerClassName = props.headerClassName, isAnimating = props.isAnimating, isFooterSticky = props.isFooterSticky, isFooterAtBottom = props.isFooterAtBottom, isOnRightSide = props.isOnRightSide, isOpen = props.isOpen, isHiddenOnDismiss = props.isHiddenOnDismiss, hasCustomNavigation = props.hasCustomNavigation, theme = props.theme, _e2 = props.type, type = _e2 === void 0 ? PanelType.smallFixedFar : _e2;
  var effects = theme.effects, fonts = theme.fonts, semanticColors = theme.semanticColors;
  var classNames2 = getGlobalClassNames(GlobalClassNames$c, theme);
  var isCustomPanel = type === PanelType.custom || type === PanelType.customNear;
  return {
    root: [
      classNames2.root,
      theme.fonts.medium,
      isOpen && classNames2.isOpen,
      hasCloseButton && classNames2.hasCloseButton,
      {
        pointerEvents: "none",
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      },
      isCustomPanel && isOnRightSide && classNames2.custom,
      isCustomPanel && !isOnRightSide && classNames2.customNear,
      className
    ],
    overlay: [
      {
        pointerEvents: "auto",
        cursor: "pointer"
      },
      isOpen && isAnimating && AnimationClassNames.fadeIn100,
      !isOpen && isAnimating && AnimationClassNames.fadeOut100
    ],
    hiddenPanel: [
      !isOpen && !isAnimating && isHiddenOnDismiss && {
        visibility: "hidden"
      }
    ],
    main: [
      classNames2.main,
      {
        backgroundColor: semanticColors.bodyBackground,
        boxShadow: effects.elevation64,
        pointerEvents: "auto",
        position: "absolute",
        display: "flex",
        flexDirection: "column",
        overflowX: "hidden",
        overflowY: "auto",
        WebkitOverflowScrolling: "touch",
        bottom: 0,
        top: 0,
        // left, right, width are overridden depending on the type of the Panel and the screen breakpoint.
        left: panelMargin.auto,
        right: panelMargin.none,
        width: panelWidth.full,
        selectors: __assign$1((_a2 = {}, _a2[HighContrastSelector] = {
          borderLeft: "3px solid " + semanticColors.variantBorder,
          borderRight: "3px solid " + semanticColors.variantBorder
        }, _a2), getPanelBreakpoints(type))
      },
      type === PanelType.smallFluid && {
        left: panelMargin.none
      },
      type === PanelType.smallFixedNear && {
        left: panelMargin.none,
        right: panelMargin.auto,
        width: panelWidth.xs
      },
      type === PanelType.customNear && {
        right: "auto",
        left: 0
      },
      isCustomPanel && {
        maxWidth: "100vw"
      },
      isOpen && isAnimating && !isOnRightSide && AnimationClassNames.slideRightIn40,
      isOpen && isAnimating && isOnRightSide && AnimationClassNames.slideLeftIn40,
      !isOpen && isAnimating && !isOnRightSide && AnimationClassNames.slideLeftOut40,
      !isOpen && isAnimating && isOnRightSide && AnimationClassNames.slideRightOut40,
      focusTrapZoneClassName
    ],
    commands: [
      classNames2.commands,
      {
        // Ensures that the sticky header always has a background to prevent overlaps on scroll.
        backgroundColor: semanticColors.bodyBackground,
        paddingTop: 18,
        selectors: (_b2 = {}, _b2["@media (min-height: " + ScreenWidthMinMedium + "px)"] = {
          position: "sticky",
          top: 0,
          zIndex: 1
        }, _b2)
      },
      hasCustomNavigation && {
        paddingTop: "inherit"
      }
    ],
    navigation: [
      classNames2.navigation,
      {
        display: "flex",
        justifyContent: "flex-end"
      },
      hasCustomNavigation && {
        height: commandBarHeight
      }
    ],
    contentInner: [
      classNames2.contentInner,
      {
        display: "flex",
        flexDirection: "column",
        flexGrow: 1,
        overflowY: "hidden"
      }
    ],
    header: [
      classNames2.header,
      sharedPaddingStyles,
      {
        alignSelf: "flex-start"
      },
      hasCloseButton && !hasCustomNavigation && {
        flexGrow: 1
      },
      hasCustomNavigation && {
        // Ensure that title doesn't shrink if screen is too small
        flexShrink: 0
      }
    ],
    headerText: [
      classNames2.headerText,
      fonts.xLarge,
      {
        color: semanticColors.bodyText,
        lineHeight: "27px",
        overflowWrap: "break-word",
        wordWrap: "break-word",
        wordBreak: "break-word",
        hyphens: "auto"
      },
      headerClassName
    ],
    scrollableContent: [
      classNames2.scrollableContent,
      {
        overflowY: "auto"
      },
      isFooterAtBottom && {
        flexGrow: 1,
        display: "inherit",
        flexDirection: "inherit"
      }
    ],
    content: [
      classNames2.content,
      sharedPaddingStyles,
      {
        paddingBottom: 20
      },
      isFooterAtBottom && {
        selectors: (_c2 = {}, _c2["@media (min-height: " + ScreenWidthMinMedium + "px)"] = {
          flexGrow: 1
        }, _c2)
      }
    ],
    footer: [
      classNames2.footer,
      {
        // Ensure that footer doesn't shrink if screen is too small
        flexShrink: 0,
        borderTop: "1px solid transparent",
        transition: "opacity " + AnimationVariables.durationValue3 + " " + AnimationVariables.easeFunction2,
        selectors: (_d2 = {}, _d2["@media (min-height: " + ScreenWidthMinMedium + "px)"] = {
          position: "sticky",
          bottom: 0
        }, _d2)
      },
      isFooterSticky && {
        backgroundColor: semanticColors.bodyBackground,
        borderTopColor: semanticColors.variantBorder
      }
    ],
    footerInner: [
      classNames2.footerInner,
      sharedPaddingStyles,
      {
        paddingBottom: 16,
        paddingTop: 16
      }
    ],
    subComponentStyles: {
      closeButton: {
        root: [
          classNames2.closeButton,
          {
            marginRight: 14,
            color: theme.palette.neutralSecondary,
            fontSize: IconFontSizes.large
          },
          hasCustomNavigation && {
            marginRight: 0,
            height: "auto",
            width: "44px"
          }
        ],
        rootHovered: {
          color: theme.palette.neutralPrimary
        }
      }
    }
  };
};
var Panel = styled(PanelBase, getStyles$d, void 0, {
  scope: "Panel"
});
var COMPONENT_NAME$2 = "Dropdown";
var getClassNames$c = classNamesFunction();
var DEFAULT_PROPS$1 = {
  options: []
};
function useSelectedItemsState(_a2) {
  var defaultSelectedKeys = _a2.defaultSelectedKeys, selectedKeys = _a2.selectedKeys, defaultSelectedKey = _a2.defaultSelectedKey, selectedKey = _a2.selectedKey, options2 = _a2.options, multiSelect = _a2.multiSelect;
  var oldOptions = usePrevious(options2);
  var _b2 = React__namespace.useState([]), selectedIndices = _b2[0], setSelectedIndices = _b2[1];
  var selectedKeyPropToUse;
  var didOptionsChange = options2 !== oldOptions;
  if (multiSelect) {
    if (didOptionsChange && defaultSelectedKeys !== void 0) {
      selectedKeyPropToUse = defaultSelectedKeys;
    } else {
      selectedKeyPropToUse = selectedKeys;
    }
  } else {
    if (didOptionsChange && defaultSelectedKey !== void 0) {
      selectedKeyPropToUse = defaultSelectedKey;
    } else {
      selectedKeyPropToUse = selectedKey;
    }
  }
  var oldSelectedKeyProp = usePrevious(selectedKeyPropToUse);
  React__namespace.useEffect(function() {
    var getSelectedIndexes = function() {
      if (selectedKeyPropToUse === void 0) {
        if (multiSelect) {
          return getAllSelectedIndices();
        }
        var selectedIndex = getSelectedIndex(null);
        return selectedIndex !== -1 ? [selectedIndex] : [];
      } else if (!Array.isArray(selectedKeyPropToUse)) {
        var selectedIndex = getSelectedIndex(selectedKeyPropToUse);
        return selectedIndex !== -1 ? [selectedIndex] : [];
      }
      var returnValue = [];
      for (var _i = 0, selectedKeyPropToUse_1 = selectedKeyPropToUse; _i < selectedKeyPropToUse_1.length; _i++) {
        var key = selectedKeyPropToUse_1[_i];
        var selectedIndex = getSelectedIndex(key);
        selectedIndex !== -1 && returnValue.push(selectedIndex);
      }
      return returnValue;
    };
    var getAllSelectedIndices = function() {
      return options2.map(function(option, index2) {
        return option.selected ? index2 : -1;
      }).filter(function(index2) {
        return index2 !== -1;
      });
    };
    var getSelectedIndex = function(searchKey) {
      return findIndex(options2, function(option) {
        if (searchKey != null) {
          return option.key === searchKey;
        } else {
          return !!option.selected || !!option.isSelected;
        }
      });
    };
    if ((selectedKeyPropToUse !== void 0 || !oldOptions) && (selectedKeyPropToUse !== oldSelectedKeyProp || didOptionsChange)) {
      setSelectedIndices(getSelectedIndexes());
    }
  }, [didOptionsChange, multiSelect, oldOptions, oldSelectedKeyProp, options2, selectedKeyPropToUse]);
  return [selectedIndices, setSelectedIndices];
}
var DropdownBase = React__namespace.forwardRef(function(propsWithoutDefaults, forwardedRef) {
  var props = getPropsWithDefaults(DEFAULT_PROPS$1, propsWithoutDefaults);
  var rootRef = React__namespace.useRef(null);
  var mergedRootRef = useMergedRefs(forwardedRef, rootRef);
  var responsiveMode = useResponsiveMode(rootRef, props.responsiveMode);
  var _a2 = useSelectedItemsState(props), selectedIndices = _a2[0], setSelectedIndices = _a2[1];
  return React__namespace.createElement(DropdownInternal, __assign$1({}, props, { responsiveMode, hoisted: { rootRef: mergedRootRef, selectedIndices, setSelectedIndices } }));
});
DropdownBase.displayName = "DropdownBase";
var DropdownInternal = (
  /** @class */
  function(_super) {
    __extends(DropdownInternal2, _super);
    function DropdownInternal2(props) {
      var _this = _super.call(this, props) || this;
      _this._host = React__namespace.createRef();
      _this._focusZone = React__namespace.createRef();
      _this._dropDown = React__namespace.createRef();
      _this._scrollIdleDelay = 250;
      _this._sizePosCache = new DropdownSizePosCache();
      _this._requestAnimationFrame = safeRequestAnimationFrame(_this);
      _this.dismissMenu = function() {
        var isOpen = _this.state.isOpen;
        isOpen && _this.setState({ isOpen: false });
      };
      _this._onChange = function(event, options3, index2, checked, multiSelect2) {
        var _a2 = _this.props, onChange2 = _a2.onChange, onChanged = _a2.onChanged;
        if (onChange2 || onChanged) {
          var changedOpt = multiSelect2 ? __assign$1(__assign$1({}, options3[index2]), { selected: !checked }) : options3[index2];
          onChange2 && onChange2(__assign$1(__assign$1({}, event), { target: _this._dropDown.current }), changedOpt, index2);
          onChanged && onChanged(changedOpt, index2);
        }
      };
      _this._getPlaceholder = function() {
        return _this.props.placeholder || _this.props.placeHolder;
      };
      _this._getTitle = function(items, _unused) {
        var _a2 = _this.props.multiSelectDelimiter, multiSelectDelimiter = _a2 === void 0 ? ", " : _a2;
        return items.map(function(i) {
          return i.text;
        }).join(multiSelectDelimiter);
      };
      _this._onRenderTitle = function(items) {
        return React__namespace.createElement(React__namespace.Fragment, null, _this._getTitle(items));
      };
      _this._onRenderPlaceholder = function(props2) {
        if (!_this._getPlaceholder()) {
          return null;
        }
        return React__namespace.createElement(React__namespace.Fragment, null, _this._getPlaceholder());
      };
      _this._onRenderContainer = function(props2) {
        var calloutProps = props2.calloutProps, panelProps = props2.panelProps;
        var _a2 = _this.props, responsiveMode = _a2.responsiveMode, dropdownWidth = _a2.dropdownWidth;
        var isSmall = responsiveMode <= ResponsiveMode.medium;
        var focusTrapZoneProps = { firstFocusableTarget: "#" + _this._listId + "1" };
        var panelStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.panel : void 0;
        var calloutWidth = void 0;
        var calloutMinWidth = void 0;
        if (dropdownWidth === "auto") {
          calloutMinWidth = _this._dropDown.current ? _this._dropDown.current.clientWidth : 0;
        } else {
          calloutWidth = dropdownWidth || (_this._dropDown.current ? _this._dropDown.current.clientWidth : 0);
        }
        return isSmall ? React__namespace.createElement(Panel, __assign$1({ closeButtonAriaLabel: "Close", focusTrapZoneProps, hasCloseButton: true, isOpen: true, isLightDismiss: true, onDismiss: _this._onDismiss, styles: panelStyles }, panelProps), _this._renderFocusableList(props2)) : React__namespace.createElement(Callout, __assign$1({ isBeakVisible: false, gapSpace: 0, doNotLayer: false, directionalHintFixed: false, directionalHint: DirectionalHint.bottomLeftEdge, calloutWidth, calloutMinWidth }, calloutProps, { className: _this._classNames.callout, target: _this._dropDown.current, onDismiss: _this._onDismiss, onScroll: _this._onScroll, onPositioned: _this._onPositioned }), _this._renderFocusableList(props2));
      };
      _this._onRenderCaretDown = function(props2) {
        return React__namespace.createElement(Icon, { className: _this._classNames.caretDown, iconName: "ChevronDown", "aria-hidden": true });
      };
      _this._onRenderList = function(props2) {
        var _a2 = props2.onRenderItem, onRenderItem = _a2 === void 0 ? _this._onRenderItem : _a2;
        var queue = { items: [] };
        var renderedList = [];
        var emptyQueue = function() {
          var newGroup = queue.id ? [
            React__namespace.createElement("div", { role: "group", key: queue.id, "aria-labelledby": queue.id }, queue.items)
          ] : queue.items;
          renderedList = __spreadArray(__spreadArray([], renderedList), newGroup);
          queue = { items: [] };
        };
        var placeRenderedOptionIntoQueue = function(item, index2) {
          switch (item.itemType) {
            case SelectableOptionMenuItemType.Header:
              queue.items.length > 0 && emptyQueue();
              var id = _this._id + item.key;
              queue.items.push(onRenderItem(__assign$1(__assign$1({ id }, item), { index: index2 }), _this._onRenderItem));
              queue.id = id;
              break;
            case SelectableOptionMenuItemType.Divider:
              index2 > 0 && queue.items.push(onRenderItem(__assign$1(__assign$1({}, item), { index: index2 }), _this._onRenderItem));
              queue.items.length > 0 && emptyQueue();
              break;
            default:
              queue.items.push(onRenderItem(__assign$1(__assign$1({}, item), { index: index2 }), _this._onRenderItem));
          }
        };
        props2.options.forEach(function(item, index2) {
          placeRenderedOptionIntoQueue(item, index2);
        });
        queue.items.length > 0 && emptyQueue();
        return React__namespace.createElement(React__namespace.Fragment, null, renderedList);
      };
      _this._onRenderItem = function(item) {
        switch (item.itemType) {
          case SelectableOptionMenuItemType.Divider:
            return _this._renderSeparator(item);
          case SelectableOptionMenuItemType.Header:
            return _this._renderHeader(item);
          default:
            return _this._renderOption(item);
        }
      };
      _this._renderOption = function(item) {
        var _a2;
        var _b2 = _this.props, _c2 = _b2.onRenderOption, onRenderOption = _c2 === void 0 ? _this._onRenderOption : _c2, _d2 = _b2.hoisted.selectedIndices, selectedIndices = _d2 === void 0 ? [] : _d2;
        var isItemSelected = item.index !== void 0 && selectedIndices ? selectedIndices.indexOf(item.index) > -1 : false;
        var itemClassName = item.hidden ? _this._classNames.dropdownItemHidden : isItemSelected && item.disabled === true ? _this._classNames.dropdownItemSelectedAndDisabled : isItemSelected ? _this._classNames.dropdownItemSelected : item.disabled === true ? _this._classNames.dropdownItemDisabled : _this._classNames.dropdownItem;
        var title = item.title;
        var id = _this._listId + item.index;
        var labelId = (_a2 = item.id) !== null && _a2 !== void 0 ? _a2 : id + "-label";
        var multiSelectItemStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.multiSelectItem : void 0;
        return !_this.props.multiSelect ? React__namespace.createElement(CommandButton, {
          id,
          key: item.key,
          "data-index": item.index,
          "data-is-focusable": !item.disabled,
          disabled: item.disabled,
          className: itemClassName,
          onClick: _this._onItemClick(item),
          // eslint-disable-next-line react/jsx-no-bind
          onMouseEnter: _this._onItemMouseEnter.bind(_this, item),
          // eslint-disable-next-line react/jsx-no-bind
          onMouseLeave: _this._onMouseItemLeave.bind(_this, item),
          // eslint-disable-next-line react/jsx-no-bind
          onMouseMove: _this._onItemMouseMove.bind(_this, item),
          role: "option",
          "aria-selected": isItemSelected ? "true" : "false",
          ariaLabel: item.ariaLabel,
          title,
          "aria-posinset": _this._sizePosCache.positionInSet(item.index),
          "aria-setsize": _this._sizePosCache.optionSetSize
        }, onRenderOption(item, _this._onRenderOption)) : React__namespace.createElement(Checkbox, {
          id,
          key: item.key,
          disabled: item.disabled,
          onChange: _this._onItemClick(item),
          inputProps: __assign$1({ "aria-selected": isItemSelected, onMouseEnter: _this._onItemMouseEnter.bind(_this, item), onMouseLeave: _this._onMouseItemLeave.bind(_this, item), onMouseMove: _this._onItemMouseMove.bind(_this, item), role: "option" }, {
            "data-index": item.index,
            "data-is-focusable": !(item.disabled || item.hidden)
          }),
          label: item.text,
          title,
          // eslint-disable-next-line react/jsx-no-bind
          onRenderLabel: _this._onRenderItemLabel.bind(_this, __assign$1(__assign$1({}, item), { id: labelId })),
          className: css$3(itemClassName, "is-multi-select"),
          checked: isItemSelected,
          styles: multiSelectItemStyles,
          ariaPositionInSet: !item.hidden ? _this._sizePosCache.positionInSet(item.index) : void 0,
          ariaSetSize: !item.hidden ? _this._sizePosCache.optionSetSize : void 0,
          ariaLabel: item.ariaLabel,
          ariaLabelledBy: item.ariaLabel ? void 0 : labelId
        });
      };
      _this._onRenderOption = function(item) {
        return React__namespace.createElement("span", { className: _this._classNames.dropdownOptionText }, item.text);
      };
      _this._onRenderMultiselectOption = function(item) {
        return React__namespace.createElement("span", { id: item.id, "aria-hidden": "true", className: _this._classNames.dropdownOptionText }, item.text);
      };
      _this._onRenderItemLabel = function(item) {
        var _a2 = _this.props.onRenderOption, onRenderOption = _a2 === void 0 ? _this._onRenderMultiselectOption : _a2;
        return onRenderOption(item, _this._onRenderMultiselectOption);
      };
      _this._onPositioned = function(positions) {
        if (_this._focusZone.current) {
          _this._requestAnimationFrame(function() {
            var selectedIndices = _this.props.hoisted.selectedIndices;
            if (_this._focusZone.current) {
              if (!_this._hasBeenPositioned && selectedIndices && selectedIndices[0] && !_this.props.options[selectedIndices[0]].disabled) {
                var element = getDocument().getElementById(_this._id + "-list" + selectedIndices[0]);
                if (element) {
                  _this._focusZone.current.focusElement(element);
                }
                _this._hasBeenPositioned = true;
              } else {
                _this._focusZone.current.focus();
              }
            }
          });
        }
        if (!_this.state.calloutRenderEdge || _this.state.calloutRenderEdge !== positions.targetEdge) {
          _this.setState({
            calloutRenderEdge: positions.targetEdge
          });
        }
      };
      _this._onItemClick = function(item) {
        return function(event) {
          if (!item.disabled) {
            _this.setSelectedIndex(event, item.index);
            if (!_this.props.multiSelect) {
              _this.setState({
                isOpen: false
              });
            }
          }
        };
      };
      _this._onScroll = function() {
        if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== void 0) {
          clearTimeout(_this._scrollIdleTimeoutId);
          _this._scrollIdleTimeoutId = void 0;
        } else {
          _this._isScrollIdle = false;
        }
        _this._scrollIdleTimeoutId = window.setTimeout(function() {
          _this._isScrollIdle = true;
        }, _this._scrollIdleDelay);
      };
      _this._onMouseItemLeave = function(item, ev) {
        if (_this._shouldIgnoreMouseEvent()) {
          return;
        }
        if (_this._host.current) {
          if (_this._host.current.setActive) {
            try {
              _this._host.current.setActive();
            } catch (e) {
            }
          } else {
            _this._host.current.focus();
          }
        }
      };
      _this._onDismiss = function() {
        _this.setState({ isOpen: false });
      };
      _this._onDropdownBlur = function(ev) {
        var disabled = _this._isDisabled();
        if (disabled) {
          return;
        }
        if (_this.state.isOpen) {
          return;
        }
        _this.setState({ hasFocus: false });
        if (_this.props.onBlur) {
          _this.props.onBlur(ev);
        }
      };
      _this._onDropdownKeyDown = function(ev) {
        var disabled = _this._isDisabled();
        if (disabled) {
          return;
        }
        _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown(ev);
          if (ev.defaultPrevented) {
            return;
          }
        }
        var newIndex;
        var selectedIndex = _this.props.hoisted.selectedIndices.length ? _this.props.hoisted.selectedIndices[0] : -1;
        var containsExpandCollapseModifier = ev.altKey || ev.metaKey;
        var isOpen = _this.state.isOpen;
        switch (ev.which) {
          case KeyCodes.enter:
            _this.setState({
              isOpen: !isOpen
            });
            break;
          case KeyCodes.escape:
            if (!isOpen) {
              return;
            }
            _this.setState({
              isOpen: false
            });
            break;
          case KeyCodes.up:
            if (containsExpandCollapseModifier) {
              if (isOpen) {
                _this.setState({ isOpen: false });
                break;
              }
              return;
            }
            if (_this.props.multiSelect) {
              _this.setState({ isOpen: true });
            } else if (!_this._isDisabled()) {
              newIndex = _this._moveIndex(ev, -1, selectedIndex - 1, selectedIndex);
            }
            break;
          case KeyCodes.down:
            if (containsExpandCollapseModifier) {
              ev.stopPropagation();
              ev.preventDefault();
            }
            if (containsExpandCollapseModifier && !isOpen || _this.props.multiSelect) {
              _this.setState({ isOpen: true });
            } else if (!_this._isDisabled()) {
              newIndex = _this._moveIndex(ev, 1, selectedIndex + 1, selectedIndex);
            }
            break;
          case KeyCodes.home:
            if (!_this.props.multiSelect) {
              newIndex = _this._moveIndex(ev, 1, 0, selectedIndex);
            }
            break;
          case KeyCodes.end:
            if (!_this.props.multiSelect) {
              newIndex = _this._moveIndex(ev, -1, _this.props.options.length - 1, selectedIndex);
            }
            break;
          case KeyCodes.space:
            break;
          default:
            return;
        }
        if (newIndex !== selectedIndex) {
          ev.stopPropagation();
          ev.preventDefault();
        }
      };
      _this._onDropdownKeyUp = function(ev) {
        var disabled = _this._isDisabled();
        if (disabled) {
          return;
        }
        var shouldHandleKey = _this._shouldHandleKeyUp(ev);
        var isOpen = _this.state.isOpen;
        if (_this.props.onKeyUp) {
          _this.props.onKeyUp(ev);
          if (ev.defaultPrevented) {
            return;
          }
        }
        switch (ev.which) {
          case KeyCodes.space:
            _this.setState({
              isOpen: !isOpen
            });
            break;
          default:
            if (shouldHandleKey && isOpen) {
              _this.setState({ isOpen: false });
            }
            return;
        }
        ev.stopPropagation();
        ev.preventDefault();
      };
      _this._onZoneKeyDown = function(ev) {
        var _a2, _b2;
        var elementToFocus;
        _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);
        var containsExpandCollapseModifier = ev.altKey || ev.metaKey;
        switch (ev.which) {
          case KeyCodes.up:
            if (containsExpandCollapseModifier) {
              _this.setState({ isOpen: false });
            } else {
              if (_this._host.current) {
                elementToFocus = getLastFocusable(_this._host.current, _this._host.current.lastChild, true);
              }
            }
            break;
          case KeyCodes.home:
          case KeyCodes.end:
          case KeyCodes.pageUp:
          case KeyCodes.pageDown:
            break;
          case KeyCodes.down:
            if (!containsExpandCollapseModifier && _this._host.current) {
              elementToFocus = getFirstFocusable(_this._host.current, _this._host.current.firstChild, true);
            }
            break;
          case KeyCodes.escape:
            _this.setState({ isOpen: false });
            break;
          case KeyCodes.tab:
            _this.setState({ isOpen: false });
            var document_1 = getDocument();
            if (document_1) {
              if (ev.shiftKey) {
                (_a2 = getPreviousElement(document_1.body, _this._dropDown.current, false, false, true, true)) === null || _a2 === void 0 ? void 0 : _a2.focus();
              } else {
                (_b2 = getNextElement(document_1.body, _this._dropDown.current, false, false, true, true)) === null || _b2 === void 0 ? void 0 : _b2.focus();
              }
            }
            break;
          default:
            return;
        }
        if (elementToFocus) {
          elementToFocus.focus();
        }
        ev.stopPropagation();
        ev.preventDefault();
      };
      _this._onZoneKeyUp = function(ev) {
        var shouldHandleKey = _this._shouldHandleKeyUp(ev);
        if (shouldHandleKey && _this.state.isOpen) {
          _this.setState({ isOpen: false });
          ev.preventDefault();
        }
      };
      _this._onDropdownClick = function(ev) {
        if (_this.props.onClick) {
          _this.props.onClick(ev);
          if (ev.defaultPrevented) {
            return;
          }
        }
        var isOpen = _this.state.isOpen;
        var disabled = _this._isDisabled();
        if (!disabled && !_this._shouldOpenOnFocus()) {
          _this.setState({
            isOpen: !isOpen
          });
        }
        _this._isFocusedByClick = false;
      };
      _this._onDropdownMouseDown = function() {
        _this._isFocusedByClick = true;
      };
      _this._onFocus = function(ev) {
        var disabled = _this._isDisabled();
        if (!disabled) {
          if (_this.props.onFocus) {
            _this.props.onFocus(ev);
          }
          var state = { hasFocus: true };
          if (_this._shouldOpenOnFocus()) {
            state.isOpen = true;
          }
          _this.setState(state);
        }
      };
      _this._isDisabled = function() {
        var disabled = _this.props.disabled;
        var isDisabled = _this.props.isDisabled;
        if (disabled === void 0) {
          disabled = isDisabled;
        }
        return disabled;
      };
      _this._onRenderLabel = function(props2) {
        var label = props2.label, required = props2.required, disabled = props2.disabled;
        var labelStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.label : void 0;
        return label ? React__namespace.createElement(Label, { className: _this._classNames.label, id: _this._labelId, required, styles: labelStyles, disabled }, label) : null;
      };
      initializeComponentRef(_this);
      var multiSelect = props.multiSelect, selectedKey = props.selectedKey, selectedKeys = props.selectedKeys, defaultSelectedKey = props.defaultSelectedKey, defaultSelectedKeys = props.defaultSelectedKeys, options2 = props.options;
      if (process.env.NODE_ENV !== "production") {
        warnDeprecations(COMPONENT_NAME$2, props, {
          isDisabled: "disabled",
          onChanged: "onChange",
          placeHolder: "placeholder",
          onRenderPlaceHolder: "onRenderPlaceholder"
        });
        warnMutuallyExclusive(COMPONENT_NAME$2, props, {
          defaultSelectedKey: "selectedKey",
          defaultSelectedKeys: "selectedKeys",
          selectedKeys: "selectedKey"
        });
        if (multiSelect) {
          var warnMultiSelect = function(prop) {
            return warn("Dropdown property '" + prop + "' cannot be used when 'multiSelect' is true. Use '" + prop + "s' instead.");
          };
          if (selectedKey !== void 0) {
            warnMultiSelect("selectedKey");
          }
          if (defaultSelectedKey !== void 0) {
            warnMultiSelect("defaultSelectedKey");
          }
        } else {
          var warnNotMultiSelect = function(prop) {
            return warn("Dropdown property '" + prop + "s' cannot be used when 'multiSelect' is false/unset. Use '" + prop + "' instead.");
          };
          if (selectedKeys !== void 0) {
            warnNotMultiSelect("selectedKey");
          }
          if (defaultSelectedKeys !== void 0) {
            warnNotMultiSelect("defaultSelectedKey");
          }
        }
      }
      _this._id = props.id || getId("Dropdown");
      _this._labelId = _this._id + "-label";
      _this._listId = _this._id + "-list";
      _this._optionId = _this._id + "-option";
      _this._isScrollIdle = true;
      _this._hasBeenPositioned = false;
      _this._sizePosCache.updateOptions(options2);
      _this.state = {
        isOpen: false,
        hasFocus: false,
        calloutRenderEdge: void 0
      };
      return _this;
    }
    Object.defineProperty(DropdownInternal2.prototype, "selectedOptions", {
      /**
       * All selected options
       */
      get: function() {
        var _a2 = this.props, options2 = _a2.options, selectedIndices = _a2.hoisted.selectedIndices;
        return getAllSelectedOptions(options2, selectedIndices);
      },
      enumerable: false,
      configurable: true
    });
    DropdownInternal2.prototype.componentWillUnmount = function() {
      clearTimeout(this._scrollIdleTimeoutId);
    };
    DropdownInternal2.prototype.componentDidUpdate = function(prevProps, prevState) {
      if (prevState.isOpen === true && this.state.isOpen === false) {
        this._gotMouseMove = false;
        this._hasBeenPositioned = false;
        if (this.props.onDismiss) {
          this.props.onDismiss();
        }
      }
    };
    DropdownInternal2.prototype.render = function() {
      var id = this._id;
      var props = this.props;
      var className = props.className, label = props.label, options2 = props.options, ariaLabel = props.ariaLabel, required = props.required, errorMessage = props.errorMessage, propStyles = props.styles, theme = props.theme, panelProps = props.panelProps, calloutProps = props.calloutProps, _a2 = props.onRenderTitle, onRenderTitle = _a2 === void 0 ? this._getTitle : _a2, _b2 = props.onRenderContainer, onRenderContainer = _b2 === void 0 ? this._onRenderContainer : _b2, _c2 = props.onRenderCaretDown, onRenderCaretDown = _c2 === void 0 ? this._onRenderCaretDown : _c2, _d2 = props.onRenderLabel, onRenderLabel = _d2 === void 0 ? this._onRenderLabel : _d2, _e2 = props.onRenderItem, onRenderItem = _e2 === void 0 ? this._onRenderItem : _e2, selectedIndices = props.hoisted.selectedIndices;
      var _f = this.state, isOpen = _f.isOpen, calloutRenderEdge = _f.calloutRenderEdge, hasFocus = _f.hasFocus;
      var onRenderPlaceholder = props.onRenderPlaceholder || props.onRenderPlaceHolder || this._getPlaceholder;
      if (options2 !== this._sizePosCache.cachedOptions) {
        this._sizePosCache.updateOptions(options2);
      }
      var selectedOptions = getAllSelectedOptions(options2, selectedIndices);
      var divProps = getNativeProps(props, divProperties);
      var disabled = this._isDisabled();
      var errorMessageId = id + "-errorMessage";
      this._classNames = getClassNames$c(propStyles, {
        theme,
        className,
        hasError: !!(errorMessage && errorMessage.length > 0),
        hasLabel: !!label,
        isOpen,
        required,
        disabled,
        isRenderingPlaceholder: !selectedOptions.length,
        panelClassName: panelProps ? panelProps.className : void 0,
        calloutClassName: calloutProps ? calloutProps.className : void 0,
        calloutRenderEdge
      });
      var hasErrorMessage = !!errorMessage && errorMessage.length > 0;
      return React__namespace.createElement(
        "div",
        { className: this._classNames.root, ref: this.props.hoisted.rootRef, "aria-owns": isOpen ? this._listId : void 0 },
        onRenderLabel(this.props, this._onRenderLabel),
        React__namespace.createElement(
          "div",
          __assign$1({ "data-is-focusable": !disabled, "data-ktp-target": true, ref: this._dropDown, id, tabIndex: disabled ? -1 : 0, role: "combobox", "aria-haspopup": "listbox", "aria-expanded": isOpen ? "true" : "false", "aria-label": ariaLabel, "aria-labelledby": label && !ariaLabel ? mergeAriaAttributeValues(this._labelId, this._optionId) : void 0, "aria-describedby": hasErrorMessage ? this._id + "-errorMessage" : void 0, "aria-required": required, "aria-disabled": disabled, "aria-controls": isOpen ? this._listId : void 0 }, divProps, { className: this._classNames.dropdown, onBlur: this._onDropdownBlur, onKeyDown: this._onDropdownKeyDown, onKeyUp: this._onDropdownKeyUp, onClick: this._onDropdownClick, onMouseDown: this._onDropdownMouseDown, onFocus: this._onFocus }),
          React__namespace.createElement(
            "span",
            { id: this._optionId, className: this._classNames.title, "aria-live": hasFocus ? "polite" : void 0, "aria-atomic": hasFocus ? true : void 0, "aria-invalid": hasErrorMessage },
            // If option is selected render title, otherwise render the placeholder text
            selectedOptions.length ? onRenderTitle(selectedOptions, this._onRenderTitle) : onRenderPlaceholder(props, this._onRenderPlaceholder)
          ),
          React__namespace.createElement("span", { className: this._classNames.caretDownWrapper }, onRenderCaretDown(props, this._onRenderCaretDown))
        ),
        isOpen && onRenderContainer(__assign$1(__assign$1({}, props), { onDismiss: this._onDismiss, onRenderItem }), this._onRenderContainer),
        hasErrorMessage && React__namespace.createElement("div", { role: "alert", id: errorMessageId, className: this._classNames.errorMessage }, errorMessage)
      );
    };
    DropdownInternal2.prototype.focus = function(shouldOpenOnFocus) {
      if (this._dropDown.current) {
        this._dropDown.current.focus();
        if (shouldOpenOnFocus) {
          this.setState({
            isOpen: true
          });
        }
      }
    };
    DropdownInternal2.prototype.setSelectedIndex = function(event, index2) {
      var _a2 = this.props, options2 = _a2.options, selectedKey = _a2.selectedKey, selectedKeys = _a2.selectedKeys, multiSelect = _a2.multiSelect, notifyOnReselect = _a2.notifyOnReselect, _b2 = _a2.hoisted.selectedIndices, selectedIndices = _b2 === void 0 ? [] : _b2;
      var checked = selectedIndices ? selectedIndices.indexOf(index2) > -1 : false;
      var newIndexes = [];
      index2 = Math.max(0, Math.min(options2.length - 1, index2));
      if (selectedKey !== void 0 || selectedKeys !== void 0) {
        this._onChange(event, options2, index2, checked, multiSelect);
        return;
      }
      if (!multiSelect && !notifyOnReselect && index2 === selectedIndices[0]) {
        return;
      } else if (multiSelect) {
        newIndexes = selectedIndices ? this._copyArray(selectedIndices) : [];
        if (checked) {
          var position2 = newIndexes.indexOf(index2);
          if (position2 > -1) {
            newIndexes.splice(position2, 1);
          }
        } else {
          newIndexes.push(index2);
        }
      } else {
        newIndexes = [index2];
      }
      event.persist();
      this.props.hoisted.setSelectedIndices(newIndexes);
      this._onChange(event, options2, index2, checked, multiSelect);
    };
    DropdownInternal2.prototype._copyArray = function(array) {
      var newArray = [];
      for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var element = array_1[_i];
        newArray.push(element);
      }
      return newArray;
    };
    DropdownInternal2.prototype._moveIndex = function(event, stepValue, index2, selectedIndex) {
      var options2 = this.props.options;
      if (selectedIndex === index2 || options2.length === 0) {
        return selectedIndex;
      }
      if (index2 >= options2.length) {
        index2 = 0;
      } else if (index2 < 0) {
        index2 = options2.length - 1;
      }
      var stepCounter = 0;
      while (options2[index2].itemType === SelectableOptionMenuItemType.Header || options2[index2].itemType === SelectableOptionMenuItemType.Divider || options2[index2].disabled) {
        if (stepCounter >= options2.length) {
          return selectedIndex;
        }
        if (index2 + stepValue < 0) {
          index2 = options2.length;
        } else if (index2 + stepValue >= options2.length) {
          index2 = -1;
        }
        index2 = index2 + stepValue;
        stepCounter++;
      }
      this.setSelectedIndex(event, index2);
      return index2;
    };
    DropdownInternal2.prototype._renderFocusableList = function(props) {
      var _a2 = props.onRenderList, onRenderList = _a2 === void 0 ? this._onRenderList : _a2, label = props.label, ariaLabel = props.ariaLabel, multiSelect = props.multiSelect;
      return React__namespace.createElement(
        "div",
        { className: this._classNames.dropdownItemsWrapper, onKeyDown: this._onZoneKeyDown, onKeyUp: this._onZoneKeyUp, ref: this._host, tabIndex: 0 },
        React__namespace.createElement(FocusZone, { ref: this._focusZone, direction: FocusZoneDirection.vertical, id: this._listId, className: this._classNames.dropdownItems, role: "listbox", "aria-label": ariaLabel, "aria-labelledby": label && !ariaLabel ? this._labelId : void 0, "aria-multiselectable": multiSelect }, onRenderList(props, this._onRenderList))
      );
    };
    DropdownInternal2.prototype._renderSeparator = function(item) {
      var index2 = item.index, key = item.key;
      var separatorClassName = item.hidden ? this._classNames.dropdownDividerHidden : this._classNames.dropdownDivider;
      if (index2 > 0) {
        return React__namespace.createElement("div", { role: "separator", key, className: separatorClassName });
      }
      return null;
    };
    DropdownInternal2.prototype._renderHeader = function(item) {
      var _a2 = this.props.onRenderOption, onRenderOption = _a2 === void 0 ? this._onRenderOption : _a2;
      var key = item.key, id = item.id;
      var headerClassName = item.hidden ? this._classNames.dropdownItemHeaderHidden : this._classNames.dropdownItemHeader;
      return React__namespace.createElement("div", { id, key, className: headerClassName }, onRenderOption(item, this._onRenderOption));
    };
    DropdownInternal2.prototype._onItemMouseEnter = function(item, ev) {
      if (this._shouldIgnoreMouseEvent()) {
        return;
      }
      var targetElement = ev.currentTarget;
      targetElement.focus();
    };
    DropdownInternal2.prototype._onItemMouseMove = function(item, ev) {
      var targetElement = ev.currentTarget;
      this._gotMouseMove = true;
      if (!this._isScrollIdle || document.activeElement === targetElement) {
        return;
      }
      targetElement.focus();
    };
    DropdownInternal2.prototype._shouldIgnoreMouseEvent = function() {
      return !this._isScrollIdle || !this._gotMouseMove;
    };
    DropdownInternal2.prototype._isAltOrMeta = function(ev) {
      return ev.which === KeyCodes.alt || ev.key === "Meta";
    };
    DropdownInternal2.prototype._shouldHandleKeyUp = function(ev) {
      var keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);
      this._lastKeyDownWasAltOrMeta = false;
      return !!keyPressIsAltOrMetaAlone && !(isMac() || isIOS());
    };
    DropdownInternal2.prototype._shouldOpenOnFocus = function() {
      var hasFocus = this.state.hasFocus;
      var openOnKeyboardFocus = this.props.openOnKeyboardFocus;
      return !this._isFocusedByClick && openOnKeyboardFocus === true && !hasFocus;
    };
    DropdownInternal2.defaultProps = {
      options: []
    };
    return DropdownInternal2;
  }(React__namespace.Component)
);
var _a$2, _b$1, _c$1;
var GlobalClassNames$b = {
  root: "ms-Dropdown-container",
  label: "ms-Dropdown-label",
  dropdown: "ms-Dropdown",
  title: "ms-Dropdown-title",
  caretDownWrapper: "ms-Dropdown-caretDownWrapper",
  caretDown: "ms-Dropdown-caretDown",
  callout: "ms-Dropdown-callout",
  panel: "ms-Dropdown-panel",
  dropdownItems: "ms-Dropdown-items",
  dropdownItem: "ms-Dropdown-item",
  dropdownDivider: "ms-Dropdown-divider",
  dropdownOptionText: "ms-Dropdown-optionText",
  dropdownItemHeader: "ms-Dropdown-header",
  titleIsPlaceHolder: "ms-Dropdown-titleIsPlaceHolder",
  titleHasError: "ms-Dropdown-title--hasError"
};
var DROPDOWN_HEIGHT = 32;
var DROPDOWN_ITEM_HEIGHT = 36;
var highContrastAdjustMixin = (_a$2 = {}, _a$2[HighContrastSelector + ", " + HighContrastSelectorWhite.replace("@media ", "")] = __assign$1({}, getHighContrastNoAdjustStyle()), _a$2);
var highContrastItemAndTitleStateMixin = {
  selectors: __assign$1((_b$1 = {}, _b$1[HighContrastSelector] = {
    backgroundColor: "Highlight",
    borderColor: "Highlight",
    color: "HighlightText"
  }, _b$1), highContrastAdjustMixin)
};
var highContrastBorderState = {
  selectors: (_c$1 = {}, _c$1[HighContrastSelector] = {
    borderColor: "Highlight"
  }, _c$1)
};
var MinimumScreenSelector = getScreenSelector(0, ScreenWidthMinMedium);
var getStyles$c = function(props) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l, _m;
  var theme = props.theme, hasError = props.hasError, hasLabel = props.hasLabel, className = props.className, isOpen = props.isOpen, disabled = props.disabled, required = props.required, isRenderingPlaceholder = props.isRenderingPlaceholder, panelClassName = props.panelClassName, calloutClassName = props.calloutClassName, calloutRenderEdge = props.calloutRenderEdge;
  if (!theme) {
    throw new Error("theme is undefined or null in base Dropdown getStyles function.");
  }
  var globalClassnames = getGlobalClassNames(GlobalClassNames$b, theme);
  var palette = theme.palette, semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
  var rootHoverFocusActiveSelectorNeutralDarkMixin = {
    color: semanticColors.menuItemTextHovered
  };
  var rootHoverFocusActiveSelectorNeutralPrimaryMixin = {
    color: semanticColors.menuItemText
  };
  var borderColorError = {
    borderColor: semanticColors.errorText
  };
  var dropdownItemStyle = [
    globalClassnames.dropdownItem,
    {
      backgroundColor: "transparent",
      boxSizing: "border-box",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      padding: "0 8px",
      width: "100%",
      minHeight: DROPDOWN_ITEM_HEIGHT,
      lineHeight: 20,
      height: 0,
      position: "relative",
      border: "1px solid transparent",
      borderRadius: 0,
      wordWrap: "break-word",
      overflowWrap: "break-word",
      textAlign: "left",
      ".ms-Button-flexContainer": {
        width: "100%"
      }
    }
  ];
  var dropdownHeaderStyle = [
    globalClassnames.dropdownItemHeader,
    __assign$1(__assign$1({}, fonts.medium), { fontWeight: FontWeights.semibold, color: semanticColors.menuHeader, background: "none", backgroundColor: "transparent", border: "none", height: DROPDOWN_ITEM_HEIGHT, lineHeight: DROPDOWN_ITEM_HEIGHT, cursor: "default", padding: "0 8px", userSelect: "none", textAlign: "left", selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign$1({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _a2) })
  ];
  var selectedItemBackgroundColor = semanticColors.menuItemBackgroundPressed;
  var itemSelectors = function(isSelected) {
    var _a3, _b3;
    if (isSelected === void 0) {
      isSelected = false;
    }
    return {
      selectors: (_a3 = {
        "&:hover": [
          {
            color: semanticColors.menuItemTextHovered,
            backgroundColor: !isSelected ? semanticColors.menuItemBackgroundHovered : selectedItemBackgroundColor
          },
          highContrastItemAndTitleStateMixin
        ],
        "&.is-multi-select:hover": [{ backgroundColor: !isSelected ? "transparent" : selectedItemBackgroundColor }],
        "&:active:hover": [
          {
            color: semanticColors.menuItemTextHovered,
            backgroundColor: !isSelected ? semanticColors.menuItemBackgroundPressed : semanticColors.menuItemBackgroundHovered
          },
          highContrastItemAndTitleStateMixin
        ]
      }, _a3["." + IsFocusVisibleClassName + " &:focus:after"] = (_b3 = {
        left: 0,
        top: 0,
        bottom: 0,
        right: 0
      }, _b3[HighContrastSelector] = {
        inset: "2px"
      }, _b3), _a3[HighContrastSelector] = {
        border: "none"
      }, _a3)
    };
  };
  var dropdownItemSelected = __spreadArray(__spreadArray([], dropdownItemStyle), [
    {
      backgroundColor: selectedItemBackgroundColor,
      color: semanticColors.menuItemTextHovered
    },
    itemSelectors(true),
    highContrastItemAndTitleStateMixin
  ]);
  var dropdownItemDisabled = __spreadArray(__spreadArray([], dropdownItemStyle), [
    {
      color: semanticColors.disabledText,
      cursor: "default",
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        color: "GrayText",
        border: "none"
      }, _b2)
    }
  ]);
  var titleOpenBorderRadius = calloutRenderEdge === RectangleEdge.bottom ? effects.roundedCorner2 + " " + effects.roundedCorner2 + " 0 0" : "0 0 " + effects.roundedCorner2 + " " + effects.roundedCorner2;
  var calloutOpenBorderRadius = calloutRenderEdge === RectangleEdge.bottom ? "0 0 " + effects.roundedCorner2 + " " + effects.roundedCorner2 : effects.roundedCorner2 + " " + effects.roundedCorner2 + " 0 0";
  return {
    root: [globalClassnames.root, className],
    label: globalClassnames.label,
    dropdown: [
      globalClassnames.dropdown,
      normalize,
      fonts.medium,
      {
        color: semanticColors.menuItemText,
        borderColor: semanticColors.focusBorder,
        position: "relative",
        outline: 0,
        userSelect: "none",
        selectors: (_c2 = {}, _c2["&:hover ." + globalClassnames.title] = [
          !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
          { borderColor: isOpen ? palette.neutralSecondary : palette.neutralPrimary },
          highContrastBorderState
        ], _c2["&:focus ." + globalClassnames.title] = [
          !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
          { selectors: (_d2 = {}, _d2[HighContrastSelector] = { color: "Highlight" }, _d2) }
        ], _c2["&:focus:after"] = [
          {
            pointerEvents: "none",
            content: "''",
            position: "absolute",
            boxSizing: "border-box",
            top: "0px",
            left: "0px",
            width: "100%",
            height: "100%",
            // see https://github.com/microsoft/fluentui/pull/9182 for semantic color disc
            border: !disabled ? "2px solid " + palette.themePrimary : "none",
            borderRadius: "2px",
            selectors: (_e2 = {}, _e2[HighContrastSelector] = {
              color: "Highlight"
            }, _e2)
          }
        ], _c2["&:active ." + globalClassnames.title] = [
          !disabled && rootHoverFocusActiveSelectorNeutralDarkMixin,
          { borderColor: palette.themePrimary },
          highContrastBorderState
        ], _c2["&:hover ." + globalClassnames.caretDown] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c2["&:focus ." + globalClassnames.caretDown] = [
          !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin,
          { selectors: (_f = {}, _f[HighContrastSelector] = { color: "Highlight" }, _f) }
        ], _c2["&:active ." + globalClassnames.caretDown] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c2["&:hover ." + globalClassnames.titleIsPlaceHolder] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c2["&:focus ." + globalClassnames.titleIsPlaceHolder] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c2["&:active ." + globalClassnames.titleIsPlaceHolder] = !disabled && rootHoverFocusActiveSelectorNeutralPrimaryMixin, _c2["&:hover ." + globalClassnames.titleHasError] = borderColorError, _c2["&:active ." + globalClassnames.titleHasError] = borderColorError, _c2)
      },
      isOpen && "is-open",
      disabled && "is-disabled",
      required && "is-required",
      required && !hasLabel && {
        selectors: (_g = {
          ":before": {
            content: "'*'",
            color: semanticColors.errorText,
            position: "absolute",
            top: -5,
            right: -10
          }
        }, _g[HighContrastSelector] = {
          selectors: {
            ":after": {
              right: -14
              // moving the * 4 pixel to right to alleviate border clipping in HC mode.
            }
          }
        }, _g)
      }
    ],
    title: [
      globalClassnames.title,
      normalize,
      {
        backgroundColor: semanticColors.inputBackground,
        borderWidth: 1,
        borderStyle: "solid",
        borderColor: semanticColors.inputBorder,
        borderRadius: isOpen ? titleOpenBorderRadius : effects.roundedCorner2,
        cursor: "pointer",
        display: "block",
        height: DROPDOWN_HEIGHT,
        lineHeight: DROPDOWN_HEIGHT - 2,
        padding: "0 28px 0 8px",
        position: "relative",
        overflow: "hidden",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis"
      },
      isRenderingPlaceholder && [globalClassnames.titleIsPlaceHolder, { color: semanticColors.inputPlaceholderText }],
      hasError && [globalClassnames.titleHasError, borderColorError],
      disabled && {
        backgroundColor: semanticColors.disabledBackground,
        border: "none",
        color: semanticColors.disabledText,
        cursor: "default",
        selectors: (_h = {}, _h[HighContrastSelector] = __assign$1({ border: "1px solid GrayText", color: "GrayText", backgroundColor: "Window" }, getHighContrastNoAdjustStyle()), _h)
      }
    ],
    caretDownWrapper: [
      globalClassnames.caretDownWrapper,
      {
        height: DROPDOWN_HEIGHT,
        lineHeight: DROPDOWN_HEIGHT - 2,
        paddingTop: 1,
        position: "absolute",
        right: 8,
        top: 0
      },
      !disabled && {
        cursor: "pointer"
      }
    ],
    caretDown: [
      globalClassnames.caretDown,
      { color: palette.neutralSecondary, fontSize: fonts.small.fontSize, pointerEvents: "none" },
      disabled && {
        color: semanticColors.disabledText,
        selectors: (_j = {}, _j[HighContrastSelector] = __assign$1({ color: "GrayText" }, getHighContrastNoAdjustStyle()), _j)
      }
    ],
    errorMessage: __assign$1(__assign$1({ color: semanticColors.errorText }, theme.fonts.small), { paddingTop: 5 }),
    callout: [
      globalClassnames.callout,
      {
        boxShadow: effects.elevation8,
        borderRadius: calloutOpenBorderRadius,
        selectors: (_k = {}, _k[".ms-Callout-main"] = { borderRadius: calloutOpenBorderRadius }, _k)
      },
      calloutClassName
    ],
    dropdownItemsWrapper: { selectors: { "&:focus": { outline: 0 } } },
    dropdownItems: [globalClassnames.dropdownItems, { display: "block" }],
    dropdownItem: __spreadArray(__spreadArray([], dropdownItemStyle), [itemSelectors()]),
    dropdownItemSelected,
    dropdownItemDisabled,
    dropdownItemSelectedAndDisabled: [dropdownItemSelected, dropdownItemDisabled, { backgroundColor: "transparent" }],
    dropdownItemHidden: __spreadArray(__spreadArray([], dropdownItemStyle), [{ display: "none" }]),
    dropdownDivider: [globalClassnames.dropdownDivider, { height: 1, backgroundColor: semanticColors.bodyDivider }],
    dropdownDividerHidden: [globalClassnames.dropdownDivider, { display: "none" }],
    dropdownOptionText: [
      globalClassnames.dropdownOptionText,
      {
        overflow: "hidden",
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        minWidth: 0,
        maxWidth: "100%",
        wordWrap: "break-word",
        overflowWrap: "break-word",
        margin: "1px"
      }
    ],
    dropdownItemHeader: dropdownHeaderStyle,
    dropdownItemHeaderHidden: __spreadArray(__spreadArray([], dropdownHeaderStyle), [{ display: "none" }]),
    subComponentStyles: {
      label: { root: { display: "inline-block" } },
      multiSelectItem: {
        root: {
          padding: 0
        },
        label: {
          alignSelf: "stretch",
          padding: "0 8px",
          width: "100%"
        },
        input: {
          selectors: (_l = {}, _l["." + IsFocusVisibleClassName + " &:focus + label::before"] = {
            outlineOffset: "0px"
          }, _l)
        }
      },
      panel: {
        root: [panelClassName],
        main: {
          selectors: (_m = {}, // In case of extra small screen sizes
          _m[MinimumScreenSelector] = {
            // panelWidth xs
            width: 272
          }, _m)
        },
        contentInner: { padding: "0 0 20px" }
      }
    }
  };
};
var Dropdown = styled(DropdownBase, getStyles$c, void 0, {
  scope: "Dropdown"
});
Dropdown.displayName = "Dropdown";
var SuggestionActionType;
(function(SuggestionActionType2) {
  SuggestionActionType2[SuggestionActionType2["none"] = 0] = "none";
  SuggestionActionType2[SuggestionActionType2["forceResolve"] = 1] = "forceResolve";
  SuggestionActionType2[SuggestionActionType2["searchMore"] = 2] = "searchMore";
})(SuggestionActionType || (SuggestionActionType = {}));
loadStyles([{ "rawString": ".root_8c91000a{min-width:260px}.suggestionsItem_8c91000a{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-sizing:border-box;box-sizing:border-box;width:100%;position:relative;overflow:hidden}.suggestionsItem_8c91000a:hover{background:" }, { "theme": "neutralLighter", "defaultValue": "#f3f2f1" }, { "rawString": "}.suggestionsItem_8c91000a:hover .closeButton_8c91000a{display:block}.suggestionsItem_8c91000a.suggestionsItemIsSuggested_8c91000a{background:" }, { "theme": "neutralLight", "defaultValue": "#edebe9" }, { "rawString": "}.suggestionsItem_8c91000a.suggestionsItemIsSuggested_8c91000a:hover{background:" }, { "theme": "neutralTertiaryAlt", "defaultValue": "#c8c6c4" }, { "rawString": "}@media screen and (-ms-high-contrast:active),screen and (forced-colors:active){.suggestionsItem_8c91000a.suggestionsItemIsSuggested_8c91000a:hover{background:Highlight;color:HighlightText}}@media screen and (-ms-high-contrast:active),screen and (forced-colors:active){.suggestionsItem_8c91000a.suggestionsItemIsSuggested_8c91000a{background:Highlight;color:HighlightText;-ms-high-contrast-adjust:none}}.suggestionsItem_8c91000a.suggestionsItemIsSuggested_8c91000a .closeButton_8c91000a:hover{background:" }, { "theme": "neutralTertiary", "defaultValue": "#a19f9d" }, { "rawString": ";color:" }, { "theme": "neutralPrimary", "defaultValue": "#323130" }, { "rawString": "}@media screen and (-ms-high-contrast:active),screen and (forced-colors:active){.suggestionsItem_8c91000a.suggestionsItemIsSuggested_8c91000a .itemButton_8c91000a{color:HighlightText}}.suggestionsItem_8c91000a .closeButton_8c91000a{display:none;color:" }, { "theme": "neutralSecondary", "defaultValue": "#605e5c" }, { "rawString": "}.suggestionsItem_8c91000a .closeButton_8c91000a:hover{background:" }, { "theme": "neutralLight", "defaultValue": "#edebe9" }, { "rawString": "}.actionButton_8c91000a{background-color:transparent;border:0;cursor:pointer;margin:0;position:relative;border-top:1px solid " }, { "theme": "neutralLight", "defaultValue": "#edebe9" }, { "rawString": ";height:40px;width:100%;font-size:12px}[dir=ltr] .actionButton_8c91000a{padding-left:8px}[dir=rtl] .actionButton_8c91000a{padding-right:8px}html[dir=ltr] .actionButton_8c91000a{text-align:left}html[dir=rtl] .actionButton_8c91000a{text-align:right}.actionButton_8c91000a:hover{background-color:" }, { "theme": "neutralLight", "defaultValue": "#edebe9" }, { "rawString": ";cursor:pointer}.actionButton_8c91000a:active,.actionButton_8c91000a:focus{background-color:" }, { "theme": "themeLight", "defaultValue": "#c7e0f4" }, { "rawString": "}.actionButton_8c91000a .ms-Button-icon{font-size:16px;width:25px}.actionButton_8c91000a .ms-Button-label{margin:0 4px 0 9px}html[dir=rtl] .actionButton_8c91000a .ms-Button-label{margin:0 9px 0 4px}.buttonSelected_8c91000a{background-color:" }, { "theme": "themeLight", "defaultValue": "#c7e0f4" }, { "rawString": "}.suggestionsTitle_8c91000a{padding:0 12px;color:" }, { "theme": "themePrimary", "defaultValue": "#0078d4" }, { "rawString": ";font-size:12px;line-height:40px;border-bottom:1px solid " }, { "theme": "neutralLight", "defaultValue": "#edebe9" }, { "rawString": "}.suggestionsContainer_8c91000a{overflow-y:auto;overflow-x:hidden;max-height:300px;border-bottom:1px solid " }, { "theme": "neutralLight", "defaultValue": "#edebe9" }, { "rawString": "}.suggestionsNone_8c91000a{text-align:center;color:#797775;font-size:12px;line-height:30px}.suggestionsSpinner_8c91000a{margin:5px 0;white-space:nowrap;line-height:20px;font-size:12px}html[dir=ltr] .suggestionsSpinner_8c91000a{padding-left:14px}html[dir=rtl] .suggestionsSpinner_8c91000a{padding-right:14px}html[dir=ltr] .suggestionsSpinner_8c91000a{text-align:left}html[dir=rtl] .suggestionsSpinner_8c91000a{text-align:right}.suggestionsSpinner_8c91000a .ms-Spinner-circle{display:inline-block;vertical-align:middle}.suggestionsSpinner_8c91000a .ms-Spinner-label{display:inline-block;margin:0 10px 0 16px;vertical-align:middle}html[dir=rtl] .suggestionsSpinner_8c91000a .ms-Spinner-label{margin:0 16px 0 10px}.itemButton_8c91000a.itemButton_8c91000a{width:100%;padding:0;min-width:0;height:100%}@media screen and (-ms-high-contrast:active),screen and (forced-colors:active){.itemButton_8c91000a.itemButton_8c91000a{color:WindowText}}.itemButton_8c91000a.itemButton_8c91000a:hover{color:" }, { "theme": "neutralDark", "defaultValue": "#201f1e" }, { "rawString": "}.closeButton_8c91000a.closeButton_8c91000a{padding:0 4px;height:auto;width:32px}@media screen and (-ms-high-contrast:active),screen and (forced-colors:active){.closeButton_8c91000a.closeButton_8c91000a{color:WindowText}}.closeButton_8c91000a.closeButton_8c91000a:hover{background:" }, { "theme": "neutralTertiaryAlt", "defaultValue": "#c8c6c4" }, { "rawString": ";color:" }, { "theme": "neutralDark", "defaultValue": "#201f1e" }, { "rawString": "}.suggestionsAvailable_8c91000a{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}" }]);
var root = "root_8c91000a";
var suggestionsItem = "suggestionsItem_8c91000a";
var closeButton = "closeButton_8c91000a";
var suggestionsItemIsSuggested = "suggestionsItemIsSuggested_8c91000a";
var itemButton = "itemButton_8c91000a";
var actionButton = "actionButton_8c91000a";
var buttonSelected = "buttonSelected_8c91000a";
var suggestionsTitle = "suggestionsTitle_8c91000a";
var suggestionsContainer = "suggestionsContainer_8c91000a";
var suggestionsNone = "suggestionsNone_8c91000a";
var suggestionsSpinner = "suggestionsSpinner_8c91000a";
var suggestionsAvailable = "suggestionsAvailable_8c91000a";
const stylesImport$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  actionButton,
  buttonSelected,
  closeButton,
  itemButton,
  root,
  suggestionsAvailable,
  suggestionsContainer,
  suggestionsItem,
  suggestionsItemIsSuggested,
  suggestionsNone,
  suggestionsSpinner,
  suggestionsTitle
}, Symbol.toStringTag, { value: "Module" }));
var legacyStyles$2 = stylesImport$1;
var getClassNames$b = classNamesFunction();
var SuggestionsItem = (
  /** @class */
  function(_super) {
    __extends(SuggestionsItem2, _super);
    function SuggestionsItem2(props) {
      var _this = _super.call(this, props) || this;
      initializeComponentRef(_this);
      return _this;
    }
    SuggestionsItem2.prototype.render = function() {
      var _a2;
      var _b2 = this.props, suggestionModel = _b2.suggestionModel, RenderSuggestion = _b2.RenderSuggestion, onClick = _b2.onClick, className = _b2.className, id = _b2.id, onRemoveItem = _b2.onRemoveItem, isSelectedOverride = _b2.isSelectedOverride, removeButtonAriaLabel = _b2.removeButtonAriaLabel, styles2 = _b2.styles, theme = _b2.theme, removeButtonIconProps = _b2.removeButtonIconProps;
      var classNames2 = styles2 ? getClassNames$b(styles2, {
        theme,
        className,
        suggested: suggestionModel.selected || isSelectedOverride
      }) : {
        root: css$3("ms-Suggestions-item", legacyStyles$2.suggestionsItem, (_a2 = {}, _a2["is-suggested " + legacyStyles$2.suggestionsItemIsSuggested] = suggestionModel.selected || isSelectedOverride, _a2), className),
        itemButton: css$3("ms-Suggestions-itemButton", legacyStyles$2.itemButton),
        closeButton: css$3("ms-Suggestions-closeButton", legacyStyles$2.closeButton)
      };
      return React__namespace.createElement(
        "div",
        { className: classNames2.root, role: "presentation" },
        React__namespace.createElement(CommandButton, { onClick, className: classNames2.itemButton, id, "aria-selected": suggestionModel.selected, role: "option", "aria-label": suggestionModel.ariaLabel }, RenderSuggestion(suggestionModel.item, this.props)),
        this.props.showRemoveButton ? React__namespace.createElement(IconButton, { iconProps: removeButtonIconProps !== null && removeButtonIconProps !== void 0 ? removeButtonIconProps : { iconName: "Cancel" }, styles: { icon: { fontSize: "12px" } }, title: removeButtonAriaLabel, ariaLabel: removeButtonAriaLabel, onClick: onRemoveItem, className: classNames2.closeButton }) : null
      );
    };
    return SuggestionsItem2;
  }(React__namespace.Component)
);
var SuggestionsItemGlobalClassNames = {
  root: "ms-Suggestions-item",
  itemButton: "ms-Suggestions-itemButton",
  closeButton: "ms-Suggestions-closeButton",
  isSuggested: "is-suggested"
};
function getStyles$b(props) {
  var _a2, _b2, _c2, _d2, _e2, _f;
  var className = props.className, theme = props.theme, suggested = props.suggested;
  var palette = theme.palette, semanticColors = theme.semanticColors;
  var classNames2 = getGlobalClassNames(SuggestionsItemGlobalClassNames, theme);
  return {
    root: [
      classNames2.root,
      {
        display: "flex",
        alignItems: "stretch",
        boxSizing: "border-box",
        width: "100%",
        position: "relative",
        selectors: {
          "&:hover": {
            background: semanticColors.menuItemBackgroundHovered
          },
          "&:hover .ms-Suggestions-closeButton": {
            display: "block"
          }
        }
      },
      suggested && {
        selectors: (_a2 = {}, _a2["." + IsFocusVisibleClassName + " &"] = {
          selectors: (_b2 = {}, _b2["." + classNames2.closeButton] = {
            display: "block",
            background: semanticColors.menuItemBackgroundPressed
          }, _b2)
        }, _a2[":after"] = {
          pointerEvents: "none",
          content: '""',
          position: "absolute",
          left: 0,
          top: 0,
          bottom: 0,
          right: 0,
          border: "1px solid " + theme.semanticColors.focusBorder
        }, _a2)
      },
      className
    ],
    itemButton: [
      classNames2.itemButton,
      {
        width: "100%",
        padding: 0,
        border: "none",
        height: "100%",
        // Force the item button to be collapsible so it can always shrink
        // to accommodate the close button as a peer in its flex container.
        minWidth: 0,
        // Require for IE11 to truncate the component.
        overflow: "hidden",
        selectors: (_c2 = {}, _c2[HighContrastSelector] = {
          color: "WindowText",
          selectors: {
            ":hover": __assign$1({ background: "Highlight", color: "HighlightText" }, getHighContrastNoAdjustStyle())
          }
        }, _c2[":hover"] = {
          color: semanticColors.menuItemTextHovered
        }, _c2)
      },
      suggested && [
        classNames2.isSuggested,
        {
          background: semanticColors.menuItemBackgroundPressed,
          selectors: (_d2 = {
            ":hover": {
              background: semanticColors.menuDivider
            }
          }, _d2[HighContrastSelector] = __assign$1({ background: "Highlight", color: "HighlightText" }, getHighContrastNoAdjustStyle()), _d2)
        }
      ]
    ],
    closeButton: [
      classNames2.closeButton,
      {
        display: "none",
        color: palette.neutralSecondary,
        padding: "0 4px",
        height: "auto",
        width: 32,
        selectors: (_e2 = {
          ":hover, :active": {
            background: palette.neutralTertiaryAlt,
            color: palette.neutralDark
          }
        }, _e2[HighContrastSelector] = {
          color: "WindowText"
        }, _e2)
      },
      suggested && (_f = {}, _f["." + IsFocusVisibleClassName + " &"] = {
        selectors: {
          ":hover, :active": {
            background: palette.neutralTertiary
          }
        }
      }, _f.selectors = {
        ":hover, :active": {
          background: palette.neutralTertiary,
          color: palette.neutralPrimary
        }
      }, _f)
    ]
  };
}
var legacyStyles$1 = stylesImport$1;
var getClassNames$a = classNamesFunction();
var StyledSuggestionsItem = styled(SuggestionsItem, getStyles$b, void 0, {
  scope: "SuggestionItem"
});
var Suggestions = (
  /** @class */
  function(_super) {
    __extends(Suggestions2, _super);
    function Suggestions2(suggestionsProps) {
      var _this = _super.call(this, suggestionsProps) || this;
      _this._forceResolveButton = React__namespace.createRef();
      _this._searchForMoreButton = React__namespace.createRef();
      _this._selectedElement = React__namespace.createRef();
      _this._scrollContainer = React__namespace.createRef();
      _this.tryHandleKeyDown = function(keyCode, currentSuggestionIndex) {
        var isEventHandled = false;
        var newSelectedActionType = null;
        var currentSelectedAction = _this.state.selectedActionType;
        var suggestionLength = _this.props.suggestions.length;
        if (keyCode === KeyCodes.down) {
          switch (currentSelectedAction) {
            case SuggestionActionType.forceResolve:
              if (suggestionLength > 0) {
                _this._refocusOnSuggestions(keyCode);
                newSelectedActionType = SuggestionActionType.none;
              } else if (_this._searchForMoreButton.current) {
                newSelectedActionType = SuggestionActionType.searchMore;
              } else {
                newSelectedActionType = SuggestionActionType.forceResolve;
              }
              break;
            case SuggestionActionType.searchMore:
              if (_this._forceResolveButton.current) {
                newSelectedActionType = SuggestionActionType.forceResolve;
              } else if (suggestionLength > 0) {
                _this._refocusOnSuggestions(keyCode);
                newSelectedActionType = SuggestionActionType.none;
              } else {
                newSelectedActionType = SuggestionActionType.searchMore;
              }
              break;
            case SuggestionActionType.none:
              if (currentSuggestionIndex === -1 && _this._forceResolveButton.current) {
                newSelectedActionType = SuggestionActionType.forceResolve;
              }
              break;
          }
        } else if (keyCode === KeyCodes.up) {
          switch (currentSelectedAction) {
            case SuggestionActionType.forceResolve:
              if (_this._searchForMoreButton.current) {
                newSelectedActionType = SuggestionActionType.searchMore;
              } else if (suggestionLength > 0) {
                _this._refocusOnSuggestions(keyCode);
                newSelectedActionType = SuggestionActionType.none;
              }
              break;
            case SuggestionActionType.searchMore:
              if (suggestionLength > 0) {
                _this._refocusOnSuggestions(keyCode);
                newSelectedActionType = SuggestionActionType.none;
              } else if (_this._forceResolveButton.current) {
                newSelectedActionType = SuggestionActionType.forceResolve;
              }
              break;
            case SuggestionActionType.none:
              if (currentSuggestionIndex === -1 && _this._searchForMoreButton.current) {
                newSelectedActionType = SuggestionActionType.searchMore;
              }
              break;
          }
        }
        if (newSelectedActionType !== null) {
          _this.setState({ selectedActionType: newSelectedActionType });
          isEventHandled = true;
        }
        return isEventHandled;
      };
      _this._getAlertText = function() {
        var _a2 = _this.props, isLoading = _a2.isLoading, isSearching = _a2.isSearching, suggestions = _a2.suggestions, suggestionsAvailableAlertText = _a2.suggestionsAvailableAlertText, noResultsFoundText = _a2.noResultsFoundText, isExtendedLoading = _a2.isExtendedLoading, loadingText = _a2.loadingText;
        if (!isLoading && !isSearching) {
          if (suggestions.length > 0) {
            return suggestionsAvailableAlertText || "";
          }
          if (noResultsFoundText) {
            return noResultsFoundText;
          }
        } else if (isLoading && isExtendedLoading) {
          return loadingText || "";
        }
        return "";
      };
      _this._getMoreResults = function() {
        if (_this.props.onGetMoreResults) {
          _this.props.onGetMoreResults();
          _this.setState({ selectedActionType: SuggestionActionType.none });
        }
      };
      _this._forceResolve = function() {
        if (_this.props.createGenericItem) {
          _this.props.createGenericItem();
        }
      };
      _this._shouldShowForceResolve = function() {
        return _this.props.showForceResolve ? _this.props.showForceResolve() : false;
      };
      _this._onClickTypedSuggestionsItem = function(item, index2) {
        return function(ev) {
          _this.props.onSuggestionClick(ev, item, index2);
        };
      };
      _this._refocusOnSuggestions = function(keyCode) {
        if (typeof _this.props.refocusSuggestions === "function") {
          _this.props.refocusSuggestions(keyCode);
        }
      };
      _this._onRemoveTypedSuggestionsItem = function(item, index2) {
        return function(ev) {
          var onSuggestionRemove = _this.props.onSuggestionRemove;
          onSuggestionRemove(ev, item, index2);
          ev.stopPropagation();
        };
      };
      initializeComponentRef(_this);
      _this.state = {
        selectedActionType: SuggestionActionType.none
      };
      return _this;
    }
    Suggestions2.prototype.componentDidMount = function() {
      this.scrollSelected();
      this.activeSelectedElement = this._selectedElement ? this._selectedElement.current : null;
    };
    Suggestions2.prototype.componentDidUpdate = function() {
      if (this._selectedElement.current && this.activeSelectedElement !== this._selectedElement.current) {
        this.scrollSelected();
        this.activeSelectedElement = this._selectedElement.current;
      }
    };
    Suggestions2.prototype.render = function() {
      var _a2, _b2;
      var _this = this;
      var _c2 = this.props, forceResolveText = _c2.forceResolveText, mostRecentlyUsedHeaderText = _c2.mostRecentlyUsedHeaderText, searchForMoreIcon = _c2.searchForMoreIcon, searchForMoreText = _c2.searchForMoreText, className = _c2.className, moreSuggestionsAvailable = _c2.moreSuggestionsAvailable, noResultsFoundText = _c2.noResultsFoundText, suggestions = _c2.suggestions, isLoading = _c2.isLoading, isSearching = _c2.isSearching, loadingText = _c2.loadingText, onRenderNoResultFound = _c2.onRenderNoResultFound, searchingText = _c2.searchingText, isMostRecentlyUsedVisible = _c2.isMostRecentlyUsedVisible, resultsMaximumNumber = _c2.resultsMaximumNumber, resultsFooterFull = _c2.resultsFooterFull, resultsFooter = _c2.resultsFooter, _d2 = _c2.isResultsFooterVisible, isResultsFooterVisible = _d2 === void 0 ? true : _d2, suggestionsHeaderText = _c2.suggestionsHeaderText, suggestionsClassName = _c2.suggestionsClassName, theme = _c2.theme, styles2 = _c2.styles, suggestionsListId = _c2.suggestionsListId, suggestionsContainerAriaLabel = _c2.suggestionsContainerAriaLabel;
      this._classNames = styles2 ? getClassNames$a(styles2, {
        theme,
        className,
        suggestionsClassName,
        forceResolveButtonSelected: this.state.selectedActionType === SuggestionActionType.forceResolve,
        searchForMoreButtonSelected: this.state.selectedActionType === SuggestionActionType.searchMore
      }) : {
        root: css$3("ms-Suggestions", className, legacyStyles$1.root),
        title: css$3("ms-Suggestions-title", legacyStyles$1.suggestionsTitle),
        searchForMoreButton: css$3("ms-SearchMore-button", legacyStyles$1.actionButton, (_a2 = {}, _a2["is-selected " + legacyStyles$1.buttonSelected] = this.state.selectedActionType === SuggestionActionType.searchMore, _a2)),
        forceResolveButton: css$3("ms-forceResolve-button", legacyStyles$1.actionButton, (_b2 = {}, _b2["is-selected " + legacyStyles$1.buttonSelected] = this.state.selectedActionType === SuggestionActionType.forceResolve, _b2)),
        suggestionsAvailable: css$3("ms-Suggestions-suggestionsAvailable", legacyStyles$1.suggestionsAvailable),
        suggestionsContainer: css$3("ms-Suggestions-container", legacyStyles$1.suggestionsContainer, suggestionsClassName),
        noSuggestions: css$3("ms-Suggestions-none", legacyStyles$1.suggestionsNone)
      };
      var spinnerStyles = this._classNames.subComponentStyles ? this._classNames.subComponentStyles.spinner : void 0;
      var spinnerClassNameOrStyles = styles2 ? { styles: spinnerStyles } : {
        className: css$3("ms-Suggestions-spinner", legacyStyles$1.suggestionsSpinner)
      };
      var noResults = function() {
        var defaultRender = function() {
          return React__namespace.createElement("div", { className: _this._classNames.noSuggestions }, noResultsFoundText);
        };
        return (
          // This ID can be used by the parent to set aria-activedescendant to this
          React__namespace.createElement("div", { id: "sug-noResultsFound", role: "option" }, onRenderNoResultFound ? onRenderNoResultFound(void 0, defaultRender) : defaultRender())
        );
      };
      var headerText = suggestionsHeaderText;
      if (isMostRecentlyUsedVisible && mostRecentlyUsedHeaderText) {
        headerText = mostRecentlyUsedHeaderText;
      }
      var footerTitle = void 0;
      if (isResultsFooterVisible) {
        footerTitle = suggestions.length >= resultsMaximumNumber ? resultsFooterFull : resultsFooter;
      }
      var hasNoSuggestions = (!suggestions || !suggestions.length) && !isLoading;
      var forceResolveId = this.state.selectedActionType === SuggestionActionType.forceResolve ? "sug-selectedAction" : void 0;
      var searchForMoreId = this.state.selectedActionType === SuggestionActionType.searchMore ? "sug-selectedAction" : void 0;
      return React__namespace.createElement(
        "div",
        { className: this._classNames.root, "aria-label": suggestionsContainerAriaLabel || headerText, id: suggestionsListId, role: "listbox" },
        React__namespace.createElement(Announced, { message: this._getAlertText(), "aria-live": "polite" }),
        headerText ? React__namespace.createElement("div", { className: this._classNames.title }, headerText) : null,
        forceResolveText && this._shouldShowForceResolve() && React__namespace.createElement(CommandButton, { componentRef: this._forceResolveButton, className: this._classNames.forceResolveButton, id: forceResolveId, onClick: this._forceResolve, "data-automationid": "sug-forceResolve" }, forceResolveText),
        isLoading && React__namespace.createElement(Spinner, __assign$1({}, spinnerClassNameOrStyles, { ariaLabel: loadingText, label: loadingText })),
        hasNoSuggestions ? noResults() : this._renderSuggestions(),
        searchForMoreText && moreSuggestionsAvailable && React__namespace.createElement(CommandButton, { componentRef: this._searchForMoreButton, className: this._classNames.searchForMoreButton, iconProps: searchForMoreIcon || { iconName: "Search" }, id: searchForMoreId, onClick: this._getMoreResults, "data-automationid": "sug-searchForMore", role: "option" }, searchForMoreText),
        isSearching ? React__namespace.createElement(Spinner, __assign$1({}, spinnerClassNameOrStyles, { ariaLabel: searchingText, label: searchingText })) : null,
        footerTitle && !moreSuggestionsAvailable && !isMostRecentlyUsedVisible && !isSearching ? React__namespace.createElement("div", { className: this._classNames.title }, footerTitle(this.props)) : null
      );
    };
    Suggestions2.prototype.hasSuggestedAction = function() {
      return !!this._searchForMoreButton.current || !!this._forceResolveButton.current;
    };
    Suggestions2.prototype.hasSuggestedActionSelected = function() {
      return this.state.selectedActionType !== SuggestionActionType.none;
    };
    Suggestions2.prototype.executeSelectedAction = function() {
      switch (this.state.selectedActionType) {
        case SuggestionActionType.forceResolve:
          this._forceResolve();
          break;
        case SuggestionActionType.searchMore:
          this._getMoreResults();
          break;
      }
    };
    Suggestions2.prototype.focusAboveSuggestions = function() {
      if (this._forceResolveButton.current) {
        this.setState({ selectedActionType: SuggestionActionType.forceResolve });
      } else if (this._searchForMoreButton.current) {
        this.setState({ selectedActionType: SuggestionActionType.searchMore });
      }
    };
    Suggestions2.prototype.focusBelowSuggestions = function() {
      if (this._searchForMoreButton.current) {
        this.setState({ selectedActionType: SuggestionActionType.searchMore });
      } else if (this._forceResolveButton.current) {
        this.setState({ selectedActionType: SuggestionActionType.forceResolve });
      }
    };
    Suggestions2.prototype.focusSearchForMoreButton = function() {
      if (this._searchForMoreButton.current) {
        this._searchForMoreButton.current.focus();
      }
    };
    Suggestions2.prototype.scrollSelected = function() {
      if (this._selectedElement.current && this._scrollContainer.current && this._scrollContainer.current.scrollTo !== void 0) {
        var _a2 = this._selectedElement.current, offsetHeight = _a2.offsetHeight, offsetTop = _a2.offsetTop;
        var _b2 = this._scrollContainer.current, parentOffsetHeight = _b2.offsetHeight, scrollTop = _b2.scrollTop;
        var isAbove = offsetTop < scrollTop;
        var isBelow = offsetTop + offsetHeight > scrollTop + parentOffsetHeight;
        if (isAbove) {
          this._scrollContainer.current.scrollTo(0, offsetTop);
        } else if (isBelow) {
          this._scrollContainer.current.scrollTo(0, offsetTop - parentOffsetHeight + offsetHeight);
        }
      }
    };
    Suggestions2.prototype._renderSuggestions = function() {
      var _this = this;
      var _a2 = this.props, onRenderSuggestion = _a2.onRenderSuggestion, removeSuggestionAriaLabel = _a2.removeSuggestionAriaLabel, suggestionsItemClassName = _a2.suggestionsItemClassName, resultsMaximumNumber = _a2.resultsMaximumNumber, showRemoveButtons = _a2.showRemoveButtons, removeButtonIconProps = _a2.removeButtonIconProps;
      var suggestions = this.props.suggestions;
      var StyledTypedSuggestionsItem = StyledSuggestionsItem;
      var selectedIndex = -1;
      suggestions.some(function(element, index2) {
        if (element.selected) {
          selectedIndex = index2;
          return true;
        }
        return false;
      });
      if (resultsMaximumNumber) {
        suggestions = selectedIndex >= resultsMaximumNumber ? suggestions.slice(selectedIndex - resultsMaximumNumber + 1, selectedIndex + 1) : suggestions.slice(0, resultsMaximumNumber);
      }
      if (suggestions.length === 0) {
        return null;
      }
      return React__namespace.createElement("div", { className: this._classNames.suggestionsContainer, ref: this._scrollContainer, role: "presentation" }, suggestions.map(function(suggestion, index2) {
        return React__namespace.createElement(
          "div",
          { ref: suggestion.selected ? _this._selectedElement : void 0, key: suggestion.item.key ? suggestion.item.key : index2, role: "presentation" },
          React__namespace.createElement(StyledTypedSuggestionsItem, { suggestionModel: suggestion, RenderSuggestion: onRenderSuggestion, onClick: _this._onClickTypedSuggestionsItem(suggestion.item, index2), className: suggestionsItemClassName, showRemoveButton: showRemoveButtons, removeButtonAriaLabel: removeSuggestionAriaLabel, onRemoveItem: _this._onRemoveTypedSuggestionsItem(suggestion.item, index2), id: "sug-" + index2, removeButtonIconProps })
        );
      }));
    };
    return Suggestions2;
  }(React__namespace.Component)
);
var GlobalClassNames$a = {
  root: "ms-Suggestions",
  suggestionsContainer: "ms-Suggestions-container",
  title: "ms-Suggestions-title",
  forceResolveButton: "ms-forceResolve-button",
  searchForMoreButton: "ms-SearchMore-button",
  spinner: "ms-Suggestions-spinner",
  noSuggestions: "ms-Suggestions-none",
  suggestionsAvailable: "ms-Suggestions-suggestionsAvailable",
  isSelected: "is-selected"
};
function getStyles$a(props) {
  var _a2;
  var className = props.className, suggestionsClassName = props.suggestionsClassName, theme = props.theme, forceResolveButtonSelected = props.forceResolveButtonSelected, searchForMoreButtonSelected = props.searchForMoreButtonSelected;
  var palette = theme.palette, semanticColors = theme.semanticColors, fonts = theme.fonts;
  var classNames2 = getGlobalClassNames(GlobalClassNames$a, theme);
  var actionButtonStyles = {
    backgroundColor: "transparent",
    border: 0,
    cursor: "pointer",
    margin: 0,
    paddingLeft: 8,
    position: "relative",
    borderTop: "1px solid " + palette.neutralLight,
    height: 40,
    textAlign: "left",
    width: "100%",
    fontSize: fonts.small.fontSize,
    selectors: {
      ":hover": {
        backgroundColor: semanticColors.menuItemBackgroundPressed,
        cursor: "pointer"
      },
      ":focus, :active": {
        backgroundColor: palette.themeLight
      },
      ".ms-Button-icon": {
        fontSize: fonts.mediumPlus.fontSize,
        width: 25
      },
      ".ms-Button-label": {
        margin: "0 4px 0 9px"
      }
    }
  };
  var actionButtonSelectedStyles = {
    backgroundColor: palette.themeLight,
    selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign$1({ backgroundColor: "Highlight", borderColor: "Highlight", color: "HighlightText" }, getHighContrastNoAdjustStyle()), _a2)
  };
  return {
    root: [
      classNames2.root,
      {
        minWidth: 260
      },
      className
    ],
    suggestionsContainer: [
      classNames2.suggestionsContainer,
      {
        overflowY: "auto",
        overflowX: "hidden",
        maxHeight: 300,
        transform: "translate3d(0,0,0)"
      },
      suggestionsClassName
    ],
    title: [
      classNames2.title,
      {
        padding: "0 12px",
        fontSize: fonts.small.fontSize,
        color: palette.themePrimary,
        lineHeight: 40,
        borderBottom: "1px solid " + semanticColors.menuItemBackgroundPressed
      }
    ],
    forceResolveButton: [
      classNames2.forceResolveButton,
      actionButtonStyles,
      forceResolveButtonSelected && [classNames2.isSelected, actionButtonSelectedStyles]
    ],
    searchForMoreButton: [
      classNames2.searchForMoreButton,
      actionButtonStyles,
      searchForMoreButtonSelected && [classNames2.isSelected, actionButtonSelectedStyles]
    ],
    noSuggestions: [
      classNames2.noSuggestions,
      {
        textAlign: "center",
        color: palette.neutralSecondary,
        fontSize: fonts.small.fontSize,
        lineHeight: 30
      }
    ],
    suggestionsAvailable: [classNames2.suggestionsAvailable, hiddenContentStyle],
    subComponentStyles: {
      spinner: {
        root: [
          classNames2.spinner,
          {
            margin: "5px 0",
            paddingLeft: 14,
            textAlign: "left",
            whiteSpace: "nowrap",
            lineHeight: 20,
            fontSize: fonts.small.fontSize
          }
        ],
        circle: {
          display: "inline-block",
          verticalAlign: "middle"
        },
        label: {
          display: "inline-block",
          verticalAlign: "middle",
          margin: "0 10px 0 16px"
        }
      }
    }
  };
}
var SuggestionsController = (
  /** @class */
  function() {
    function SuggestionsController2() {
      var _this = this;
      this._isSuggestionModel = function(value) {
        return value.item !== void 0;
      };
      this._ensureSuggestionModel = function(suggestion) {
        if (_this._isSuggestionModel(suggestion)) {
          return suggestion;
        } else {
          return {
            item: suggestion,
            selected: false,
            ariaLabel: suggestion.name || suggestion.primaryText
          };
        }
      };
      this.suggestions = [];
      this.currentIndex = -1;
    }
    SuggestionsController2.prototype.updateSuggestions = function(newSuggestions, selectedIndex, maxCount) {
      if (newSuggestions && newSuggestions.length > 0) {
        if (maxCount && newSuggestions.length > maxCount) {
          var startIndex = selectedIndex && selectedIndex > maxCount ? selectedIndex + 1 - maxCount : 0;
          newSuggestions = newSuggestions.slice(startIndex, startIndex + maxCount - 1);
        }
        this.suggestions = this.convertSuggestionsToSuggestionItems(newSuggestions);
        this.currentIndex = selectedIndex ? selectedIndex : 0;
        if (selectedIndex === -1) {
          this.currentSuggestion = void 0;
        } else if (selectedIndex !== void 0) {
          this.suggestions[selectedIndex].selected = true;
          this.currentSuggestion = this.suggestions[selectedIndex];
        }
      } else {
        this.suggestions = [];
        this.currentIndex = -1;
        this.currentSuggestion = void 0;
      }
    };
    SuggestionsController2.prototype.nextSuggestion = function() {
      if (this.suggestions && this.suggestions.length) {
        if (this.currentIndex < this.suggestions.length - 1) {
          this.setSelectedSuggestion(this.currentIndex + 1);
          return true;
        } else if (this.currentIndex === this.suggestions.length - 1) {
          this.setSelectedSuggestion(0);
          return true;
        }
      }
      return false;
    };
    SuggestionsController2.prototype.previousSuggestion = function() {
      if (this.suggestions && this.suggestions.length) {
        if (this.currentIndex > 0) {
          this.setSelectedSuggestion(this.currentIndex - 1);
          return true;
        } else if (this.currentIndex === 0) {
          this.setSelectedSuggestion(this.suggestions.length - 1);
          return true;
        }
      }
      return false;
    };
    SuggestionsController2.prototype.getSuggestions = function() {
      return this.suggestions;
    };
    SuggestionsController2.prototype.getCurrentItem = function() {
      return this.currentSuggestion;
    };
    SuggestionsController2.prototype.getSuggestionAtIndex = function(index2) {
      return this.suggestions[index2];
    };
    SuggestionsController2.prototype.hasSelectedSuggestion = function() {
      return this.currentSuggestion ? true : false;
    };
    SuggestionsController2.prototype.removeSuggestion = function(index2) {
      this.suggestions.splice(index2, 1);
    };
    SuggestionsController2.prototype.createGenericSuggestion = function(itemToConvert) {
      var itemToAdd = this.convertSuggestionsToSuggestionItems([itemToConvert])[0];
      this.currentSuggestion = itemToAdd;
    };
    SuggestionsController2.prototype.convertSuggestionsToSuggestionItems = function(suggestions) {
      return Array.isArray(suggestions) ? suggestions.map(this._ensureSuggestionModel) : [];
    };
    SuggestionsController2.prototype.deselectAllSuggestions = function() {
      if (this.currentIndex > -1) {
        this.suggestions[this.currentIndex].selected = false;
        this.currentIndex = -1;
      }
    };
    SuggestionsController2.prototype.setSelectedSuggestion = function(index2) {
      if (index2 > this.suggestions.length - 1 || index2 < 0) {
        this.currentIndex = 0;
        this.currentSuggestion.selected = false;
        this.currentSuggestion = this.suggestions[0];
        this.currentSuggestion.selected = true;
      } else {
        if (this.currentIndex > -1) {
          this.suggestions[this.currentIndex].selected = false;
        }
        this.suggestions[index2].selected = true;
        this.currentIndex = index2;
        this.currentSuggestion = this.suggestions[index2];
      }
    };
    return SuggestionsController2;
  }()
);
var ValidationState;
(function(ValidationState2) {
  ValidationState2[ValidationState2["valid"] = 0] = "valid";
  ValidationState2[ValidationState2["warning"] = 1] = "warning";
  ValidationState2[ValidationState2["invalid"] = 2] = "invalid";
})(ValidationState || (ValidationState = {}));
loadStyles([{ "rawString": ".picker_94f06b16{position:relative}.pickerText_94f06b16{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-sizing:border-box;box-sizing:border-box;border:1px solid " }, { "theme": "neutralTertiary", "defaultValue": "#a19f9d" }, { "rawString": ";min-width:180px;min-height:30px}.pickerText_94f06b16:hover{border-color:" }, { "theme": "inputBorderHovered", "defaultValue": "#323130" }, { "rawString": "}.pickerText_94f06b16.inputFocused_94f06b16{position:relative;border-color:" }, { "theme": "inputFocusBorderAlt", "defaultValue": "#0078d4" }, { "rawString": '}.pickerText_94f06b16.inputFocused_94f06b16:after{pointer-events:none;content:"";position:absolute;left:-1px;top:-1px;bottom:-1px;right:-1px;border:2px solid ' }, { "theme": "inputFocusBorderAlt", "defaultValue": "#0078d4" }, { "rawString": '}@media screen and (-ms-high-contrast:active),screen and (forced-colors:active){.pickerText_94f06b16.inputDisabled_94f06b16{position:relative;border-color:GrayText}.pickerText_94f06b16.inputDisabled_94f06b16:after{pointer-events:none;content:"";position:absolute;left:0;top:0;bottom:0;right:0;background-color:Window}}.pickerInput_94f06b16{height:34px;border:none;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;outline:0;padding:0 6px 0;-ms-flex-item-align:end;align-self:flex-end}.pickerItems_94f06b16{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;max-width:100%}.screenReaderOnly_94f06b16{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}' }]);
var picker = "picker_94f06b16";
var pickerText = "pickerText_94f06b16";
var inputFocused = "inputFocused_94f06b16";
var inputDisabled = "inputDisabled_94f06b16";
var pickerInput = "pickerInput_94f06b16";
var pickerItems = "pickerItems_94f06b16";
var screenReaderOnly = "screenReaderOnly_94f06b16";
const stylesImport = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  inputDisabled,
  inputFocused,
  picker,
  pickerInput,
  pickerItems,
  pickerText,
  screenReaderOnly
}, Symbol.toStringTag, { value: "Module" }));
var legacyStyles = stylesImport;
var EXTENDED_LOAD_TIME = 3e3;
var getClassNames$9 = classNamesFunction();
function getStyledSuggestions(suggestionsType) {
  return styled(suggestionsType, getStyles$a, void 0, {
    scope: "Suggestions"
  });
}
var BasePicker = (
  /** @class */
  function(_super) {
    __extends(BasePicker2, _super);
    function BasePicker2(basePickerProps) {
      var _this = _super.call(this, basePickerProps) || this;
      _this.root = React__namespace.createRef();
      _this.input = React__namespace.createRef();
      _this.suggestionElement = React__namespace.createRef();
      _this.SuggestionOfProperType = Suggestions;
      _this._styledSuggestions = getStyledSuggestions(_this.SuggestionOfProperType);
      _this.dismissSuggestions = function(ev) {
        var selectItemFunction = function() {
          var addItemOnDismiss = true;
          if (_this.props.onDismiss) {
            addItemOnDismiss = _this.props.onDismiss(ev, _this.suggestionStore.currentSuggestion ? _this.suggestionStore.currentSuggestion.item : void 0);
          }
          if (!ev || ev && !ev.defaultPrevented) {
            if (addItemOnDismiss !== false && _this.canAddItems() && _this.suggestionStore.hasSelectedSuggestion() && _this.state.suggestedDisplayValue) {
              _this.addItemByIndex(0);
            }
          }
        };
        if (_this.currentPromise) {
          _this.currentPromise.then(function() {
            return selectItemFunction();
          });
        } else {
          selectItemFunction();
        }
        _this.setState({ suggestionsVisible: false });
      };
      _this.refocusSuggestions = function(keyCode) {
        _this.resetFocus();
        if (_this.suggestionStore.suggestions && _this.suggestionStore.suggestions.length > 0) {
          if (keyCode === KeyCodes.up) {
            _this.suggestionStore.setSelectedSuggestion(_this.suggestionStore.suggestions.length - 1);
          } else if (keyCode === KeyCodes.down) {
            _this.suggestionStore.setSelectedSuggestion(0);
          }
        }
      };
      _this.onInputChange = function(value) {
        _this.updateValue(value);
        _this.setState({
          moreSuggestionsAvailable: true,
          isMostRecentlyUsedVisible: false
        });
      };
      _this.onSuggestionClick = function(ev, item, index2) {
        _this.addItemByIndex(index2);
      };
      _this.onSuggestionRemove = function(ev, item, index2) {
        if (_this.props.onRemoveSuggestion) {
          _this.props.onRemoveSuggestion(item);
        }
        _this.suggestionStore.removeSuggestion(index2);
      };
      _this.onInputFocus = function(ev) {
        _this.selection.setAllSelected(false);
        if (!_this.state.isFocused) {
          _this._userTriggeredSuggestions();
          if (_this.props.inputProps && _this.props.inputProps.onFocus) {
            _this.props.inputProps.onFocus(ev);
          }
        }
      };
      _this.onInputBlur = function(ev) {
        if (_this.props.inputProps && _this.props.inputProps.onBlur) {
          _this.props.inputProps.onBlur(ev);
        }
      };
      _this.onBlur = function(ev) {
        if (_this.state.isFocused) {
          var relatedTarget = ev.relatedTarget;
          if (ev.relatedTarget === null) {
            relatedTarget = document.activeElement;
          }
          if (relatedTarget && !elementContains(_this.root.current, relatedTarget)) {
            _this.setState({ isFocused: false });
            if (_this.props.onBlur) {
              _this.props.onBlur(ev);
            }
          }
        }
      };
      _this.onWrapperClick = function(ev) {
        if (_this.state.items.length && !_this.canAddItems()) {
          _this.resetFocus(_this.state.items.length - 1);
        }
      };
      _this.onClick = function(ev) {
        if (_this.props.inputProps !== void 0 && _this.props.inputProps.onClick !== void 0) {
          _this.props.inputProps.onClick(ev);
        }
        if (ev.button === 0) {
          _this._userTriggeredSuggestions();
        }
      };
      _this.onFocus = function() {
        if (!_this.state.isFocused) {
          _this.setState({ isFocused: true });
        }
      };
      _this.onKeyDown = function(ev) {
        var keyCode = ev.which;
        switch (keyCode) {
          case KeyCodes.escape:
            if (_this.state.suggestionsVisible) {
              _this.setState({ suggestionsVisible: false });
              ev.preventDefault();
              ev.stopPropagation();
            }
            break;
          case KeyCodes.tab:
          case KeyCodes.enter:
            if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedActionSelected()) {
              _this.suggestionElement.current.executeSelectedAction();
            } else if (!ev.shiftKey && _this.suggestionStore.hasSelectedSuggestion() && _this.state.suggestionsVisible) {
              _this.completeSuggestion();
              ev.preventDefault();
              ev.stopPropagation();
            } else {
              _this._completeGenericSuggestion();
            }
            break;
          case KeyCodes.backspace:
            if (!_this.props.disabled) {
              _this.onBackspace(ev);
            }
            ev.stopPropagation();
            break;
          case KeyCodes.del:
            if (!_this.props.disabled) {
              if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible && _this.suggestionStore.currentIndex !== -1) {
                if (_this.props.onRemoveSuggestion) {
                  _this.props.onRemoveSuggestion(_this.suggestionStore.currentSuggestion.item);
                }
                _this.suggestionStore.removeSuggestion(_this.suggestionStore.currentIndex);
                _this.forceUpdate();
              } else {
                _this.onBackspace(ev);
              }
            }
            ev.stopPropagation();
            break;
          case KeyCodes.up:
            if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible) {
              if (_this.suggestionElement.current && _this.suggestionElement.current.tryHandleKeyDown(keyCode, _this.suggestionStore.currentIndex)) {
                ev.preventDefault();
                ev.stopPropagation();
                _this.forceUpdate();
              } else {
                if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedAction() && _this.suggestionStore.currentIndex === 0) {
                  ev.preventDefault();
                  ev.stopPropagation();
                  _this.suggestionElement.current.focusAboveSuggestions();
                  _this.suggestionStore.deselectAllSuggestions();
                  _this.forceUpdate();
                } else {
                  if (_this.suggestionStore.previousSuggestion()) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    _this.onSuggestionSelect();
                  }
                }
              }
            }
            break;
          case KeyCodes.down:
            if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible) {
              if (_this.suggestionElement.current && _this.suggestionElement.current.tryHandleKeyDown(keyCode, _this.suggestionStore.currentIndex)) {
                ev.preventDefault();
                ev.stopPropagation();
                _this.forceUpdate();
              } else {
                if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedAction() && _this.suggestionStore.currentIndex + 1 === _this.suggestionStore.suggestions.length) {
                  ev.preventDefault();
                  ev.stopPropagation();
                  _this.suggestionElement.current.focusBelowSuggestions();
                  _this.suggestionStore.deselectAllSuggestions();
                  _this.forceUpdate();
                } else {
                  if (_this.suggestionStore.nextSuggestion()) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    _this.onSuggestionSelect();
                  }
                }
              }
            }
            break;
        }
      };
      _this.onItemChange = function(changedItem, index2) {
        var items2 = _this.state.items;
        if (index2 >= 0) {
          var newItems = items2;
          newItems[index2] = changedItem;
          _this._updateSelectedItems(newItems);
        }
      };
      _this.onGetMoreResults = function() {
        _this.setState({
          isSearching: true
        }, function() {
          if (_this.props.onGetMoreResults && _this.input.current) {
            var suggestions = _this.props.onGetMoreResults(_this.input.current.value, _this.state.items);
            var suggestionsArray = suggestions;
            var suggestionsPromiseLike = suggestions;
            if (Array.isArray(suggestionsArray)) {
              _this.updateSuggestions(suggestionsArray);
              _this.setState({ isSearching: false });
            } else if (suggestionsPromiseLike.then) {
              suggestionsPromiseLike.then(function(newSuggestions) {
                _this.updateSuggestions(newSuggestions);
                _this.setState({ isSearching: false });
              });
            }
          } else {
            _this.setState({ isSearching: false });
          }
          if (_this.input.current) {
            _this.input.current.focus();
          }
          _this.setState({
            moreSuggestionsAvailable: false,
            isResultsFooterVisible: true
          });
        });
      };
      _this.completeSelection = function(item) {
        _this.addItem(item);
        _this.updateValue("");
        if (_this.input.current) {
          _this.input.current.clear();
        }
        _this.setState({ suggestionsVisible: false });
      };
      _this.addItemByIndex = function(index2) {
        _this.completeSelection(_this.suggestionStore.getSuggestionAtIndex(index2).item);
      };
      _this.addItem = function(item) {
        var processedItem = _this.props.onItemSelected ? _this.props.onItemSelected(item) : item;
        if (processedItem === null) {
          return;
        }
        var processedItemObject = processedItem;
        var processedItemPromiseLike = processedItem;
        if (processedItemPromiseLike && processedItemPromiseLike.then) {
          processedItemPromiseLike.then(function(resolvedProcessedItem) {
            var newItems2 = _this.state.items.concat([resolvedProcessedItem]);
            _this._updateSelectedItems(newItems2);
          });
        } else {
          var newItems = _this.state.items.concat([processedItemObject]);
          _this._updateSelectedItems(newItems);
        }
        _this.setState({ suggestedDisplayValue: "", selectionRemoved: void 0 });
      };
      _this.removeItem = function(item) {
        var items2 = _this.state.items;
        var index2 = items2.indexOf(item);
        if (index2 >= 0) {
          var newItems = items2.slice(0, index2).concat(items2.slice(index2 + 1));
          _this.setState({ selectionRemoved: item });
          _this._updateSelectedItems(newItems);
          _this._async.setTimeout(function() {
            _this.setState({ selectionRemoved: void 0 });
          }, 1e3);
        }
      };
      _this.removeItems = function(itemsToRemove) {
        var items2 = _this.state.items;
        var newItems = items2.filter(function(item) {
          return itemsToRemove.indexOf(item) === -1;
        });
        _this._updateSelectedItems(newItems);
      };
      _this._shouldFocusZoneEnterInnerZone = function(ev) {
        if (_this.state.suggestionsVisible) {
          switch (ev.which) {
            case KeyCodes.up:
            case KeyCodes.down:
              return true;
          }
        }
        if (ev.which === KeyCodes.enter) {
          return true;
        }
        return false;
      };
      _this._onResolveSuggestions = function(updatedValue) {
        var suggestions = _this.props.onResolveSuggestions(updatedValue, _this.state.items);
        if (suggestions !== null) {
          _this.updateSuggestionsList(suggestions, updatedValue);
        }
      };
      _this._completeGenericSuggestion = function() {
        if (_this.props.onValidateInput && _this.input.current && _this.props.onValidateInput(_this.input.current.value) !== ValidationState.invalid && _this.props.createGenericItem) {
          var itemToConvert = _this.props.createGenericItem(_this.input.current.value, _this.props.onValidateInput(_this.input.current.value));
          _this.suggestionStore.createGenericSuggestion(itemToConvert);
          _this.completeSuggestion();
        }
      };
      _this._userTriggeredSuggestions = function() {
        if (!_this.state.suggestionsVisible) {
          var input = _this.input.current ? _this.input.current.value : "";
          if (!input) {
            _this.onEmptyInputFocus();
          } else {
            if (_this.suggestionStore.suggestions.length === 0) {
              _this._onResolveSuggestions(input);
            } else {
              _this.setState({
                isMostRecentlyUsedVisible: false,
                suggestionsVisible: true
              });
            }
          }
        }
      };
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      var items = basePickerProps.selectedItems || basePickerProps.defaultSelectedItems || [];
      _this._id = getId();
      _this._ariaMap = {
        selectedItems: "selected-items-" + _this._id,
        selectedSuggestionAlert: "selected-suggestion-alert-" + _this._id,
        suggestionList: "suggestion-list-" + _this._id,
        combobox: "combobox-" + _this._id
      };
      _this.suggestionStore = new SuggestionsController();
      _this.selection = new Selection({ onSelectionChanged: function() {
        return _this.onSelectionChange();
      } });
      _this.selection.setItems(items);
      _this.state = {
        items,
        suggestedDisplayValue: "",
        isMostRecentlyUsedVisible: false,
        moreSuggestionsAvailable: false,
        isFocused: false,
        isSearching: false,
        selectedIndices: [],
        selectionRemoved: void 0
      };
      return _this;
    }
    BasePicker2.getDerivedStateFromProps = function(newProps) {
      if (newProps.selectedItems) {
        return { items: newProps.selectedItems };
      }
      return null;
    };
    Object.defineProperty(BasePicker2.prototype, "items", {
      get: function() {
        return this.state.items;
      },
      enumerable: false,
      configurable: true
    });
    BasePicker2.prototype.componentDidMount = function() {
      this.selection.setItems(this.state.items);
      this._onResolveSuggestions = this._async.debounce(this._onResolveSuggestions, this.props.resolveDelay);
    };
    BasePicker2.prototype.componentDidUpdate = function(oldProps, oldState) {
      if (this.state.items && this.state.items !== oldState.items) {
        var currentSelectedIndex = this.selection.getSelectedIndices()[0];
        this.selection.setItems(this.state.items);
        if (this.state.isFocused) {
          if (this.state.items.length < oldState.items.length) {
            this.selection.setIndexSelected(currentSelectedIndex, false, true);
            this.resetFocus(currentSelectedIndex);
          } else if (this.state.items.length > oldState.items.length && !this.canAddItems()) {
            this.resetFocus(this.state.items.length - 1);
          }
        }
      }
    };
    BasePicker2.prototype.componentWillUnmount = function() {
      if (this.currentPromise) {
        this.currentPromise = void 0;
      }
      this._async.dispose();
    };
    BasePicker2.prototype.focus = function() {
      if (this.input.current) {
        this.input.current.focus();
      }
    };
    BasePicker2.prototype.focusInput = function() {
      if (this.input.current) {
        this.input.current.focus();
      }
    };
    BasePicker2.prototype.completeSuggestion = function(forceComplete) {
      if (this.suggestionStore.hasSelectedSuggestion() && this.input.current) {
        this.completeSelection(this.suggestionStore.currentSuggestion.item);
      } else if (forceComplete) {
        this._completeGenericSuggestion();
      }
    };
    BasePicker2.prototype.render = function() {
      var _a2 = this.state, suggestedDisplayValue = _a2.suggestedDisplayValue, isFocused = _a2.isFocused, items = _a2.items;
      var _b2 = this.props, className = _b2.className, inputProps = _b2.inputProps, disabled = _b2.disabled, selectionAriaLabel = _b2.selectionAriaLabel, _c2 = _b2.selectionRole, selectionRole = _c2 === void 0 ? "list" : _c2, theme = _b2.theme, styles2 = _b2.styles;
      var suggestionsVisible = !!this.state.suggestionsVisible;
      var suggestionsAvailable2 = suggestionsVisible ? this._ariaMap.suggestionList : void 0;
      var classNames2 = styles2 ? getClassNames$9(styles2, {
        theme,
        className,
        isFocused,
        disabled,
        inputClassName: inputProps && inputProps.className
      }) : {
        root: css$3("ms-BasePicker", className ? className : ""),
        text: css$3("ms-BasePicker-text", legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),
        itemsWrapper: legacyStyles.pickerItems,
        input: css$3("ms-BasePicker-input", legacyStyles.pickerInput, inputProps && inputProps.className),
        screenReaderText: legacyStyles.screenReaderOnly
      };
      var comboLabel = this.props["aria-label"] || (inputProps === null || inputProps === void 0 ? void 0 : inputProps["aria-label"]);
      return React__namespace.createElement(
        "div",
        { ref: this.root, className: classNames2.root, onKeyDown: this.onKeyDown, onFocus: this.onFocus, onBlur: this.onBlur, onClick: this.onWrapperClick },
        this.renderCustomAlert(classNames2.screenReaderText),
        React__namespace.createElement("span", { id: this._ariaMap.selectedItems + "-label", hidden: true }, selectionAriaLabel || comboLabel),
        React__namespace.createElement(
          SelectionZone,
          { selection: this.selection, selectionMode: SelectionMode.multiple },
          React__namespace.createElement(
            "div",
            { className: classNames2.text, "aria-owns": suggestionsAvailable2 },
            items.length > 0 && React__namespace.createElement("span", { id: this._ariaMap.selectedItems, className: classNames2.itemsWrapper, role: selectionRole, "aria-labelledby": this._ariaMap.selectedItems + "-label" }, this.renderItems()),
            this.canAddItems() && React__namespace.createElement(Autofill, __assign$1({ spellCheck: false }, inputProps, { className: classNames2.input, componentRef: this.input, id: (inputProps === null || inputProps === void 0 ? void 0 : inputProps.id) ? inputProps.id : this._ariaMap.combobox, onClick: this.onClick, onFocus: this.onInputFocus, onBlur: this.onInputBlur, onInputValueChange: this.onInputChange, suggestedDisplayValue, "aria-activedescendant": suggestionsVisible ? this.getActiveDescendant() : void 0, "aria-controls": suggestionsAvailable2, "aria-describedby": items.length > 0 ? this._ariaMap.selectedItems : void 0, "aria-expanded": suggestionsVisible, "aria-haspopup": "listbox", "aria-label": comboLabel, role: "combobox", disabled, onInputChange: this.props.onInputChange }))
          )
        ),
        this.renderSuggestions()
      );
    };
    BasePicker2.prototype.canAddItems = function() {
      var items = this.state.items;
      var itemLimit = this.props.itemLimit;
      return itemLimit === void 0 || items.length < itemLimit;
    };
    BasePicker2.prototype.renderSuggestions = function() {
      var StyledTypedSuggestions = this._styledSuggestions;
      return this.state.suggestionsVisible && this.input ? React__namespace.createElement(
        Callout,
        __assign$1({ isBeakVisible: false, gapSpace: 5, target: this.input.current ? this.input.current.inputElement : void 0, onDismiss: this.dismissSuggestions, directionalHint: DirectionalHint.bottomLeftEdge, directionalHintForRTL: DirectionalHint.bottomRightEdge }, this.props.pickerCalloutProps),
        React__namespace.createElement(
          StyledTypedSuggestions,
          __assign$1({
            // Assumed to set in derived component's defaultProps
            onRenderSuggestion: this.props.onRenderSuggestionsItem,
            onSuggestionClick: this.onSuggestionClick,
            onSuggestionRemove: this.onSuggestionRemove,
            suggestions: this.suggestionStore.getSuggestions(),
            componentRef: this.suggestionElement,
            onGetMoreResults: this.onGetMoreResults,
            moreSuggestionsAvailable: this.state.moreSuggestionsAvailable,
            isLoading: this.state.suggestionsLoading,
            isExtendedLoading: this.state.suggestionsExtendedLoading,
            isSearching: this.state.isSearching,
            isMostRecentlyUsedVisible: this.state.isMostRecentlyUsedVisible,
            isResultsFooterVisible: this.state.isResultsFooterVisible,
            refocusSuggestions: this.refocusSuggestions,
            removeSuggestionAriaLabel: this.props.removeButtonAriaLabel,
            suggestionsListId: this._ariaMap.suggestionList,
            createGenericItem: this._completeGenericSuggestion
          }, this.props.pickerSuggestionsProps)
        )
      ) : null;
    };
    BasePicker2.prototype.renderItems = function() {
      var _this = this;
      var _a2 = this.props, disabled = _a2.disabled, removeButtonAriaLabel = _a2.removeButtonAriaLabel, removeButtonIconProps = _a2.removeButtonIconProps;
      var onRenderItem = this.props.onRenderItem;
      var _b2 = this.state, items = _b2.items, selectedIndices = _b2.selectedIndices;
      return items.map(function(item, index2) {
        return onRenderItem({
          item,
          index: index2,
          key: item.key ? item.key : index2,
          selected: selectedIndices.indexOf(index2) !== -1,
          onRemoveItem: function() {
            return _this.removeItem(item);
          },
          disabled,
          onItemChange: _this.onItemChange,
          removeButtonAriaLabel,
          removeButtonIconProps
        });
      });
    };
    BasePicker2.prototype.resetFocus = function(index2) {
      var items = this.state.items;
      if (items.length) {
        index2 = index2 !== null && index2 !== void 0 ? index2 : items.length - 1;
        var newEl = this.root.current && this.root.current.querySelectorAll("[data-selection-index] > button")[Math.min(index2, items.length - 1)];
        if (newEl) {
          newEl.focus();
        }
      } else {
        if (this.input.current) {
          this.input.current.focus();
        }
      }
    };
    BasePicker2.prototype.onSuggestionSelect = function() {
      if (this.suggestionStore.currentSuggestion) {
        var currentValue = this.input.current ? this.input.current.value : "";
        var itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, currentValue);
        this.setState({ suggestedDisplayValue: itemValue });
      }
    };
    BasePicker2.prototype.onSelectionChange = function() {
      this.setState({
        selectedIndices: this.selection.getSelectedIndices()
      });
    };
    BasePicker2.prototype.updateSuggestions = function(suggestions) {
      var _a2;
      var maxSuggestionsCount = (_a2 = this.props.pickerSuggestionsProps) === null || _a2 === void 0 ? void 0 : _a2.resultsMaximumNumber;
      this.suggestionStore.updateSuggestions(suggestions, 0, maxSuggestionsCount);
      this.forceUpdate();
    };
    BasePicker2.prototype.onEmptyInputFocus = function() {
      var emptyResolveSuggestions = this.props.onEmptyResolveSuggestions ? this.props.onEmptyResolveSuggestions : (
        // eslint-disable-next-line deprecation/deprecation
        this.props.onEmptyInputFocus
      );
      if (emptyResolveSuggestions) {
        var suggestions = emptyResolveSuggestions(this.state.items);
        this.updateSuggestionsList(suggestions);
        this.setState({
          isMostRecentlyUsedVisible: true,
          suggestionsVisible: true,
          moreSuggestionsAvailable: false
        });
      }
    };
    BasePicker2.prototype.updateValue = function(updatedValue) {
      this._onResolveSuggestions(updatedValue);
    };
    BasePicker2.prototype.updateSuggestionsList = function(suggestions, updatedValue) {
      var _this = this;
      if (Array.isArray(suggestions)) {
        this._updateAndResolveValue(updatedValue, suggestions);
      } else if (suggestions && suggestions.then) {
        this.setState({
          suggestionsLoading: true
        });
        this._startLoadTimer();
        this.suggestionStore.updateSuggestions([]);
        if (updatedValue !== void 0) {
          this.setState({
            suggestionsVisible: this._getShowSuggestions()
          });
        } else {
          this.setState({
            suggestionsVisible: this.input.current && this.input.current.inputElement === document.activeElement
          });
        }
        this.currentPromise = suggestions;
        suggestions.then(function(newSuggestions) {
          if (suggestions === _this.currentPromise) {
            _this._updateAndResolveValue(updatedValue, newSuggestions);
          }
        });
      }
    };
    BasePicker2.prototype.resolveNewValue = function(updatedValue, suggestions) {
      var _this = this;
      this.updateSuggestions(suggestions);
      var itemValue = void 0;
      if (this.suggestionStore.currentSuggestion) {
        itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, updatedValue);
      }
      this.setState({
        suggestedDisplayValue: itemValue,
        suggestionsVisible: this._getShowSuggestions()
      }, function() {
        return _this.setState({ suggestionsLoading: false, suggestionsExtendedLoading: false });
      });
    };
    BasePicker2.prototype.onChange = function(items) {
      if (this.props.onChange) {
        this.props.onChange(items);
      }
    };
    BasePicker2.prototype.onBackspace = function(ev) {
      if (this.state.items.length && !this.input.current || this.input.current && !this.input.current.isValueSelected && this.input.current.cursorLocation === 0) {
        if (this.selection.getSelectedCount() > 0) {
          this.removeItems(this.selection.getSelection());
        } else {
          this.removeItem(this.state.items[this.state.items.length - 1]);
        }
      }
    };
    BasePicker2.prototype.getActiveDescendant = function() {
      var _a2;
      if (this.state.suggestionsLoading) {
        return void 0;
      }
      var currentIndex = this.suggestionStore.currentIndex;
      if (currentIndex < 0) {
        if ((_a2 = this.suggestionElement.current) === null || _a2 === void 0 ? void 0 : _a2.hasSuggestedAction()) {
          return "sug-selectedAction";
        }
        if (this.suggestionStore.suggestions.length === 0) {
          return "sug-noResultsFound";
        }
        return void 0;
      } else {
        return "sug-" + currentIndex;
      }
    };
    BasePicker2.prototype.getSuggestionsAlert = function(suggestionAlertClassName) {
      if (suggestionAlertClassName === void 0) {
        suggestionAlertClassName = legacyStyles.screenReaderOnly;
      }
      var currentIndex = this.suggestionStore.currentIndex;
      if (this.props.enableSelectedSuggestionAlert) {
        var selectedSuggestion = currentIndex > -1 ? this.suggestionStore.getSuggestionAtIndex(this.suggestionStore.currentIndex) : void 0;
        var selectedSuggestionAlertText = selectedSuggestion ? selectedSuggestion.ariaLabel : void 0;
        return React__namespace.createElement("div", { id: this._ariaMap.selectedSuggestionAlert, className: suggestionAlertClassName }, selectedSuggestionAlertText + " ");
      }
    };
    BasePicker2.prototype.renderCustomAlert = function(alertClassName) {
      if (alertClassName === void 0) {
        alertClassName = legacyStyles.screenReaderOnly;
      }
      var _a2 = this.props.suggestionRemovedText, suggestionRemovedText = _a2 === void 0 ? "removed {0}" : _a2;
      var removedItemText = "";
      if (this.state.selectionRemoved) {
        var itemName = this._getTextFromItem(this.state.selectionRemoved, "");
        removedItemText = format$1(suggestionRemovedText, itemName);
      }
      return React__namespace.createElement(
        "div",
        { className: alertClassName, id: this._ariaMap.selectedSuggestionAlert, "aria-live": "assertive" },
        // eslint-disable-next-line deprecation/deprecation
        this.getSuggestionsAlert(alertClassName),
        removedItemText
      );
    };
    BasePicker2.prototype._startLoadTimer = function() {
      var _this = this;
      this._async.setTimeout(function() {
        if (_this.state.suggestionsLoading) {
          _this.setState({ suggestionsExtendedLoading: true });
        }
      }, EXTENDED_LOAD_TIME);
    };
    BasePicker2.prototype._updateAndResolveValue = function(updatedValue, newSuggestions) {
      var _a2;
      if (updatedValue !== void 0) {
        this.resolveNewValue(updatedValue, newSuggestions);
      } else {
        var maxSuggestionsCount = (_a2 = this.props.pickerSuggestionsProps) === null || _a2 === void 0 ? void 0 : _a2.resultsMaximumNumber;
        this.suggestionStore.updateSuggestions(newSuggestions, -1, maxSuggestionsCount);
        if (this.state.suggestionsLoading) {
          this.setState({
            suggestionsLoading: false,
            suggestionsExtendedLoading: false
          });
        }
      }
    };
    BasePicker2.prototype._updateSelectedItems = function(items) {
      var _this = this;
      if (this.props.selectedItems) {
        this.onChange(items);
      } else {
        this.setState({ items }, function() {
          _this._onSelectedItemsUpdated(items);
        });
      }
    };
    BasePicker2.prototype._onSelectedItemsUpdated = function(items) {
      this.onChange(items);
    };
    BasePicker2.prototype._getShowSuggestions = function() {
      var areSuggestionsVisible = this.input.current !== void 0 && this.input.current !== null && this.input.current.inputElement === document.activeElement && this.input.current.value !== "";
      return areSuggestionsVisible;
    };
    BasePicker2.prototype._getTextFromItem = function(item, currentValue) {
      if (this.props.getTextFromItem) {
        return this.props.getTextFromItem(item, currentValue);
      } else {
        return "";
      }
    };
    return BasePicker2;
  }(React__namespace.Component)
);
(function(_super) {
  __extends(BasePickerListBelow, _super);
  function BasePickerListBelow() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  BasePickerListBelow.prototype.render = function() {
    var _a2 = this.state, suggestedDisplayValue = _a2.suggestedDisplayValue, isFocused = _a2.isFocused;
    var _b2 = this.props, className = _b2.className, inputProps = _b2.inputProps, disabled = _b2.disabled, selectionAriaLabel = _b2.selectionAriaLabel, _c2 = _b2.selectionRole, selectionRole = _c2 === void 0 ? "list" : _c2, theme = _b2.theme, styles2 = _b2.styles;
    var suggestionsVisible = !!this.state.suggestionsVisible;
    var suggestionsAvailable2 = suggestionsVisible ? this._ariaMap.suggestionList : void 0;
    var classNames2 = styles2 ? getClassNames$9(styles2, {
      theme,
      className,
      isFocused,
      inputClassName: inputProps && inputProps.className
    }) : {
      root: css$3("ms-BasePicker", legacyStyles.picker, className ? className : ""),
      text: css$3("ms-BasePicker-text", legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused, disabled && legacyStyles.inputDisabled),
      itemsWrapper: legacyStyles.pickerItems,
      input: css$3("ms-BasePicker-input", legacyStyles.pickerInput, inputProps && inputProps.className),
      screenReaderText: legacyStyles.screenReaderOnly
    };
    var comboLabel = this.props["aria-label"] || (inputProps === null || inputProps === void 0 ? void 0 : inputProps["aria-label"]);
    return React__namespace.createElement(
      "div",
      { ref: this.root, onBlur: this.onBlur, onFocus: this.onFocus },
      React__namespace.createElement(
        "div",
        { className: classNames2.root, onKeyDown: this.onKeyDown },
        this.renderCustomAlert(classNames2.screenReaderText),
        React__namespace.createElement("span", { id: this._ariaMap.selectedItems + "-label", hidden: true }, selectionAriaLabel || comboLabel),
        React__namespace.createElement(
          "div",
          { className: classNames2.text, "aria-owns": suggestionsAvailable2 },
          React__namespace.createElement(Autofill, __assign$1({}, inputProps, { className: classNames2.input, componentRef: this.input, onFocus: this.onInputFocus, onBlur: this.onInputBlur, onClick: this.onClick, onInputValueChange: this.onInputChange, suggestedDisplayValue, "aria-activedescendant": suggestionsVisible ? this.getActiveDescendant() : void 0, "aria-controls": suggestionsAvailable2, "aria-expanded": suggestionsVisible, "aria-haspopup": "listbox", "aria-label": comboLabel, "aria-describedby": this.state.items.length > 0 ? this._ariaMap.selectedItems : void 0, role: "combobox", id: (inputProps === null || inputProps === void 0 ? void 0 : inputProps.id) ? inputProps.id : this._ariaMap.combobox, disabled, onInputChange: this.props.onInputChange }))
        )
      ),
      this.renderSuggestions(),
      React__namespace.createElement(
        SelectionZone,
        { selection: this.selection, selectionMode: SelectionMode.single },
        React__namespace.createElement("div", {
          id: this._ariaMap.selectedItems,
          className: "ms-BasePicker-selectedItems",
          role: selectionRole,
          "aria-labelledby": this._ariaMap.selectedItems + "-label"
        }, this.renderItems())
      )
    );
  };
  BasePickerListBelow.prototype.onBackspace = function(ev) {
  };
  return BasePickerListBelow;
})(BasePicker);
var GlobalClassNames$9 = {
  root: "ms-BasePicker",
  text: "ms-BasePicker-text",
  itemsWrapper: "ms-BasePicker-itemsWrapper",
  input: "ms-BasePicker-input"
};
function getStyles$9(props) {
  var _a2, _b2, _c2;
  var className = props.className, theme = props.theme, isFocused = props.isFocused, inputClassName = props.inputClassName, disabled = props.disabled;
  if (!theme) {
    throw new Error("theme is undefined or null in base BasePicker getStyles function.");
  }
  var semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
  var inputBorder = semanticColors.inputBorder, inputBorderHovered = semanticColors.inputBorderHovered, inputFocusBorderAlt = semanticColors.inputFocusBorderAlt;
  var classNames2 = getGlobalClassNames(GlobalClassNames$9, theme);
  var placeholderStyles = [
    fonts.medium,
    {
      color: semanticColors.inputPlaceholderText,
      opacity: 1,
      selectors: (_a2 = {}, _a2[HighContrastSelector] = {
        color: "GrayText"
      }, _a2)
    }
  ];
  var disabledPlaceholderStyles = {
    color: semanticColors.disabledText,
    selectors: (_b2 = {}, _b2[HighContrastSelector] = {
      color: "GrayText"
    }, _b2)
  };
  var disabledOverlayColor = "rgba(218, 218, 218, 0.29)";
  return {
    root: [classNames2.root, className, { position: "relative" }],
    text: [
      classNames2.text,
      {
        display: "flex",
        position: "relative",
        flexWrap: "wrap",
        alignItems: "center",
        boxSizing: "border-box",
        minWidth: 180,
        minHeight: 30,
        border: "1px solid " + inputBorder,
        borderRadius: effects.roundedCorner2
      },
      !isFocused && !disabled && {
        selectors: {
          ":hover": {
            borderColor: inputBorderHovered
          }
        }
      },
      isFocused && !disabled && getInputFocusStyle(inputFocusBorderAlt, effects.roundedCorner2),
      disabled && {
        borderColor: disabledOverlayColor,
        selectors: (_c2 = {
          ":after": {
            content: '""',
            position: "absolute",
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            background: disabledOverlayColor
          }
        }, _c2[HighContrastSelector] = {
          borderColor: "GrayText",
          selectors: {
            ":after": {
              background: "none"
            }
          }
        }, _c2)
      }
    ],
    itemsWrapper: [
      classNames2.itemsWrapper,
      {
        display: "flex",
        flexWrap: "wrap",
        maxWidth: "100%"
      }
    ],
    input: [
      classNames2.input,
      fonts.medium,
      {
        height: 30,
        border: "none",
        flexGrow: 1,
        outline: "none",
        padding: "0 6px 0",
        alignSelf: "flex-end",
        borderRadius: effects.roundedCorner2,
        backgroundColor: "transparent",
        color: semanticColors.inputText,
        selectors: {
          "::-ms-clear": {
            display: "none"
          },
          "&:placeholder-shown": {
            textOverflow: "ellipsis"
          }
        }
      },
      getPlaceholderStyles(placeholderStyles),
      disabled && getPlaceholderStyles(disabledPlaceholderStyles),
      inputClassName
    ],
    screenReaderText: hiddenContentStyle
  };
}
var GlobalClassNames$8 = {
  root: "ms-TagItem",
  text: "ms-TagItem-text",
  close: "ms-TagItem-close",
  isSelected: "is-selected"
};
var TAG_HEIGHT = 26;
function getStyles$8(props) {
  var _a2, _b2, _c2, _d2, _e2;
  var className = props.className, theme = props.theme, selected = props.selected, disabled = props.disabled;
  var palette = theme.palette, effects = theme.effects, fonts = theme.fonts, semanticColors = theme.semanticColors;
  var classNames2 = getGlobalClassNames(GlobalClassNames$8, theme);
  return {
    root: [
      classNames2.root,
      fonts.medium,
      getFocusStyle(theme),
      {
        boxSizing: "content-box",
        flexShrink: "1",
        margin: 2,
        height: TAG_HEIGHT,
        lineHeight: TAG_HEIGHT,
        cursor: "default",
        userSelect: "none",
        display: "flex",
        flexWrap: "nowrap",
        maxWidth: 300,
        minWidth: 0,
        borderRadius: effects.roundedCorner2,
        color: semanticColors.inputText,
        background: palette.neutralLighter,
        selectors: (_a2 = {
          ":hover": [
            !disabled && !selected && {
              color: palette.neutralDark,
              background: palette.neutralLight,
              selectors: {
                ".ms-TagItem-close": {
                  color: palette.neutralPrimary
                }
              }
            },
            disabled && { background: palette.neutralLighter }
          ]
        }, _a2[HighContrastSelector] = {
          border: "1px solid " + (!selected ? "WindowText" : "WindowFrame")
        }, _a2)
      },
      disabled && {
        selectors: (_b2 = {}, _b2[HighContrastSelector] = {
          borderColor: "GrayText"
        }, _b2)
      },
      selected && !disabled && [
        classNames2.isSelected,
        {
          background: palette.themePrimary,
          color: palette.white
        }
      ],
      className
    ],
    text: [
      classNames2.text,
      {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        minWidth: 30,
        margin: "0 8px"
      },
      disabled && {
        selectors: (_c2 = {}, _c2[HighContrastSelector] = {
          color: "GrayText"
        }, _c2)
      }
    ],
    close: [
      classNames2.close,
      getFocusStyle(theme, { borderColor: "transparent", inset: 1, outlineColor: palette.white }),
      {
        color: palette.neutralSecondary,
        width: 30,
        height: "100%",
        flex: "0 0 auto",
        borderRadius: getRTL(theme) ? effects.roundedCorner2 + " 0 0 " + effects.roundedCorner2 : "0 " + effects.roundedCorner2 + " " + effects.roundedCorner2 + " 0",
        selectors: (_d2 = {
          ":hover": {
            background: palette.neutralQuaternaryAlt,
            color: palette.neutralPrimary
          }
        }, _d2["." + classNames2.isSelected + " &, :focus"] = {
          color: palette.white,
          background: palette.themePrimary
        }, _d2[":focus:hover"] = {
          color: palette.white,
          background: palette.themeDark
        }, _d2[":active"] = {
          color: palette.white,
          backgroundColor: palette.themeDark
        }, _d2)
      },
      disabled && {
        selectors: (_e2 = {}, _e2["." + ButtonGlobalClassNames.msButtonIcon] = {
          color: palette.neutralSecondary
        }, _e2)
      }
    ]
  };
}
var getClassNames$8 = classNamesFunction();
var TagItemBase = function(props) {
  var theme = props.theme, styles2 = props.styles, selected = props.selected, disabled = props.disabled, enableTagFocusInDisabledPicker = props.enableTagFocusInDisabledPicker, children = props.children, className = props.className, index2 = props.index, onRemoveItem = props.onRemoveItem, removeButtonAriaLabel = props.removeButtonAriaLabel, _a2 = props.title, title = _a2 === void 0 ? typeof props.children === "string" ? props.children : props.item.name : _a2, removeButtonIconProps = props.removeButtonIconProps;
  var buttonRef = React__namespace.createRef();
  var handleClick = function() {
    var _a3;
    (_a3 = buttonRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus();
  };
  var classNames2 = getClassNames$8(styles2, {
    theme,
    className,
    selected,
    disabled
  });
  var itemId = useId();
  var disabledAttrs = enableTagFocusInDisabledPicker ? {
    "aria-disabled": disabled,
    tabindex: 0
  } : {
    disabled
  };
  return React__namespace.createElement(
    "div",
    { "data-selection-index": index2, className: classNames2.root, role: "listitem", key: index2, onClick: handleClick },
    React__namespace.createElement("span", { className: classNames2.text, title, id: itemId + "-text" }, children),
    React__namespace.createElement(IconButton, __assign$1({ componentRef: buttonRef, id: itemId, onClick: onRemoveItem }, disabledAttrs, { iconProps: removeButtonIconProps !== null && removeButtonIconProps !== void 0 ? removeButtonIconProps : { iconName: "Cancel" }, styles: { icon: { fontSize: "12px" } }, className: classNames2.close, "aria-labelledby": itemId + "-removeLabel " + itemId + "-text" })),
    React__namespace.createElement("span", { id: itemId + "-removeLabel", hidden: true }, removeButtonAriaLabel)
  );
};
var TagItem = styled(TagItemBase, getStyles$8, void 0, {
  scope: "TagItem"
});
var GlobalClassNames$7 = {
  suggestionTextOverflow: "ms-TagItem-TextOverflow"
};
function getStyles$7(props) {
  var className = props.className, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames$7, theme);
  return {
    suggestionTextOverflow: [
      classNames2.suggestionTextOverflow,
      {
        overflow: "hidden",
        textOverflow: "ellipsis",
        maxWidth: "60vw",
        padding: "6px 12px 7px",
        whiteSpace: "nowrap"
      },
      className
    ]
  };
}
var getClassNames$7 = classNamesFunction();
var TagItemSuggestionBase = function(props) {
  var styles2 = props.styles, theme = props.theme, children = props.children;
  var classNames2 = getClassNames$7(styles2, {
    theme
  });
  return React__namespace.createElement(
    "div",
    { className: classNames2.suggestionTextOverflow },
    " ",
    children,
    " "
  );
};
var TagItemSuggestion = styled(TagItemSuggestionBase, getStyles$7, void 0, { scope: "TagItemSuggestion" });
var TagPickerBase = (
  /** @class */
  function(_super) {
    __extends(TagPickerBase2, _super);
    function TagPickerBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TagPickerBase2.defaultProps = {
      onRenderItem: function(props) {
        return React__namespace.createElement(TagItem, __assign$1({}, props), props.item.name);
      },
      onRenderSuggestionsItem: function(props) {
        return React__namespace.createElement(TagItemSuggestion, null, props.name);
      }
    };
    return TagPickerBase2;
  }(BasePicker)
);
var TagPicker = styled(TagPickerBase, getStyles$9, void 0, {
  scope: "TagPicker"
});
var GlobalClassNames$6 = {
  host: "ms-HoverCard-host"
};
function getStyles$6(props) {
  var className = props.className, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames$6, theme);
  return {
    host: [classNames2.host, className]
  };
}
var OpenCardMode;
(function(OpenCardMode2) {
  OpenCardMode2[OpenCardMode2["hover"] = 0] = "hover";
  OpenCardMode2[OpenCardMode2["hotKey"] = 1] = "hotKey";
})(OpenCardMode || (OpenCardMode = {}));
var HoverCardType;
(function(HoverCardType2) {
  HoverCardType2["plain"] = "PlainCard";
  HoverCardType2["expanding"] = "ExpandingCard";
})(HoverCardType || (HoverCardType = {}));
var GlobalClassNames$5 = {
  root: "ms-ExpandingCard-root",
  compactCard: "ms-ExpandingCard-compactCard",
  expandedCard: "ms-ExpandingCard-expandedCard",
  expandedCardScroll: "ms-ExpandingCard-expandedCardScrollRegion"
};
function getStyles$5(props) {
  var _a2;
  var theme = props.theme, needsScroll = props.needsScroll, expandedCardFirstFrameRendered = props.expandedCardFirstFrameRendered, compactCardHeight = props.compactCardHeight, expandedCardHeight = props.expandedCardHeight, className = props.className;
  var palette = theme.palette;
  var classNames2 = getGlobalClassNames(GlobalClassNames$5, theme);
  return {
    root: [
      classNames2.root,
      {
        width: 320,
        pointerEvents: "none",
        selectors: (_a2 = {}, _a2[HighContrastSelector] = {
          border: "1px solid WindowText"
        }, _a2)
      },
      className
    ],
    compactCard: [
      classNames2.compactCard,
      {
        pointerEvents: "auto",
        position: "relative",
        height: compactCardHeight
      }
    ],
    expandedCard: [
      classNames2.expandedCard,
      {
        height: 1,
        overflowY: "hidden",
        pointerEvents: "auto",
        transition: "height 0.467s cubic-bezier(0.5, 0, 0, 1)",
        selectors: {
          ":before": {
            content: '""',
            position: "relative",
            display: "block",
            top: 0,
            left: 24,
            width: 272,
            height: 1,
            backgroundColor: palette.neutralLighter
          }
        }
      },
      expandedCardFirstFrameRendered && {
        height: expandedCardHeight
      }
    ],
    expandedCardScroll: [
      classNames2.expandedCardScroll,
      needsScroll && {
        height: "100%",
        boxSizing: "border-box",
        overflowY: "auto"
      }
    ]
  };
}
var ExpandingCardMode;
(function(ExpandingCardMode2) {
  ExpandingCardMode2[ExpandingCardMode2["compact"] = 0] = "compact";
  ExpandingCardMode2[ExpandingCardMode2["expanded"] = 1] = "expanded";
})(ExpandingCardMode || (ExpandingCardMode = {}));
var CardCallout = function(props) {
  var _a2 = props.gapSpace, gapSpace = _a2 === void 0 ? 0 : _a2, _b2 = props.directionalHint, directionalHint = _b2 === void 0 ? DirectionalHint.bottomLeftEdge : _b2, directionalHintFixed = props.directionalHintFixed, targetElement = props.targetElement, firstFocus = props.firstFocus, trapFocus = props.trapFocus, onLeave = props.onLeave, className = props.className, finalHeight = props.finalHeight, content = props.content, calloutProps = props.calloutProps;
  var mergedCalloutProps = __assign$1(__assign$1(__assign$1({}, getNativeProps(props, divProperties)), { className, target: targetElement, isBeakVisible: false, directionalHint, directionalHintFixed, finalHeight, minPagePadding: 24, onDismiss: onLeave, gapSpace }), calloutProps);
  return React__namespace.createElement(React__namespace.Fragment, null, trapFocus ? React__namespace.createElement(FocusTrapCallout, __assign$1({}, mergedCalloutProps, { focusTrapProps: {
    forceFocusInsideTrap: false,
    isClickableOutsideFocusTrap: true,
    disableFirstFocus: !firstFocus
  } }), content) : React__namespace.createElement(Callout, __assign$1({}, mergedCalloutProps), content));
};
var getClassNames$6 = classNamesFunction();
var ExpandingCardBase = (
  /** @class */
  function(_super) {
    __extends(ExpandingCardBase2, _super);
    function ExpandingCardBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._expandedElem = React__namespace.createRef();
      _this._onKeyDown = function(ev) {
        if (ev.which === KeyCodes.escape) {
          _this.props.onLeave && _this.props.onLeave(ev);
        }
      };
      _this._onRenderCompactCard = function() {
        return React__namespace.createElement("div", { className: _this._classNames.compactCard }, _this.props.onRenderCompactCard(_this.props.renderData));
      };
      _this._onRenderExpandedCard = function() {
        !_this.state.firstFrameRendered && _this._async.requestAnimationFrame(function() {
          _this.setState({
            firstFrameRendered: true
          });
        });
        return React__namespace.createElement(
          "div",
          { className: _this._classNames.expandedCard, ref: _this._expandedElem },
          React__namespace.createElement("div", { className: _this._classNames.expandedCardScroll }, _this.props.onRenderExpandedCard && _this.props.onRenderExpandedCard(_this.props.renderData))
        );
      };
      _this._checkNeedsScroll = function() {
        var expandedCardHeight = _this.props.expandedCardHeight;
        _this._async.requestAnimationFrame(function() {
          if (_this._expandedElem.current && _this._expandedElem.current.scrollHeight >= expandedCardHeight) {
            _this.setState({
              needsScroll: true
            });
          }
        });
      };
      _this._async = new Async(_this);
      initializeComponentRef(_this);
      _this.state = {
        firstFrameRendered: false,
        needsScroll: false
      };
      return _this;
    }
    ExpandingCardBase2.prototype.componentDidMount = function() {
      this._checkNeedsScroll();
    };
    ExpandingCardBase2.prototype.componentWillUnmount = function() {
      this._async.dispose();
    };
    ExpandingCardBase2.prototype.render = function() {
      var _a2 = this.props, styles2 = _a2.styles, compactCardHeight = _a2.compactCardHeight, expandedCardHeight = _a2.expandedCardHeight, theme = _a2.theme, mode = _a2.mode, className = _a2.className;
      var _b2 = this.state, needsScroll = _b2.needsScroll, firstFrameRendered = _b2.firstFrameRendered;
      var finalHeight = compactCardHeight + expandedCardHeight;
      this._classNames = getClassNames$6(styles2, {
        theme,
        compactCardHeight,
        className,
        expandedCardHeight,
        needsScroll,
        expandedCardFirstFrameRendered: mode === ExpandingCardMode.expanded && firstFrameRendered
      });
      var content = React__namespace.createElement(
        "div",
        { onMouseEnter: this.props.onEnter, onMouseLeave: this.props.onLeave, onKeyDown: this._onKeyDown },
        this._onRenderCompactCard(),
        this._onRenderExpandedCard()
      );
      return React__namespace.createElement(CardCallout, __assign$1({}, this.props, { content, finalHeight, className: this._classNames.root }));
    };
    ExpandingCardBase2.defaultProps = {
      compactCardHeight: 156,
      expandedCardHeight: 384,
      directionalHintFixed: true
    };
    return ExpandingCardBase2;
  }(React__namespace.Component)
);
var ExpandingCard = styled(ExpandingCardBase, getStyles$5, void 0, {
  scope: "ExpandingCard"
});
var GlobalClassNames$4 = {
  root: "ms-PlainCard-root"
};
function getStyles$4(props) {
  var _a2;
  var theme = props.theme, className = props.className;
  var classNames2 = getGlobalClassNames(GlobalClassNames$4, theme);
  return {
    root: [
      classNames2.root,
      {
        pointerEvents: "auto",
        selectors: (_a2 = {}, _a2[HighContrastSelector] = {
          border: "1px solid WindowText"
        }, _a2)
      },
      className
    ]
  };
}
var getClassNames$5 = classNamesFunction();
var PlainCardBase = (
  /** @class */
  function(_super) {
    __extends(PlainCardBase2, _super);
    function PlainCardBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._onKeyDown = function(ev) {
        if (ev.which === KeyCodes.escape) {
          _this.props.onLeave && _this.props.onLeave(ev);
        }
      };
      initializeComponentRef(_this);
      return _this;
    }
    PlainCardBase2.prototype.render = function() {
      var _a2 = this.props, styles2 = _a2.styles, theme = _a2.theme, className = _a2.className;
      this._classNames = getClassNames$5(styles2, {
        theme,
        className
      });
      var content = React__namespace.createElement("div", { onMouseEnter: this.props.onEnter, onMouseLeave: this.props.onLeave, onKeyDown: this._onKeyDown }, this.props.onRenderPlainCard(this.props.renderData));
      return React__namespace.createElement(CardCallout, __assign$1({}, this.props, { content, className: this._classNames.root }));
    };
    return PlainCardBase2;
  }(React__namespace.Component)
);
var PlainCard = styled(PlainCardBase, getStyles$4, void 0, {
  scope: "PlainCard"
});
var getClassNames$4 = classNamesFunction();
var HoverCardBase = (
  /** @class */
  function(_super) {
    __extends(HoverCardBase2, _super);
    function HoverCardBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._hoverCard = React__namespace.createRef();
      _this.dismiss = function(withTimeOut) {
        _this._async.clearTimeout(_this._openTimerId);
        _this._async.clearTimeout(_this._dismissTimerId);
        if (!withTimeOut) {
          _this._setDismissedState();
        } else {
          _this._dismissTimerId = _this._async.setTimeout(function() {
            _this._setDismissedState();
          }, _this.props.cardDismissDelay);
        }
      };
      _this._cardOpen = function(ev) {
        if (_this._shouldBlockHoverCard() || ev.type === "keydown" && !(ev.which === _this.props.openHotKey)) {
          return;
        }
        _this._async.clearTimeout(_this._dismissTimerId);
        if (ev.type === "mouseenter") {
          _this._currentMouseTarget = ev.currentTarget;
        }
        _this._executeCardOpen(ev);
      };
      _this._executeCardOpen = function(ev) {
        _this._async.clearTimeout(_this._openTimerId);
        _this._openTimerId = _this._async.setTimeout(function() {
          _this.setState(function(prevState) {
            if (!prevState.isHoverCardVisible) {
              return {
                isHoverCardVisible: true,
                mode: ExpandingCardMode.compact,
                openMode: ev.type === "keydown" ? OpenCardMode.hotKey : OpenCardMode.hover
              };
            }
            return prevState;
          });
        }, _this.props.cardOpenDelay);
      };
      _this._cardDismiss = function(isNativeEvent, ev) {
        if (isNativeEvent) {
          if (!(ev instanceof MouseEvent)) {
            return;
          }
          if (ev.type === "keydown" && ev.which !== KeyCodes.escape) {
            return;
          }
          if (!_this.props.sticky && (_this._currentMouseTarget === ev.currentTarget || ev.which === KeyCodes.escape)) {
            _this.dismiss(true);
          }
        } else {
          if (_this.props.sticky && !(ev instanceof MouseEvent) && ev.nativeEvent instanceof MouseEvent && ev.type === "mouseleave") {
            return;
          }
          _this.dismiss(true);
        }
      };
      _this._setDismissedState = function() {
        _this.setState({
          isHoverCardVisible: false,
          mode: ExpandingCardMode.compact,
          openMode: OpenCardMode.hover
        });
      };
      _this._instantOpenAsExpanded = function(ev) {
        _this._async.clearTimeout(_this._dismissTimerId);
        _this.setState(function(prevState) {
          if (!prevState.isHoverCardVisible) {
            return {
              isHoverCardVisible: true,
              mode: ExpandingCardMode.expanded
            };
          }
          return prevState;
        });
      };
      _this._setEventListeners = function() {
        var _a2 = _this.props, trapFocus = _a2.trapFocus, instantOpenOnClick = _a2.instantOpenOnClick, eventListenerTarget = _a2.eventListenerTarget;
        var target = eventListenerTarget ? _this._getTargetElement(eventListenerTarget) : _this._getTargetElement(_this.props.target);
        var nativeEventDismiss = _this._nativeDismissEvent;
        if (target) {
          _this._events.on(target, "mouseenter", _this._cardOpen);
          _this._events.on(target, "mouseleave", nativeEventDismiss);
          if (trapFocus) {
            _this._events.on(target, "keydown", _this._cardOpen);
          } else {
            _this._events.on(target, "focus", _this._cardOpen);
            _this._events.on(target, "blur", nativeEventDismiss);
          }
          if (instantOpenOnClick) {
            _this._events.on(target, "click", _this._instantOpenAsExpanded);
          } else {
            _this._events.on(target, "mousedown", nativeEventDismiss);
            _this._events.on(target, "keydown", nativeEventDismiss);
          }
        }
      };
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      _this._nativeDismissEvent = _this._cardDismiss.bind(_this, true);
      _this._childDismissEvent = _this._cardDismiss.bind(_this, false);
      _this.state = {
        isHoverCardVisible: false,
        mode: ExpandingCardMode.compact,
        openMode: OpenCardMode.hover
      };
      return _this;
    }
    HoverCardBase2.prototype.componentDidMount = function() {
      this._setEventListeners();
    };
    HoverCardBase2.prototype.componentWillUnmount = function() {
      this._async.dispose();
      this._events.dispose();
    };
    HoverCardBase2.prototype.componentDidUpdate = function(prevProps, prevState) {
      var _this = this;
      if (prevProps.target !== this.props.target) {
        this._events.off();
        this._setEventListeners();
      }
      if (prevState.isHoverCardVisible !== this.state.isHoverCardVisible) {
        if (this.state.isHoverCardVisible) {
          this._async.setTimeout(function() {
            _this.setState({
              mode: ExpandingCardMode.expanded
            }, function() {
              _this.props.onCardExpand && _this.props.onCardExpand();
            });
          }, this.props.expandedCardOpenDelay);
          this.props.onCardVisible && this.props.onCardVisible();
        } else {
          this.setState({
            mode: ExpandingCardMode.compact
          });
          this.props.onCardHide && this.props.onCardHide();
        }
      }
    };
    HoverCardBase2.prototype.render = function() {
      var _a2 = this.props, expandingCardProps = _a2.expandingCardProps, children = _a2.children, id = _a2.id, _b2 = _a2.setAriaDescribedBy, setAriaDescribedBy = _b2 === void 0 ? true : _b2, customStyles = _a2.styles, theme = _a2.theme, className = _a2.className, type = _a2.type, plainCardProps = _a2.plainCardProps, trapFocus = _a2.trapFocus, setInitialFocus = _a2.setInitialFocus;
      var _c2 = this.state, isHoverCardVisible = _c2.isHoverCardVisible, mode = _c2.mode, openMode = _c2.openMode;
      var hoverCardId = id || getId("hoverCard");
      this._classNames = getClassNames$4(customStyles, {
        theme,
        className
      });
      var commonCardProps = __assign$1(__assign$1({}, getNativeProps(this.props, divProperties)), { id: hoverCardId, trapFocus: !!trapFocus, firstFocus: setInitialFocus || openMode === OpenCardMode.hotKey, targetElement: this._getTargetElement(this.props.target), onEnter: this._cardOpen, onLeave: this._childDismissEvent });
      var finalExpandedCardProps = __assign$1(__assign$1(__assign$1({}, expandingCardProps), commonCardProps), { mode });
      var finalPlainCardProps = __assign$1(__assign$1({}, plainCardProps), commonCardProps);
      return React__namespace.createElement(
        "div",
        { className: this._classNames.host, ref: this._hoverCard, "aria-describedby": setAriaDescribedBy && isHoverCardVisible ? hoverCardId : void 0, "data-is-focusable": !this.props.target },
        children,
        isHoverCardVisible && (type === HoverCardType.expanding ? React__namespace.createElement(ExpandingCard, __assign$1({}, finalExpandedCardProps)) : React__namespace.createElement(PlainCard, __assign$1({}, finalPlainCardProps)))
      );
    };
    HoverCardBase2.prototype._getTargetElement = function(target) {
      switch (typeof target) {
        case "string":
          return getDocument().querySelector(target);
        case "object":
          return target;
        default:
          return this._hoverCard.current || void 0;
      }
    };
    HoverCardBase2.prototype._shouldBlockHoverCard = function() {
      return !!(this.props.shouldBlockHoverCard && this.props.shouldBlockHoverCard());
    };
    HoverCardBase2.defaultProps = {
      cardOpenDelay: 500,
      cardDismissDelay: 100,
      expandedCardOpenDelay: 1500,
      instantOpenOnClick: false,
      setInitialFocus: false,
      openHotKey: KeyCodes.c,
      type: HoverCardType.expanding
    };
    return HoverCardBase2;
  }(React__namespace.Component)
);
var HoverCard = styled(HoverCardBase, getStyles$6, void 0, {
  scope: "HoverCard"
});
function initializeIcons$j(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons"',
      src: "url('" + baseUrl + "fabric-icons-a13498cf.woff') format('woff')"
    },
    icons: {
      GlobalNavButton: "",
      ChevronDown: "",
      ChevronUp: "",
      Edit: "",
      Add: "",
      Cancel: "",
      More: "",
      Settings: "",
      Mail: "",
      Filter: "",
      Search: "",
      Share: "",
      BlockedSite: "",
      FavoriteStar: "",
      FavoriteStarFill: "",
      CheckMark: "",
      Delete: "",
      ChevronLeft: "",
      ChevronRight: "",
      Calendar: "",
      Megaphone: "",
      Undo: "",
      Flag: "",
      Page: "",
      Pinned: "",
      View: "",
      Clear: "",
      Download: "",
      Upload: "",
      Folder: "",
      Sort: "",
      AlignRight: "",
      AlignLeft: "",
      Tag: "",
      AddFriend: "",
      Info: "",
      SortLines: "",
      List: "",
      CircleRing: "",
      Heart: "",
      HeartFill: "",
      Tiles: "",
      Embed: "",
      Glimmer: "",
      Ascending: "",
      Descending: "",
      SortUp: "",
      SortDown: "",
      SyncToPC: "",
      LargeGrid: "",
      SkypeCheck: "",
      SkypeClock: "",
      SkypeMinus: "",
      ClearFilter: "",
      Flow: "",
      StatusCircleCheckmark: "",
      MoreVertical: ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$i(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-0"',
      src: "url('" + baseUrl + "fabric-icons-0-467ee27f.woff') format('woff')"
    },
    icons: {
      "PageLink": "",
      "CommentSolid": "",
      "ChangeEntitlements": "",
      "Installation": "",
      "WebAppBuilderModule": "",
      "WebAppBuilderFragment": "",
      "WebAppBuilderSlot": "",
      "BullseyeTargetEdit": "",
      "WebAppBuilderFragmentCreate": "",
      "PageData": "",
      "PageHeaderEdit": "",
      "ProductList": "",
      "UnpublishContent": "",
      "DependencyAdd": "",
      "DependencyRemove": "",
      "EntitlementPolicy": "",
      "EntitlementRedemption": "",
      "SchoolDataSyncLogo": "",
      "PinSolid12": "",
      "PinSolidOff12": "",
      "AddLink": "",
      "SharepointAppIcon16": "",
      "DataflowsLink": "",
      "TimePicker": "",
      "UserWarning": "",
      "ComplianceAudit": "",
      "InternetSharing": "",
      "Brightness": "",
      "MapPin": "",
      "Airplane": "",
      "Tablet": "",
      "QuickNote": "",
      "Video": "",
      "People": "",
      "Phone": "",
      "Pin": "",
      "Shop": "",
      "Stop": "",
      "Link": "",
      "AllApps": "",
      "Zoom": "",
      "ZoomOut": "",
      "Microphone": "",
      "Camera": "",
      "Attach": "",
      "Send": "",
      "FavoriteList": "",
      "PageSolid": "",
      "Forward": "",
      "Back": "",
      "Refresh": "",
      "Lock": "",
      "ReportHacked": "",
      "EMI": "",
      "MiniLink": "",
      "Blocked": "",
      "ReadingMode": "",
      "Favicon": "",
      "Remove": "",
      "Checkbox": "",
      "CheckboxComposite": "",
      "CheckboxFill": "",
      "CheckboxIndeterminate": "",
      "CheckboxCompositeReversed": "",
      "BackToWindow": "",
      "FullScreen": "",
      "Print": "",
      "Up": "",
      "Down": "",
      "OEM": "",
      "Save": "",
      "ReturnKey": "",
      "Cloud": "",
      "Flashlight": "",
      "CommandPrompt": "",
      "Sad": "",
      "RealEstate": "",
      "SIPMove": "",
      "EraseTool": "",
      "GripperTool": "",
      "Dialpad": "",
      "PageLeft": "",
      "PageRight": "",
      "MultiSelect": "",
      "KeyboardClassic": "",
      "Play": "",
      "Pause": "",
      "InkingTool": "",
      "Emoji2": "",
      "GripperBarHorizontal": "",
      "System": "",
      "Personalize": "",
      "SearchAndApps": "",
      "Globe": "",
      "EaseOfAccess": "",
      "ContactInfo": "",
      "Unpin": "",
      "Contact": "",
      "Memo": "",
      "IncomingCall": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$h(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-1"',
      src: "url('" + baseUrl + "fabric-icons-1-4d521695.woff') format('woff')"
    },
    icons: {
      "Paste": "",
      "WindowsLogo": "",
      "Error": "",
      "GripperBarVertical": "",
      "Unlock": "",
      "Slideshow": "",
      "Trim": "",
      "AutoEnhanceOn": "",
      "AutoEnhanceOff": "",
      "Color": "",
      "SaveAs": "",
      "Light": "",
      "Filters": "",
      "AspectRatio": "",
      "Contrast": "",
      "Redo": "",
      "Crop": "",
      "PhotoCollection": "",
      "Album": "",
      "Rotate": "",
      "PanoIndicator": "",
      "Translate": "",
      "RedEye": "",
      "ViewOriginal": "",
      "ThumbnailView": "",
      "Package": "",
      "Telemarketer": "",
      "Warning": "",
      "Financial": "",
      "Education": "",
      "ShoppingCart": "",
      "Train": "",
      "Move": "",
      "TouchPointer": "",
      "Merge": "",
      "TurnRight": "",
      "Ferry": "",
      "Highlight": "",
      "PowerButton": "",
      "Tab": "",
      "Admin": "",
      "TVMonitor": "",
      "Speakers": "",
      "Game": "",
      "HorizontalTabKey": "",
      "UnstackSelected": "",
      "StackIndicator": "",
      "Nav2DMapView": "",
      "StreetsideSplitMinimize": "",
      "Car": "",
      "Bus": "",
      "EatDrink": "",
      "SeeDo": "",
      "LocationCircle": "",
      "Home": "",
      "SwitcherStartEnd": "",
      "ParkingLocation": "",
      "IncidentTriangle": "",
      "Touch": "",
      "MapDirections": "",
      "CaretHollow": "",
      "CaretSolid": "",
      "History": "",
      "Location": "",
      "MapLayers": "",
      "SearchNearby": "",
      "Work": "",
      "Recent": "",
      "Hotel": "",
      "Bank": "",
      "LocationDot": "",
      "Dictionary": "",
      "ChromeBack": "",
      "FolderOpen": "",
      "PinnedFill": "",
      "RevToggleKey": "",
      "USB": "",
      "Previous": "",
      "Next": "",
      "Sync": "",
      "Help": "",
      "Emoji": "",
      "MailForward": "",
      "ClosePane": "",
      "OpenPane": "",
      "PreviewLink": "",
      "ZoomIn": "",
      "Bookmarks": "",
      "Document": "",
      "ProtectedDocument": "",
      "OpenInNewWindow": "",
      "MailFill": "",
      "ViewAll": "",
      "Switch": "",
      "Rename": "",
      "Go": "",
      "Remote": "",
      "SelectAll": "",
      "Orientation": "",
      "Import": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$g(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-2"',
      src: "url('" + baseUrl + "fabric-icons-2-63c99abf.woff') format('woff')"
    },
    icons: {
      "Picture": "",
      "ChromeClose": "",
      "ShowResults": "",
      "Message": "",
      "CalendarDay": "",
      "CalendarWeek": "",
      "MailReplyAll": "",
      "Read": "",
      "Cut": "",
      "PaymentCard": "",
      "Copy": "",
      "Important": "",
      "MailReply": "",
      "GotoToday": "",
      "Font": "",
      "FontColor": "",
      "FolderFill": "",
      "Permissions": "",
      "DisableUpdates": "",
      "Unfavorite": "",
      "Italic": "",
      "Underline": "",
      "Bold": "",
      "MoveToFolder": "",
      "Dislike": "",
      "Like": "",
      "AlignCenter": "",
      "OpenFile": "",
      "ClearSelection": "",
      "FontDecrease": "",
      "FontIncrease": "",
      "FontSize": "",
      "CellPhone": "",
      "RepeatOne": "",
      "RepeatAll": "",
      "Calculator": "",
      "Library": "",
      "PostUpdate": "",
      "NewFolder": "",
      "CalendarReply": "",
      "UnsyncFolder": "",
      "SyncFolder": "",
      "BlockContact": "",
      "Accept": "",
      "BulletedList": "",
      "Preview": "",
      "News": "",
      "Chat": "",
      "Group": "",
      "World": "",
      "Comment": "",
      "DockLeft": "",
      "DockRight": "",
      "Repair": "",
      "Accounts": "",
      "Street": "",
      "RadioBullet": "",
      "Stopwatch": "",
      "Clock": "",
      "WorldClock": "",
      "AlarmClock": "",
      "Photo": "",
      "ActionCenter": "",
      "Hospital": "",
      "Timer": "",
      "FullCircleMask": "",
      "LocationFill": "",
      "ChromeMinimize": "",
      "ChromeRestore": "",
      "Annotation": "",
      "Fingerprint": "",
      "Handwriting": "",
      "ChromeFullScreen": "",
      "Completed": "",
      "Label": "",
      "FlickDown": "",
      "FlickUp": "",
      "FlickLeft": "",
      "FlickRight": "",
      "MiniExpand": "",
      "MiniContract": "",
      "Streaming": "",
      "MusicInCollection": "",
      "OneDriveLogo": "",
      "CompassNW": "",
      "Code": "",
      "LightningBolt": "",
      "CalculatorMultiply": "",
      "CalculatorAddition": "",
      "CalculatorSubtract": "",
      "CalculatorPercentage": "",
      "CalculatorEqualTo": "",
      "PrintfaxPrinterFile": "",
      "StorageOptical": "",
      "Communications": "",
      "Headset": "",
      "Health": "",
      "Webcam2": "",
      "FrontCamera": "",
      "ChevronUpSmall": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$f(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-3"',
      src: "url('" + baseUrl + "fabric-icons-3-089e217a.woff') format('woff')"
    },
    icons: {
      "ChevronDownSmall": "",
      "ChevronLeftSmall": "",
      "ChevronRightSmall": "",
      "ChevronUpMed": "",
      "ChevronDownMed": "",
      "ChevronLeftMed": "",
      "ChevronRightMed": "",
      "Devices2": "",
      "PC1": "",
      "PresenceChickletVideo": "",
      "Reply": "",
      "HalfAlpha": "",
      "ConstructionCone": "",
      "DoubleChevronLeftMed": "",
      "Volume0": "",
      "Volume1": "",
      "Volume2": "",
      "Volume3": "",
      "Chart": "",
      "Robot": "",
      "Manufacturing": "",
      "LockSolid": "",
      "FitPage": "",
      "FitWidth": "",
      "BidiLtr": "",
      "BidiRtl": "",
      "RightDoubleQuote": "",
      "Sunny": "",
      "CloudWeather": "",
      "Cloudy": "",
      "PartlyCloudyDay": "",
      "PartlyCloudyNight": "",
      "ClearNight": "",
      "RainShowersDay": "",
      "Rain": "",
      "Thunderstorms": "",
      "RainSnow": "",
      "Snow": "",
      "BlowingSnow": "",
      "Frigid": "",
      "Fog": "",
      "Squalls": "",
      "Duststorm": "",
      "Unknown": "",
      "Precipitation": "",
      "Ribbon": "",
      "AreaChart": "",
      "Assign": "",
      "FlowChart": "",
      "CheckList": "",
      "Diagnostic": "",
      "Generate": "",
      "LineChart": "",
      "Equalizer": "",
      "BarChartHorizontal": "",
      "BarChartVertical": "",
      "Freezing": "",
      "FunnelChart": "",
      "Processing": "",
      "Quantity": "",
      "ReportDocument": "",
      "StackColumnChart": "",
      "SnowShowerDay": "",
      "HailDay": "",
      "WorkFlow": "",
      "HourGlass": "",
      "StoreLogoMed20": "",
      "TimeSheet": "",
      "TriangleSolid": "",
      "UpgradeAnalysis": "",
      "VideoSolid": "",
      "RainShowersNight": "",
      "SnowShowerNight": "",
      "Teamwork": "",
      "HailNight": "",
      "PeopleAdd": "",
      "Glasses": "",
      "DateTime2": "",
      "Shield": "",
      "Header1": "",
      "PageAdd": "",
      "NumberedList": "",
      "PowerBILogo": "",
      "Info2": "",
      "MusicInCollectionFill": "",
      "Asterisk": "",
      "ErrorBadge": "",
      "CircleFill": "",
      "Record2": "",
      "AllAppsMirrored": "",
      "BookmarksMirrored": "",
      "BulletedListMirrored": "",
      "CaretHollowMirrored": "",
      "CaretSolidMirrored": "",
      "ChromeBackMirrored": "",
      "ClearSelectionMirrored": "",
      "ClosePaneMirrored": "",
      "DockLeftMirrored": "",
      "DoubleChevronLeftMedMirrored": "",
      "GoMirrored": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$e(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-4"',
      src: "url('" + baseUrl + "fabric-icons-4-a656cc0a.woff') format('woff')"
    },
    icons: {
      "HelpMirrored": "",
      "ImportMirrored": "",
      "ImportAllMirrored": "",
      "ListMirrored": "",
      "MailForwardMirrored": "",
      "MailReplyMirrored": "",
      "MailReplyAllMirrored": "",
      "MiniContractMirrored": "",
      "MiniExpandMirrored": "",
      "OpenPaneMirrored": "",
      "ParkingLocationMirrored": "",
      "SendMirrored": "",
      "ShowResultsMirrored": "",
      "ThumbnailViewMirrored": "",
      "Media": "",
      "Devices3": "",
      "Focus": "",
      "VideoLightOff": "",
      "Lightbulb": "",
      "StatusTriangle": "",
      "VolumeDisabled": "",
      "Puzzle": "",
      "EmojiNeutral": "",
      "EmojiDisappointed": "",
      "HomeSolid": "",
      "Ringer": "",
      "PDF": "",
      "HeartBroken": "",
      "StoreLogo16": "",
      "MultiSelectMirrored": "",
      "Broom": "",
      "AddToShoppingList": "",
      "Cocktails": "",
      "Wines": "",
      "Articles": "",
      "Cycling": "",
      "DietPlanNotebook": "",
      "Pill": "",
      "ExerciseTracker": "",
      "HandsFree": "",
      "Medical": "",
      "Running": "",
      "Weights": "",
      "Trackers": "",
      "AddNotes": "",
      "AllCurrency": "",
      "BarChart4": "",
      "CirclePlus": "",
      "Coffee": "",
      "Cotton": "",
      "Market": "",
      "Money": "",
      "PieDouble": "",
      "PieSingle": "",
      "RemoveFilter": "",
      "Savings": "",
      "Sell": "",
      "StockDown": "",
      "StockUp": "",
      "Lamp": "",
      "Source": "",
      "MSNVideos": "",
      "Cricket": "",
      "Golf": "",
      "Baseball": "",
      "Soccer": "",
      "MoreSports": "",
      "AutoRacing": "",
      "CollegeHoops": "",
      "CollegeFootball": "",
      "ProFootball": "",
      "ProHockey": "",
      "Rugby": "",
      "SubstitutionsIn": "",
      "Tennis": "",
      "Arrivals": "",
      "Design": "",
      "Website": "",
      "Drop": "",
      "HistoricalWeather": "",
      "SkiResorts": "",
      "Snowflake": "",
      "BusSolid": "",
      "FerrySolid": "",
      "AirplaneSolid": "",
      "TrainSolid": "",
      "Ticket": "",
      "WifiWarning4": "",
      "Devices4": "",
      "AzureLogo": "",
      "BingLogo": "",
      "MSNLogo": "",
      "OutlookLogoInverse": "",
      "OfficeLogo": "",
      "SkypeLogo": "",
      "Door": "",
      "EditMirrored": "",
      "GiftCard": "",
      "DoubleBookmark": "",
      "StatusErrorFull": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$d(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-5"',
      src: "url('" + baseUrl + "fabric-icons-5-f95ba260.woff') format('woff')"
    },
    icons: {
      "Certificate": "",
      "FastForward": "",
      "Rewind": "",
      "Photo2": "",
      "OpenSource": "",
      "Movers": "",
      "CloudDownload": "",
      "Family": "",
      "WindDirection": "",
      "Bug": "",
      "SiteScan": "",
      "BrowserScreenShot": "",
      "F12DevTools": "",
      "CSS": "",
      "JS": "",
      "DeliveryTruck": "",
      "ReminderPerson": "",
      "ReminderGroup": "",
      "ReminderTime": "",
      "TabletMode": "",
      "Umbrella": "",
      "NetworkTower": "",
      "CityNext": "",
      "CityNext2": "",
      "Section": "",
      "OneNoteLogoInverse": "",
      "ToggleFilled": "",
      "ToggleBorder": "",
      "SliderThumb": "",
      "ToggleThumb": "",
      "Documentation": "",
      "Badge": "",
      "Giftbox": "",
      "VisualStudioLogo": "",
      "HomeGroup": "",
      "ExcelLogoInverse": "",
      "WordLogoInverse": "",
      "PowerPointLogoInverse": "",
      "Cafe": "",
      "SpeedHigh": "",
      "Commitments": "",
      "ThisPC": "",
      "MusicNote": "",
      "MicOff": "",
      "PlaybackRate1x": "",
      "EdgeLogo": "",
      "CompletedSolid": "",
      "AlbumRemove": "",
      "MessageFill": "",
      "TabletSelected": "",
      "MobileSelected": "",
      "LaptopSelected": "",
      "TVMonitorSelected": "",
      "DeveloperTools": "",
      "Shapes": "",
      "InsertTextBox": "",
      "LowerBrightness": "",
      "WebComponents": "",
      "OfflineStorage": "",
      "DOM": "",
      "CloudUpload": "",
      "ScrollUpDown": "",
      "DateTime": "",
      "Event": "",
      "Cake": "",
      "Org": "",
      "PartyLeader": "",
      "DRM": "",
      "CloudAdd": "",
      "AppIconDefault": "",
      "Photo2Add": "",
      "Photo2Remove": "",
      "Calories": "",
      "POI": "",
      "AddTo": "",
      "RadioBtnOff": "",
      "RadioBtnOn": "",
      "ExploreContent": "",
      "Product": "",
      "ProgressLoopInner": "",
      "ProgressLoopOuter": "",
      "Blocked2": "",
      "FangBody": "",
      "Toolbox": "",
      "PageHeader": "",
      "ChatInviteFriend": "",
      "Brush": "",
      "Shirt": "",
      "Crown": "",
      "Diamond": "",
      "ScaleUp": "",
      "QRCode": "",
      "Feedback": "",
      "SharepointLogoInverse": "",
      "YammerLogo": "",
      "Hide": "",
      "Uneditable": "",
      "ReturnToSession": "",
      "OpenFolderHorizontal": "",
      "CalendarMirrored": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$c(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-6"',
      src: "url('" + baseUrl + "fabric-icons-6-ef6fd590.woff') format('woff')"
    },
    icons: {
      "SwayLogoInverse": "",
      "OutOfOffice": "",
      "Trophy": "",
      "ReopenPages": "",
      "EmojiTabSymbols": "",
      "AADLogo": "",
      "AccessLogo": "",
      "AdminALogoInverse32": "",
      "AdminCLogoInverse32": "",
      "AdminDLogoInverse32": "",
      "AdminELogoInverse32": "",
      "AdminLLogoInverse32": "",
      "AdminMLogoInverse32": "",
      "AdminOLogoInverse32": "",
      "AdminPLogoInverse32": "",
      "AdminSLogoInverse32": "",
      "AdminYLogoInverse32": "",
      "DelveLogoInverse": "",
      "ExchangeLogoInverse": "",
      "LyncLogo": "",
      "OfficeVideoLogoInverse": "",
      "SocialListeningLogo": "",
      "VisioLogoInverse": "",
      "Balloons": "",
      "Cat": "",
      "MailAlert": "",
      "MailCheck": "",
      "MailLowImportance": "",
      "MailPause": "",
      "MailRepeat": "",
      "SecurityGroup": "",
      "Table": "",
      "VoicemailForward": "",
      "VoicemailReply": "",
      "Waffle": "",
      "RemoveEvent": "",
      "EventInfo": "",
      "ForwardEvent": "",
      "WipePhone": "",
      "AddOnlineMeeting": "",
      "JoinOnlineMeeting": "",
      "RemoveLink": "",
      "PeopleBlock": "",
      "PeopleRepeat": "",
      "PeopleAlert": "",
      "PeoplePause": "",
      "TransferCall": "",
      "AddPhone": "",
      "UnknownCall": "",
      "NoteReply": "",
      "NoteForward": "",
      "NotePinned": "",
      "RemoveOccurrence": "",
      "Timeline": "",
      "EditNote": "",
      "CircleHalfFull": "",
      "Room": "",
      "Unsubscribe": "",
      "Subscribe": "",
      "HardDrive": "",
      "RecurringTask": "",
      "TaskManager": "",
      "TaskManagerMirrored": "",
      "Combine": "",
      "Split": "",
      "DoubleChevronUp": "",
      "DoubleChevronLeft": "",
      "DoubleChevronRight": "",
      "TextBox": "",
      "TextField": "",
      "NumberField": "",
      "Dropdown": "",
      "PenWorkspace": "",
      "BookingsLogo": "",
      "ClassNotebookLogoInverse": "",
      "DelveAnalyticsLogo": "",
      "DocsLogoInverse": "",
      "Dynamics365Logo": "",
      "DynamicSMBLogo": "",
      "OfficeAssistantLogo": "",
      "OfficeStoreLogo": "",
      "OneNoteEduLogoInverse": "",
      "PlannerLogo": "",
      "PowerApps": "",
      "Suitcase": "",
      "ProjectLogoInverse": "",
      "CaretLeft8": "",
      "CaretRight8": "",
      "CaretUp8": "",
      "CaretDown8": "",
      "CaretLeftSolid8": "",
      "CaretRightSolid8": "",
      "CaretUpSolid8": "",
      "CaretDownSolid8": "",
      "ClearFormatting": "",
      "Superscript": "",
      "Subscript": "",
      "Strikethrough": "",
      "Export": "",
      "ExportMirrored": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$b(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-7"',
      src: "url('" + baseUrl + "fabric-icons-7-2b97bb99.woff') format('woff')"
    },
    icons: {
      "SingleBookmark": "",
      "SingleBookmarkSolid": "",
      "DoubleChevronDown": "",
      "FollowUser": "",
      "ReplyAll": "",
      "WorkforceManagement": "",
      "RecruitmentManagement": "",
      "Questionnaire": "",
      "ManagerSelfService": "",
      "ProductionFloorManagement": "",
      "ProductRelease": "",
      "ProductVariant": "",
      "ReplyMirrored": "",
      "ReplyAllMirrored": "",
      "Medal": "",
      "AddGroup": "",
      "QuestionnaireMirrored": "",
      "CloudImportExport": "",
      "TemporaryUser": "",
      "CaretSolid16": "",
      "GroupedDescending": "",
      "GroupedAscending": "",
      "AwayStatus": "",
      "MyMoviesTV": "",
      "GenericScan": "",
      "AustralianRules": "",
      "WifiEthernet": "",
      "TrackersMirrored": "",
      "DateTimeMirrored": "",
      "StopSolid": "",
      "DoubleChevronUp12": "",
      "DoubleChevronDown12": "",
      "DoubleChevronLeft12": "",
      "DoubleChevronRight12": "",
      "CalendarAgenda": "",
      "ConnectVirtualMachine": "",
      "AddEvent": "",
      "AssetLibrary": "",
      "DataConnectionLibrary": "",
      "DocLibrary": "",
      "FormLibrary": "",
      "FormLibraryMirrored": "",
      "ReportLibrary": "",
      "ReportLibraryMirrored": "",
      "ContactCard": "",
      "CustomList": "",
      "CustomListMirrored": "",
      "IssueTracking": "",
      "IssueTrackingMirrored": "",
      "PictureLibrary": "",
      "OfficeAddinsLogo": "",
      "OfflineOneDriveParachute": "",
      "OfflineOneDriveParachuteDisabled": "",
      "TriangleSolidUp12": "",
      "TriangleSolidDown12": "",
      "TriangleSolidLeft12": "",
      "TriangleSolidRight12": "",
      "TriangleUp12": "",
      "TriangleDown12": "",
      "TriangleLeft12": "",
      "TriangleRight12": "",
      "ArrowUpRight8": "",
      "ArrowDownRight8": "",
      "DocumentSet": "",
      "GoToDashboard": "",
      "DelveAnalytics": "",
      "ArrowUpRightMirrored8": "",
      "ArrowDownRightMirrored8": "",
      "CompanyDirectory": "",
      "OpenEnrollment": "",
      "CompanyDirectoryMirrored": "",
      "OneDriveAdd": "",
      "ProfileSearch": "",
      "Header2": "",
      "Header3": "",
      "Header4": "",
      "RingerSolid": "",
      "Eyedropper": "",
      "MarketDown": "",
      "CalendarWorkWeek": "",
      "SidePanel": "",
      "GlobeFavorite": "",
      "CaretTopLeftSolid8": "",
      "CaretTopRightSolid8": "",
      "ViewAll2": "",
      "DocumentReply": "",
      "PlayerSettings": "",
      "ReceiptForward": "",
      "ReceiptReply": "",
      "ReceiptCheck": "",
      "Fax": "",
      "RecurringEvent": "",
      "ReplyAlt": "",
      "ReplyAllAlt": "",
      "EditStyle": "",
      "EditMail": "",
      "Lifesaver": "",
      "LifesaverLock": "",
      "InboxCheck": "",
      "FolderSearch": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$a(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-8"',
      src: "url('" + baseUrl + "fabric-icons-8-6fdf1528.woff') format('woff')"
    },
    icons: {
      "CollapseMenu": "",
      "ExpandMenu": "",
      "Boards": "",
      "SunAdd": "",
      "SunQuestionMark": "",
      "LandscapeOrientation": "",
      "DocumentSearch": "",
      "PublicCalendar": "",
      "PublicContactCard": "",
      "PublicEmail": "",
      "PublicFolder": "",
      "WordDocument": "",
      "PowerPointDocument": "",
      "ExcelDocument": "",
      "GroupedList": "",
      "ClassroomLogo": "",
      "Sections": "",
      "EditPhoto": "",
      "Starburst": "",
      "ShareiOS": "",
      "AirTickets": "",
      "PencilReply": "",
      "Tiles2": "",
      "SkypeCircleCheck": "",
      "SkypeCircleClock": "",
      "SkypeCircleMinus": "",
      "SkypeMessage": "",
      "ClosedCaption": "",
      "ATPLogo": "",
      "OfficeFormsLogoInverse": "",
      "RecycleBin": "",
      "EmptyRecycleBin": "",
      "Hide2": "",
      "Breadcrumb": "",
      "BirthdayCake": "",
      "TimeEntry": "",
      "CRMProcesses": "",
      "PageEdit": "",
      "PageArrowRight": "",
      "PageRemove": "",
      "Database": "",
      "DataManagementSettings": "",
      "CRMServices": "",
      "EditContact": "",
      "ConnectContacts": "",
      "AppIconDefaultAdd": "",
      "AppIconDefaultList": "",
      "ActivateOrders": "",
      "DeactivateOrders": "",
      "ProductCatalog": "",
      "ScatterChart": "",
      "AccountActivity": "",
      "DocumentManagement": "",
      "CRMReport": "",
      "KnowledgeArticle": "",
      "Relationship": "",
      "HomeVerify": "",
      "ZipFolder": "",
      "SurveyQuestions": "",
      "TextDocument": "",
      "TextDocumentShared": "",
      "PageCheckedOut": "",
      "PageShared": "",
      "SaveAndClose": "",
      "Script": "",
      "Archive": "",
      "ActivityFeed": "",
      "Compare": "",
      "EventDate": "",
      "ArrowUpRight": "",
      "CaretRight": "",
      "SetAction": "",
      "ChatBot": "",
      "CaretSolidLeft": "",
      "CaretSolidDown": "",
      "CaretSolidRight": "",
      "CaretSolidUp": "",
      "PowerAppsLogo": "",
      "PowerApps2Logo": "",
      "SearchIssue": "",
      "SearchIssueMirrored": "",
      "FabricAssetLibrary": "",
      "FabricDataConnectionLibrary": "",
      "FabricDocLibrary": "",
      "FabricFormLibrary": "",
      "FabricFormLibraryMirrored": "",
      "FabricReportLibrary": "",
      "FabricReportLibraryMirrored": "",
      "FabricPublicFolder": "",
      "FabricFolderSearch": "",
      "FabricMovetoFolder": "",
      "FabricUnsyncFolder": "",
      "FabricSyncFolder": "",
      "FabricOpenFolderHorizontal": "",
      "FabricFolder": "",
      "FabricFolderFill": "",
      "FabricNewFolder": "",
      "FabricPictureLibrary": "",
      "PhotoVideoMedia": "",
      "AddFavorite": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$9(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-9"',
      src: "url('" + baseUrl + "fabric-icons-9-c6162b42.woff') format('woff')"
    },
    icons: {
      "AddFavoriteFill": "",
      "BufferTimeBefore": "",
      "BufferTimeAfter": "",
      "BufferTimeBoth": "",
      "PublishContent": "",
      "ClipboardList": "",
      "ClipboardListMirrored": "",
      "CannedChat": "",
      "SkypeForBusinessLogo": "",
      "TabCenter": "",
      "PageCheckedin": "",
      "PageList": "",
      "ReadOutLoud": "",
      "CaretBottomLeftSolid8": "",
      "CaretBottomRightSolid8": "",
      "FolderHorizontal": "",
      "MicrosoftStaffhubLogo": "",
      "GiftboxOpen": "",
      "StatusCircleOuter": "",
      "StatusCircleInner": "",
      "StatusCircleRing": "",
      "StatusTriangleOuter": "",
      "StatusTriangleInner": "",
      "StatusTriangleExclamation": "",
      "StatusCircleExclamation": "",
      "StatusCircleErrorX": "",
      "StatusCircleInfo": "",
      "StatusCircleBlock": "",
      "StatusCircleBlock2": "",
      "StatusCircleQuestionMark": "",
      "StatusCircleSync": "",
      "Toll": "",
      "ExploreContentSingle": "",
      "CollapseContent": "",
      "CollapseContentSingle": "",
      "InfoSolid": "",
      "GroupList": "",
      "ProgressRingDots": "",
      "CaloriesAdd": "",
      "BranchFork": "",
      "MuteChat": "",
      "AddHome": "",
      "AddWork": "",
      "MobileReport": "",
      "ScaleVolume": "",
      "HardDriveGroup": "",
      "FastMode": "",
      "ToggleLeft": "",
      "ToggleRight": "",
      "TriangleShape": "",
      "RectangleShape": "",
      "CubeShape": "",
      "Trophy2": "",
      "BucketColor": "",
      "BucketColorFill": "",
      "Taskboard": "",
      "SingleColumn": "",
      "DoubleColumn": "",
      "TripleColumn": "",
      "ColumnLeftTwoThirds": "",
      "ColumnRightTwoThirds": "",
      "AccessLogoFill": "",
      "AnalyticsLogo": "",
      "AnalyticsQuery": "",
      "NewAnalyticsQuery": "",
      "AnalyticsReport": "",
      "WordLogo": "",
      "WordLogoFill": "",
      "ExcelLogo": "",
      "ExcelLogoFill": "",
      "OneNoteLogo": "",
      "OneNoteLogoFill": "",
      "OutlookLogo": "",
      "OutlookLogoFill": "",
      "PowerPointLogo": "",
      "PowerPointLogoFill": "",
      "PublisherLogo": "",
      "PublisherLogoFill": "",
      "ScheduleEventAction": "",
      "FlameSolid": "",
      "ServerProcesses": "",
      "Server": "",
      "SaveAll": "",
      "LinkedInLogo": "",
      "Decimals": "",
      "SidePanelMirrored": "",
      "ProtectRestrict": "",
      "Blog": "",
      "UnknownMirrored": "",
      "PublicContactCardMirrored": "",
      "GridViewSmall": "",
      "GridViewMedium": "",
      "GridViewLarge": "",
      "Step": "",
      "StepInsert": "",
      "StepShared": "",
      "StepSharedAdd": "",
      "StepSharedInsert": "",
      "ViewDashboard": "",
      "ViewList": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$8(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-10"',
      src: "url('" + baseUrl + "fabric-icons-10-c4ded8e4.woff') format('woff')"
    },
    icons: {
      "ViewListGroup": "",
      "ViewListTree": "",
      "TriggerAuto": "",
      "TriggerUser": "",
      "PivotChart": "",
      "StackedBarChart": "",
      "StackedLineChart": "",
      "BuildQueue": "",
      "BuildQueueNew": "",
      "UserFollowed": "",
      "ContactLink": "",
      "Stack": "",
      "Bullseye": "",
      "VennDiagram": "",
      "FiveTileGrid": "",
      "FocalPoint": "",
      "Insert": "",
      "RingerRemove": "",
      "TeamsLogoInverse": "",
      "TeamsLogo": "",
      "TeamsLogoFill": "",
      "SkypeForBusinessLogoFill": "",
      "SharepointLogo": "",
      "SharepointLogoFill": "",
      "DelveLogo": "",
      "DelveLogoFill": "",
      "OfficeVideoLogo": "",
      "OfficeVideoLogoFill": "",
      "ExchangeLogo": "",
      "ExchangeLogoFill": "",
      "Signin": "",
      "DocumentApproval": "",
      "CloneToDesktop": "",
      "InstallToDrive": "",
      "Blur": "",
      "Build": "",
      "ProcessMetaTask": "",
      "BranchFork2": "",
      "BranchLocked": "",
      "BranchCommit": "",
      "BranchCompare": "",
      "BranchMerge": "",
      "BranchPullRequest": "",
      "BranchSearch": "",
      "BranchShelveset": "",
      "RawSource": "",
      "MergeDuplicate": "",
      "RowsGroup": "",
      "RowsChild": "",
      "Deploy": "",
      "Redeploy": "",
      "ServerEnviroment": "",
      "VisioDiagram": "",
      "HighlightMappedShapes": "",
      "TextCallout": "",
      "IconSetsFlag": "",
      "VisioLogo": "",
      "VisioLogoFill": "",
      "VisioDocument": "",
      "TimelineProgress": "",
      "TimelineDelivery": "",
      "Backlog": "",
      "TeamFavorite": "",
      "TaskGroup": "",
      "TaskGroupMirrored": "",
      "ScopeTemplate": "",
      "AssessmentGroupTemplate": "",
      "NewTeamProject": "",
      "CommentAdd": "",
      "CommentNext": "",
      "CommentPrevious": "",
      "ShopServer": "",
      "LocaleLanguage": "",
      "QueryList": "",
      "UserSync": "",
      "UserPause": "",
      "StreamingOff": "",
      "ArrowTallUpLeft": "",
      "ArrowTallUpRight": "",
      "ArrowTallDownLeft": "",
      "ArrowTallDownRight": "",
      "FieldEmpty": "",
      "FieldFilled": "",
      "FieldChanged": "",
      "FieldNotChanged": "",
      "RingerOff": "",
      "PlayResume": "",
      "BulletedList2": "",
      "BulletedList2Mirrored": "",
      "ImageCrosshair": "",
      "GitGraph": "",
      "Repo": "",
      "RepoSolid": "",
      "FolderQuery": "",
      "FolderList": "",
      "FolderListMirrored": "",
      "LocationOutline": "",
      "POISolid": "",
      "CalculatorNotEqualTo": "",
      "BoxSubtractSolid": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$7(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-11"',
      src: "url('" + baseUrl + "fabric-icons-11-2a8393d6.woff') format('woff')"
    },
    icons: {
      "BoxAdditionSolid": "",
      "BoxMultiplySolid": "",
      "BoxPlaySolid": "",
      "BoxCheckmarkSolid": "",
      "CirclePauseSolid": "",
      "CirclePause": "",
      "MSNVideosSolid": "",
      "CircleStopSolid": "",
      "CircleStop": "",
      "NavigateBack": "",
      "NavigateBackMirrored": "",
      "NavigateForward": "",
      "NavigateForwardMirrored": "",
      "UnknownSolid": "",
      "UnknownMirroredSolid": "",
      "CircleAddition": "",
      "CircleAdditionSolid": "",
      "FilePDB": "",
      "FileTemplate": "",
      "FileSQL": "",
      "FileJAVA": "",
      "FileASPX": "",
      "FileCSS": "",
      "FileSass": "",
      "FileLess": "",
      "FileHTML": "",
      "JavaScriptLanguage": "",
      "CSharpLanguage": "",
      "CSharp": "",
      "VisualBasicLanguage": "",
      "VB": "",
      "CPlusPlusLanguage": "",
      "CPlusPlus": "",
      "FSharpLanguage": "",
      "FSharp": "",
      "TypeScriptLanguage": "",
      "PythonLanguage": "",
      "PY": "",
      "CoffeeScript": "",
      "MarkDownLanguage": "",
      "FullWidth": "",
      "FullWidthEdit": "",
      "Plug": "",
      "PlugSolid": "",
      "PlugConnected": "",
      "PlugDisconnected": "",
      "UnlockSolid": "",
      "Variable": "",
      "Parameter": "",
      "CommentUrgent": "",
      "Storyboard": "",
      "DiffInline": "",
      "DiffSideBySide": "",
      "ImageDiff": "",
      "ImagePixel": "",
      "FileBug": "",
      "FileCode": "",
      "FileComment": "",
      "BusinessHoursSign": "",
      "FileImage": "",
      "FileSymlink": "",
      "AutoFillTemplate": "",
      "WorkItem": "",
      "WorkItemBug": "",
      "LogRemove": "",
      "ColumnOptions": "",
      "Packages": "",
      "BuildIssue": "",
      "AssessmentGroup": "",
      "VariableGroup": "",
      "FullHistory": "",
      "Wheelchair": "",
      "SingleColumnEdit": "",
      "DoubleColumnEdit": "",
      "TripleColumnEdit": "",
      "ColumnLeftTwoThirdsEdit": "",
      "ColumnRightTwoThirdsEdit": "",
      "StreamLogo": "",
      "PassiveAuthentication": "",
      "AlertSolid": "",
      "MegaphoneSolid": "",
      "TaskSolid": "",
      "ConfigurationSolid": "",
      "BugSolid": "",
      "CrownSolid": "",
      "Trophy2Solid": "",
      "QuickNoteSolid": "",
      "ConstructionConeSolid": "",
      "PageListSolid": "",
      "PageListMirroredSolid": "",
      "StarburstSolid": "",
      "ReadingModeSolid": "",
      "SadSolid": "",
      "HealthSolid": "",
      "ShieldSolid": "",
      "GiftBoxSolid": "",
      "ShoppingCartSolid": "",
      "MailSolid": "",
      "ChatSolid": "",
      "RibbonSolid": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$6(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-12"',
      src: "url('" + baseUrl + "fabric-icons-12-7e945a1e.woff') format('woff')"
    },
    icons: {
      "FinancialSolid": "",
      "FinancialMirroredSolid": "",
      "HeadsetSolid": "",
      "PermissionsSolid": "",
      "ParkingSolid": "",
      "ParkingMirroredSolid": "",
      "DiamondSolid": "",
      "AsteriskSolid": "",
      "OfflineStorageSolid": "",
      "BankSolid": "",
      "DecisionSolid": "",
      "Parachute": "",
      "ParachuteSolid": "",
      "FiltersSolid": "",
      "ColorSolid": "",
      "ReviewSolid": "",
      "ReviewRequestSolid": "",
      "ReviewRequestMirroredSolid": "",
      "ReviewResponseSolid": "",
      "FeedbackRequestSolid": "",
      "FeedbackRequestMirroredSolid": "",
      "FeedbackResponseSolid": "",
      "WorkItemBar": "",
      "WorkItemBarSolid": "",
      "Separator": "",
      "NavigateExternalInline": "",
      "PlanView": "",
      "TimelineMatrixView": "",
      "EngineeringGroup": "",
      "ProjectCollection": "",
      "CaretBottomRightCenter8": "",
      "CaretBottomLeftCenter8": "",
      "CaretTopRightCenter8": "",
      "CaretTopLeftCenter8": "",
      "DonutChart": "",
      "ChevronUnfold10": "",
      "ChevronFold10": "",
      "DoubleChevronDown8": "",
      "DoubleChevronUp8": "",
      "DoubleChevronLeft8": "",
      "DoubleChevronRight8": "",
      "ChevronDownEnd6": "",
      "ChevronUpEnd6": "",
      "ChevronLeftEnd6": "",
      "ChevronRightEnd6": "",
      "ContextMenu": "",
      "AzureAPIManagement": "",
      "AzureServiceEndpoint": "",
      "VSTSLogo": "",
      "VSTSAltLogo1": "",
      "VSTSAltLogo2": "",
      "FileTypeSolution": "",
      "WordLogoInverse16": "",
      "WordLogo16": "",
      "WordLogoFill16": "",
      "PowerPointLogoInverse16": "",
      "PowerPointLogo16": "",
      "PowerPointLogoFill16": "",
      "ExcelLogoInverse16": "",
      "ExcelLogo16": "",
      "ExcelLogoFill16": "",
      "OneNoteLogoInverse16": "",
      "OneNoteLogo16": "",
      "OneNoteLogoFill16": "",
      "OutlookLogoInverse16": "",
      "OutlookLogo16": "",
      "OutlookLogoFill16": "",
      "PublisherLogoInverse16": "",
      "PublisherLogo16": "",
      "PublisherLogoFill16": "",
      "VisioLogoInverse16": "",
      "VisioLogo16": "",
      "VisioLogoFill16": "",
      "TestBeaker": "",
      "TestBeakerSolid": "",
      "TestExploreSolid": "",
      "TestAutoSolid": "",
      "TestUserSolid": "",
      "TestImpactSolid": "",
      "TestPlan": "",
      "TestStep": "",
      "TestParameter": "",
      "TestSuite": "",
      "TestCase": "",
      "Sprint": "",
      "SignOut": "",
      "TriggerApproval": "",
      "Rocket": "",
      "AzureKeyVault": "",
      "Onboarding": "",
      "Transition": "",
      "LikeSolid": "",
      "DislikeSolid": "",
      "CRMCustomerInsightsApp": "",
      "EditCreate": "",
      "PlayReverseResume": "",
      "PlayReverse": "",
      "SearchData": "",
      "UnSetColor": "",
      "DeclineCall": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$5(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-13"',
      src: "url('" + baseUrl + "fabric-icons-13-c3989a02.woff') format('woff')"
    },
    icons: {
      "RectangularClipping": "",
      "TeamsLogo16": "",
      "TeamsLogoFill16": "",
      "Spacer": "",
      "SkypeLogo16": "",
      "SkypeForBusinessLogo16": "",
      "SkypeForBusinessLogoFill16": "",
      "FilterSolid": "",
      "MailUndelivered": "",
      "MailTentative": "",
      "MailTentativeMirrored": "",
      "MailReminder": "",
      "ReceiptUndelivered": "",
      "ReceiptTentative": "",
      "ReceiptTentativeMirrored": "",
      "Inbox": "",
      "IRMReply": "",
      "IRMReplyMirrored": "",
      "IRMForward": "",
      "IRMForwardMirrored": "",
      "VoicemailIRM": "",
      "EventAccepted": "",
      "EventTentative": "",
      "EventTentativeMirrored": "",
      "EventDeclined": "",
      "IDBadge": "",
      "BackgroundColor": "",
      "OfficeFormsLogoInverse16": "",
      "OfficeFormsLogo": "",
      "OfficeFormsLogoFill": "",
      "OfficeFormsLogo16": "",
      "OfficeFormsLogoFill16": "",
      "OfficeFormsLogoInverse24": "",
      "OfficeFormsLogo24": "",
      "OfficeFormsLogoFill24": "",
      "PageLock": "",
      "NotExecuted": "",
      "NotImpactedSolid": "",
      "FieldReadOnly": "",
      "FieldRequired": "",
      "BacklogBoard": "",
      "ExternalBuild": "",
      "ExternalTFVC": "",
      "ExternalXAML": "",
      "IssueSolid": "",
      "DefectSolid": "",
      "LadybugSolid": "",
      "NugetLogo": "",
      "TFVCLogo": "",
      "ProjectLogo32": "",
      "ProjectLogoFill32": "",
      "ProjectLogo16": "",
      "ProjectLogoFill16": "",
      "SwayLogo32": "",
      "SwayLogoFill32": "",
      "SwayLogo16": "",
      "SwayLogoFill16": "",
      "ClassNotebookLogo32": "",
      "ClassNotebookLogoFill32": "",
      "ClassNotebookLogo16": "",
      "ClassNotebookLogoFill16": "",
      "ClassNotebookLogoInverse32": "",
      "ClassNotebookLogoInverse16": "",
      "StaffNotebookLogo32": "",
      "StaffNotebookLogoFill32": "",
      "StaffNotebookLogo16": "",
      "StaffNotebookLogoFill16": "",
      "StaffNotebookLogoInverted32": "",
      "StaffNotebookLogoInverted16": "",
      "KaizalaLogo": "",
      "TaskLogo": "",
      "ProtectionCenterLogo32": "",
      "GallatinLogo": "",
      "Globe2": "",
      "Guitar": "",
      "Breakfast": "",
      "Brunch": "",
      "BeerMug": "",
      "Vacation": "",
      "Teeth": "",
      "Taxi": "",
      "Chopsticks": "",
      "SyncOccurence": "",
      "UnsyncOccurence": "",
      "GIF": "",
      "PrimaryCalendar": "",
      "SearchCalendar": "",
      "VideoOff": "",
      "MicrosoftFlowLogo": "",
      "BusinessCenterLogo": "",
      "ToDoLogoBottom": "",
      "ToDoLogoTop": "",
      "EditSolid12": "",
      "EditSolidMirrored12": "",
      "UneditableSolid12": "",
      "UneditableSolidMirrored12": "",
      "UneditableMirrored": "",
      "AdminALogo32": "",
      "AdminALogoFill32": "",
      "ToDoLogoInverse": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$4(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-14"',
      src: "url('" + baseUrl + "fabric-icons-14-5cf58db8.woff') format('woff')"
    },
    icons: {
      "Snooze": "",
      "WaffleOffice365": "",
      "ImageSearch": "",
      "NewsSearch": "",
      "VideoSearch": "",
      "R": "",
      "FontColorA": "",
      "FontColorSwatch": "",
      "LightWeight": "",
      "NormalWeight": "",
      "SemiboldWeight": "",
      "GroupObject": "",
      "UngroupObject": "",
      "AlignHorizontalLeft": "",
      "AlignHorizontalCenter": "",
      "AlignHorizontalRight": "",
      "AlignVerticalTop": "",
      "AlignVerticalCenter": "",
      "AlignVerticalBottom": "",
      "HorizontalDistributeCenter": "",
      "VerticalDistributeCenter": "",
      "Ellipse": "",
      "Line": "",
      "Octagon": "",
      "Hexagon": "",
      "Pentagon": "",
      "RightTriangle": "",
      "HalfCircle": "",
      "QuarterCircle": "",
      "ThreeQuarterCircle": "",
      "6PointStar": "",
      "12PointStar": "",
      "ArrangeBringToFront": "",
      "ArrangeSendToBack": "",
      "ArrangeSendBackward": "",
      "ArrangeBringForward": "",
      "BorderDash": "",
      "BorderDot": "",
      "LineStyle": "",
      "LineThickness": "",
      "WindowEdit": "",
      "HintText": "",
      "MediaAdd": "",
      "AnchorLock": "",
      "AutoHeight": "",
      "ChartSeries": "",
      "ChartXAngle": "",
      "ChartYAngle": "",
      "Combobox": "",
      "LineSpacing": "",
      "Padding": "",
      "PaddingTop": "",
      "PaddingBottom": "",
      "PaddingLeft": "",
      "PaddingRight": "",
      "NavigationFlipper": "",
      "AlignJustify": "",
      "TextOverflow": "",
      "VisualsFolder": "",
      "VisualsStore": "",
      "PictureCenter": "",
      "PictureFill": "",
      "PicturePosition": "",
      "PictureStretch": "",
      "PictureTile": "",
      "Slider": "",
      "SliderHandleSize": "",
      "DefaultRatio": "",
      "NumberSequence": "",
      "GUID": "",
      "ReportAdd": "",
      "DashboardAdd": "",
      "MapPinSolid": "",
      "WebPublish": "",
      "PieSingleSolid": "",
      "BlockedSolid": "",
      "DrillDown": "",
      "DrillDownSolid": "",
      "DrillExpand": "",
      "DrillShow": "",
      "SpecialEvent": "",
      "OneDriveFolder16": "",
      "FunctionalManagerDashboard": "",
      "BIDashboard": "",
      "CodeEdit": "",
      "RenewalCurrent": "",
      "RenewalFuture": "",
      "SplitObject": "",
      "BulkUpload": "",
      "DownloadDocument": "",
      "GreetingCard": "",
      "Flower": "",
      "WaitlistConfirm": "",
      "WaitlistConfirmMirrored": "",
      "LaptopSecure": "",
      "DragObject": "",
      "EntryView": "",
      "EntryDecline": "",
      "ContactCardSettings": "",
      "ContactCardSettingsMirrored": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$3(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-15"',
      src: "url('" + baseUrl + "fabric-icons-15-3807251b.woff') format('woff')"
    },
    icons: {
      "CalendarSettings": "",
      "CalendarSettingsMirrored": "",
      "HardDriveLock": "",
      "HardDriveUnlock": "",
      "AccountManagement": "",
      "ReportWarning": "",
      "TransitionPop": "",
      "TransitionPush": "",
      "TransitionEffect": "",
      "LookupEntities": "",
      "ExploreData": "",
      "AddBookmark": "",
      "SearchBookmark": "",
      "DrillThrough": "",
      "MasterDatabase": "",
      "CertifiedDatabase": "",
      "MaximumValue": "",
      "MinimumValue": "",
      "VisualStudioIDELogo32": "",
      "PasteAsText": "",
      "PasteAsCode": "",
      "BrowserTab": "",
      "BrowserTabScreenshot": "",
      "DesktopScreenshot": "",
      "FileYML": "",
      "ClipboardSolid": "",
      "FabricUserFolder": "",
      "FabricNetworkFolder": "",
      "BullseyeTarget": "",
      "AnalyticsView": "",
      "Video360Generic": "",
      "Untag": "",
      "Leave": "",
      "Trending12": "",
      "Blocked12": "",
      "Warning12": "",
      "CheckedOutByOther12": "",
      "CheckedOutByYou12": "",
      "CircleShapeSolid": "",
      "SquareShapeSolid": "",
      "TriangleShapeSolid": "",
      "DropShapeSolid": "",
      "RectangleShapeSolid": "",
      "ZoomToFit": "",
      "InsertColumnsLeft": "",
      "InsertColumnsRight": "",
      "InsertRowsAbove": "",
      "InsertRowsBelow": "",
      "DeleteColumns": "",
      "DeleteRows": "",
      "DeleteRowsMirrored": "",
      "DeleteTable": "",
      "AccountBrowser": "",
      "VersionControlPush": "",
      "StackedColumnChart2": "",
      "TripleColumnWide": "",
      "QuadColumn": "",
      "WhiteBoardApp16": "",
      "WhiteBoardApp32": "",
      "PinnedSolid": "",
      "InsertSignatureLine": "",
      "ArrangeByFrom": "",
      "Phishing": "",
      "CreateMailRule": "",
      "PublishCourse": "",
      "DictionaryRemove": "",
      "UserRemove": "",
      "UserEvent": "",
      "Encryption": "",
      "PasswordField": "",
      "OpenInNewTab": "",
      "Hide3": "",
      "VerifiedBrandSolid": "",
      "MarkAsProtected": "",
      "AuthenticatorApp": "",
      "WebTemplate": "",
      "DefenderTVM": "",
      "MedalSolid": "",
      "D365TalentLearn": "",
      "D365TalentInsight": "",
      "D365TalentHRCore": "",
      "BacklogList": "",
      "ButtonControl": "",
      "TableGroup": "",
      "MountainClimbing": "",
      "TagUnknown": "",
      "TagUnknownMirror": "",
      "TagUnknown12": "",
      "TagUnknown12Mirror": "",
      "Link12": "",
      "Presentation": "",
      "Presentation12": "",
      "Lock12": "",
      "BuildDefinition": "",
      "ReleaseDefinition": "",
      "SaveTemplate": "",
      "UserGauge": "",
      "BlockedSiteSolid12": "",
      "TagSolid": "",
      "OfficeChat": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$2(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-16"',
      src: "url('" + baseUrl + "fabric-icons-16-9cf93f3b.woff') format('woff')"
    },
    icons: {
      "OfficeChatSolid": "",
      "MailSchedule": "",
      "WarningSolid": "",
      "Blocked2Solid": "",
      "SkypeCircleArrow": "",
      "SkypeArrow": "",
      "SyncStatus": "",
      "SyncStatusSolid": "",
      "ProjectDocument": "",
      "ToDoLogoOutline": "",
      "VisioOnlineLogoFill32": "",
      "VisioOnlineLogo32": "",
      "VisioOnlineLogoCloud32": "",
      "VisioDiagramSync": "",
      "Event12": "",
      "EventDateMissed12": "",
      "UserOptional": "",
      "ResponsesMenu": "",
      "DoubleDownArrow": "",
      "DistributeDown": "",
      "BookmarkReport": "",
      "FilterSettings": "",
      "GripperDotsVertical": "",
      "MailAttached": "",
      "AddIn": "",
      "LinkedDatabase": "",
      "TableLink": "",
      "PromotedDatabase": "",
      "BarChartVerticalFilter": "",
      "BarChartVerticalFilterSolid": "",
      "MicOff2": "",
      "MicrosoftTranslatorLogo": "",
      "ShowTimeAs": "",
      "FileRequest": "",
      "WorkItemAlert": "",
      "PowerBILogo16": "",
      "PowerBILogoBackplate16": "",
      "BulletedListText": "",
      "BulletedListBullet": "",
      "BulletedListTextMirrored": "",
      "BulletedListBulletMirrored": "",
      "NumberedListText": "",
      "NumberedListNumber": "",
      "NumberedListTextMirrored": "",
      "NumberedListNumberMirrored": "",
      "RemoveLinkChain": "",
      "RemoveLinkX": "",
      "FabricTextHighlight": "",
      "ClearFormattingA": "",
      "ClearFormattingEraser": "",
      "Photo2Fill": "",
      "IncreaseIndentText": "",
      "IncreaseIndentArrow": "",
      "DecreaseIndentText": "",
      "DecreaseIndentArrow": "",
      "IncreaseIndentTextMirrored": "",
      "IncreaseIndentArrowMirrored": "",
      "DecreaseIndentTextMirrored": "",
      "DecreaseIndentArrowMirrored": "",
      "CheckListText": "",
      "CheckListCheck": "",
      "CheckListTextMirrored": "",
      "CheckListCheckMirrored": "",
      "NumberSymbol": "",
      "Coupon": "",
      "VerifiedBrand": "",
      "ReleaseGate": "",
      "ReleaseGateCheck": "",
      "ReleaseGateError": "",
      "M365InvoicingLogo": "",
      "RemoveFromShoppingList": "",
      "ShieldAlert": "",
      "FabricTextHighlightComposite": "",
      "Dataflows": "",
      "GenericScanFilled": "",
      "DiagnosticDataBarTooltip": "",
      "SaveToMobile": "",
      "Orientation2": "",
      "ScreenCast": "",
      "ShowGrid": "",
      "SnapToGrid": "",
      "ContactList": "",
      "NewMail": "",
      "EyeShadow": "",
      "FabricFolderConfirm": "",
      "InformationBarriers": "",
      "CommentActive": "",
      "ColumnVerticalSectionEdit": "",
      "WavingHand": "",
      "ShakeDevice": "",
      "SmartGlassRemote": "",
      "Rotate90Clockwise": "",
      "Rotate90CounterClockwise": "",
      "CampaignTemplate": "",
      "ChartTemplate": "",
      "PageListFilter": "",
      "SecondaryNav": "",
      "ColumnVerticalSection": "",
      "SkypeCircleSlash": "",
      "SkypeSlash": ""
    }
  };
  registerIcons(subset, options2);
}
function initializeIcons$1(baseUrl, options2) {
  if (baseUrl === void 0) {
    baseUrl = "";
  }
  var subset = {
    style: {
      MozOsxFontSmoothing: "grayscale",
      WebkitFontSmoothing: "antialiased",
      fontStyle: "normal",
      fontWeight: "normal",
      speak: "none"
    },
    fontFace: {
      fontFamily: '"FabricMDL2Icons-17"',
      src: "url('" + baseUrl + "fabric-icons-17-0c4ed701.woff') format('woff')"
    },
    icons: {
      "CustomizeToolbar": "",
      "DuplicateRow": "",
      "RemoveFromTrash": "",
      "MailOptions": "",
      "Childof": "",
      "Footer": "",
      "Header": "",
      "BarChartVerticalFill": "",
      "StackedColumnChart2Fill": "",
      "PlainText": "",
      "AccessibiltyChecker": "",
      "DatabaseSync": "",
      "ReservationOrders": "",
      "TabOneColumn": "",
      "TabTwoColumn": "",
      "TabThreeColumn": "",
      "BulletedTreeList": "",
      "MicrosoftTranslatorLogoGreen": "",
      "MicrosoftTranslatorLogoBlue": "",
      "InternalInvestigation": "",
      "AddReaction": "",
      "ContactHeart": "",
      "VisuallyImpaired": "",
      "EventToDoLogo": "",
      "Variable2": "",
      "ModelingView": "",
      "DisconnectVirtualMachine": "",
      "ReportLock": "",
      "Uneditable2": "",
      "Uneditable2Mirrored": "",
      "BarChartVerticalEdit": "",
      "GlobalNavButtonActive": "",
      "PollResults": "",
      "Rerun": "",
      "QandA": "",
      "QandAMirror": "",
      "BookAnswers": "",
      "AlertSettings": "",
      "TrimStart": "",
      "TrimEnd": "",
      "TableComputed": "",
      "DecreaseIndentLegacy": "",
      "IncreaseIndentLegacy": "",
      "SizeLegacy": ""
    }
  };
  registerIcons(subset, options2);
}
var registerIconAliases = function() {
  registerIconAlias("trash", "delete");
  registerIconAlias("onedrive", "onedrivelogo");
  registerIconAlias("alertsolid12", "eventdatemissed12");
  registerIconAlias("sixpointstar", "6pointstar");
  registerIconAlias("twelvepointstar", "12pointstar");
  registerIconAlias("toggleon", "toggleleft");
  registerIconAlias("toggleoff", "toggleright");
};
setVersion("@fluentui/font-icons-mdl2", "8.5.18");
var DEFAULT_BASE_URL = FLUENT_CDN_BASE_URL + "/assets/icons/";
var win = getWindow$1();
function initializeIcons(baseUrl, options2) {
  var _a2, _b2;
  if (baseUrl === void 0) {
    baseUrl = ((_a2 = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _a2 === void 0 ? void 0 : _a2.iconBaseUrl) || ((_b2 = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _b2 === void 0 ? void 0 : _b2.fontBaseUrl) || DEFAULT_BASE_URL;
  }
  [initializeIcons$j, initializeIcons$i, initializeIcons$h, initializeIcons$g, initializeIcons$f, initializeIcons$e, initializeIcons$d, initializeIcons$c, initializeIcons$b, initializeIcons$a, initializeIcons$9, initializeIcons$8, initializeIcons$7, initializeIcons$6, initializeIcons$5, initializeIcons$4, initializeIcons$3, initializeIcons$2, initializeIcons$1].forEach(function(initialize) {
    return initialize(baseUrl, options2);
  });
  registerIconAliases();
}
var getClassNames$3 = classNamesFunction();
var MIN_DRAG_DISTANCE = 5;
var MarqueeSelectionBase = (
  /** @class */
  function(_super) {
    __extends(MarqueeSelectionBase2, _super);
    function MarqueeSelectionBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._root = React__namespace.createRef();
      _this._onMouseDown = function(ev) {
        var _a2 = _this.props, isEnabled = _a2.isEnabled, onShouldStartSelection = _a2.onShouldStartSelection;
        if (_this._isMouseEventOnScrollbar(ev)) {
          return;
        }
        if (_this._isInSelectionToggle(ev)) {
          return;
        }
        if (!_this._isTouch && isEnabled && !_this._isDragStartInSelection(ev) && (!onShouldStartSelection || onShouldStartSelection(ev))) {
          if (_this._scrollableSurface && ev.button === 0 && _this._root.current) {
            _this._selectedIndicies = {};
            _this._preservedIndicies = void 0;
            _this._events.on(window, "mousemove", _this._onAsyncMouseMove, true);
            _this._events.on(_this._scrollableParent, "scroll", _this._onAsyncMouseMove);
            _this._events.on(window, "click", _this._onMouseUp, true);
            _this._autoScroll = new AutoScroll(_this._root.current);
            _this._scrollTop = _this._scrollableSurface.scrollTop;
            _this._scrollLeft = _this._scrollableSurface.scrollLeft;
            _this._rootRect = _this._root.current.getBoundingClientRect();
            _this._onMouseMove(ev);
          }
        }
      };
      _this._onTouchStart = function(ev) {
        _this._isTouch = true;
        _this._async.setTimeout(function() {
          _this._isTouch = false;
        }, 0);
      };
      _this._onPointerDown = function(ev) {
        if (ev.pointerType === "touch") {
          _this._isTouch = true;
          _this._async.setTimeout(function() {
            _this._isTouch = false;
          }, 0);
        }
      };
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      _this.state = {
        dragRect: void 0
      };
      return _this;
    }
    MarqueeSelectionBase2.prototype.componentDidMount = function() {
      this._scrollableParent = findScrollableParent(this._root.current);
      this._scrollableSurface = this._scrollableParent === window ? document.body : this._scrollableParent;
      var hitTarget = this.props.isDraggingConstrainedToRoot ? this._root.current : this._scrollableSurface;
      this._events.on(hitTarget, "mousedown", this._onMouseDown);
      this._events.on(hitTarget, "touchstart", this._onTouchStart, true);
      this._events.on(hitTarget, "pointerdown", this._onPointerDown, true);
    };
    MarqueeSelectionBase2.prototype.componentWillUnmount = function() {
      if (this._autoScroll) {
        this._autoScroll.dispose();
      }
      delete this._scrollableParent;
      delete this._scrollableSurface;
      this._events.dispose();
      this._async.dispose();
    };
    MarqueeSelectionBase2.prototype.render = function() {
      var _a2 = this.props, rootProps = _a2.rootProps, children = _a2.children, theme = _a2.theme, className = _a2.className, styles2 = _a2.styles;
      var dragRect = this.state.dragRect;
      var classNames2 = getClassNames$3(styles2, {
        theme,
        className
      });
      return React__namespace.createElement(
        "div",
        __assign$1({}, rootProps, { className: classNames2.root, ref: this._root }),
        children,
        dragRect && React__namespace.createElement("div", { className: classNames2.dragMask }),
        dragRect && React__namespace.createElement(
          "div",
          { className: classNames2.box, style: dragRect },
          React__namespace.createElement("div", { className: classNames2.boxFill })
        )
      );
    };
    MarqueeSelectionBase2.prototype._isMouseEventOnScrollbar = function(ev) {
      var targetElement = ev.target;
      var targetScrollbarWidth = targetElement.offsetWidth - targetElement.clientWidth;
      var targetScrollbarHeight = targetElement.offsetHeight - targetElement.clientHeight;
      if (targetScrollbarWidth || targetScrollbarHeight) {
        var targetRect = targetElement.getBoundingClientRect();
        if (getRTL(this.props.theme)) {
          if (ev.clientX < targetRect.left + targetScrollbarWidth) {
            return true;
          }
        } else {
          if (ev.clientX > targetRect.left + targetElement.clientWidth) {
            return true;
          }
        }
        if (ev.clientY > targetRect.top + targetElement.clientHeight) {
          return true;
        }
      }
      return false;
    };
    MarqueeSelectionBase2.prototype._getRootRect = function() {
      return {
        left: this._rootRect.left + (this._scrollableSurface ? this._scrollLeft - this._scrollableSurface.scrollLeft : this._scrollLeft),
        top: this._rootRect.top + (this._scrollableSurface ? this._scrollTop - this._scrollableSurface.scrollTop : this._scrollTop),
        width: this._rootRect.width,
        height: this._rootRect.height
      };
    };
    MarqueeSelectionBase2.prototype._onAsyncMouseMove = function(ev) {
      var _this = this;
      this._async.requestAnimationFrame(function() {
        _this._onMouseMove(ev);
      });
      ev.stopPropagation();
      ev.preventDefault();
    };
    MarqueeSelectionBase2.prototype._onMouseMove = function(ev) {
      if (!this._autoScroll) {
        return;
      }
      if (ev.clientX !== void 0) {
        this._lastMouseEvent = ev;
      }
      var rootRect = this._getRootRect();
      var currentPoint = { left: ev.clientX - rootRect.left, top: ev.clientY - rootRect.top };
      if (!this._dragOrigin) {
        this._dragOrigin = currentPoint;
      }
      if (ev.buttons !== void 0 && ev.buttons === 0) {
        this._onMouseUp(ev);
      } else {
        if (this.state.dragRect || getDistanceBetweenPoints(this._dragOrigin, currentPoint) > MIN_DRAG_DISTANCE) {
          if (!this.state.dragRect) {
            var selection = this.props.selection;
            if (!ev.shiftKey) {
              selection.setAllSelected(false);
            }
            this._preservedIndicies = selection && selection.getSelectedIndices && selection.getSelectedIndices();
          }
          var constrainedPoint = this.props.isDraggingConstrainedToRoot ? {
            left: Math.max(0, Math.min(rootRect.width, this._lastMouseEvent.clientX - rootRect.left)),
            top: Math.max(0, Math.min(rootRect.height, this._lastMouseEvent.clientY - rootRect.top))
          } : {
            left: this._lastMouseEvent.clientX - rootRect.left,
            top: this._lastMouseEvent.clientY - rootRect.top
          };
          var dragRect = {
            left: Math.min(this._dragOrigin.left || 0, constrainedPoint.left),
            top: Math.min(this._dragOrigin.top || 0, constrainedPoint.top),
            width: Math.abs(constrainedPoint.left - (this._dragOrigin.left || 0)),
            height: Math.abs(constrainedPoint.top - (this._dragOrigin.top || 0))
          };
          this._evaluateSelection(dragRect, rootRect);
          this.setState({ dragRect });
        }
      }
      return false;
    };
    MarqueeSelectionBase2.prototype._onMouseUp = function(ev) {
      this._events.off(window);
      this._events.off(this._scrollableParent, "scroll");
      if (this._autoScroll) {
        this._autoScroll.dispose();
      }
      this._autoScroll = this._dragOrigin = this._lastMouseEvent = void 0;
      this._selectedIndicies = this._itemRectCache = void 0;
      if (this.state.dragRect) {
        this.setState({
          dragRect: void 0
        });
        ev.preventDefault();
        ev.stopPropagation();
      }
    };
    MarqueeSelectionBase2.prototype._isPointInRectangle = function(rectangle, point) {
      return !!point.top && rectangle.top < point.top && rectangle.bottom > point.top && !!point.left && rectangle.left < point.left && rectangle.right > point.left;
    };
    MarqueeSelectionBase2.prototype._isDragStartInSelection = function(ev) {
      var selection = this.props.selection;
      if (!this._root.current || selection && selection.getSelectedCount() === 0) {
        return false;
      }
      var allElements = this._root.current.querySelectorAll("[data-selection-index]");
      for (var i = 0; i < allElements.length; i++) {
        var element = allElements[i];
        var index2 = Number(element.getAttribute("data-selection-index"));
        if (selection.isIndexSelected(index2)) {
          var itemRect = element.getBoundingClientRect();
          if (this._isPointInRectangle(itemRect, { left: ev.clientX, top: ev.clientY })) {
            return true;
          }
        }
      }
      return false;
    };
    MarqueeSelectionBase2.prototype._isInSelectionToggle = function(ev) {
      var element = ev.target;
      while (element && element !== this._root.current) {
        if (element.getAttribute("data-selection-toggle") === "true") {
          return true;
        }
        element = element.parentElement;
      }
      return false;
    };
    MarqueeSelectionBase2.prototype._evaluateSelection = function(dragRect, rootRect) {
      if (!dragRect || !this._root.current) {
        return;
      }
      var selection = this.props.selection;
      var allElements = this._root.current.querySelectorAll("[data-selection-index]");
      if (!this._itemRectCache) {
        this._itemRectCache = {};
      }
      for (var i = 0; i < allElements.length; i++) {
        var element = allElements[i];
        var index2 = element.getAttribute("data-selection-index");
        var itemRect = this._itemRectCache[index2];
        if (!itemRect) {
          itemRect = element.getBoundingClientRect();
          itemRect = {
            left: itemRect.left - rootRect.left,
            top: itemRect.top - rootRect.top,
            width: itemRect.width,
            height: itemRect.height,
            right: itemRect.left - rootRect.left + itemRect.width,
            bottom: itemRect.top - rootRect.top + itemRect.height
          };
          if (itemRect.width > 0 && itemRect.height > 0) {
            this._itemRectCache[index2] = itemRect;
          }
        }
        if (itemRect.top < dragRect.top + dragRect.height && itemRect.bottom > dragRect.top && itemRect.left < dragRect.left + dragRect.width && itemRect.right > dragRect.left) {
          this._selectedIndicies[index2] = true;
        } else {
          delete this._selectedIndicies[index2];
        }
      }
      var previousSelectedIndices = this._allSelectedIndices || {};
      this._allSelectedIndices = {};
      for (var index2 in this._selectedIndicies) {
        if (this._selectedIndicies.hasOwnProperty(index2)) {
          this._allSelectedIndices[index2] = true;
        }
      }
      if (this._preservedIndicies) {
        for (var _i = 0, _a2 = this._preservedIndicies; _i < _a2.length; _i++) {
          var index2 = _a2[_i];
          this._allSelectedIndices[index2] = true;
        }
      }
      var needToUpdate = false;
      for (var index2 in this._allSelectedIndices) {
        if (this._allSelectedIndices[index2] !== previousSelectedIndices[index2]) {
          needToUpdate = true;
          break;
        }
      }
      if (!needToUpdate) {
        for (var index2 in previousSelectedIndices) {
          if (this._allSelectedIndices[index2] !== previousSelectedIndices[index2]) {
            needToUpdate = true;
            break;
          }
        }
      }
      if (needToUpdate) {
        selection.setChangeEvents(false);
        selection.setAllSelected(false);
        for (var _b2 = 0, _c2 = Object.keys(this._allSelectedIndices); _b2 < _c2.length; _b2++) {
          var index2 = _c2[_b2];
          selection.setIndexSelected(Number(index2), true, false);
        }
        selection.setChangeEvents(true);
      }
    };
    MarqueeSelectionBase2.defaultProps = {
      rootTagName: "div",
      rootProps: {},
      isEnabled: true
    };
    return MarqueeSelectionBase2;
  }(React__namespace.Component)
);
var getStyles$3 = function(props) {
  var _a2, _b2, _c2;
  var theme = props.theme, className = props.className;
  var palette = theme.palette;
  return {
    root: [
      className,
      {
        position: "relative",
        cursor: "default"
      }
    ],
    dragMask: [
      {
        position: "absolute",
        background: "rgba(255, 0, 0, 0)",
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        selectors: (_a2 = {}, _a2[HighContrastSelector] = {
          background: "none",
          backgroundColor: "transparent"
        }, _a2)
      }
    ],
    box: [
      {
        position: "absolute",
        boxSizing: "border-box",
        border: "1px solid " + palette.themePrimary,
        pointerEvents: "none",
        zIndex: 10,
        selectors: (_b2 = {}, _b2[HighContrastSelector] = {
          borderColor: "Highlight"
        }, _b2)
      }
    ],
    boxFill: [
      {
        position: "absolute",
        boxSizing: "border-box",
        backgroundColor: palette.themePrimary,
        opacity: 0.1,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        selectors: (_c2 = {}, _c2[HighContrastSelector] = {
          background: "none",
          backgroundColor: "transparent"
        }, _c2)
      }
    ]
  };
};
var MarqueeSelection = (
  // TODO: MarqueeSelectionBase defaultProps are not lining up with IMarqueeSelectionProps, so we have to be explicit
  // with styled here. defaultProps.rootTagName doesn't appear to be used anywhere and defaultProps.rootProps is not
  // in IMarqueeSelectionProps.
  styled(MarqueeSelectionBase, getStyles$3, void 0, {
    scope: "MarqueeSelection"
  })
);
var MessageBarType;
(function(MessageBarType2) {
  MessageBarType2[MessageBarType2["info"] = 0] = "info";
  MessageBarType2[MessageBarType2["error"] = 1] = "error";
  MessageBarType2[MessageBarType2["blocked"] = 2] = "blocked";
  MessageBarType2[MessageBarType2["severeWarning"] = 3] = "severeWarning";
  MessageBarType2[MessageBarType2["success"] = 4] = "success";
  MessageBarType2[MessageBarType2["warning"] = 5] = "warning";
})(MessageBarType || (MessageBarType = {}));
var _a$1;
var ICON_MAP = (_a$1 = {}, _a$1[MessageBarType.info] = "Info", _a$1[MessageBarType.warning] = "Info", _a$1[MessageBarType.error] = "ErrorBadge", _a$1[MessageBarType.blocked] = "Blocked2", _a$1[MessageBarType.severeWarning] = "Warning", _a$1[MessageBarType.success] = "Completed", _a$1);
var COMPONENT_NAME$1 = "MessageBar";
var getClassNames$2 = classNamesFunction();
var getAnnouncementPriority = function(messageBarType) {
  switch (messageBarType) {
    case MessageBarType.blocked:
    case MessageBarType.error:
    case MessageBarType.severeWarning:
      return "assertive";
  }
  return "polite";
};
var getRole = function(messageBarType) {
  switch (messageBarType) {
    case MessageBarType.blocked:
    case MessageBarType.error:
    case MessageBarType.severeWarning:
      return "alert";
  }
  return "status";
};
var MessageBarBase = React__namespace.forwardRef(function(props, ref) {
  var _a2 = useBoolean(false), expandSingleLine = _a2[0], toggleExpandSingleLine = _a2[1].toggle;
  var labelId = useId("MessageBar");
  var actions = props.actions, className = props.className, children = props.children, overflowButtonAriaLabel = props.overflowButtonAriaLabel, dismissIconProps = props.dismissIconProps, styles2 = props.styles, theme = props.theme, _b2 = props.messageBarType, messageBarType = _b2 === void 0 ? MessageBarType.info : _b2, _c2 = props.onDismiss, onDismiss = _c2 === void 0 ? void 0 : _c2, _d2 = props.isMultiline, isMultiline = _d2 === void 0 ? true : _d2, truncated = props.truncated, dismissButtonAriaLabel = props.dismissButtonAriaLabel, messageBarIconProps = props.messageBarIconProps, role = props.role, _e2 = props.delayedRender, delayedRender = _e2 === void 0 ? true : _e2, expandButtonProps = props.expandButtonProps;
  var nativeProps = getNativeProps(props, htmlElementProperties, [
    "className",
    "role"
  ]);
  var classNames2 = getClassNames$2(styles2, {
    theme,
    messageBarType: messageBarType || MessageBarType.info,
    onDismiss: onDismiss !== void 0,
    actions: actions !== void 0,
    truncated,
    isMultiline,
    expandSingleLine,
    className
  });
  var expandIconProps = { iconName: expandSingleLine ? "DoubleChevronUp" : "DoubleChevronDown" };
  var regionProps = actions || onDismiss ? { "aria-describedby": labelId, role: "region" } : {};
  var actionsDiv = actions ? React__namespace.createElement("div", { className: classNames2.actions }, actions) : null;
  var dismissButton = onDismiss ? React__namespace.createElement(IconButton, { disabled: false, className: classNames2.dismissal, onClick: onDismiss, iconProps: dismissIconProps ? dismissIconProps : { iconName: "Clear" }, title: dismissButtonAriaLabel, ariaLabel: dismissButtonAriaLabel }) : null;
  return React__namespace.createElement(
    "div",
    __assign$1({ ref, className: classNames2.root }, regionProps),
    React__namespace.createElement(
      "div",
      { className: classNames2.content },
      React__namespace.createElement("div", { className: classNames2.iconContainer, "aria-hidden": true }, messageBarIconProps ? React__namespace.createElement(Icon, __assign$1({}, messageBarIconProps, { className: css$3(classNames2.icon, messageBarIconProps.className) })) : React__namespace.createElement(Icon, { iconName: ICON_MAP[messageBarType], className: classNames2.icon })),
      React__namespace.createElement(
        "div",
        { className: classNames2.text, id: labelId, role: role || getRole(messageBarType), "aria-live": getAnnouncementPriority(messageBarType) },
        React__namespace.createElement("span", __assign$1({ className: classNames2.innerText }, nativeProps), delayedRender ? React__namespace.createElement(
          DelayedRender,
          null,
          React__namespace.createElement("span", null, children)
        ) : (
          // this span is probably not necessary, but preserving it for now in case anyone
          // has styling that expects it to be present
          React__namespace.createElement("span", null, children)
        ))
      ),
      /* singleline expand/collapse button */
      !isMultiline && !actionsDiv && truncated && React__namespace.createElement(
        "div",
        { className: classNames2.expandSingleLine },
        React__namespace.createElement(IconButton, __assign$1({ disabled: false, className: classNames2.expand, onClick: toggleExpandSingleLine, iconProps: expandIconProps, ariaLabel: overflowButtonAriaLabel, "aria-expanded": expandSingleLine }, expandButtonProps))
      ),
      !isMultiline && actionsDiv,
      /* singleline dismiss */
      !isMultiline && dismissButton && React__namespace.createElement("div", { className: classNames2.dismissSingleLine }, dismissButton),
      isMultiline && dismissButton
    ),
    isMultiline && actionsDiv
  );
});
MessageBarBase.displayName = COMPONENT_NAME$1;
var _a, _b, _c, _d;
var GlobalClassNames$3 = {
  root: "ms-MessageBar",
  error: "ms-MessageBar--error",
  blocked: "ms-MessageBar--blocked",
  severeWarning: "ms-MessageBar--severeWarning",
  success: "ms-MessageBar--success",
  warning: "ms-MessageBar--warning",
  multiline: "ms-MessageBar-multiline",
  singleline: "ms-MessageBar-singleline",
  dismissalSingleLine: "ms-MessageBar-dismissalSingleLine",
  expandingSingleLine: "ms-MessageBar-expandingSingleLine",
  content: "ms-MessageBar-content",
  iconContainer: "ms-MessageBar-icon",
  text: "ms-MessageBar-text",
  innerText: "ms-MessageBar-innerText",
  dismissSingleLine: "ms-MessageBar-dismissSingleLine",
  expandSingleLine: "ms-MessageBar-expandSingleLine",
  dismissal: "ms-MessageBar-dismissal",
  expand: "ms-MessageBar-expand",
  actions: "ms-MessageBar-actions",
  actionsSingleline: "ms-MessageBar-actionsSingleLine"
};
var backgroundColor = (_a = {}, _a[MessageBarType.error] = "errorBackground", _a[MessageBarType.blocked] = "errorBackground", _a[MessageBarType.success] = "successBackground", _a[MessageBarType.warning] = "warningBackground", _a[MessageBarType.severeWarning] = "severeWarningBackground", _a[MessageBarType.info] = "infoBackground", _a);
var iconColor = (_b = {}, _b[MessageBarType.error] = "errorIcon", _b[MessageBarType.blocked] = "errorIcon", _b[MessageBarType.success] = "successIcon", _b[MessageBarType.warning] = "warningIcon", _b[MessageBarType.severeWarning] = "severeWarningIcon", _b[MessageBarType.info] = "infoIcon", _b);
var highContrastBorderColor = (_c = {}, _c[MessageBarType.error] = "#ff0000", _c[MessageBarType.blocked] = "#ff0000", _c[MessageBarType.success] = "#bad80a", _c[MessageBarType.warning] = "#fff100", _c[MessageBarType.severeWarning] = "#ff0000", _c[MessageBarType.info] = "WindowText", _c);
var highContrastWhiteBorderColor = (_d = {}, _d[MessageBarType.error] = "#e81123", _d[MessageBarType.blocked] = "#e81123", _d[MessageBarType.success] = "#107c10", _d[MessageBarType.warning] = "#966400", _d[MessageBarType.severeWarning] = "#d83b01", _d[MessageBarType.info] = "WindowText", _d);
var getStyles$2 = function(props) {
  var _a2, _b2, _c2, _d2, _e2;
  var theme = props.theme, className = props.className, onDismiss = props.onDismiss, truncated = props.truncated, isMultiline = props.isMultiline, expandSingleLine = props.expandSingleLine, _f = props.messageBarType, messageBarType = _f === void 0 ? MessageBarType.info : _f;
  var semanticColors = theme.semanticColors, fonts = theme.fonts;
  var SmallScreenSelector = getScreenSelector(0, ScreenWidthMaxSmall);
  var classNames2 = getGlobalClassNames(GlobalClassNames$3, theme);
  var dismissalAndExpandIconStyle = {
    fontSize: IconFontSizes.xSmall,
    height: 10,
    lineHeight: "10px",
    color: semanticColors.messageText,
    selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign$1(__assign$1({}, getHighContrastNoAdjustStyle()), { color: "WindowText" }), _a2)
  };
  var dismissalAndExpandStyle = [
    getFocusStyle(theme, {
      inset: 1,
      highContrastStyle: {
        outlineOffset: "-6px",
        outline: "1px solid Highlight"
      },
      borderColor: "transparent"
    }),
    {
      flexShrink: 0,
      width: 32,
      height: 32,
      padding: "8px 12px",
      selectors: {
        "& .ms-Button-icon": dismissalAndExpandIconStyle,
        ":hover": {
          backgroundColor: "transparent"
        },
        ":active": {
          backgroundColor: "transparent"
        }
      }
    }
  ];
  return {
    root: [
      classNames2.root,
      fonts.medium,
      messageBarType === MessageBarType.error && classNames2.error,
      messageBarType === MessageBarType.blocked && classNames2.blocked,
      messageBarType === MessageBarType.severeWarning && classNames2.severeWarning,
      messageBarType === MessageBarType.success && classNames2.success,
      messageBarType === MessageBarType.warning && classNames2.warning,
      isMultiline ? classNames2.multiline : classNames2.singleline,
      !isMultiline && onDismiss && classNames2.dismissalSingleLine,
      !isMultiline && truncated && classNames2.expandingSingleLine,
      {
        background: semanticColors[backgroundColor[messageBarType]],
        boxSizing: "border-box",
        color: semanticColors.messageText,
        minHeight: 32,
        width: "100%",
        display: "flex",
        wordBreak: "break-word",
        selectors: (_b2 = {
          ".ms-Link": {
            color: semanticColors.messageLink,
            selectors: {
              ":hover": {
                color: semanticColors.messageLinkHovered
              }
            }
          }
        }, _b2[HighContrastSelector] = __assign$1(__assign$1({}, getHighContrastNoAdjustStyle()), { background: "transparent", border: "1px solid " + highContrastBorderColor[messageBarType], color: "WindowText" }), _b2[HighContrastSelectorWhite] = {
          border: "1px solid " + highContrastWhiteBorderColor[messageBarType]
        }, _b2)
      },
      isMultiline && {
        flexDirection: "column"
      },
      className
    ],
    content: [
      classNames2.content,
      {
        display: "flex",
        width: "100%",
        lineHeight: "normal"
      }
    ],
    iconContainer: [
      classNames2.iconContainer,
      {
        fontSize: IconFontSizes.medium,
        minWidth: 16,
        minHeight: 16,
        display: "flex",
        flexShrink: 0,
        margin: "8px 0 8px 12px"
      }
    ],
    icon: {
      color: semanticColors[iconColor[messageBarType]],
      selectors: (_c2 = {}, _c2[HighContrastSelector] = __assign$1(__assign$1({}, getHighContrastNoAdjustStyle()), { color: "WindowText" }), _c2)
    },
    text: [
      classNames2.text,
      __assign$1(__assign$1({ minWidth: 0, display: "flex", flexGrow: 1, margin: 8 }, fonts.small), { selectors: (_d2 = {}, _d2[HighContrastSelector] = __assign$1({}, getHighContrastNoAdjustStyle()), _d2) }),
      !onDismiss && {
        marginRight: 12
      }
    ],
    innerText: [
      classNames2.innerText,
      {
        lineHeight: 16,
        selectors: {
          "& span a:last-child": {
            paddingLeft: 4
          }
        }
      },
      truncated && {
        overflow: "visible",
        whiteSpace: "pre-wrap"
      },
      !isMultiline && {
        // In high contrast this causes the top and bottom of links' focus outline to be clipped
        // (not sure of a good way around that while still maintaining text clipping)
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      },
      !isMultiline && !truncated && {
        selectors: (_e2 = {}, _e2[SmallScreenSelector] = {
          overflow: "visible",
          whiteSpace: "pre-wrap"
        }, _e2)
      },
      expandSingleLine && {
        overflow: "visible",
        whiteSpace: "pre-wrap"
      }
    ],
    dismissSingleLine: classNames2.dismissSingleLine,
    expandSingleLine: classNames2.expandSingleLine,
    dismissal: [classNames2.dismissal, dismissalAndExpandStyle],
    expand: [classNames2.expand, dismissalAndExpandStyle],
    actions: [
      isMultiline ? classNames2.actions : classNames2.actionsSingleline,
      {
        display: "flex",
        flexGrow: 0,
        flexShrink: 0,
        flexBasis: "auto",
        flexDirection: "row-reverse",
        alignItems: "center",
        margin: "0 12px 0 8px",
        // reset forced colors to browser control for inner actions
        forcedColorAdjust: "auto",
        MsHighContrastAdjust: "auto",
        selectors: {
          "& button:nth-child(n+2)": {
            marginLeft: 8
          }
        }
      },
      isMultiline && {
        marginBottom: 8
      },
      onDismiss && !isMultiline && {
        marginRight: 0
      }
    ]
  };
};
var MessageBar = styled(MessageBarBase, getStyles$2, void 0, {
  scope: "MessageBar"
});
var GlobalClassNames$2 = {
  root: "ms-ScrollablePane",
  contentContainer: "ms-ScrollablePane--contentContainer"
};
var getStyles$1 = function(props) {
  var _a2, _b2;
  var className = props.className, theme = props.theme;
  var classNames2 = getGlobalClassNames(GlobalClassNames$2, theme);
  var AboveAndBelowStyles = {
    position: "absolute",
    pointerEvents: "none"
  };
  var positioningStyle = {
    position: "absolute",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    WebkitOverflowScrolling: "touch"
  };
  return {
    root: [classNames2.root, theme.fonts.medium, positioningStyle, className],
    contentContainer: [
      classNames2.contentContainer,
      {
        overflowY: props.scrollbarVisibility === "always" ? "scroll" : "auto"
      },
      positioningStyle
    ],
    stickyAbove: [
      {
        top: 0,
        zIndex: 1,
        selectors: (_a2 = {}, _a2[HighContrastSelector] = {
          borderBottom: "1px solid WindowText"
        }, _a2)
      },
      AboveAndBelowStyles
    ],
    stickyBelow: [
      {
        bottom: 0,
        selectors: (_b2 = {}, _b2[HighContrastSelector] = {
          borderTop: "1px solid WindowText"
        }, _b2)
      },
      AboveAndBelowStyles
    ],
    stickyBelowItems: [
      {
        bottom: 0
      },
      AboveAndBelowStyles,
      {
        width: "100%"
      }
    ]
  };
};
var ScrollbarVisibility = {
  auto: "auto",
  always: "always"
};
var ScrollablePaneContext = React__namespace.createContext({ scrollablePane: void 0 });
var getClassNames$1 = classNamesFunction();
var ScrollablePaneBase = (
  /** @class */
  function(_super) {
    __extends(ScrollablePaneBase2, _super);
    function ScrollablePaneBase2(props) {
      var _this = _super.call(this, props) || this;
      _this._root = React__namespace.createRef();
      _this._stickyAboveRef = React__namespace.createRef();
      _this._stickyBelowRef = React__namespace.createRef();
      _this._contentContainer = React__namespace.createRef();
      _this.subscribe = function(handler) {
        _this._subscribers.add(handler);
      };
      _this.unsubscribe = function(handler) {
        _this._subscribers.delete(handler);
      };
      _this.addSticky = function(sticky) {
        _this._stickies.add(sticky);
        if (_this.contentContainer) {
          sticky.setDistanceFromTop(_this.contentContainer);
          _this.sortSticky(sticky);
        }
      };
      _this.removeSticky = function(sticky) {
        _this._stickies.delete(sticky);
        _this._removeStickyFromContainers(sticky);
        _this.notifySubscribers();
      };
      _this.sortSticky = function(sticky, sortAgain) {
        if (_this.stickyAbove && _this.stickyBelow) {
          if (sortAgain) {
            _this._removeStickyFromContainers(sticky);
          }
          if (sticky.canStickyTop && sticky.stickyContentTop) {
            _this._addToStickyContainer(sticky, _this.stickyAbove, sticky.stickyContentTop);
          }
          if (sticky.canStickyBottom && sticky.stickyContentBottom) {
            _this._addToStickyContainer(sticky, _this.stickyBelow, sticky.stickyContentBottom);
          }
        }
      };
      _this.updateStickyRefHeights = function() {
        var stickyItems = _this._stickies;
        var stickyTopHeight = 0;
        var stickyBottomHeight = 0;
        stickyItems.forEach(function(sticky) {
          var _a2 = sticky.state, isStickyTop = _a2.isStickyTop, isStickyBottom = _a2.isStickyBottom;
          if (sticky.nonStickyContent) {
            if (isStickyTop) {
              stickyTopHeight += sticky.nonStickyContent.offsetHeight;
            }
            if (isStickyBottom) {
              stickyBottomHeight += sticky.nonStickyContent.offsetHeight;
            }
            _this._checkStickyStatus(sticky);
          }
        });
        _this.setState({
          stickyTopHeight,
          stickyBottomHeight
        });
      };
      _this.notifySubscribers = function() {
        if (_this.contentContainer) {
          _this._subscribers.forEach(function(handle) {
            handle(_this.contentContainer, _this.stickyBelow);
          });
        }
      };
      _this.getScrollPosition = function() {
        if (_this.contentContainer) {
          return _this.contentContainer.scrollTop;
        }
        return 0;
      };
      _this.syncScrollSticky = function(sticky) {
        if (sticky && _this.contentContainer) {
          sticky.syncScroll(_this.contentContainer);
        }
      };
      _this._getScrollablePaneContext = function() {
        return {
          scrollablePane: {
            subscribe: _this.subscribe,
            unsubscribe: _this.unsubscribe,
            addSticky: _this.addSticky,
            removeSticky: _this.removeSticky,
            updateStickyRefHeights: _this.updateStickyRefHeights,
            sortSticky: _this.sortSticky,
            notifySubscribers: _this.notifySubscribers,
            syncScrollSticky: _this.syncScrollSticky
          }
        };
      };
      _this._addToStickyContainer = function(sticky, stickyContainer, stickyContentToAdd) {
        if (!stickyContainer.children.length) {
          stickyContainer.appendChild(stickyContentToAdd);
        } else {
          if (!stickyContainer.contains(stickyContentToAdd)) {
            var stickyChildrenElements_1 = [].slice.call(stickyContainer.children);
            var stickyList_1 = [];
            _this._stickies.forEach(function(stickyItem) {
              if (stickyContainer === _this.stickyAbove && sticky.canStickyTop) {
                stickyList_1.push(stickyItem);
              } else if (sticky.canStickyBottom) {
                stickyList_1.push(stickyItem);
              }
            });
            var stickyListSorted = stickyList_1.sort(function(a, b) {
              return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);
            }).filter(function(item) {
              var stickyContent = stickyContainer === _this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;
              if (stickyContent) {
                return stickyChildrenElements_1.indexOf(stickyContent) > -1;
              }
              return false;
            });
            var targetStickyToAppendBefore = void 0;
            for (var _i = 0, stickyListSorted_1 = stickyListSorted; _i < stickyListSorted_1.length; _i++) {
              var stickyListItem = stickyListSorted_1[_i];
              if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {
                targetStickyToAppendBefore = stickyListItem;
                break;
              }
            }
            var targetContainer = null;
            if (targetStickyToAppendBefore) {
              targetContainer = stickyContainer === _this.stickyAbove ? targetStickyToAppendBefore.stickyContentTop : targetStickyToAppendBefore.stickyContentBottom;
            }
            stickyContainer.insertBefore(stickyContentToAdd, targetContainer);
          }
        }
      };
      _this._removeStickyFromContainers = function(sticky) {
        if (_this.stickyAbove && sticky.stickyContentTop && _this.stickyAbove.contains(sticky.stickyContentTop)) {
          _this.stickyAbove.removeChild(sticky.stickyContentTop);
        }
        if (_this.stickyBelow && sticky.stickyContentBottom && _this.stickyBelow.contains(sticky.stickyContentBottom)) {
          _this.stickyBelow.removeChild(sticky.stickyContentBottom);
        }
      };
      _this._onWindowResize = function() {
        var scrollbarWidth = _this._getScrollbarWidth();
        var scrollbarHeight = _this._getScrollbarHeight();
        _this.setState({
          scrollbarWidth,
          scrollbarHeight
        });
        _this.notifySubscribers();
      };
      _this._getStickyContainerStyle = function(height, isTop) {
        return __assign$1(__assign$1({ height }, getRTL(_this.props.theme) ? {
          right: "0",
          left: (_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0) + "px"
        } : {
          left: "0",
          right: (_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0) + "px"
        }), isTop ? {
          top: "0"
        } : {
          bottom: (_this.state.scrollbarHeight || _this._getScrollbarHeight() || 0) + "px"
        });
      };
      _this._onScroll = function() {
        var contentContainer = _this.contentContainer;
        if (contentContainer) {
          _this._stickies.forEach(function(sticky) {
            sticky.syncScroll(contentContainer);
          });
        }
        _this._notifyThrottled();
      };
      _this._subscribers = /* @__PURE__ */ new Set();
      _this._stickies = /* @__PURE__ */ new Set();
      initializeComponentRef(_this);
      _this._async = new Async(_this);
      _this._events = new EventGroup(_this);
      _this.state = {
        stickyTopHeight: 0,
        stickyBottomHeight: 0,
        scrollbarWidth: 0,
        scrollbarHeight: 0
      };
      _this._notifyThrottled = _this._async.throttle(_this.notifySubscribers, 50);
      return _this;
    }
    Object.defineProperty(ScrollablePaneBase2.prototype, "root", {
      get: function() {
        return this._root.current;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ScrollablePaneBase2.prototype, "stickyAbove", {
      get: function() {
        return this._stickyAboveRef.current;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ScrollablePaneBase2.prototype, "stickyBelow", {
      get: function() {
        return this._stickyBelowRef.current;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ScrollablePaneBase2.prototype, "contentContainer", {
      get: function() {
        return this._contentContainer.current;
      },
      enumerable: false,
      configurable: true
    });
    ScrollablePaneBase2.prototype.componentDidMount = function() {
      var _this = this;
      var initialScrollPosition = this.props.initialScrollPosition;
      this._events.on(this.contentContainer, "scroll", this._onScroll);
      this._events.on(window, "resize", this._onWindowResize);
      if (this.contentContainer && initialScrollPosition) {
        this.contentContainer.scrollTop = initialScrollPosition;
      }
      this.setStickiesDistanceFromTop();
      this._stickies.forEach(function(sticky) {
        _this.sortSticky(sticky);
      });
      this.notifySubscribers();
      if ("MutationObserver" in window) {
        this._mutationObserver = new MutationObserver(function(mutation) {
          function checkIfMutationIsSticky(mutationRecord) {
            if (this.stickyAbove !== null && this.stickyBelow !== null) {
              return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);
            }
            return false;
          }
          var scrollbarHeight = _this._getScrollbarHeight();
          if (scrollbarHeight !== _this.state.scrollbarHeight) {
            _this.setState({
              scrollbarHeight
            });
          }
          _this.notifySubscribers();
          if (mutation.some(checkIfMutationIsSticky.bind(_this))) {
            _this.updateStickyRefHeights();
          } else {
            var stickyList_2 = [];
            _this._stickies.forEach(function(sticky) {
              if (sticky.root && sticky.root.contains(mutation[0].target)) {
                stickyList_2.push(sticky);
              }
            });
            if (stickyList_2.length) {
              stickyList_2.forEach(function(sticky) {
                sticky.forceUpdate();
              });
            }
          }
        });
        if (this.root) {
          this._mutationObserver.observe(this.root, {
            childList: true,
            attributes: true,
            subtree: true,
            characterData: true
          });
        }
      }
    };
    ScrollablePaneBase2.prototype.componentWillUnmount = function() {
      this._events.dispose();
      this._async.dispose();
      if (this._mutationObserver) {
        this._mutationObserver.disconnect();
      }
    };
    ScrollablePaneBase2.prototype.shouldComponentUpdate = function(nextProps, nextState) {
      return this.props.children !== nextProps.children || this.props.initialScrollPosition !== nextProps.initialScrollPosition || this.props.className !== nextProps.className || this.state.stickyTopHeight !== nextState.stickyTopHeight || this.state.stickyBottomHeight !== nextState.stickyBottomHeight || this.state.scrollbarWidth !== nextState.scrollbarWidth || this.state.scrollbarHeight !== nextState.scrollbarHeight;
    };
    ScrollablePaneBase2.prototype.componentDidUpdate = function(prevProps, prevState) {
      var initialScrollPosition = this.props.initialScrollPosition;
      if (this.contentContainer && typeof initialScrollPosition === "number" && prevProps.initialScrollPosition !== initialScrollPosition) {
        this.contentContainer.scrollTop = initialScrollPosition;
      }
      if (prevState.stickyTopHeight !== this.state.stickyTopHeight || prevState.stickyBottomHeight !== this.state.stickyBottomHeight) {
        this.notifySubscribers();
      }
      this._async.setTimeout(this._onWindowResize, 0);
    };
    ScrollablePaneBase2.prototype.render = function() {
      var _a2 = this.props, className = _a2.className, scrollContainerFocus = _a2.scrollContainerFocus, scrollContainerAriaLabel = _a2.scrollContainerAriaLabel, theme = _a2.theme, styles2 = _a2.styles, onScroll = _a2.onScroll;
      var _b2 = this.state, stickyTopHeight = _b2.stickyTopHeight, stickyBottomHeight = _b2.stickyBottomHeight;
      var classNames2 = getClassNames$1(styles2, {
        theme,
        className,
        scrollbarVisibility: this.props.scrollbarVisibility
      });
      var scrollContainerProps = scrollContainerFocus ? {
        role: "group",
        tabIndex: 0,
        "aria-label": scrollContainerAriaLabel,
        onScroll
      } : {
        onScroll
      };
      return React__namespace.createElement(
        "div",
        __assign$1({}, getNativeProps(
          __assign$1({}, this.props),
          divProperties,
          // on React 17 onScroll is not being invoked on root element,
          // as a fix this method will be provided to the container element
          ["onScroll"]
        ), { ref: this._root, className: classNames2.root }),
        React__namespace.createElement("div", { ref: this._stickyAboveRef, className: classNames2.stickyAbove, style: this._getStickyContainerStyle(stickyTopHeight, true) }),
        React__namespace.createElement(
          "div",
          __assign$1({ ref: this._contentContainer }, scrollContainerProps, { className: classNames2.contentContainer, "data-is-scrollable": true }),
          React__namespace.createElement(ScrollablePaneContext.Provider, { value: this._getScrollablePaneContext() }, this.props.children)
        ),
        React__namespace.createElement(
          "div",
          { className: classNames2.stickyBelow, style: this._getStickyContainerStyle(stickyBottomHeight, false) },
          React__namespace.createElement("div", { ref: this._stickyBelowRef, className: classNames2.stickyBelowItems })
        )
      );
    };
    ScrollablePaneBase2.prototype.setStickiesDistanceFromTop = function() {
      var _this = this;
      if (this.contentContainer) {
        this._stickies.forEach(function(sticky) {
          sticky.setDistanceFromTop(_this.contentContainer);
        });
      }
    };
    ScrollablePaneBase2.prototype.forceLayoutUpdate = function() {
      this._onWindowResize();
    };
    ScrollablePaneBase2.prototype._checkStickyStatus = function(sticky) {
      if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {
        if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {
          if (sticky.state.isStickyTop && !this.stickyAbove.contains(sticky.nonStickyContent) && sticky.stickyContentTop) {
            sticky.addSticky(sticky.stickyContentTop);
          }
          if (sticky.state.isStickyBottom && !this.stickyBelow.contains(sticky.nonStickyContent) && sticky.stickyContentBottom) {
            sticky.addSticky(sticky.stickyContentBottom);
          }
        } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {
          sticky.resetSticky();
        }
      }
    };
    ScrollablePaneBase2.prototype._getScrollbarWidth = function() {
      var contentContainer = this.contentContainer;
      return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;
    };
    ScrollablePaneBase2.prototype._getScrollbarHeight = function() {
      var contentContainer = this.contentContainer;
      return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;
    };
    return ScrollablePaneBase2;
  }(React__namespace.Component)
);
var ScrollablePane = styled(ScrollablePaneBase, getStyles$1, void 0, { scope: "ScrollablePane" });
var ARROW_BUTTON_WIDTH = 23;
var ARROW_BUTTON_ICON_SIZE = 8;
var DEFAULT_HEIGHT = 32;
var DEFAULT_MIN_WIDTH = 86;
var LABEL_MARGIN = 10;
var getDisabledStyles = memoizeFunction(function(theme) {
  var _a2;
  var semanticColors = theme.semanticColors;
  var SpinButtonTextColorDisabled = semanticColors.disabledText;
  var SpinButtonBackgroundColorDisabled = semanticColors.disabledBackground;
  return {
    backgroundColor: SpinButtonBackgroundColorDisabled,
    pointerEvents: "none",
    cursor: "default",
    color: SpinButtonTextColorDisabled,
    selectors: (_a2 = {
      ":after": {
        borderColor: SpinButtonBackgroundColorDisabled
      }
    }, _a2[HighContrastSelector] = {
      color: "GrayText"
    }, _a2)
  };
});
var getArrowButtonStyles = memoizeFunction(function(theme, isUpArrow, customSpecificArrowStyles) {
  var _a2, _b2, _c2;
  var palette = theme.palette, semanticColors = theme.semanticColors, effects = theme.effects;
  var ArrowButtonTextColor = palette.neutralSecondary;
  var ArrowButtonTextColorHovered = semanticColors.buttonText;
  var ArrowButtonTextColorPressed = semanticColors.buttonText;
  var ArrowButtonBackgroundHovered = semanticColors.buttonBackgroundHovered;
  var ArrowButtonBackgroundPressed = semanticColors.buttonBackgroundPressed;
  var defaultArrowButtonStyles = {
    root: {
      outline: "none",
      display: "block",
      height: "50%",
      width: ARROW_BUTTON_WIDTH,
      padding: 0,
      backgroundColor: "transparent",
      textAlign: "center",
      cursor: "default",
      color: ArrowButtonTextColor,
      selectors: {
        "&.ms-DownButton": {
          borderRadius: "0 0 " + effects.roundedCorner2 + " 0"
        },
        "&.ms-UpButton": {
          borderRadius: "0 " + effects.roundedCorner2 + " 0 0"
        }
      }
    },
    rootHovered: {
      backgroundColor: ArrowButtonBackgroundHovered,
      color: ArrowButtonTextColorHovered
    },
    rootChecked: {
      backgroundColor: ArrowButtonBackgroundPressed,
      color: ArrowButtonTextColorPressed,
      selectors: (_a2 = {}, _a2[HighContrastSelector] = {
        backgroundColor: "Highlight",
        color: "HighlightText"
      }, _a2)
    },
    rootPressed: {
      backgroundColor: ArrowButtonBackgroundPressed,
      color: ArrowButtonTextColorPressed,
      selectors: (_b2 = {}, _b2[HighContrastSelector] = {
        backgroundColor: "Highlight",
        color: "HighlightText"
      }, _b2)
    },
    rootDisabled: {
      opacity: 0.5,
      selectors: (_c2 = {}, _c2[HighContrastSelector] = {
        color: "GrayText",
        opacity: 1
      }, _c2)
    },
    icon: {
      fontSize: ARROW_BUTTON_ICON_SIZE,
      marginTop: 0,
      marginRight: 0,
      marginBottom: 0,
      marginLeft: 0
    }
  };
  var defaultUpArrowButtonStyles = {};
  var defaultDownArrowButtonStyles = {};
  return concatStyleSets(defaultArrowButtonStyles, isUpArrow ? defaultUpArrowButtonStyles : defaultDownArrowButtonStyles, customSpecificArrowStyles);
});
var getStyles = function(props) {
  var _a2, _b2, _c2, _d2;
  var theme = props.theme, className = props.className, labelPosition = props.labelPosition, disabled = props.disabled, isFocused = props.isFocused;
  var palette = theme.palette, semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
  var SpinButtonRootBorderColor = semanticColors.inputBorder;
  var SpinButtonRootBackgroundColor = semanticColors.inputBackground;
  var SpinButtonRootBorderColorHovered = semanticColors.inputBorderHovered;
  var SpinButtonRootBorderColorFocused = semanticColors.inputFocusBorderAlt;
  var SpinButtonInputTextColor = semanticColors.inputText;
  var SpinButtonInputTextColorSelected = palette.white;
  var SpinButtonInputBackgroundColorSelected = semanticColors.inputBackgroundChecked;
  var SpinButtonIconDisabledColor = semanticColors.disabledText;
  return {
    root: [
      fonts.medium,
      {
        outline: "none",
        width: "100%",
        minWidth: DEFAULT_MIN_WIDTH
      },
      className
    ],
    labelWrapper: [
      {
        display: "inline-flex",
        alignItems: "center"
      },
      labelPosition === Position.start && {
        height: DEFAULT_HEIGHT,
        float: "left",
        marginRight: LABEL_MARGIN
      },
      labelPosition === Position.end && {
        height: DEFAULT_HEIGHT,
        float: "right",
        marginLeft: LABEL_MARGIN
      },
      labelPosition === Position.top && {
        // Due to the lineHeight set on the label (below), the height of the wrapper (contains icon+label)
        // ends up 1px taller than a standard label height, causing the vertical alignment to be off when
        // the SpinButton is displayed with the label on top next to other form fields.
        // Decrease the wrapper's effective height slightly to compensate.
        marginBottom: -1
      }
    ],
    icon: [
      {
        padding: "0 5px",
        fontSize: IconFontSizes.large
      },
      disabled && {
        color: SpinButtonIconDisabledColor
      }
    ],
    label: {
      pointerEvents: "none",
      // centering the label with the icon by forcing the exact same height as the icon.
      lineHeight: IconFontSizes.large
    },
    spinButtonWrapper: [
      __assign$1(__assign$1({ display: "flex", position: "relative", boxSizing: "border-box", height: DEFAULT_HEIGHT, minWidth: DEFAULT_MIN_WIDTH }, getInputFocusStyle(SpinButtonRootBorderColor, effects.roundedCorner2, "border", 0)), { ":after": (_a2 = {
        borderWidth: "1px"
      }, _a2[HighContrastSelector] = {
        borderColor: "GrayText"
      }, _a2) }),
      (labelPosition === Position.top || labelPosition === Position.bottom) && {
        width: "100%"
      },
      !disabled && [
        {
          ":hover:after": (_b2 = {
            borderColor: SpinButtonRootBorderColorHovered
          }, _b2[HighContrastSelector] = {
            borderColor: "Highlight"
          }, _b2)
        },
        isFocused && {
          ":hover:after, :after": (_c2 = {
            borderColor: SpinButtonRootBorderColorFocused,
            borderWidth: "2px"
          }, _c2[HighContrastSelector] = {
            borderColor: "Highlight"
          }, _c2)
        }
      ],
      disabled && getDisabledStyles(theme)
    ],
    input: [
      "ms-spinButton-input",
      {
        boxSizing: "border-box",
        boxShadow: "none",
        borderStyle: "none",
        flex: 1,
        margin: 0,
        fontSize: fonts.medium.fontSize,
        fontFamily: "inherit",
        color: SpinButtonInputTextColor,
        backgroundColor: SpinButtonRootBackgroundColor,
        height: "100%",
        padding: "0 8px 0 9px",
        outline: 0,
        display: "block",
        minWidth: DEFAULT_MIN_WIDTH - ARROW_BUTTON_WIDTH - 2,
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden",
        cursor: "text",
        userSelect: "text",
        borderRadius: effects.roundedCorner2 + " 0 0 " + effects.roundedCorner2
      },
      !disabled && {
        selectors: {
          "::selection": {
            backgroundColor: SpinButtonInputBackgroundColorSelected,
            color: SpinButtonInputTextColorSelected,
            selectors: (_d2 = {}, _d2[HighContrastSelector] = {
              backgroundColor: "Highlight",
              borderColor: "Highlight",
              color: "HighlightText"
            }, _d2)
          }
        }
      },
      disabled && getDisabledStyles(theme)
    ],
    arrowButtonsContainer: [
      {
        display: "block",
        height: "100%",
        cursor: "default"
      },
      disabled && getDisabledStyles(theme)
    ]
  };
};
var KeyboardSpinDirection;
(function(KeyboardSpinDirection2) {
  KeyboardSpinDirection2[KeyboardSpinDirection2["down"] = -1] = "down";
  KeyboardSpinDirection2[KeyboardSpinDirection2["notSpinning"] = 0] = "notSpinning";
  KeyboardSpinDirection2[KeyboardSpinDirection2["up"] = 1] = "up";
})(KeyboardSpinDirection || (KeyboardSpinDirection = {}));
var getClassNames = classNamesFunction();
var COMPONENT_NAME = "SpinButton";
var DEFAULT_PROPS = {
  disabled: false,
  label: "",
  step: 1,
  labelPosition: Position.start,
  incrementButtonIcon: { iconName: "ChevronUpSmall" },
  decrementButtonIcon: { iconName: "ChevronDownSmall" }
};
var INITIAL_STEP_DELAY = 400;
var STEP_DELAY = 75;
var useComponentRef = function(props, input, value) {
  React__namespace.useImperativeHandle(props.componentRef, function() {
    return {
      get value() {
        return value;
      },
      focus: function() {
        if (input.current) {
          input.current.focus();
        }
      }
    };
  }, [input, value]);
};
var noOp = function() {
};
var clampValue = function(value, _a2) {
  var min2 = _a2.min, max2 = _a2.max;
  if (typeof max2 === "number") {
    value = Math.min(value, max2);
  }
  if (typeof min2 === "number") {
    value = Math.max(value, min2);
  }
  return value;
};
var SpinButtonBase = React__namespace.forwardRef(function(propsWithoutDefaults, ref) {
  var props = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);
  var disabled = props.disabled, label = props.label, min2 = props.min, max2 = props.max, step = props.step, defaultValue = props.defaultValue, valueFromProps = props.value, precisionFromProps = props.precision, labelPosition = props.labelPosition, iconProps = props.iconProps, incrementButtonIcon = props.incrementButtonIcon, incrementButtonAriaLabel = props.incrementButtonAriaLabel, decrementButtonIcon = props.decrementButtonIcon, decrementButtonAriaLabel = props.decrementButtonAriaLabel, ariaLabel = props.ariaLabel, ariaDescribedBy = props.ariaDescribedBy, customUpArrowButtonStyles = props.upArrowButtonStyles, customDownArrowButtonStyles = props.downArrowButtonStyles, theme = props.theme, ariaPositionInSet = props.ariaPositionInSet, ariaSetSize = props.ariaSetSize, ariaValueNow = props.ariaValueNow, ariaValueText = props.ariaValueText, className = props.className, inputProps = props.inputProps, onDecrement = props.onDecrement, onIncrement = props.onIncrement, iconButtonProps = props.iconButtonProps, onValidate = props.onValidate, onChange2 = props.onChange, styles2 = props.styles;
  var input = React__namespace.useRef(null);
  var inputId = useId("input");
  var labelId = useId("Label");
  var _a2 = React__namespace.useState(false), isFocused = _a2[0], setIsFocused = _a2[1];
  var _b2 = React__namespace.useState(KeyboardSpinDirection.notSpinning), keyboardSpinDirection = _b2[0], setKeyboardSpinDirection = _b2[1];
  var async = useAsync();
  var precision = React__namespace.useMemo(function() {
    return precisionFromProps !== null && precisionFromProps !== void 0 ? precisionFromProps : Math.max(calculatePrecision(step), 0);
  }, [precisionFromProps, step]);
  var _c2 = useControllableValue(valueFromProps, defaultValue !== null && defaultValue !== void 0 ? defaultValue : String(min2 || 0), onChange2), value = _c2[0], setValue = _c2[1];
  var _d2 = React__namespace.useState(), intermediateValue = _d2[0], setIntermediateValue = _d2[1];
  var internalState = React__namespace.useRef({
    stepTimeoutHandle: -1,
    latestValue: void 0,
    latestIntermediateValue: void 0
  }).current;
  internalState.latestValue = value;
  internalState.latestIntermediateValue = intermediateValue;
  var previousValueFromProps = usePrevious(valueFromProps);
  React__namespace.useEffect(function() {
    if (valueFromProps !== previousValueFromProps && intermediateValue !== void 0) {
      setIntermediateValue(void 0);
    }
  }, [valueFromProps, previousValueFromProps, intermediateValue]);
  var classNames2 = getClassNames(styles2, {
    theme,
    disabled,
    isFocused,
    keyboardSpinDirection,
    labelPosition,
    className
  });
  var nativeProps = getNativeProps(props, divProperties, [
    "onBlur",
    "onFocus",
    "className",
    "onChange"
  ]);
  var validate = React__namespace.useCallback(function(ev) {
    var enteredValue = internalState.latestIntermediateValue;
    if (enteredValue !== void 0 && enteredValue !== internalState.latestValue) {
      var newValue = void 0;
      if (onValidate) {
        newValue = onValidate(enteredValue, ev);
      } else if (enteredValue && enteredValue.trim().length && !isNaN(Number(enteredValue))) {
        newValue = String(clampValue(Number(enteredValue), { min: min2, max: max2 }));
      }
      if (newValue !== void 0 && newValue !== internalState.latestValue) {
        setValue(newValue, ev);
      }
    }
    setIntermediateValue(void 0);
  }, [internalState, max2, min2, onValidate, setValue]);
  var stop = React__namespace.useCallback(function() {
    if (internalState.stepTimeoutHandle >= 0) {
      async.clearTimeout(internalState.stepTimeoutHandle);
      internalState.stepTimeoutHandle = -1;
    }
    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {
      internalState.spinningByMouse = false;
      setKeyboardSpinDirection(KeyboardSpinDirection.notSpinning);
    }
  }, [internalState, keyboardSpinDirection, async]);
  var updateValue = React__namespace.useCallback(function(stepFunction, ev) {
    ev.persist();
    if (internalState.latestIntermediateValue !== void 0) {
      if (ev.type === "keydown" || ev.type === "mousedown") {
        validate(ev);
      }
      async.requestAnimationFrame(function() {
        updateValue(stepFunction, ev);
      });
      return;
    }
    var newValue = stepFunction(internalState.latestValue || "", ev);
    if (newValue !== void 0 && newValue !== internalState.latestValue) {
      setValue(newValue, ev);
    }
    var wasSpinning = internalState.spinningByMouse;
    internalState.spinningByMouse = ev.type === "mousedown";
    if (internalState.spinningByMouse) {
      internalState.stepTimeoutHandle = async.setTimeout(function() {
        updateValue(stepFunction, ev);
      }, wasSpinning ? STEP_DELAY : INITIAL_STEP_DELAY);
    }
  }, [internalState, async, validate, setValue]);
  var handleIncrement = React__namespace.useCallback(function(newValue) {
    if (onIncrement) {
      return onIncrement(newValue);
    } else {
      var numericValue = clampValue(Number(newValue) + Number(step), { max: max2 });
      numericValue = precisionRound(numericValue, precision);
      return String(numericValue);
    }
  }, [precision, max2, onIncrement, step]);
  var handleDecrement = React__namespace.useCallback(function(newValue) {
    if (onDecrement) {
      return onDecrement(newValue);
    } else {
      var numericValue = clampValue(Number(newValue) - Number(step), { min: min2 });
      numericValue = precisionRound(numericValue, precision);
      return String(numericValue);
    }
  }, [precision, min2, onDecrement, step]);
  var handleInputChange = function(ev) {
    setIntermediateValue(ev.target.value);
  };
  var handleFocus = function(ev) {
    var _a3;
    if (!input.current) {
      return;
    }
    if (internalState.spinningByMouse || keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {
      stop();
    }
    input.current.select();
    setIsFocused(true);
    (_a3 = props.onFocus) === null || _a3 === void 0 ? void 0 : _a3.call(props, ev);
  };
  var handleBlur = function(ev) {
    var _a3;
    validate(ev);
    setIsFocused(false);
    (_a3 = props.onBlur) === null || _a3 === void 0 ? void 0 : _a3.call(props, ev);
  };
  var handleKeyDown = function(ev) {
    if (ev.which === KeyCodes.up || ev.which === KeyCodes.down || ev.which === KeyCodes.enter) {
      ev.preventDefault();
      ev.stopPropagation();
    }
    if (disabled) {
      stop();
      return;
    }
    var spinDirection = KeyboardSpinDirection.notSpinning;
    switch (ev.which) {
      case KeyCodes.up:
        spinDirection = KeyboardSpinDirection.up;
        updateValue(handleIncrement, ev);
        break;
      case KeyCodes.down:
        spinDirection = KeyboardSpinDirection.down;
        updateValue(handleDecrement, ev);
        break;
      case KeyCodes.enter:
        validate(ev);
        break;
      case KeyCodes.escape:
        setIntermediateValue(void 0);
        break;
    }
    if (keyboardSpinDirection !== spinDirection) {
      setKeyboardSpinDirection(spinDirection);
    }
  };
  var handleKeyUp = React__namespace.useCallback(function(ev) {
    if (disabled || ev.which === KeyCodes.up || ev.which === KeyCodes.down) {
      stop();
      return;
    }
  }, [disabled, stop]);
  var handleIncrementMouseDown = React__namespace.useCallback(function(ev) {
    updateValue(handleIncrement, ev);
  }, [handleIncrement, updateValue]);
  var handleDecrementMouseDown = React__namespace.useCallback(function(ev) {
    updateValue(handleDecrement, ev);
  }, [handleDecrement, updateValue]);
  useComponentRef(props, input, value);
  useDebugWarnings(props);
  var valueIsNumber = !!value && !isNaN(Number(value));
  var labelContent = (iconProps || label) && React__namespace.createElement(
    "div",
    { className: classNames2.labelWrapper },
    iconProps && React__namespace.createElement(Icon, __assign$1({}, iconProps, { className: classNames2.icon, "aria-hidden": "true" })),
    label && React__namespace.createElement(Label, { id: labelId, htmlFor: inputId, className: classNames2.label, disabled }, label)
  );
  return React__namespace.createElement(
    "div",
    { className: classNames2.root, ref },
    labelPosition !== Position.bottom && labelContent,
    React__namespace.createElement(
      "div",
      __assign$1({}, nativeProps, { className: classNames2.spinButtonWrapper, "aria-label": ariaLabel && ariaLabel, "aria-posinset": ariaPositionInSet, "aria-setsize": ariaSetSize, "data-ktp-target": true }),
      React__namespace.createElement("input", __assign$1({
        // Display intermediateValue while editing the text (before commit)
        value: intermediateValue !== null && intermediateValue !== void 0 ? intermediateValue : value,
        id: inputId,
        onChange: noOp,
        onInput: handleInputChange,
        className: classNames2.input,
        type: "text",
        autoComplete: "off",
        role: "spinbutton",
        "aria-labelledby": label && labelId,
        "aria-valuenow": ariaValueNow !== null && ariaValueNow !== void 0 ? ariaValueNow : valueIsNumber ? Number(value) : void 0,
        "aria-valuetext": ariaValueText !== null && ariaValueText !== void 0 ? ariaValueText : valueIsNumber ? void 0 : value,
        "aria-valuemin": min2,
        "aria-valuemax": max2,
        "aria-describedby": ariaDescribedBy,
        onBlur: handleBlur,
        ref: input,
        onFocus: handleFocus,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        disabled,
        "aria-disabled": disabled,
        "data-lpignore": true,
        "data-ktp-execute-target": true
      }, inputProps)),
      React__namespace.createElement(
        "span",
        { className: classNames2.arrowButtonsContainer },
        React__namespace.createElement(IconButton, __assign$1({ styles: getArrowButtonStyles(theme, true, customUpArrowButtonStyles), className: "ms-UpButton", checked: keyboardSpinDirection === KeyboardSpinDirection.up, disabled, iconProps: incrementButtonIcon, onMouseDown: handleIncrementMouseDown, onMouseLeave: stop, onMouseUp: stop, tabIndex: -1, ariaLabel: incrementButtonAriaLabel, "data-is-focusable": false }, iconButtonProps)),
        React__namespace.createElement(IconButton, __assign$1({ styles: getArrowButtonStyles(theme, false, customDownArrowButtonStyles), className: "ms-DownButton", checked: keyboardSpinDirection === KeyboardSpinDirection.down, disabled, iconProps: decrementButtonIcon, onMouseDown: handleDecrementMouseDown, onMouseLeave: stop, onMouseUp: stop, tabIndex: -1, ariaLabel: decrementButtonAriaLabel, "data-is-focusable": false }, iconButtonProps))
      )
    ),
    labelPosition === Position.bottom && labelContent
  );
});
SpinButtonBase.displayName = COMPONENT_NAME;
var useDebugWarnings = function(props) {
  if (process.env.NODE_ENV !== "production") {
    useWarnings({
      name: COMPONENT_NAME,
      props,
      mutuallyExclusive: { value: "defaultValue" }
    });
  }
};
var SpinButton = styled(SpinButtonBase, getStyles, void 0, {
  scope: "SpinButton"
});
var assign$1 = __assign$1;
function withSlots(type, props) {
  var children = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }
  var slotType = type;
  if (slotType.isSlot) {
    children = React__namespace.Children.toArray(children);
    if (children.length === 0) {
      return slotType(props);
    }
    return slotType(__assign$1(__assign$1({}, props), { children }));
  } else {
    return React__namespace.createElement.apply(React__namespace, __spreadArray([type, props], children));
  }
}
function createFactory(DefaultComponent, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _a2 = options2.defaultProp, defaultProp = _a2 === void 0 ? "children" : _a2;
  var result = function(componentProps, userProps, userSlotOptions, defaultStyles2, theme) {
    if (React__namespace.isValidElement(userProps)) {
      return userProps;
    }
    var flattenedUserProps = _translateShorthand(defaultProp, userProps);
    var finalProps = _constructFinalProps(defaultStyles2, theme, componentProps, flattenedUserProps);
    if (userSlotOptions) {
      if (userSlotOptions.component) {
        var UserComponent = userSlotOptions.component;
        return React__namespace.createElement(UserComponent, __assign$1({}, finalProps));
      }
      if (userSlotOptions.render) {
        return userSlotOptions.render(finalProps, DefaultComponent);
      }
    }
    return React__namespace.createElement(DefaultComponent, __assign$1({}, finalProps));
  };
  return result;
}
var defaultFactory = memoizeFunction(function(type) {
  return createFactory(type);
});
function getSlots(userProps, slots) {
  var result = {};
  var mixedProps = userProps;
  var _loop_1 = function(name_12) {
    if (slots.hasOwnProperty(name_12)) {
      var slot = function(componentProps) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        if (args.length > 0) {
          throw new Error("Any module using getSlots must use withSlots. Please see withSlots javadoc for more info.");
        }
        return _renderSlot(
          slots[name_12],
          // TODO: this cast to any is hiding a relationship issue between the first two args
          componentProps,
          mixedProps[name_12],
          mixedProps.slots && mixedProps.slots[name_12],
          // _defaultStyles should always be present, but a check for existence is added to make view tests
          // easier to use.
          mixedProps._defaultStyles && mixedProps._defaultStyles[name_12],
          mixedProps.theme
        );
      };
      slot.isSlot = true;
      result[name_12] = slot;
    }
  };
  for (var name_1 in slots) {
    _loop_1(name_1);
  }
  return result;
}
function _translateShorthand(defaultProp, slotProps) {
  var _a2;
  var transformedProps;
  if (typeof slotProps === "string" || typeof slotProps === "number" || typeof slotProps === "boolean") {
    transformedProps = (_a2 = {}, _a2[defaultProp] = slotProps, _a2);
  } else {
    transformedProps = slotProps;
  }
  return transformedProps;
}
function _constructFinalProps(defaultStyles2, theme) {
  var allProps = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    allProps[_i - 2] = arguments[_i];
  }
  var finalProps = {};
  var classNames2 = [];
  for (var _a2 = 0, allProps_1 = allProps; _a2 < allProps_1.length; _a2++) {
    var props = allProps_1[_a2];
    classNames2.push(props && props.className);
    assign$1(finalProps, props);
  }
  finalProps.className = mergeCss([defaultStyles2, classNames2], { rtl: getRTL(theme) });
  return finalProps;
}
function _renderSlot(ComponentType, componentProps, userProps, slotOptions, defaultStyles2, theme) {
  if (ComponentType.create !== void 0) {
    return ComponentType.create(componentProps, userProps, slotOptions, defaultStyles2);
  } else {
    return defaultFactory(ComponentType)(componentProps, userProps, slotOptions, defaultStyles2, theme);
  }
}
function createComponent(view, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _a2 = options2.factoryOptions, factoryOptions = _a2 === void 0 ? {} : _a2;
  var defaultProp = factoryOptions.defaultProp;
  var ResultComponent = function(componentProps) {
    var settings = _getCustomizations(options2.displayName, React__namespace.useContext(CustomizerContext), options2.fields);
    var stateReducer = options2.state;
    if (stateReducer) {
      componentProps = __assign$1(__assign$1({}, componentProps), stateReducer(componentProps));
    }
    var theme = componentProps.theme || settings.theme;
    var tokens = _resolveTokens(componentProps, theme, options2.tokens, settings.tokens, componentProps.tokens);
    var styles2 = _resolveStyles(componentProps, theme, tokens, options2.styles, settings.styles, componentProps.styles);
    var viewProps = __assign$1(__assign$1({}, componentProps), { styles: styles2, tokens, _defaultStyles: styles2, theme });
    return view(viewProps);
  };
  ResultComponent.displayName = options2.displayName || view.name;
  if (defaultProp) {
    ResultComponent.create = createFactory(ResultComponent, { defaultProp });
  }
  assign$1(ResultComponent, options2.statics);
  return ResultComponent;
}
function _resolveStyles(props, theme, tokens) {
  var allStyles = [];
  for (var _i = 3; _i < arguments.length; _i++) {
    allStyles[_i - 3] = arguments[_i];
  }
  return concatStyleSets.apply(void 0, allStyles.map(function(styles2) {
    return typeof styles2 === "function" ? styles2(props, theme, tokens) : styles2;
  }));
}
function _resolveTokens(props, theme) {
  var allTokens = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    allTokens[_i - 2] = arguments[_i];
  }
  var tokens = {};
  for (var _a2 = 0, allTokens_1 = allTokens; _a2 < allTokens_1.length; _a2++) {
    var currentTokens = allTokens_1[_a2];
    if (currentTokens) {
      currentTokens = typeof currentTokens === "function" ? currentTokens(props, theme) : currentTokens;
      if (Array.isArray(currentTokens)) {
        currentTokens = _resolveTokens.apply(void 0, __spreadArray([props, theme], currentTokens));
      }
      assign$1(tokens, currentTokens);
    }
  }
  return tokens;
}
function _getCustomizations(displayName, context, fields) {
  var DefaultFields2 = ["theme", "styles", "tokens"];
  return Customizations.getSettings(fields || DefaultFields2, displayName, context.customizations);
}
var GlobalClassNames$1 = {
  root: "ms-StackItem"
};
var alignMap = {
  start: "flex-start",
  end: "flex-end"
};
var StackItemStyles = function(props, theme, tokens) {
  var grow = props.grow, shrink = props.shrink, disableShrink = props.disableShrink, align = props.align, verticalFill = props.verticalFill, order = props.order, className = props.className, _a2 = props.basis, basis = _a2 === void 0 ? "auto" : _a2;
  var classNames2 = getGlobalClassNames(GlobalClassNames$1, theme);
  return {
    root: [
      theme.fonts.medium,
      classNames2.root,
      {
        flexBasis: basis,
        margin: tokens.margin,
        padding: tokens.padding,
        height: verticalFill ? "100%" : "auto",
        width: "auto"
      },
      grow && {
        flexGrow: grow === true ? 1 : grow
      },
      (disableShrink || !grow && !shrink) && {
        flexShrink: 0
      },
      shrink && !disableShrink && {
        flexShrink: 1
      },
      align && {
        alignSelf: alignMap[align] || align
      },
      order && {
        order
      },
      className
    ]
    // TODO: this cast may be hiding some potential issues with styling and name
    //        lookups and should be removed
  };
};
var StackItemView = function(props) {
  var children = props.children;
  var nativeProps = getNativeProps(props, htmlElementProperties);
  if (children == null) {
    return null;
  }
  var Slots = getSlots(props, {
    root: "div"
  });
  return withSlots(Slots.root, __assign$1({}, nativeProps), children);
};
var StackItem = createComponent(StackItemView, {
  displayName: "StackItem",
  styles: StackItemStyles
});
var _getThemedSpacing = function(space, theme) {
  if (theme.spacing.hasOwnProperty(space)) {
    return theme.spacing[space];
  }
  return space;
};
var _getValueUnitGap = function(gap) {
  var numericalPart = parseFloat(gap);
  var numericalValue = isNaN(numericalPart) ? 0 : numericalPart;
  var numericalString = isNaN(numericalPart) ? "" : numericalPart.toString();
  var unitPart = gap.substring(numericalString.toString().length);
  return {
    value: numericalValue,
    unit: unitPart || "px"
  };
};
var parseGap = function(gap, theme) {
  if (gap === void 0 || gap === "") {
    return {
      rowGap: {
        value: 0,
        unit: "px"
      },
      columnGap: {
        value: 0,
        unit: "px"
      }
    };
  }
  if (typeof gap === "number") {
    return {
      rowGap: {
        value: gap,
        unit: "px"
      },
      columnGap: {
        value: gap,
        unit: "px"
      }
    };
  }
  var splitGap = gap.split(" ");
  if (splitGap.length > 2) {
    return {
      rowGap: {
        value: 0,
        unit: "px"
      },
      columnGap: {
        value: 0,
        unit: "px"
      }
    };
  }
  if (splitGap.length === 2) {
    return {
      rowGap: _getValueUnitGap(_getThemedSpacing(splitGap[0], theme)),
      columnGap: _getValueUnitGap(_getThemedSpacing(splitGap[1], theme))
    };
  }
  var calculatedGap = _getValueUnitGap(_getThemedSpacing(gap, theme));
  return {
    rowGap: calculatedGap,
    columnGap: calculatedGap
  };
};
var parsePadding = function(padding, theme) {
  if (padding === void 0 || typeof padding === "number" || padding === "") {
    return padding;
  }
  var paddingValues = padding.split(" ");
  if (paddingValues.length < 2) {
    return _getThemedSpacing(padding, theme);
  }
  return paddingValues.reduce(function(padding1, padding2) {
    return _getThemedSpacing(padding1, theme) + " " + _getThemedSpacing(padding2, theme);
  });
};
var nameMap = {
  start: "flex-start",
  end: "flex-end"
};
var GlobalClassNames = {
  root: "ms-Stack",
  inner: "ms-Stack-inner",
  child: "ms-Stack-child"
};
var styles$2 = function(props, theme, tokens) {
  var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l, _m, _o;
  var className = props.className, disableShrink = props.disableShrink, enableScopedSelectors = props.enableScopedSelectors, grow = props.grow, horizontal = props.horizontal, horizontalAlign = props.horizontalAlign, reversed = props.reversed, verticalAlign = props.verticalAlign, verticalFill = props.verticalFill, wrap = props.wrap;
  var classNames2 = getGlobalClassNames(GlobalClassNames, theme);
  var childrenGap = tokens && tokens.childrenGap ? tokens.childrenGap : props.gap;
  var maxHeight = tokens && tokens.maxHeight ? tokens.maxHeight : props.maxHeight;
  var maxWidth = tokens && tokens.maxWidth ? tokens.maxWidth : props.maxWidth;
  var padding = tokens && tokens.padding ? tokens.padding : props.padding;
  var _p = parseGap(childrenGap, theme), rowGap = _p.rowGap, columnGap = _p.columnGap;
  var horizontalMargin = "" + -0.5 * columnGap.value + columnGap.unit;
  var verticalMargin = "" + -0.5 * rowGap.value + rowGap.unit;
  var childStyles = {
    textOverflow: "ellipsis"
  };
  var childSelector = "> " + (enableScopedSelectors ? "." + GlobalClassNames.child : "*");
  var disableShrinkStyles = (_a2 = {}, // flexShrink styles are applied by the StackItem
  _a2[childSelector + ":not(." + GlobalClassNames$1.root + ")"] = {
    flexShrink: 0
  }, _a2);
  if (wrap) {
    return {
      root: [
        classNames2.root,
        {
          flexWrap: "wrap",
          maxWidth,
          maxHeight,
          width: "auto",
          overflow: "visible",
          height: "100%"
        },
        horizontalAlign && (_b2 = {}, _b2[horizontal ? "justifyContent" : "alignItems"] = nameMap[horizontalAlign] || horizontalAlign, _b2),
        verticalAlign && (_c2 = {}, _c2[horizontal ? "alignItems" : "justifyContent"] = nameMap[verticalAlign] || verticalAlign, _c2),
        className,
        {
          // not allowed to be overridden by className
          // since this is necessary in order to prevent collapsing margins
          display: "flex"
        },
        horizontal && {
          height: verticalFill ? "100%" : "auto"
        }
      ],
      inner: [
        classNames2.inner,
        (_d2 = {
          display: "flex",
          flexWrap: "wrap",
          marginLeft: horizontalMargin,
          marginRight: horizontalMargin,
          marginTop: verticalMargin,
          marginBottom: verticalMargin,
          overflow: "visible",
          boxSizing: "border-box",
          padding: parsePadding(padding, theme),
          // avoid unnecessary calc() calls if horizontal gap is 0
          width: columnGap.value === 0 ? "100%" : "calc(100% + " + columnGap.value + columnGap.unit + ")",
          maxWidth: "100vw"
        }, _d2[childSelector] = __assign$1({ margin: "" + 0.5 * rowGap.value + rowGap.unit + " " + 0.5 * columnGap.value + columnGap.unit }, childStyles), _d2),
        disableShrink && disableShrinkStyles,
        horizontalAlign && (_e2 = {}, _e2[horizontal ? "justifyContent" : "alignItems"] = nameMap[horizontalAlign] || horizontalAlign, _e2),
        verticalAlign && (_f = {}, _f[horizontal ? "alignItems" : "justifyContent"] = nameMap[verticalAlign] || verticalAlign, _f),
        horizontal && (_g = {
          flexDirection: reversed ? "row-reverse" : "row",
          // avoid unnecessary calc() calls if vertical gap is 0
          height: rowGap.value === 0 ? "100%" : "calc(100% + " + rowGap.value + rowGap.unit + ")"
        }, _g[childSelector] = {
          maxWidth: columnGap.value === 0 ? "100%" : "calc(100% - " + columnGap.value + columnGap.unit + ")"
        }, _g),
        !horizontal && (_h = {
          flexDirection: reversed ? "column-reverse" : "column",
          height: "calc(100% + " + rowGap.value + rowGap.unit + ")"
        }, _h[childSelector] = {
          maxHeight: rowGap.value === 0 ? "100%" : "calc(100% - " + rowGap.value + rowGap.unit + ")"
        }, _h)
      ]
    };
  }
  return {
    root: [
      classNames2.root,
      (_j = {
        display: "flex",
        flexDirection: horizontal ? reversed ? "row-reverse" : "row" : reversed ? "column-reverse" : "column",
        flexWrap: "nowrap",
        width: "auto",
        height: verticalFill ? "100%" : "auto",
        maxWidth,
        maxHeight,
        padding: parsePadding(padding, theme),
        boxSizing: "border-box"
      }, _j[childSelector] = childStyles, _j),
      disableShrink && disableShrinkStyles,
      grow && {
        flexGrow: grow === true ? 1 : grow
      },
      horizontalAlign && (_k = {}, _k[horizontal ? "justifyContent" : "alignItems"] = nameMap[horizontalAlign] || horizontalAlign, _k),
      verticalAlign && (_l = {}, _l[horizontal ? "alignItems" : "justifyContent"] = nameMap[verticalAlign] || verticalAlign, _l),
      horizontal && columnGap.value > 0 && (_m = {}, // apply gap margin to every direct child except the first direct child if the direction is not reversed,
      // and the last direct one if it is
      _m[reversed ? childSelector + ":not(:last-child)" : childSelector + ":not(:first-child)"] = {
        marginLeft: "" + columnGap.value + columnGap.unit
      }, _m),
      !horizontal && rowGap.value > 0 && (_o = {}, // apply gap margin to every direct child except the first direct child if the direction is not reversed,
      // and the last direct one if it is
      _o[reversed ? childSelector + ":not(:last-child)" : childSelector + ":not(:first-child)"] = {
        marginTop: "" + rowGap.value + rowGap.unit
      }, _o),
      className
    ]
    // TODO: this cast may be hiding some potential issues with styling and name
    //        lookups and should be removed
  };
};
var StackView = function(props) {
  var _a2 = props.as, RootType = _a2 === void 0 ? "div" : _a2, _b2 = props.disableShrink, disableShrink = _b2 === void 0 ? false : _b2, _c2 = props.enableScopedSelectors, enableScopedSelectors = _c2 === void 0 ? false : _c2, wrap = props.wrap, rest = __rest$1(props, ["as", "disableShrink", "enableScopedSelectors", "wrap"]);
  warnDeprecations("Stack", props, {
    gap: "tokens.childrenGap",
    maxHeight: "tokens.maxHeight",
    maxWidth: "tokens.maxWidth",
    padding: "tokens.padding"
  });
  var stackChildren = _processStackChildren(props.children, { disableShrink, enableScopedSelectors });
  var nativeProps = getNativeProps(rest, htmlElementProperties);
  var Slots = getSlots(props, {
    root: RootType,
    inner: "div"
  });
  if (wrap) {
    return withSlots(
      Slots.root,
      __assign$1({}, nativeProps),
      withSlots(Slots.inner, null, stackChildren)
    );
  }
  return withSlots(Slots.root, __assign$1({}, nativeProps), stackChildren);
};
function _processStackChildren(children, _a2) {
  var disableShrink = _a2.disableShrink, enableScopedSelectors = _a2.enableScopedSelectors;
  var childrenArray = React__namespace.Children.toArray(children);
  childrenArray = React__namespace.Children.map(childrenArray, function(child) {
    if (!child || !React__namespace.isValidElement(child)) {
      return child;
    }
    if (child.type === React__namespace.Fragment) {
      return child.props.children ? _processStackChildren(child.props.children, { disableShrink, enableScopedSelectors }) : null;
    }
    var childAsReactElement = child;
    var defaultItemProps = {};
    if (_isStackItem(child)) {
      defaultItemProps = { shrink: !disableShrink };
    }
    var childClassName = childAsReactElement.props.className;
    return React__namespace.cloneElement(childAsReactElement, __assign$1(__assign$1(__assign$1(__assign$1({}, defaultItemProps), childAsReactElement.props), childClassName && { className: childClassName }), enableScopedSelectors && { className: css$3(GlobalClassNames.child, childClassName) }));
  });
  return childrenArray;
}
function _isStackItem(item) {
  return !!item && typeof item === "object" && !!item.type && // StackItem is generated by createComponent, so we need to check its displayName instead of name
  item.type.displayName === StackItem.displayName;
}
var StackStatics = {
  Item: StackItem
};
var Stack = createComponent(StackView, {
  displayName: "Stack",
  styles: styles$2,
  statics: StackStatics
});
var StickyPositionType;
(function(StickyPositionType2) {
  StickyPositionType2[StickyPositionType2["Both"] = 0] = "Both";
  StickyPositionType2[StickyPositionType2["Header"] = 1] = "Header";
  StickyPositionType2[StickyPositionType2["Footer"] = 2] = "Footer";
})(StickyPositionType || (StickyPositionType = {}));
var Sticky = (
  /** @class */
  function(_super) {
    __extends(Sticky2, _super);
    function Sticky2(props) {
      var _this = _super.call(this, props) || this;
      _this._root = React__namespace.createRef();
      _this._stickyContentTop = React__namespace.createRef();
      _this._stickyContentBottom = React__namespace.createRef();
      _this._nonStickyContent = React__namespace.createRef();
      _this._placeHolder = React__namespace.createRef();
      _this.syncScroll = function(container) {
        var nonStickyContent = _this.nonStickyContent;
        if (nonStickyContent && _this.props.isScrollSynced) {
          nonStickyContent.scrollLeft = container.scrollLeft;
        }
      };
      _this._getContext = function() {
        return _this.context;
      };
      _this._onScrollEvent = function(container, footerStickyContainer) {
        if (_this.root && _this.nonStickyContent) {
          var distanceFromTop = _this._getNonStickyDistanceFromTop(container);
          var isStickyTop = false;
          var isStickyBottom = false;
          if (_this.canStickyTop) {
            var distanceToStickTop = distanceFromTop - _this._getStickyDistanceFromTop();
            isStickyTop = distanceToStickTop < container.scrollTop;
          }
          if (_this.canStickyBottom && container.clientHeight - footerStickyContainer.offsetHeight <= distanceFromTop) {
            isStickyBottom = distanceFromTop - Math.floor(container.scrollTop) >= _this._getStickyDistanceFromTopForFooter(container, footerStickyContainer);
          }
          if (document.activeElement && _this.nonStickyContent.contains(document.activeElement) && (_this.state.isStickyTop !== isStickyTop || _this.state.isStickyBottom !== isStickyBottom)) {
            _this._activeElement = document.activeElement;
          } else {
            _this._activeElement = void 0;
          }
          _this.setState({
            isStickyTop: _this.canStickyTop && isStickyTop,
            isStickyBottom,
            distanceFromTop
          });
        }
      };
      _this._getStickyDistanceFromTop = function() {
        var distance = 0;
        if (_this.stickyContentTop) {
          distance = _this.stickyContentTop.offsetTop;
        }
        return distance;
      };
      _this._getStickyDistanceFromTopForFooter = function(container, footerStickyVisibleContainer) {
        var distance = 0;
        if (_this.stickyContentBottom) {
          distance = container.clientHeight - footerStickyVisibleContainer.offsetHeight + _this.stickyContentBottom.offsetTop;
        }
        return distance;
      };
      _this._getNonStickyDistanceFromTop = function(container) {
        var distance = 0;
        var currElem = _this.root;
        if (currElem) {
          while (currElem && currElem.offsetParent !== container) {
            distance += currElem.offsetTop;
            currElem = currElem.offsetParent;
          }
          if (currElem && currElem.offsetParent === container) {
            distance += currElem.offsetTop;
          }
        }
        return distance;
      };
      initializeComponentRef(_this);
      _this.state = {
        isStickyTop: false,
        isStickyBottom: false,
        distanceFromTop: void 0
      };
      _this._activeElement = void 0;
      return _this;
    }
    Object.defineProperty(Sticky2.prototype, "root", {
      get: function() {
        return this._root.current;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sticky2.prototype, "placeholder", {
      get: function() {
        return this._placeHolder.current;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sticky2.prototype, "stickyContentTop", {
      get: function() {
        return this._stickyContentTop.current;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sticky2.prototype, "stickyContentBottom", {
      get: function() {
        return this._stickyContentBottom.current;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sticky2.prototype, "nonStickyContent", {
      get: function() {
        return this._nonStickyContent.current;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sticky2.prototype, "canStickyTop", {
      get: function() {
        return this.props.stickyPosition === StickyPositionType.Both || this.props.stickyPosition === StickyPositionType.Header;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Sticky2.prototype, "canStickyBottom", {
      get: function() {
        return this.props.stickyPosition === StickyPositionType.Both || this.props.stickyPosition === StickyPositionType.Footer;
      },
      enumerable: false,
      configurable: true
    });
    Sticky2.prototype.componentDidMount = function() {
      var scrollablePane = this._getContext().scrollablePane;
      if (!scrollablePane) {
        return;
      }
      scrollablePane.subscribe(this._onScrollEvent);
      scrollablePane.addSticky(this);
    };
    Sticky2.prototype.componentWillUnmount = function() {
      var scrollablePane = this._getContext().scrollablePane;
      if (!scrollablePane) {
        return;
      }
      scrollablePane.unsubscribe(this._onScrollEvent);
      scrollablePane.removeSticky(this);
    };
    Sticky2.prototype.componentDidUpdate = function(prevProps, prevState) {
      var scrollablePane = this._getContext().scrollablePane;
      if (!scrollablePane) {
        return;
      }
      var _a2 = this.state, isStickyBottom = _a2.isStickyBottom, isStickyTop = _a2.isStickyTop, distanceFromTop = _a2.distanceFromTop;
      var syncScroll = false;
      if (prevState.distanceFromTop !== distanceFromTop) {
        scrollablePane.sortSticky(
          this,
          true
          /*sortAgain*/
        );
        syncScroll = true;
      }
      if (prevState.isStickyTop !== isStickyTop || prevState.isStickyBottom !== isStickyBottom) {
        if (this._activeElement) {
          this._activeElement.focus();
        }
        scrollablePane.updateStickyRefHeights();
        syncScroll = true;
      }
      if (syncScroll) {
        scrollablePane.syncScrollSticky(this);
      }
    };
    Sticky2.prototype.shouldComponentUpdate = function(nextProps, nextState) {
      if (!this.context.scrollablePane) {
        return true;
      }
      var _a2 = this.state, isStickyTop = _a2.isStickyTop, isStickyBottom = _a2.isStickyBottom, distanceFromTop = _a2.distanceFromTop;
      return isStickyTop !== nextState.isStickyTop || isStickyBottom !== nextState.isStickyBottom || this.props.stickyPosition !== nextProps.stickyPosition || this.props.children !== nextProps.children || distanceFromTop !== nextState.distanceFromTop || _isOffsetHeightDifferent(this._nonStickyContent, this._stickyContentTop) || _isOffsetHeightDifferent(this._nonStickyContent, this._stickyContentBottom) || _isOffsetHeightDifferent(this._nonStickyContent, this._placeHolder);
    };
    Sticky2.prototype.render = function() {
      var _a2 = this.state, isStickyTop = _a2.isStickyTop, isStickyBottom = _a2.isStickyBottom;
      var _b2 = this.props, stickyClassName = _b2.stickyClassName, children = _b2.children;
      if (!this.context.scrollablePane) {
        return React__namespace.createElement("div", null, this.props.children);
      }
      return React__namespace.createElement(
        "div",
        { ref: this._root },
        this.canStickyTop && React__namespace.createElement(
          "div",
          { ref: this._stickyContentTop, style: { pointerEvents: isStickyTop ? "auto" : "none" } },
          React__namespace.createElement("div", { style: this._getStickyPlaceholderHeight(isStickyTop) })
        ),
        this.canStickyBottom && React__namespace.createElement(
          "div",
          { ref: this._stickyContentBottom, style: { pointerEvents: isStickyBottom ? "auto" : "none" } },
          React__namespace.createElement("div", { style: this._getStickyPlaceholderHeight(isStickyBottom) })
        ),
        React__namespace.createElement(
          "div",
          { style: this._getNonStickyPlaceholderHeightAndWidth(), ref: this._placeHolder },
          (isStickyTop || isStickyBottom) && React__namespace.createElement("span", { style: hiddenContentStyle }, children),
          React__namespace.createElement("div", { ref: this._nonStickyContent, className: isStickyTop || isStickyBottom ? stickyClassName : void 0, style: this._getContentStyles(isStickyTop || isStickyBottom) }, children)
        )
      );
    };
    Sticky2.prototype.addSticky = function(stickyContent) {
      if (this.nonStickyContent) {
        stickyContent.appendChild(this.nonStickyContent);
      }
    };
    Sticky2.prototype.resetSticky = function() {
      if (this.nonStickyContent && this.placeholder) {
        this.placeholder.appendChild(this.nonStickyContent);
      }
    };
    Sticky2.prototype.setDistanceFromTop = function(container) {
      var distanceFromTop = this._getNonStickyDistanceFromTop(container);
      this.setState({ distanceFromTop });
    };
    Sticky2.prototype._getContentStyles = function(isSticky) {
      return {
        backgroundColor: this.props.stickyBackgroundColor || this._getBackground(),
        overflow: isSticky ? "hidden" : ""
      };
    };
    Sticky2.prototype._getStickyPlaceholderHeight = function(isSticky) {
      var height = this.nonStickyContent ? this.nonStickyContent.offsetHeight : 0;
      return {
        visibility: isSticky ? "hidden" : "visible",
        height: isSticky ? 0 : height
      };
    };
    Sticky2.prototype._getNonStickyPlaceholderHeightAndWidth = function() {
      var _a2 = this.state, isStickyTop = _a2.isStickyTop, isStickyBottom = _a2.isStickyBottom;
      if (isStickyTop || isStickyBottom) {
        var height = 0;
        var width = 0;
        if (this.nonStickyContent && this.nonStickyContent.firstElementChild) {
          height = this.nonStickyContent.offsetHeight;
          width = this.nonStickyContent.firstElementChild.scrollWidth + (this.nonStickyContent.firstElementChild.offsetWidth - this.nonStickyContent.firstElementChild.clientWidth);
        }
        return {
          height,
          width
        };
      } else {
        return {};
      }
    };
    Sticky2.prototype._getBackground = function() {
      if (!this.root) {
        return void 0;
      }
      var curr = this.root;
      while (window.getComputedStyle(curr).getPropertyValue("background-color") === "rgba(0, 0, 0, 0)" || window.getComputedStyle(curr).getPropertyValue("background-color") === "transparent") {
        if (curr.tagName === "HTML") {
          return void 0;
        }
        if (curr.parentElement) {
          curr = curr.parentElement;
        }
      }
      return window.getComputedStyle(curr).getPropertyValue("background-color");
    };
    Sticky2.defaultProps = {
      stickyPosition: StickyPositionType.Both,
      isScrollSynced: true
    };
    Sticky2.contextType = ScrollablePaneContext;
    return Sticky2;
  }(React__namespace.Component)
);
function _isOffsetHeightDifferent(a, b) {
  return a && b && a.current && b.current && a.current.offsetHeight !== b.current.offsetHeight;
}
var TextView = function(props) {
  if (props.children == null) {
    return null;
  }
  props.block;
  props.className;
  var _a2 = props.as, RootType = _a2 === void 0 ? "span" : _a2;
  props.variant;
  props.nowrap;
  var rest = __rest$1(props, ["block", "className", "as", "variant", "nowrap"]);
  var Slots = getSlots(props, {
    root: RootType
  });
  return withSlots(Slots.root, __assign$1({}, getNativeProps(rest, htmlElementProperties)));
};
var TextStyles = function(props, theme) {
  var as = props.as, className = props.className, block = props.block, nowrap = props.nowrap, variant = props.variant;
  var fonts = theme.fonts, semanticColors = theme.semanticColors;
  var variantObject = fonts[variant || "medium"];
  return {
    root: [
      variantObject,
      {
        color: variantObject.color || semanticColors.bodyText,
        display: block ? as === "td" ? "table-cell" : "block" : "inline",
        mozOsxFontSmoothing: variantObject.MozOsxFontSmoothing,
        webkitFontSmoothing: variantObject.WebkitFontSmoothing
      },
      nowrap && {
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis"
      },
      className
    ]
  };
};
var Text = createComponent(TextView, {
  displayName: "Text",
  styles: TextStyles
});
const DayPickerStrings = {
  months: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  shortMonths: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  days: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  shortDays: ["S", "M", "T", "W", "T", "F", "S"],
  goToToday: "Go to today",
  prevMonthAriaLabel: "Go to previous month",
  nextMonthAriaLabel: "Go to next month",
  prevYearAriaLabel: "Go to previous year",
  nextYearAriaLabel: "Go to next year",
  closeButtonAriaLabel: "Close date picker",
  isRequiredErrorMessage: "Field is required.",
  invalidInputErrorMessage: "Invalid date format."
};
function dateToISOLikeButLocal(date) {
  const offsetMs = date.getTimezoneOffset() * 60 * 1e3;
  const msLocal = date.getTime() - offsetMs;
  const dateLocal = new Date(msLocal);
  const iso = dateLocal.toISOString();
  const isoLocal = iso.slice(0, 10);
  return isoLocal;
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t)
          return;
        f = false;
      } else
        for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
          ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u))
          return;
      } finally {
        if (o)
          throw n;
      }
    }
    return a;
  }
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var _excluded$6 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref3) {
  var _ref$defaultInputValu = _ref3.defaultInputValue, defaultInputValue = _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu, _ref$defaultMenuIsOpe = _ref3.defaultMenuIsOpen, defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe, _ref$defaultValue = _ref3.defaultValue, defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue, propsInputValue = _ref3.inputValue, propsMenuIsOpen = _ref3.menuIsOpen, propsOnChange = _ref3.onChange, propsOnInputChange = _ref3.onInputChange, propsOnMenuClose = _ref3.onMenuClose, propsOnMenuOpen = _ref3.onMenuOpen, propsValue = _ref3.value, restSelectProps = _objectWithoutProperties(_ref3, _excluded$6);
  var _useState = React.useState(propsInputValue !== void 0 ? propsInputValue : defaultInputValue), _useState2 = _slicedToArray(_useState, 2), stateInputValue = _useState2[0], setStateInputValue = _useState2[1];
  var _useState3 = React.useState(propsMenuIsOpen !== void 0 ? propsMenuIsOpen : defaultMenuIsOpen), _useState4 = _slicedToArray(_useState3, 2), stateMenuIsOpen = _useState4[0], setStateMenuIsOpen = _useState4[1];
  var _useState5 = React.useState(propsValue !== void 0 ? propsValue : defaultValue), _useState6 = _slicedToArray(_useState5, 2), stateValue = _useState6[0], setStateValue = _useState6[1];
  var onChange2 = React.useCallback(function(value2, actionMeta) {
    if (typeof propsOnChange === "function") {
      propsOnChange(value2, actionMeta);
    }
    setStateValue(value2);
  }, [propsOnChange]);
  var onInputChange = React.useCallback(function(value2, actionMeta) {
    var newValue;
    if (typeof propsOnInputChange === "function") {
      newValue = propsOnInputChange(value2, actionMeta);
    }
    setStateInputValue(newValue !== void 0 ? newValue : value2);
  }, [propsOnInputChange]);
  var onMenuOpen = React.useCallback(function() {
    if (typeof propsOnMenuOpen === "function") {
      propsOnMenuOpen();
    }
    setStateMenuIsOpen(true);
  }, [propsOnMenuOpen]);
  var onMenuClose = React.useCallback(function() {
    if (typeof propsOnMenuClose === "function") {
      propsOnMenuClose();
    }
    setStateMenuIsOpen(false);
  }, [propsOnMenuClose]);
  var inputValue = propsInputValue !== void 0 ? propsInputValue : stateInputValue;
  var menuIsOpen = propsMenuIsOpen !== void 0 ? propsMenuIsOpen : stateMenuIsOpen;
  var value = propsValue !== void 0 ? propsValue : stateValue;
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    inputValue,
    menuIsOpen,
    onChange: onChange2,
    onInputChange,
    onMenuClose,
    onMenuOpen,
    value
  });
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options2) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options2.key);
  if (options2.nonce !== void 0) {
    tag.setAttribute("nonce", options2.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options2.speedy === void 0 ? process.env.NODE_ENV === "production" : options2.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options2.nonce;
    this.key = options2.key;
    this.container = options2.container;
    this.prepend = options2.prepend;
    this.insertionPoint = options2.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (process.env.NODE_ENV !== "production") {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (process.env.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush2() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    if (process.env.NODE_ENV !== "production") {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type, props, children, length2) {
  return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root2, props) {
  return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root2, parent, rule, rules2, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules2;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root2, parent, index2, offset, rules2, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type, rules2, props = [], length2), children), rules2, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset, rules2, points, type, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules2 : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index2; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props[k++] = z;
  return node(value, root2, parent, offset === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function memoize(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn(arg);
    return cache[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules2 = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules2.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules2[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules2[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element) {
  return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache) {
  return function(element, index2, children) {
    if (element.type !== "rule" || cache.compat)
      return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element.parent;
      var commentContainer = isNested ? element.parent.children : (
        // global rule at the root level
        children
      );
      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node2 = commentContainer[i];
        if (node2.line < element.line) {
          break;
        }
        if (node2.column < element.column) {
          if (isIgnoringComment(node2)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index2, children) {
  for (var i = index2 - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element) {
  element.type = "";
  element.value = "";
  element["return"] = "";
  element.children = "";
  element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element, index2, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index2, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};
function prefix(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy(element, {
                    props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options2) {
  var key = options2.key;
  if (process.env.NODE_ENV !== "production" && !key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
  if (process.env.NODE_ENV !== "production") {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options2.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  if (process.env.NODE_ENV !== "production") {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, process.env.NODE_ENV !== "production" ? function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    } : rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if (process.env.NODE_ENV !== "production" && serialized.map !== void 0) {
        currentSheet = {
          insert: function insert2(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend,
      insertionPoint: options2.insertionPoint
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min)
    return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w2 = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u = a.$$typeof;
      switch (u) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case n:
                case t:
                case r:
                case h:
                  return a;
                default:
                  return u;
              }
          }
        case d:
          return u;
      }
    }
  }
  function A(a) {
    return z(a) === m;
  }
  reactIs_production_min.AsyncMode = l;
  reactIs_production_min.ConcurrentMode = m;
  reactIs_production_min.ContextConsumer = k;
  reactIs_production_min.ContextProvider = h;
  reactIs_production_min.Element = c;
  reactIs_production_min.ForwardRef = n;
  reactIs_production_min.Fragment = e;
  reactIs_production_min.Lazy = t;
  reactIs_production_min.Memo = r;
  reactIs_production_min.Portal = d;
  reactIs_production_min.Profiler = g;
  reactIs_production_min.StrictMode = f;
  reactIs_production_min.Suspense = p;
  reactIs_production_min.isAsyncMode = function(a) {
    return A(a) || z(a) === l;
  };
  reactIs_production_min.isConcurrentMode = A;
  reactIs_production_min.isContextConsumer = function(a) {
    return z(a) === k;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return z(a) === h;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return z(a) === n;
  };
  reactIs_production_min.isFragment = function(a) {
    return z(a) === e;
  };
  reactIs_production_min.isLazy = function(a) {
    return z(a) === t;
  };
  reactIs_production_min.isMemo = function(a) {
    return z(a) === r;
  };
  reactIs_production_min.isPortal = function(a) {
    return z(a) === d;
  };
  reactIs_production_min.isProfiler = function(a) {
    return z(a) === g;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return z(a) === f;
  };
  reactIs_production_min.isSuspense = function(a) {
    return z(a) === p;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w2 || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
  };
  reactIs_production_min.typeOf = z;
  return reactIs_production_min;
}
var reactIs_development = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development;
function requireReactIs_development() {
  if (hasRequiredReactIs_development)
    return reactIs_development;
  hasRequiredReactIs_development = 1;
  if (process.env.NODE_ENV !== "production") {
    (function() {
      var hasSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
      var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
      var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
      var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
      var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
      var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
      var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
      function isValidElementType(type) {
        return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
        type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
      }
      function typeOf(object) {
        if (typeof object === "object" && object !== null) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              var type = object.type;
              switch (type) {
                case REACT_ASYNC_MODE_TYPE:
                case REACT_CONCURRENT_MODE_TYPE:
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                  return type;
                default:
                  var $$typeofType = type && type.$$typeof;
                  switch ($$typeofType) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                    case REACT_PROVIDER_TYPE:
                      return $$typeofType;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
        return void 0;
      }
      var AsyncMode = REACT_ASYNC_MODE_TYPE;
      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      var ContextConsumer = REACT_CONTEXT_TYPE;
      var ContextProvider = REACT_PROVIDER_TYPE;
      var Element2 = REACT_ELEMENT_TYPE;
      var ForwardRef = REACT_FORWARD_REF_TYPE;
      var Fragment = REACT_FRAGMENT_TYPE;
      var Lazy = REACT_LAZY_TYPE;
      var Memo = REACT_MEMO_TYPE;
      var Portal = REACT_PORTAL_TYPE;
      var Profiler = REACT_PROFILER_TYPE;
      var StrictMode = REACT_STRICT_MODE_TYPE;
      var Suspense = REACT_SUSPENSE_TYPE;
      var hasWarnedAboutDeprecatedIsAsyncMode = false;
      function isAsyncMode(object) {
        {
          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
            hasWarnedAboutDeprecatedIsAsyncMode = true;
            console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
          }
        }
        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
      }
      function isConcurrentMode(object) {
        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
      }
      function isContextConsumer(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      }
      function isContextProvider(object) {
        return typeOf(object) === REACT_PROVIDER_TYPE;
      }
      function isElement2(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function isForwardRef(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      }
      function isFragment(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      }
      function isLazy(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      }
      function isMemo(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      }
      function isPortal(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      }
      function isProfiler(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      }
      function isStrictMode(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      }
      function isSuspense(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      }
      reactIs_development.AsyncMode = AsyncMode;
      reactIs_development.ConcurrentMode = ConcurrentMode;
      reactIs_development.ContextConsumer = ContextConsumer;
      reactIs_development.ContextProvider = ContextProvider;
      reactIs_development.Element = Element2;
      reactIs_development.ForwardRef = ForwardRef;
      reactIs_development.Fragment = Fragment;
      reactIs_development.Lazy = Lazy;
      reactIs_development.Memo = Memo;
      reactIs_development.Portal = Portal;
      reactIs_development.Profiler = Profiler;
      reactIs_development.StrictMode = StrictMode;
      reactIs_development.Suspense = Suspense;
      reactIs_development.isAsyncMode = isAsyncMode;
      reactIs_development.isConcurrentMode = isConcurrentMode;
      reactIs_development.isContextConsumer = isContextConsumer;
      reactIs_development.isContextProvider = isContextProvider;
      reactIs_development.isElement = isElement2;
      reactIs_development.isForwardRef = isForwardRef;
      reactIs_development.isFragment = isFragment;
      reactIs_development.isLazy = isLazy;
      reactIs_development.isMemo = isMemo;
      reactIs_development.isPortal = isPortal;
      reactIs_development.isProfiler = isProfiler;
      reactIs_development.isStrictMode = isStrictMode;
      reactIs_development.isSuspense = isSuspense;
      reactIs_development.isValidElementType = isValidElementType;
      reactIs_development.typeOf = typeOf;
    })();
  }
  return reactIs_development;
}
if (process.env.NODE_ENV === "production") {
  reactIs$1.exports = requireReactIs_production_min();
} else {
  reactIs$1.exports = requireReactIs_development();
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser$1 = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$1 === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
if (process.env.NODE_ENV !== "production") {
  var contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  var contentValues = ["normal", "none", "initial", "inherit", "unset"];
  var oldProcessStyleValue = processStyleValue;
  var msPattern = /^-ms-/;
  var hyphenPattern = /-(.)/g;
  var hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value) {
    if (key === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    if (process.env.NODE_ENV !== "production" && interpolation.toString() === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        if (process.env.NODE_ENV !== "production" && interpolation.map !== void 0) {
          styles2 += interpolation.map;
        }
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else if (process.env.NODE_ENV !== "production") {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      if (process.env.NODE_ENV !== "production") {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(match2, p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
        }
      }
      break;
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && process.env.NODE_ENV !== "production") {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (process.env.NODE_ENV !== "production" && _key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
if (process.env.NODE_ENV !== "production") {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
}
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (process.env.NODE_ENV !== "production" && strings[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles2 += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      if (process.env.NODE_ENV !== "production" && strings[i] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles2 += strings[i];
    }
  }
  var sourceMap;
  if (process.env.NODE_ENV !== "production") {
    styles2 = styles2.replace(sourceMapPattern, function(match3) {
      sourceMap = match3;
      return "";
    });
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  if (process.env.NODE_ENV !== "production") {
    return {
      name,
      styles: styles2,
      map: sourceMap,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }
  return {
    name,
    styles: styles2,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React__namespace["useInsertionEffect"] ? React__namespace["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || React__namespace.useLayoutEffect;
var hasOwnProperty = {}.hasOwnProperty;
var EmotionCacheContext = /* @__PURE__ */ React__namespace.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
if (process.env.NODE_ENV !== "production") {
  EmotionCacheContext.displayName = "EmotionCacheContext";
}
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var cache = React.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext = /* @__PURE__ */ React__namespace.createContext({});
if (process.env.NODE_ENV !== "production") {
  ThemeContext.displayName = "EmotionThemeContext";
}
var getLastPart = function getLastPart2(functionName) {
  var parts = functionName.split(".");
  return parts[parts.length - 1];
};
var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine2(line2) {
  var match2 = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line2);
  if (match2)
    return getLastPart(match2[1]);
  match2 = /^([A-Za-z0-9$.]+)@/.exec(line2);
  if (match2)
    return getLastPart(match2[1]);
  return void 0;
};
var internalReactFunctionNames = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]);
var sanitizeIdentifier = function sanitizeIdentifier2(identifier2) {
  return identifier2.replace(/\$/g, "-");
};
var getLabelFromStackTrace = function getLabelFromStackTrace2(stackTrace) {
  if (!stackTrace)
    return void 0;
  var lines = stackTrace.split("\n");
  for (var i = 0; i < lines.length; i++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i]);
    if (!functionName)
      continue;
    if (internalReactFunctionNames.has(functionName))
      break;
    if (/^[A-Z]/.test(functionName))
      return sanitizeIdentifier(functionName);
  }
  return void 0;
};
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  if (process.env.NODE_ENV !== "production" && typeof props.css === "string" && // check if there is a css declaration
  props.css.indexOf(":") !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
  }
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type;
  if (process.env.NODE_ENV !== "production" && !!props.css && (typeof props.css !== "object" || typeof props.css.name !== "string" || props.css.name.indexOf("-") === -1)) {
    var label = getLabelFromStackTrace(new Error().stack);
    if (label)
      newProps[labelPropName] = label;
  }
  return newProps;
};
var Insertion$1 = function Insertion(_ref3) {
  var cache = _ref3.cache, serialized = _ref3.serialized, isStringTag = _ref3.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React__namespace.useContext(ThemeContext));
  if (process.env.NODE_ENV !== "production" && serialized.name.indexOf("-") === -1) {
    var labelFromStack = props[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && (process.env.NODE_ENV === "production" || key !== labelPropName)) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(Insertion$1, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ React__namespace.createElement(WrappedComponent, newProps));
});
if (process.env.NODE_ENV !== "production") {
  Emotion.displayName = "EmotionCssPropInternal";
}
var Emotion$1 = Emotion;
var pkg = {
  name: "@emotion/react",
  version: "11.11.1",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        "default": "./dist/emotion-react.esm.js"
      },
      "import": "./dist/emotion-react.cjs.mjs",
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        "import": "./macro.d.mts",
        "default": "./macro.d.ts"
      },
      "default": "./macro.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.11.0",
    "@emotion/cache": "^11.11.0",
    "@emotion/serialize": "^1.1.2",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
    "@emotion/utils": "^1.2.1",
    "@emotion/weak-memoize": "^0.3.1",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.11.0",
    "@emotion/css-prettifier": "1.1.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.11.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      }
    }
  }
};
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwnProperty.call(props, "css")) {
    return React__namespace.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return React__namespace.createElement.apply(null, createElementArgArray);
};
var warnedAboutCssPropForGlobal = false;
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  if (process.env.NODE_ENV !== "production" && !warnedAboutCssPropForGlobal && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  (props.className || props.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, React__namespace.useContext(ThemeContext));
  var sheetRef = React__namespace.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
if (process.env.NODE_ENV !== "production") {
  Global.displayName = "EmotionGlobal";
}
function css$2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css$2.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var classnames = function classnames2(args) {
  var len = args.length;
  var i = 0;
  var cls = "";
  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null)
      continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (process.env.NODE_ENV !== "production" && arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k in arg) {
            if (arg[k] && k) {
              toAdd && (toAdd += " ");
              toAdd += k;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css4, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css4(registeredStyles);
}
var Insertion2 = function Insertion3(_ref3) {
  var cache = _ref3.cache, serializedArr = _ref3.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i = 0; i < serializedArr.length; i++) {
      insertStyles(cache, serializedArr[i], false);
    }
  });
  return null;
};
var ClassNames = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var hasRendered = false;
  var serializedArr = [];
  var css4 = function css5() {
    if (hasRendered && process.env.NODE_ENV !== "production") {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache.registered);
    serializedArr.push(serialized);
    registerStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };
  var cx = function cx2() {
    if (hasRendered && process.env.NODE_ENV !== "production") {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache.registered, css4, classnames(args));
  };
  var content = {
    css: css4,
    cx,
    theme: React__namespace.useContext(ThemeContext)
  };
  var ele = props.children(content);
  hasRendered = true;
  return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(Insertion2, {
    cache,
    serializedArr
  }), ele);
});
if (process.env.NODE_ENV !== "production") {
  ClassNames.displayName = "EmotionClassNames";
}
if (process.env.NODE_ENV !== "production") {
  var isBrowser = true;
  var isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
  if (isBrowser && !isTestEnv) {
    var globalContext = (
      // $FlowIgnore
      typeof globalThis !== "undefined" ? globalThis : isBrowser ? window : global
    );
    var globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function getNodeName(node2) {
  if (isNode(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null ? void 0 : (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref3;
  return (_ref3 = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref3.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win2 = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win2, win2.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win2.frameElement && traverseIframes ? getOverflowAncestors(win2.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions(element) {
  const css4 = getComputedStyle$1(element);
  let width = parseFloat(css4.width) || 0;
  let height = parseFloat(css4.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x = ($2 ? round(rect.width) : rect.width) / width;
  let y = ($2 ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win2 = getWindow(element);
  if (!isWebKit() || !win2.visualViewport) {
    return noOffsets;
  }
  return {
    x: win2.visualViewport.offsetLeft,
    y: win2.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win2 = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win2.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win2) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css4 = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css4.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css4.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref3) => {
      let [firstEntry] = _ref3;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var index = React.useLayoutEffect;
var _excluded$4 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
var noop$1 = function noop() {
};
function applyPrefixToName(prefix2, name) {
  if (!name) {
    return prefix2;
  } else if (name[0] === "-") {
    return prefix2 + name;
  } else {
    return prefix2 + "__" + name;
  }
}
function classNames$1(prefix2, state) {
  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    classNameList[_key - 2] = arguments[_key];
  }
  var arr = [].concat(classNameList);
  if (state && prefix2) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("".concat(applyPrefixToName(prefix2, key)));
      }
    }
  }
  return arr.filter(function(i) {
    return i;
  }).map(function(i) {
    return String(i).trim();
  }).join(" ");
}
var cleanValue = function cleanValue2(value) {
  if (isArray(value))
    return value.filter(Boolean);
  if (_typeof(value) === "object" && value !== null)
    return [value];
  return [];
};
var cleanCommonProps = function cleanCommonProps2(props) {
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getClassNames;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;
  var innerProps = _objectWithoutProperties(props, _excluded$4);
  return _objectSpread2({}, innerProps);
};
var getStyleProps = function getStyleProps2(props, name, classNamesState) {
  var cx = props.cx, getStyles2 = props.getStyles, getClassNames2 = props.getClassNames, className = props.className;
  return {
    css: getStyles2(name, props),
    className: cx(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames2(name, props), className)
  };
};
function isDocumentElement(el) {
  return [document.documentElement, document.body, window].indexOf(el) > -1;
}
function normalizedHeight(el) {
  if (isDocumentElement(el)) {
    return window.innerHeight;
  }
  return el.clientHeight;
}
function getScrollTop(el) {
  if (isDocumentElement(el)) {
    return window.pageYOffset;
  }
  return el.scrollTop;
}
function scrollTo(el, top) {
  if (isDocumentElement(el)) {
    window.scrollTo(0, top);
    return;
  }
  el.scrollTop = top;
}
function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === "absolute";
  var overflowRx = /(auto|scroll)/;
  if (style.position === "fixed")
    return document.documentElement;
  for (var parent = element; parent = parent.parentElement; ) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === "static") {
      continue;
    }
    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return document.documentElement;
}
function easeOutCubic(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
}
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop$1;
  var start = getScrollTop(element);
  var change = to - start;
  var increment = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }
  animateScroll();
}
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
function isTouchCapable() {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e) {
    return false;
  }
}
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e) {
    return false;
  }
}
var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
var w = typeof window !== "undefined" ? window : {};
if (w.addEventListener && w.removeEventListener) {
  w.addEventListener("p", noop$1, options);
  w.removeEventListener("p", noop$1, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item) {
  return item != null;
}
function isArray(arg) {
  return Array.isArray(arg);
}
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
function singleValueAsValue(singleValue) {
  return singleValue;
}
function multiValueAsValue(multiValue) {
  return multiValue;
}
var removeProps = function removeProps2(propsObj) {
  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    properties[_key2 - 1] = arguments[_key2];
  }
  var propsMap = Object.entries(propsObj).filter(function(_ref3) {
    var _ref22 = _slicedToArray(_ref3, 1), key = _ref22[0];
    return !properties.includes(key);
  });
  return propsMap.reduce(function(newProps, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], val = _ref4[1];
    newProps[key] = val;
    return newProps;
  }, {});
};
var _excluded$3 = ["children", "innerProps"], _excluded2$1 = ["children", "innerProps"];
function getMenuPlacement(_ref3) {
  var preferredMaxHeight = _ref3.maxHeight, menuEl = _ref3.menuEl, minHeight = _ref3.minHeight, preferredPlacement = _ref3.placement, shouldScroll = _ref3.shouldScroll, isFixedPosition = _ref3.isFixedPosition, controlHeight2 = _ref3.controlHeight;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: "bottom",
    maxHeight: preferredMaxHeight
  };
  if (!menuEl || !menuEl.offsetParent)
    return defaultState;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top;
  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (preferredPlacement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (preferredPlacement === "auto" || isFixedPosition) {
        var _constrainedHeight = preferredMaxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight2, preferredMaxHeight);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (preferredPlacement === "bottom") {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = preferredMaxHeight;
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight: preferredMaxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(preferredPlacement, '".'));
  }
  return defaultState;
}
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
var coercePlacement = function coercePlacement2(p) {
  return p === "auto" ? "bottom" : p;
};
var menuCSS = function menuCSS2(_ref22, unstyled) {
  var _objectSpread2$1;
  var placement = _ref22.placement, _ref2$theme = _ref22.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors2 = _ref2$theme.colors;
  return _objectSpread2((_objectSpread2$1 = {
    label: "menu"
  }, _defineProperty(_objectSpread2$1, alignToControl(placement), "100%"), _defineProperty(_objectSpread2$1, "position", "absolute"), _defineProperty(_objectSpread2$1, "width", "100%"), _defineProperty(_objectSpread2$1, "zIndex", 1), _objectSpread2$1), unstyled ? {} : {
    backgroundColor: colors2.neutral0,
    borderRadius: borderRadius2,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: spacing2.menuGutter,
    marginTop: spacing2.menuGutter
  });
};
var PortalPlacementContext = /* @__PURE__ */ React.createContext(null);
var MenuPlacer = function MenuPlacer2(props) {
  var children = props.children, minMenuHeight = props.minMenuHeight, maxMenuHeight = props.maxMenuHeight, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuShouldScrollIntoView = props.menuShouldScrollIntoView, theme = props.theme;
  var _ref3 = React.useContext(PortalPlacementContext) || {}, setPortalPlacement = _ref3.setPortalPlacement;
  var ref = React.useRef(null);
  var _useState = React.useState(maxMenuHeight), _useState2 = _slicedToArray(_useState, 2), maxHeight = _useState2[0], setMaxHeight = _useState2[1];
  var _useState3 = React.useState(null), _useState4 = _slicedToArray(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1];
  var controlHeight2 = theme.spacing.controlHeight;
  index(function() {
    var menuEl = ref.current;
    if (!menuEl)
      return;
    var isFixedPosition = menuPosition === "fixed";
    var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
    var state = getMenuPlacement({
      maxHeight: maxMenuHeight,
      menuEl,
      minHeight: minMenuHeight,
      placement: menuPlacement,
      shouldScroll,
      isFixedPosition,
      controlHeight: controlHeight2
    });
    setMaxHeight(state.maxHeight);
    setPlacement(state.placement);
    setPortalPlacement === null || setPortalPlacement === void 0 ? void 0 : setPortalPlacement(state.placement);
  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight2]);
  return children({
    ref,
    placerProps: _objectSpread2(_objectSpread2({}, props), {}, {
      placement: placement || coercePlacement(menuPlacement),
      maxHeight
    })
  });
};
var Menu = function Menu2(props) {
  var children = props.children, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "menu", {
    menu: true
  }), {
    ref: innerRef
  }, innerProps), children);
};
var Menu$1 = Menu;
var menuListCSS = function menuListCSS2(_ref4, unstyled) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return _objectSpread2({
    maxHeight,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, unstyled ? {} : {
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2
  });
};
var MenuList = function MenuList2(props) {
  var children = props.children, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx("div", _extends({}, getStyleProps(props, "menuList", {
    "menu-list": true,
    "menu-list--is-multi": isMulti
  }), {
    ref: innerRef
  }, innerProps), children);
};
var noticeCSS = function noticeCSS2(_ref5, unstyled) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors2 = _ref5$theme.colors;
  return _objectSpread2({
    textAlign: "center"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px")
  });
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage2(_ref6) {
  var _ref6$children = _ref6.children, children = _ref6$children === void 0 ? "No options" : _ref6$children, innerProps = _ref6.innerProps, restProps = _objectWithoutProperties(_ref6, _excluded$3);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children,
    innerProps
  }), "noOptionsMessage", {
    "menu-notice": true,
    "menu-notice--no-options": true
  }), innerProps), children);
};
var LoadingMessage = function LoadingMessage2(_ref7) {
  var _ref7$children = _ref7.children, children = _ref7$children === void 0 ? "Loading..." : _ref7$children, innerProps = _ref7.innerProps, restProps = _objectWithoutProperties(_ref7, _excluded2$1);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children,
    innerProps
  }), "loadingMessage", {
    "menu-notice": true,
    "menu-notice--loading": true
  }), innerProps), children);
};
var menuPortalCSS = function menuPortalCSS2(_ref8) {
  var rect = _ref8.rect, offset = _ref8.offset, position2 = _ref8.position;
  return {
    left: rect.left,
    position: position2,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = function MenuPortal2(props) {
  var appendTo = props.appendTo, children = props.children, controlElement = props.controlElement, innerProps = props.innerProps, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition;
  var menuPortalRef = React.useRef(null);
  var cleanupRef = React.useRef(null);
  var _useState5 = React.useState(coercePlacement(menuPlacement)), _useState6 = _slicedToArray(_useState5, 2), placement = _useState6[0], setPortalPlacement = _useState6[1];
  var portalPlacementContext = React.useMemo(function() {
    return {
      setPortalPlacement
    };
  }, []);
  var _useState7 = React.useState(null), _useState8 = _slicedToArray(_useState7, 2), computedPosition = _useState8[0], setComputedPosition = _useState8[1];
  var updateComputedPosition = React.useCallback(function() {
    if (!controlElement)
      return;
    var rect = getBoundingClientObj(controlElement);
    var scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset;
    var offset = rect[placement] + scrollDistance;
    if (offset !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
      setComputedPosition({
        offset,
        rect
      });
    }
  }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
  index(function() {
    updateComputedPosition();
  }, [updateComputedPosition]);
  var runAutoUpdate = React.useCallback(function() {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (controlElement && menuPortalRef.current) {
      cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
        elementResize: "ResizeObserver" in window
      });
    }
  }, [controlElement, updateComputedPosition]);
  index(function() {
    runAutoUpdate();
  }, [runAutoUpdate]);
  var setMenuPortalElement = React.useCallback(function(menuPortalElement) {
    menuPortalRef.current = menuPortalElement;
    runAutoUpdate();
  }, [runAutoUpdate]);
  if (!appendTo && menuPosition !== "fixed" || !computedPosition)
    return null;
  var menuWrapper = jsx("div", _extends({
    ref: setMenuPortalElement
  }, getStyleProps(_objectSpread2(_objectSpread2({}, props), {}, {
    offset: computedPosition.offset,
    position: menuPosition,
    rect: computedPosition.rect
  }), "menuPortal", {
    "menu-portal": true
  }), innerProps), children);
  return jsx(PortalPlacementContext.Provider, {
    value: portalPlacementContext
  }, appendTo ? /* @__PURE__ */ ReactDOM.createPortal(menuWrapper, appendTo) : menuWrapper);
};
var containerCSS = function containerCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, isRtl = _ref3.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : void 0,
    pointerEvents: isDisabled ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
};
var SelectContainer = function SelectContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl;
  return jsx("div", _extends({}, getStyleProps(props, "container", {
    "--is-disabled": isDisabled,
    "--is-rtl": isRtl
  }), innerProps), children);
};
var valueContainerCSS = function valueContainerCSS2(_ref22, unstyled) {
  var spacing2 = _ref22.theme.spacing, isMulti = _ref22.isMulti, hasValue = _ref22.hasValue, controlShouldRenderValue = _ref22.selectProps.controlShouldRenderValue;
  return _objectSpread2({
    alignItems: "center",
    display: isMulti && hasValue && controlShouldRenderValue ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, unstyled ? {} : {
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px")
  });
};
var ValueContainer = function ValueContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isMulti = props.isMulti, hasValue = props.hasValue;
  return jsx("div", _extends({}, getStyleProps(props, "valueContainer", {
    "value-container": true,
    "value-container--is-multi": isMulti,
    "value-container--has-value": hasValue
  }), innerProps), children);
};
var indicatorsContainerCSS = function indicatorsContainerCSS2() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "indicatorsContainer", {
    indicators: true
  }), innerProps), children);
};
var _templateObject;
var _excluded$2 = ["size"], _excluded2 = ["innerProps", "isRtl", "size"];
function _EMOTION_STRINGIFIED_CSS_ERROR__$3() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref2$2 = process.env.NODE_ENV === "production" ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U3R5bGVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHtcbiAgc2l6ZSxcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU6IG51bWJlciB9KSA9PiAoXG4gIDxzdmdcbiAgICBoZWlnaHQ9e3NpemV9XG4gICAgd2lkdGg9e3NpemV9XG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgY3NzPXt7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICB9fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIENyb3NzSWNvblByb3BzID0gSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogQ3Jvc3NJY29uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCB0eXBlIERvd25DaGV2cm9uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IERvd25DaGV2cm9uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiIC8+XG4gIDwvU3ZnPlxuKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEJ1dHRvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBiYXNlQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTpcbiAgICB8IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbiAgICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICAgICc6aG92ZXInOiB7XG4gICAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgICAgICB9LFxuICAgICAgfSksXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2Ryb3Bkb3duSW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2NsZWFySW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaW5uZXJQcm9wcz86IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3BhbiddO1xufVxuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNEaXNhYmxlZCxcbiAgICB0aGVtZToge1xuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgICAgY29sb3JzLFxuICAgIH0sXG4gIH06IEluZGljYXRvclNlcGFyYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+LFxuICB1bnN0eWxlZDogYm9vbGVhblxuKTogQ1NTT2JqZWN0V2l0aExhYmVsID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yU2VwYXJhdG9yJyxcbiAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gIHdpZHRoOiAxLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGJhc2VVbml0ICogMixcbiAgICAgICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnaW5kaWNhdG9yU2VwYXJhdG9yJywge1xuICAgICAgICAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHNpemUsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICB9LFxuICB9OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgICAgICAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICAgICAgfSksXG59KTtcblxuaW50ZXJmYWNlIExvYWRpbmdEb3RQcm9wcyB7XG4gIGRlbGF5OiBudW1iZXI7XG4gIG9mZnNldDogYm9vbGVhbjtcbn1cbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IExvYWRpbmdEb3RQcm9wcykgPT4gKFxuICA8c3BhblxuICAgIGNzcz17e1xuICAgICAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nRG90QW5pbWF0aW9uc30gMXMgZWFzZS1pbi1vdXQgJHtkZWxheX1tcyBpbmZpbml0ZTtgLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRpbmdJbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgLyoqIFNldCBzaXplIG9mIHRoZSBjb250YWluZXIuICovXG4gIHNpemU6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KHtcbiAgaW5uZXJQcm9wcyxcbiAgaXNSdGwsXG4gIHNpemUgPSA0LFxuICAuLi5yZXN0UHJvcHNcbn06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPikgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKFxuICAgICAgICB7IC4uLnJlc3RQcm9wcywgaW5uZXJQcm9wcywgaXNSdGwsIHNpemUgfSxcbiAgICAgICAgJ2xvYWRpbmdJbmRpY2F0b3InLFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MH0gb2Zmc2V0PXtpc1J0bH0gLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXsxNjB9IG9mZnNldCAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezMyMH0gb2Zmc2V0PXshaXNSdGx9IC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl19 */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$3
};
var Svg = function Svg2(_ref3) {
  var size = _ref3.size, props = _objectWithoutProperties(_ref3, _excluded$2);
  return jsx("svg", _extends({
    height: size,
    width: size,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2$2
  }, props));
};
var CrossIcon = function CrossIcon2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};
var baseCSS = function baseCSS2(_ref3, unstyled) {
  var isFocused = _ref3.isFocused, _ref3$theme = _ref3.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors2 = _ref3$theme.colors;
  return _objectSpread2({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2,
    ":hover": {
      color: isFocused ? colors2.neutral80 : colors2.neutral40
    }
  });
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator = function DropdownIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "dropdownIndicator", {
    indicator: true,
    "dropdown-indicator": true
  }), innerProps), children || jsx(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "clearIndicator", {
    indicator: true,
    "clear-indicator": true
  }), innerProps), children || jsx(CrossIcon, null));
};
var indicatorSeparatorCSS = function indicatorSeparatorCSS2(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors2 = _ref4$theme.colors;
  return _objectSpread2({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral10 : colors2.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2
  });
};
var IndicatorSeparator = function IndicatorSeparator2(props) {
  var innerProps = props.innerProps;
  return jsx("span", _extends({}, innerProps, getStyleProps(props, "indicatorSeparator", {
    "indicator-separator": true
  })));
};
var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS2(_ref5, unstyled) {
  var isFocused = _ref5.isFocused, size = _ref5.size, _ref5$theme = _ref5.theme, colors2 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return _objectSpread2({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size,
    lineHeight: 1,
    marginRight: size,
    textAlign: "center",
    verticalAlign: "middle"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2
  });
};
var LoadingDot = function LoadingDot2(_ref6) {
  var delay = _ref6.delay, offset = _ref6.offset;
  return jsx("span", {
    css: /* @__PURE__ */ css$2({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, process.env.NODE_ENV === "production" ? "" : ";label:LoadingDot;", process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1RSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBrZXlmcmFtZXMgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmltcG9ydCB7XG4gIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lLFxuICBDU1NPYmplY3RXaXRoTGFiZWwsXG4gIEdyb3VwQmFzZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0U3R5bGVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEljb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgU3ZnID0gKHtcbiAgc2l6ZSxcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU6IG51bWJlciB9KSA9PiAoXG4gIDxzdmdcbiAgICBoZWlnaHQ9e3NpemV9XG4gICAgd2lkdGg9e3NpemV9XG4gICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICBmb2N1c2FibGU9XCJmYWxzZVwiXG4gICAgY3NzPXt7XG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGZpbGw6ICdjdXJyZW50Q29sb3InLFxuICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgIHN0cm9rZTogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzdHJva2VXaWR0aDogMCxcbiAgICB9fVxuICAgIHsuLi5wcm9wc31cbiAgLz5cbik7XG5cbmV4cG9ydCB0eXBlIENyb3NzSWNvblByb3BzID0gSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZT86IG51bWJlciB9O1xuZXhwb3J0IGNvbnN0IENyb3NzSWNvbiA9IChwcm9wczogQ3Jvc3NJY29uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTE0LjM0OCAxNC44NDljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDBsLTIuNjUxLTMuMDMwLTIuNjUxIDMuMDI5Yy0wLjQ2OSAwLjQ2OS0xLjIyOSAwLjQ2OS0xLjY5NyAwLTAuNDY5LTAuNDY5LTAuNDY5LTEuMjI5IDAtMS42OTdsMi43NTgtMy4xNS0yLjc1OS0zLjE1MmMtMC40NjktMC40NjktMC40NjktMS4yMjggMC0xLjY5N3MxLjIyOC0wLjQ2OSAxLjY5NyAwbDIuNjUyIDMuMDMxIDIuNjUxLTMuMDMxYzAuNDY5LTAuNDY5IDEuMjI4LTAuNDY5IDEuNjk3IDBzMC40NjkgMS4yMjkgMCAxLjY5N2wtMi43NTggMy4xNTIgMi43NTggMy4xNWMwLjQ2OSAwLjQ2OSAwLjQ2OSAxLjIyOSAwIDEuNjk4elwiIC8+XG4gIDwvU3ZnPlxuKTtcbmV4cG9ydCB0eXBlIERvd25DaGV2cm9uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgRG93bkNoZXZyb24gPSAocHJvcHM6IERvd25DaGV2cm9uUHJvcHMpID0+IChcbiAgPFN2ZyBzaXplPXsyMH0gey4uLnByb3BzfT5cbiAgICA8cGF0aCBkPVwiTTQuNTE2IDcuNTQ4YzAuNDM2LTAuNDQ2IDEuMDQzLTAuNDgxIDEuNTc2IDBsMy45MDggMy43NDcgMy45MDgtMy43NDdjMC41MzMtMC40ODEgMS4xNDEtMC40NDYgMS41NzQgMCAwLjQzNiAwLjQ0NSAwLjQwOCAxLjE5NyAwIDEuNjE1LTAuNDA2IDAuNDE4LTQuNjk1IDQuNTAyLTQuNjk1IDQuNTAyLTAuMjE3IDAuMjIzLTAuNTAyIDAuMzM1LTAuNzg3IDAuMzM1cy0wLjU3LTAuMTEyLTAuNzg5LTAuMzM1YzAgMC00LjI4Ny00LjA4NC00LjY5NS00LjUwMnMtMC40MzYtMS4xNyAwLTEuNjE1elwiIC8+XG4gIDwvU3ZnPlxuKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEcm9wZG93biAmIENsZWFyIEJ1dHRvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xufVxuXG5jb25zdCBiYXNlQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTpcbiAgICB8IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbiAgICB8IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JDb250YWluZXInLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICAgICc6aG92ZXInOiB7XG4gICAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsODAgOiBjb2xvcnMubmV1dHJhbDQwLFxuICAgICAgICB9LFxuICAgICAgfSksXG59KTtcblxuZXhwb3J0IGNvbnN0IGRyb3Bkb3duSW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBEcm9wZG93bkluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IERyb3Bkb3duSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2Ryb3Bkb3duSW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdkcm9wZG93bi1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPERvd25DaGV2cm9uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGVhckluZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnNpZGUgdGhlIGluZGljYXRvci4gKi9cbiAgY2hpbGRyZW4/OiBSZWFjdE5vZGU7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySW5kaWNhdG9yQ1NTID0gYmFzZUNTUztcbmV4cG9ydCBjb25zdCBDbGVhckluZGljYXRvciA9IDxcbiAgT3B0aW9uLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPlxuPihcbiAgcHJvcHM6IENsZWFySW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGNoaWxkcmVuLCBpbm5lclByb3BzIH0gPSBwcm9wcztcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICB7Li4uZ2V0U3R5bGVQcm9wcyhwcm9wcywgJ2NsZWFySW5kaWNhdG9yJywge1xuICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICdjbGVhci1pbmRpY2F0b3InOiB0cnVlLFxuICAgICAgfSl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW4gfHwgPENyb3NzSWNvbiAvPn1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VwYXJhdG9yXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaW5uZXJQcm9wcz86IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3BhbiddO1xufVxuXG5leHBvcnQgY29uc3QgaW5kaWNhdG9yU2VwYXJhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNEaXNhYmxlZCxcbiAgICB0aGVtZToge1xuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgICAgY29sb3JzLFxuICAgIH0sXG4gIH06IEluZGljYXRvclNlcGFyYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+LFxuICB1bnN0eWxlZDogYm9vbGVhblxuKTogQ1NTT2JqZWN0V2l0aExhYmVsID0+ICh7XG4gIGxhYmVsOiAnaW5kaWNhdG9yU2VwYXJhdG9yJyxcbiAgYWxpZ25TZWxmOiAnc3RyZXRjaCcsXG4gIHdpZHRoOiAxLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IGNvbG9ycy5uZXV0cmFsMTAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBtYXJnaW5Cb3R0b206IGJhc2VVbml0ICogMixcbiAgICAgICAgbWFyZ2luVG9wOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgSW5kaWNhdG9yU2VwYXJhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD5cbikgPT4ge1xuICBjb25zdCB7IGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxzcGFuXG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnaW5kaWNhdG9yU2VwYXJhdG9yJywge1xuICAgICAgICAnaW5kaWNhdG9yLXNlcGFyYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAvPlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbG9hZGluZ0RvdEFuaW1hdGlvbnMgPSBrZXlmcmFtZXNgXG4gIDAlLCA4MCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB9XG4gIDQwJSB7IG9wYWNpdHk6IDE7IH1cbmA7XG5cbmV4cG9ydCBjb25zdCBsb2FkaW5nSW5kaWNhdG9yQ1NTID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICB7XG4gICAgaXNGb2N1c2VkLFxuICAgIHNpemUsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9ycyxcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICB9LFxuICB9OiBMb2FkaW5nSW5kaWNhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdsb2FkaW5nSW5kaWNhdG9yJyxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICB0cmFuc2l0aW9uOiAnY29sb3IgMTUwbXMnLFxuICBhbGlnblNlbGY6ICdjZW50ZXInLFxuICBmb250U2l6ZTogc2l6ZSxcbiAgbGluZUhlaWdodDogMSxcbiAgbWFyZ2luUmlnaHQ6IHNpemUsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAuLi4odW5zdHlsZWRcbiAgICA/IHt9XG4gICAgOiB7XG4gICAgICAgIGNvbG9yOiBpc0ZvY3VzZWQgPyBjb2xvcnMubmV1dHJhbDYwIDogY29sb3JzLm5ldXRyYWwyMCxcbiAgICAgICAgcGFkZGluZzogYmFzZVVuaXQgKiAyLFxuICAgICAgfSksXG59KTtcblxuaW50ZXJmYWNlIExvYWRpbmdEb3RQcm9wcyB7XG4gIGRlbGF5OiBudW1iZXI7XG4gIG9mZnNldDogYm9vbGVhbjtcbn1cbmNvbnN0IExvYWRpbmdEb3QgPSAoeyBkZWxheSwgb2Zmc2V0IH06IExvYWRpbmdEb3RQcm9wcykgPT4gKFxuICA8c3BhblxuICAgIGNzcz17e1xuICAgICAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nRG90QW5pbWF0aW9uc30gMXMgZWFzZS1pbi1vdXQgJHtkZWxheX1tcyBpbmZpbml0ZTtgLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzFlbScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIG1hcmdpbkxlZnQ6IG9mZnNldCA/ICcxZW0nIDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiAnMWVtJyxcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgd2lkdGg6ICcxZW0nLFxuICAgIH19XG4gIC8+XG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRpbmdJbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBQcm9wcyB0aGF0IHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRoZSBjaGlsZHJlbi4gKi9cbiAgaW5uZXJQcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydkaXYnXTtcbiAgLyoqIFRoZSBmb2N1c2VkIHN0YXRlIG9mIHRoZSBzZWxlY3QuICovXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgLyoqIFNldCBzaXplIG9mIHRoZSBjb250YWluZXIuICovXG4gIHNpemU6IG51bWJlcjtcbn1cbmV4cG9ydCBjb25zdCBMb2FkaW5nSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KHtcbiAgaW5uZXJQcm9wcyxcbiAgaXNSdGwsXG4gIHNpemUgPSA0LFxuICAuLi5yZXN0UHJvcHNcbn06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPikgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKFxuICAgICAgICB7IC4uLnJlc3RQcm9wcywgaW5uZXJQcm9wcywgaXNSdGwsIHNpemUgfSxcbiAgICAgICAgJ2xvYWRpbmdJbmRpY2F0b3InLFxuICAgICAgICB7XG4gICAgICAgICAgaW5kaWNhdG9yOiB0cnVlLFxuICAgICAgICAgICdsb2FkaW5nLWluZGljYXRvcic6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICl9XG4gICAgICB7Li4uaW5uZXJQcm9wc31cbiAgICA+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MH0gb2Zmc2V0PXtpc1J0bH0gLz5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXsxNjB9IG9mZnNldCAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezMyMH0gb2Zmc2V0PXshaXNSdGx9IC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuIl19 */")
  });
};
var LoadingIndicator = function LoadingIndicator2(_ref7) {
  var innerProps = _ref7.innerProps, isRtl = _ref7.isRtl, _ref7$size = _ref7.size, size = _ref7$size === void 0 ? 4 : _ref7$size, restProps = _objectWithoutProperties(_ref7, _excluded2);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    innerProps,
    isRtl,
    size
  }), "loadingIndicator", {
    indicator: true,
    "loading-indicator": true
  }), innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
var css$1 = function css(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, _ref$theme = _ref3.theme, colors2 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return _objectSpread2({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral5 : colors2.neutral0,
    borderColor: isDisabled ? colors2.neutral10 : isFocused ? colors2.primary : colors2.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors2.primary) : void 0,
    "&:hover": {
      borderColor: isFocused ? colors2.primary : colors2.neutral30
    }
  });
};
var Control = function Control2(props) {
  var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends({
    ref: innerRef
  }, getStyleProps(props, "control", {
    control: true,
    "control--is-disabled": isDisabled,
    "control--is-focused": isFocused,
    "control--menu-is-open": menuIsOpen
  }), innerProps, {
    "aria-disabled": isDisabled || void 0
  }), children);
};
var Control$1 = Control;
var _excluded$1 = ["data"];
var groupCSS = function groupCSS2(_ref3, unstyled) {
  var spacing2 = _ref3.theme.spacing;
  return unstyled ? {} : {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
};
var Group = function Group2(props) {
  var children = props.children, cx = props.cx, getStyles2 = props.getStyles, getClassNames2 = props.getClassNames, Heading = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label = props.label, theme = props.theme, selectProps = props.selectProps;
  return jsx("div", _extends({}, getStyleProps(props, "group", {
    group: true
  }), innerProps), jsx(Heading, _extends({}, headingProps, {
    selectProps,
    theme,
    getStyles: getStyles2,
    getClassNames: getClassNames2,
    cx
  }), label), jsx("div", null, children));
};
var groupHeadingCSS = function groupHeadingCSS2(_ref22, unstyled) {
  var _ref2$theme = _ref22.theme, colors2 = _ref2$theme.colors, spacing2 = _ref2$theme.spacing;
  return _objectSpread2({
    label: "group",
    cursor: "default",
    display: "block"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  });
};
var GroupHeading = function GroupHeading2(props) {
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
  return jsx("div", _extends({}, getStyleProps(props, "groupHeading", {
    "group-heading": true
  }), innerProps));
};
var Group$1 = Group;
var _excluded$5 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
var inputCSS = function inputCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, value = _ref3.value, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2(_objectSpread2({
    visibility: isDisabled ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? "translateZ(0)" : ""
  }, containerStyle), unstyled ? {} : {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    color: colors2.neutral80
  });
};
var spacingStyle = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var containerStyle = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": _objectSpread2({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, spacingStyle)
};
var inputStyle = function inputStyle2(isHidden) {
  return _objectSpread2({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: isHidden ? 0 : 1,
    width: "100%"
  }, spacingStyle);
};
var Input = function Input2(props) {
  var cx = props.cx, value = props.value;
  var _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden = _cleanCommonProps.isHidden, inputClassName = _cleanCommonProps.inputClassName, innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$5);
  return jsx("div", _extends({}, getStyleProps(props, "input", {
    "input-container": true
  }), {
    "data-value": value || ""
  }), jsx("input", _extends({
    className: cx({
      input: true
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
};
var Input$1 = Input;
var multiValueCSS = function multiValueCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, unstyled ? {} : {
    backgroundColor: colors2.neutral10,
    borderRadius: borderRadius2 / 2,
    margin: spacing2.baseUnit / 2
  });
};
var multiValueLabelCSS = function multiValueLabelCSS2(_ref22, unstyled) {
  var _ref2$theme = _ref22.theme, borderRadius2 = _ref2$theme.borderRadius, colors2 = _ref2$theme.colors, cropWithEllipsis = _ref22.cropWithEllipsis;
  return _objectSpread2({
    overflow: "hidden",
    textOverflow: cropWithEllipsis || cropWithEllipsis === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    color: colors2.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
};
var multiValueRemoveCSS = function multiValueRemoveCSS2(_ref3, unstyled) {
  var _ref3$theme = _ref3.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors2 = _ref3$theme.colors, isFocused = _ref3.isFocused;
  return _objectSpread2({
    alignItems: "center",
    display: "flex"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused ? colors2.dangerLight : void 0,
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors2.dangerLight,
      color: colors2.danger
    }
  });
};
var MultiValueGeneric = function MultiValueGeneric2(_ref4) {
  var children = _ref4.children, innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children = _ref5.children, innerProps = _ref5.innerProps;
  return jsx("div", _extends({
    role: "button"
  }, innerProps), children || jsx(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue2(props) {
  var children = props.children, components2 = props.components, data = props.data, innerProps = props.innerProps, isDisabled = props.isDisabled, removeProps3 = props.removeProps, selectProps = props.selectProps;
  var Container = components2.Container, Label2 = components2.Label, Remove = components2.Remove;
  return jsx(Container, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValue", {
      "multi-value": true,
      "multi-value--is-disabled": isDisabled
    })), innerProps),
    selectProps
  }, jsx(Label2, {
    data,
    innerProps: _objectSpread2({}, getStyleProps(props, "multiValueLabel", {
      "multi-value__label": true
    })),
    selectProps
  }, children), jsx(Remove, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValueRemove", {
      "multi-value__remove": true
    })), {}, {
      "aria-label": "Remove ".concat(children || "option")
    }, removeProps3),
    selectProps
  }));
};
var MultiValue$1 = MultiValue;
var optionCSS = function optionCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, isSelected = _ref3.isSelected, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, unstyled ? {} : {
    backgroundColor: isSelected ? colors2.primary : isFocused ? colors2.primary25 : "transparent",
    color: isDisabled ? colors2.neutral20 : isSelected ? colors2.neutral0 : "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: !isDisabled ? isSelected ? colors2.primary : colors2.primary50 : void 0
    }
  });
};
var Option = function Option2(props) {
  var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "option", {
    option: true,
    "option--is-disabled": isDisabled,
    "option--is-focused": isFocused,
    "option--is-selected": isSelected
  }), {
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children);
};
var Option$1 = Option;
var placeholderCSS = function placeholderCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, unstyled ? {} : {
    color: colors2.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var Placeholder = function Placeholder2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "placeholder", {
    placeholder: true
  }), innerProps), children);
};
var Placeholder$1 = Placeholder;
var css2 = function css3(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    color: isDisabled ? colors2.neutral40 : colors2.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var SingleValue = function SingleValue2(props) {
  var children = props.children, isDisabled = props.isDisabled, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "singleValue", {
    "single-value": true,
    "single-value--is-disabled": isDisabled
  }), innerProps), children);
};
var SingleValue$1 = SingleValue;
var components = {
  ClearIndicator,
  Control: Control$1,
  DropdownIndicator,
  DownChevron,
  CrossIcon,
  Group: Group$1,
  GroupHeading,
  IndicatorsContainer,
  IndicatorSeparator,
  Input: Input$1,
  LoadingIndicator,
  Menu: Menu$1,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue: MultiValue$1,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option: Option$1,
  Placeholder: Placeholder$1,
  SelectContainer,
  SingleValue: SingleValue$1,
  ValueContainer
};
var defaultComponents = function defaultComponents2(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
};
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache && cache.lastThis === this && isEqual2(newArgs, cache.lastArgs)) {
      return cache.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache = null;
  };
  return memoized;
}
function _EMOTION_STRINGIFIED_CSS_ERROR__$2() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref = process.env.NODE_ENV === "production" ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFNSSIsImZpbGUiOiJBMTF5VGV4dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLy8gQXNzaXN0aXZlIHRleHQgdG8gZGVzY3JpYmUgdmlzdWFsIGVsZW1lbnRzLiBIaWRkZW4gZm9yIHNpZ2h0ZWQgdXNlcnMuXG5jb25zdCBBMTF5VGV4dCA9IChwcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ10pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$2
};
var A11yText = function A11yText2(props) {
  return jsx("span", _extends({
    css: _ref
  }, props));
};
var A11yText$1 = A11yText;
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, isDisabled = props.isDisabled, tabSelectsValue = props.tabSelectsValue, context = props.context;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options".concat(isDisabled ? "" : ", press Enter to select the currently focused option", ", press Escape to exit the menu").concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "");
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function onChange(props) {
    var action = props.action, _props$label = props.label, label = _props$label === void 0 ? "" : _props$label, labels = props.labels, isDisabled = props.isDisabled;
    switch (action) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(labels.length > 1 ? "s" : "", " ").concat(labels.join(","), ", selected.");
      case "select-option":
        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context, focused = props.focused, options2 = props.options, _props$label2 = props.label, label = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled = props.isDisabled, isSelected = props.isSelected;
    var getArrayIndex = function getArrayIndex2(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : "";
    };
    if (context === "value" && selectValue) {
      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === "menu") {
      var disabled = isDisabled ? " disabled" : "";
      var status = "".concat(isSelected ? "selected" : "focused").concat(disabled);
      return "option ".concat(label, " ").concat(status, ", ").concat(getArrayIndex(options2, focused), ".");
    }
    return "";
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }
};
var LiveRegion = function LiveRegion2(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps, id = props.id;
  var ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue;
  var ariaLabel = selectProps["aria-label"];
  var ariaLive = selectProps["aria-live"];
  var messages = React.useMemo(function() {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]);
  var ariaSelected = React.useMemo(function() {
    var message = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, selectedOptions = ariaSelection.options, removedValue = ariaSelection.removedValue, removedValues = ariaSelection.removedValues, value = ariaSelection.value;
      var asOption = function asOption2(val) {
        return !Array.isArray(val) ? val : null;
      };
      var selected = removedValue || option || asOption(value);
      var label = selected ? getOptionLabel4(selected) : "";
      var multiSelected = selectedOptions || removedValues || void 0;
      var labels = multiSelected ? multiSelected.map(getOptionLabel4) : [];
      var onChangeProps = _objectSpread2({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected && isOptionDisabled3(selected, selectValue),
        label,
        labels
      }, ariaSelection);
      message = messages.onChange(onChangeProps);
    }
    return message;
  }, [ariaSelection, messages, isOptionDisabled3, selectValue, getOptionLabel4]);
  var ariaFocused = React.useMemo(function() {
    var focusMsg = "";
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused, selectValue),
        isSelected,
        options: focusableOptions,
        context: focused === focusedOption ? "menu" : "value",
        selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, focusableOptions, selectValue]);
  var ariaResults = React.useMemo(function() {
    var resultsMsg = "";
    if (menuIsOpen && options2.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2]);
  var ariaGuidance = React.useMemo(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption, selectValue),
        isMulti,
        isSearchable,
        tabSelectsValue
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue]);
  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
  var ScreenReaderText = jsx(React.Fragment, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-context"
  }, ariaContext));
  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus";
  return jsx(React.Fragment, null, jsx(A11yText$1, {
    id
  }, isInitialFocus && ScreenReaderText), jsx(A11yText$1, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && !isInitialFocus && ScreenReaderText));
};
var LiveRegion$1 = LiveRegion;
var diacritics = [{
  base: "A",
  letters: "AⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ"
}, {
  base: "AA",
  letters: "Ꜳ"
}, {
  base: "AE",
  letters: "ÆǼǢ"
}, {
  base: "AO",
  letters: "Ꜵ"
}, {
  base: "AU",
  letters: "Ꜷ"
}, {
  base: "AV",
  letters: "ꜸꜺ"
}, {
  base: "AY",
  letters: "Ꜽ"
}, {
  base: "B",
  letters: "BⒷＢḂḄḆɃƂƁ"
}, {
  base: "C",
  letters: "CⒸＣĆĈĊČÇḈƇȻꜾ"
}, {
  base: "D",
  letters: "DⒹＤḊĎḌḐḒḎĐƋƊƉꝹ"
}, {
  base: "DZ",
  letters: "ǱǄ"
}, {
  base: "Dz",
  letters: "ǲǅ"
}, {
  base: "E",
  letters: "EⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎ"
}, {
  base: "F",
  letters: "FⒻＦḞƑꝻ"
}, {
  base: "G",
  letters: "GⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾ"
}, {
  base: "H",
  letters: "HⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ"
}, {
  base: "I",
  letters: "IⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ"
}, {
  base: "J",
  letters: "JⒿＪĴɈ"
}, {
  base: "K",
  letters: "KⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ"
}, {
  base: "L",
  letters: "LⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ"
}, {
  base: "LJ",
  letters: "Ǉ"
}, {
  base: "Lj",
  letters: "ǈ"
}, {
  base: "M",
  letters: "MⓂＭḾṀṂⱮƜ"
}, {
  base: "N",
  letters: "NⓃＮǸŃÑṄŇṆŅṊṈȠƝꞐꞤ"
}, {
  base: "NJ",
  letters: "Ǌ"
}, {
  base: "Nj",
  letters: "ǋ"
}, {
  base: "O",
  letters: "OⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ"
}, {
  base: "OI",
  letters: "Ƣ"
}, {
  base: "OO",
  letters: "Ꝏ"
}, {
  base: "OU",
  letters: "Ȣ"
}, {
  base: "P",
  letters: "PⓅＰṔṖƤⱣꝐꝒꝔ"
}, {
  base: "Q",
  letters: "QⓆＱꝖꝘɊ"
}, {
  base: "R",
  letters: "RⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ"
}, {
  base: "S",
  letters: "SⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ"
}, {
  base: "T",
  letters: "TⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ"
}, {
  base: "TZ",
  letters: "Ꜩ"
}, {
  base: "U",
  letters: "UⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ"
}, {
  base: "V",
  letters: "VⓋＶṼṾƲꝞɅ"
}, {
  base: "VY",
  letters: "Ꝡ"
}, {
  base: "W",
  letters: "WⓌＷẀẂŴẆẄẈⱲ"
}, {
  base: "X",
  letters: "XⓍＸẊẌ"
}, {
  base: "Y",
  letters: "YⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ"
}, {
  base: "Z",
  letters: "ZⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ"
}, {
  base: "a",
  letters: "aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐ"
}, {
  base: "aa",
  letters: "ꜳ"
}, {
  base: "ae",
  letters: "æǽǣ"
}, {
  base: "ao",
  letters: "ꜵ"
}, {
  base: "au",
  letters: "ꜷ"
}, {
  base: "av",
  letters: "ꜹꜻ"
}, {
  base: "ay",
  letters: "ꜽ"
}, {
  base: "b",
  letters: "bⓑｂḃḅḇƀƃɓ"
}, {
  base: "c",
  letters: "cⓒｃćĉċčçḉƈȼꜿↄ"
}, {
  base: "d",
  letters: "dⓓｄḋďḍḑḓḏđƌɖɗꝺ"
}, {
  base: "dz",
  letters: "ǳǆ"
}, {
  base: "e",
  letters: "eⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇɛǝ"
}, {
  base: "f",
  letters: "fⓕｆḟƒꝼ"
}, {
  base: "g",
  letters: "gⓖｇǵĝḡğġǧģǥɠꞡᵹꝿ"
}, {
  base: "h",
  letters: "hⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ"
}, {
  base: "hv",
  letters: "ƕ"
}, {
  base: "i",
  letters: "iⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı"
}, {
  base: "j",
  letters: "jⓙｊĵǰɉ"
}, {
  base: "k",
  letters: "kⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ"
}, {
  base: "l",
  letters: "lⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇ"
}, {
  base: "lj",
  letters: "ǉ"
}, {
  base: "m",
  letters: "mⓜｍḿṁṃɱɯ"
}, {
  base: "n",
  letters: "nⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥ"
}, {
  base: "nj",
  letters: "ǌ"
}, {
  base: "o",
  letters: "oⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿɔꝋꝍɵ"
}, {
  base: "oi",
  letters: "ƣ"
}, {
  base: "ou",
  letters: "ȣ"
}, {
  base: "oo",
  letters: "ꝏ"
}, {
  base: "p",
  letters: "pⓟｐṕṗƥᵽꝑꝓꝕ"
}, {
  base: "q",
  letters: "qⓠｑɋꝗꝙ"
}, {
  base: "r",
  letters: "rⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ"
}, {
  base: "s",
  letters: "sⓢｓßśṥŝṡšṧṣṩșşȿꞩꞅẛ"
}, {
  base: "t",
  letters: "tⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ"
}, {
  base: "tz",
  letters: "ꜩ"
}, {
  base: "u",
  letters: "uⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ"
}, {
  base: "v",
  letters: "vⓥｖṽṿʋꝟʌ"
}, {
  base: "vy",
  letters: "ꝡ"
}, {
  base: "w",
  letters: "wⓦｗẁẃŵẇẅẘẉⱳ"
}, {
  base: "x",
  letters: "xⓧｘẋẍ"
}, {
  base: "y",
  letters: "yⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ"
}, {
  base: "z",
  letters: "zⓩｚźẑżžẓẕƶȥɀⱬꝣ"
}];
var anyDiacritic = new RegExp("[" + diacritics.map(function(d) {
  return d.letters;
}).join("") + "]", "g");
var diacriticToBase = {};
for (var i = 0; i < diacritics.length; i++) {
  var diacritic = diacritics[i];
  for (var j = 0; j < diacritic.letters.length; j++) {
    diacriticToBase[diacritic.letters[j]] = diacritic.base;
  }
}
var stripDiacritics = function stripDiacritics2(str) {
  return str.replace(anyDiacritic, function(match2) {
    return diacriticToBase[match2];
  });
};
var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
var trimString = function trimString2(str) {
  return str.replace(/^\s+|\s+$/g, "");
};
var defaultStringify = function defaultStringify2(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter2(config) {
  return function(option, rawInput) {
    if (option.data.__isNew__)
      return true;
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: "any"
    }, config), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify2 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input = trim2 ? trimString(rawInput) : rawInput;
    var candidate = trim2 ? trimString(stringify2(option)) : stringify2(option);
    if (ignoreCase) {
      input = input.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input = memoizedStripDiacriticsForInput(input);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === "start" ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
  };
};
var _excluded = ["innerRef"];
function DummyInput(_ref3) {
  var innerRef = _ref3.innerRef, props = _objectWithoutProperties(_ref3, _excluded);
  var filteredProps = removeProps(props, "onExited", "in", "enter", "exit", "appear");
  return jsx("input", _extends({
    ref: innerRef
  }, filteredProps, {
    css: /* @__PURE__ */ css$2({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, process.env.NODE_ENV === "production" ? "" : ";label:DummyInput;", process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCTSIsImZpbGUiOiJEdW1teUlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgcmVtb3ZlUHJvcHMgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIER1bW15SW5wdXQoe1xuICBpbm5lclJlZixcbiAgLi4ucHJvcHNcbn06IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snaW5wdXQnXSAmIHtcbiAgcmVhZG9ubHkgaW5uZXJSZWY6IFJlZjxIVE1MSW5wdXRFbGVtZW50Pjtcbn0pIHtcbiAgLy8gUmVtb3ZlIGFuaW1hdGlvbiBwcm9wcyBub3QgbWVhbnQgZm9yIEhUTUwgZWxlbWVudHNcbiAgY29uc3QgZmlsdGVyZWRQcm9wcyA9IHJlbW92ZVByb3BzKFxuICAgIHByb3BzLFxuICAgICdvbkV4aXRlZCcsXG4gICAgJ2luJyxcbiAgICAnZW50ZXInLFxuICAgICdleGl0JyxcbiAgICAnYXBwZWFyJ1xuICApO1xuXG4gIHJldHVybiAoXG4gICAgPGlucHV0XG4gICAgICByZWY9e2lubmVyUmVmfVxuICAgICAgey4uLmZpbHRlcmVkUHJvcHN9XG4gICAgICBjc3M9e3tcbiAgICAgICAgbGFiZWw6ICdkdW1teUlucHV0JyxcbiAgICAgICAgLy8gZ2V0IHJpZCBvZiBhbnkgZGVmYXVsdCBzdHlsZXNcbiAgICAgICAgYmFja2dyb3VuZDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHRoaXMgaGlkZXMgdGhlIGZsYXNoaW5nIGN1cnNvclxuICAgICAgICBjYXJldENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBmb250U2l6ZTogJ2luaGVyaXQnLFxuICAgICAgICBncmlkQXJlYTogJzEgLyAxIC8gMiAvIDMnLFxuICAgICAgICBvdXRsaW5lOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAvLyBpbXBvcnRhbnQhIHdpdGhvdXQgYHdpZHRoYCBicm93c2VycyB3b24ndCBhbGxvdyBmb2N1c1xuICAgICAgICB3aWR0aDogMSxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIGRlc2t0b3BcbiAgICAgICAgY29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgICAgICAgLy8gcmVtb3ZlIGN1cnNvciBvbiBtb2JpbGUgd2hpbHN0IG1haW50YWluaW5nIFwic2Nyb2xsIGludG8gdmlld1wiIGJlaGF2aW91clxuICAgICAgICBsZWZ0OiAtMTAwLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoLjAxKScsXG4gICAgICB9fVxuICAgIC8+XG4gICk7XG59XG4iXX0= */")
  }));
}
var cancelScroll = function cancelScroll2(event) {
  if (event.cancelable)
    event.preventDefault();
  event.stopPropagation();
};
function useScrollCapture(_ref3) {
  var isEnabled = _ref3.isEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var isBottom = React.useRef(false);
  var isTop = React.useRef(false);
  var touchStart = React.useRef(0);
  var scrollTarget = React.useRef(null);
  var handleEventDelta = React.useCallback(function(event, delta) {
    if (scrollTarget.current === null)
      return;
    var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false;
    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave)
        onBottomLeave(event);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave)
        onTopLeave(event);
      isTop.current = false;
    }
    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true;
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    }
    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
  var onWheel = React.useCallback(function(event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = React.useCallback(function(event) {
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = React.useCallback(function(event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = React.useCallback(function(el) {
    if (!el)
      return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    el.addEventListener("wheel", onWheel, notPassive);
    el.addEventListener("touchstart", onTouchStart, notPassive);
    el.addEventListener("touchmove", onTouchMove, notPassive);
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = React.useCallback(function(el) {
    if (!el)
      return;
    el.removeEventListener("wheel", onWheel, false);
    el.removeEventListener("touchstart", onTouchStart, false);
    el.removeEventListener("touchmove", onTouchMove, false);
  }, [onTouchMove, onTouchStart, onWheel]);
  React.useEffect(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    startListening(element);
    return function() {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"];
var LOCK_STYLES = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e) {
  e.preventDefault();
}
function allowTouchMove(e) {
  e.stopPropagation();
}
function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;
  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref3) {
  var isEnabled = _ref3.isEnabled, _ref$accountForScroll = _ref3.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = React.useRef({});
  var scrollTarget = React.useRef(null);
  var addScrollLock = React.useCallback(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      STYLE_KEYS.forEach(function(key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    }
    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function(key) {
        var val = LOCK_STYLES[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    }
    if (target && isTouchDevice()) {
      target.addEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
    activeScrollLocks += 1;
  }, [accountForScrollbars]);
  var removeScrollLock = React.useCallback(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function(key) {
        var val = originalStyles.current[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    }
    if (target && isTouchDevice()) {
      target.removeEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
  }, [accountForScrollbars]);
  React.useEffect(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function() {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function(element) {
    scrollTarget.current = element;
  };
}
function _EMOTION_STRINGIFIED_CSS_ERROR__$1() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var blurSelectInput = function blurSelectInput2(event) {
  var element = event.target;
  return element.ownerDocument.activeElement && element.ownerDocument.activeElement.blur();
};
var _ref2$1 = process.env.NODE_ENV === "production" ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9EVSIsImZpbGUiOiJTY3JvbGxNYW5hZ2VyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFJlYWN0RWxlbWVudCwgUmVmQ2FsbGJhY2ssIE1vdXNlRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU2Nyb2xsQ2FwdHVyZSBmcm9tICcuL3VzZVNjcm9sbENhcHR1cmUnO1xuaW1wb3J0IHVzZVNjcm9sbExvY2sgZnJvbSAnLi91c2VTY3JvbGxMb2NrJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcmVhZG9ubHkgY2hpbGRyZW46IChyZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PikgPT4gUmVhY3RFbGVtZW50O1xuICByZWFkb25seSBsb2NrRW5hYmxlZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Cb3R0b21MZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG4gIHJlYWRvbmx5IG9uVG9wQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Ub3BMZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGJsdXJTZWxlY3RJbnB1dCA9IChldmVudDogTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgcmV0dXJuIChcbiAgICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgIChlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuYmx1cigpXG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTY3JvbGxNYW5hZ2VyKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2tFbmFibGVkLFxuICBjYXB0dXJlRW5hYmxlZCA9IHRydWUsXG4gIG9uQm90dG9tQXJyaXZlLFxuICBvbkJvdHRvbUxlYXZlLFxuICBvblRvcEFycml2ZSxcbiAgb25Ub3BMZWF2ZSxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHNldFNjcm9sbENhcHR1cmVUYXJnZXQgPSB1c2VTY3JvbGxDYXB0dXJlKHtcbiAgICBpc0VuYWJsZWQ6IGNhcHR1cmVFbmFibGVkLFxuICAgIG9uQm90dG9tQXJyaXZlLFxuICAgIG9uQm90dG9tTGVhdmUsXG4gICAgb25Ub3BBcnJpdmUsXG4gICAgb25Ub3BMZWF2ZSxcbiAgfSk7XG4gIGNvbnN0IHNldFNjcm9sbExvY2tUYXJnZXQgPSB1c2VTY3JvbGxMb2NrKHsgaXNFbmFibGVkOiBsb2NrRW5hYmxlZCB9KTtcblxuICBjb25zdCB0YXJnZXRSZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PiA9IChlbGVtZW50KSA9PiB7XG4gICAgc2V0U2Nyb2xsQ2FwdHVyZVRhcmdldChlbGVtZW50KTtcbiAgICBzZXRTY3JvbGxMb2NrVGFyZ2V0KGVsZW1lbnQpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEZyYWdtZW50PlxuICAgICAge2xvY2tFbmFibGVkICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e2JsdXJTZWxlY3RJbnB1dH1cbiAgICAgICAgICBjc3M9e3sgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAsIHRvcDogMCB9fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHtjaGlsZHJlbih0YXJnZXRSZWYpfVxuICAgIDwvRnJhZ21lbnQ+XG4gICk7XG59XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$1
};
function ScrollManager(_ref3) {
  var children = _ref3.children, lockEnabled = _ref3.lockEnabled, _ref$captureEnabled = _ref3.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef2(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return jsx(React.Fragment, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref2$1
  }), children(targetRef));
}
function _EMOTION_STRINGIFIED_CSS_ERROR__() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref2 = process.env.NODE_ENV === "production" ? {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
} : {
  name: "5kkxb2-requiredInput-RequiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%;label:RequiredInput;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVpcmVkSW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNJIiwiZmlsZSI6IlJlcXVpcmVkSW5wdXQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBGb2N1c0V2ZW50SGFuZGxlciwgRnVuY3Rpb25Db21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmNvbnN0IFJlcXVpcmVkSW5wdXQ6IEZ1bmN0aW9uQ29tcG9uZW50PHtcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgb25Gb2N1czogRm9jdXNFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG59PiA9ICh7IG5hbWUsIG9uRm9jdXMgfSkgPT4gKFxuICA8aW5wdXRcbiAgICByZXF1aXJlZFxuICAgIG5hbWU9e25hbWV9XG4gICAgdGFiSW5kZXg9ey0xfVxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAncmVxdWlyZWRJbnB1dCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH19XG4gICAgLy8gUHJldmVudCBgU3dpdGNoaW5nIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWRgIGVycm9yXG4gICAgdmFsdWU9XCJcIlxuICAgIG9uQ2hhbmdlPXsoKSA9PiB7fX1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFJlcXVpcmVkSW5wdXQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};
var RequiredInput = function RequiredInput2(_ref3) {
  var name = _ref3.name, onFocus2 = _ref3.onFocus;
  return jsx("input", {
    required: true,
    name,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: onFocus2,
    css: _ref2,
    value: "",
    onChange: function onChange2() {
    }
  });
};
var RequiredInput$1 = RequiredInput;
var formatGroupLabel = function formatGroupLabel2(group) {
  return group.label;
};
var getOptionLabel$1 = function getOptionLabel(option) {
  return option.label;
};
var getOptionValue$1 = function getOptionValue(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled2(option) {
  return !!option.isDisabled;
};
var defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css2,
  valueContainer: valueContainerCSS
};
var colors = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
};
var borderRadius = 4;
var baseUnit = 4;
var controlHeight = 38;
var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit,
  controlHeight,
  menuGutter
};
var defaultTheme = {
  borderRadius,
  colors,
  spacing
};
var defaultProps = {
  "aria-live": "polite",
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  classNames: {},
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return "No options";
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function screenReaderStatus(_ref3) {
    var count = _ref3.count;
    return "".concat(count, " result").concat(count !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true,
  unstyled: false
};
function toCategorizedOption(props, option, selectValue, index2) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label = getOptionLabel2(props, option);
  var value = getOptionValue2(props, option);
  return {
    type: "option",
    data: option,
    isDisabled,
    isSelected,
    label,
    value,
    index: index2
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if ("options" in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(notNullish);
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
  var data = categorizedOption.data, isSelected = categorizedOption.isSelected, label = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label,
    value,
    data
  }, inputValue);
}
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue, lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state, options2) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
}
var getOptionLabel2 = function getOptionLabel3(props, data) {
  return props.getOptionLabel(data);
};
var getOptionValue2 = function getOptionValue3(props, data) {
  return props.getOptionValue(data);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === "function" ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1)
    return true;
  if (typeof props.isOptionSelected === "function") {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue2(props, option);
  return selectValue.some(function(i) {
    return getOptionValue2(props, i) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions2(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  if (hideSelectedOptions === void 0)
    return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select = /* @__PURE__ */ function(_Component) {
  _inherits(Select2, _Component);
  var _super = _createSuper(Select2);
  function Select2(_props) {
    var _this;
    _classCallCheck(this, Select2);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.instancePrefix = "";
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;
    _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange2 = _this$props.onChange, name = _this$props.name;
      actionMeta.name = name;
      _this.ariaOnChange(newValue, actionMeta);
      onChange2(newValue, actionMeta);
    };
    _this.setValue = function(newValue, action, option) {
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti, inputValue = _this$props2.inputValue;
      _this.onInputChange("", {
        action: "set-value",
        prevInputValue: inputValue
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action,
        option
      });
    };
    _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(multiValueAsValue(selectValue.filter(function(i) {
          return _this.getOptionValue(i) !== candidate;
        })), "deselect-option", newValue);
      } else if (!isDisabled) {
        if (isMulti) {
          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), "select-option", newValue);
        } else {
          _this.setValue(singleValueAsValue(newValue), "select-option");
        }
      } else {
        _this.ariaOnChange(singleValueAsValue(newValue), {
          action: "select-option",
          option: newValue,
          name
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function(i) {
        return _this.getOptionValue(i) !== candidate;
      });
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: "clear",
        removedValues: selectValue
      });
    };
    _this.popValue = function() {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "pop-value",
        removedValue: lastSelectedValue
      });
    };
    _this.getValue = function() {
      return _this.state.selectValue;
    };
    _this.cx = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return classNames$1.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };
    _this.getOptionLabel = function(data) {
      return getOptionLabel2(_this.props, data);
    };
    _this.getOptionValue = function(data) {
      return getOptionValue2(_this.props, data);
    };
    _this.getStyles = function(key, props) {
      var unstyled = _this.props.unstyled;
      var base = defaultStyles[key](props, unstyled);
      base.boxSizing = "border-box";
      var custom = _this.props.styles[key];
      return custom ? custom(base, props) : base;
    };
    _this.getClassNames = function(key, props) {
      var _this$props$className, _this$props$className2;
      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
    };
    _this.getElementId = function(element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function() {
      return defaultComponents(_this.props);
    };
    _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function(event) {
      if (event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function(event) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function(event) {
      if (event.defaultPrevented) {
        return;
      }
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu("first");
        }
      } else {
        if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
          _this.onMenuClose();
        }
      }
      if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
        event.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      if (_this.props.isDisabled)
        return;
      var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu("first");
      }
      event.preventDefault();
    };
    _this.onClearIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      _this.clearValue();
      event.preventDefault();
      _this.openAfterFocus = false;
      if (event.type === "touchend") {
        _this.focusInput();
      } else {
        setTimeout(function() {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function(event) {
      if (typeof _this.props.closeMenuOnScroll === "boolean") {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === "function") {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function() {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function() {
      _this.isComposing = false;
    };
    _this.onTouchStart = function(_ref22) {
      var touches = _ref22.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function(_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      }
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onControlMouseDown(event);
    };
    _this.onClearIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onClearIndicatorMouseDown(event);
    };
    _this.onDropdownIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging)
        return;
      _this.onDropdownIndicatorMouseDown(event);
    };
    _this.handleInputChange = function(event) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: "input-change",
        prevInputValue
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function(event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu("first");
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function(event) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.onInputChange("", {
        action: "input-blur",
        prevInputValue
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function(focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      _this.setState({
        focusedOption
      });
    };
    _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onValueInputFocus = function(e) {
      e.preventDefault();
      e.stopPropagation();
      _this.focus();
    };
    _this.onKeyDown = function(event) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (isDisabled)
        return;
      if (typeof onKeyDown === "function") {
        onKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
      }
      _this.blockOptionHover = true;
      switch (event.key) {
        case "ArrowLeft":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("previous");
          break;
        case "ArrowRight":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("next");
          break;
        case "Delete":
        case "Backspace":
          if (inputValue)
            return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue)
              return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case "Tab":
          if (_this.isComposing)
            return;
          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case "Enter":
          if (event.keyCode === 229) {
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption)
              return;
            if (_this.isComposing)
              return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case "Escape":
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange("", {
              action: "menu-close",
              prevInputValue: inputValue
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case " ":
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu("first");
            break;
          }
          if (!focusedOption)
            return;
          _this.selectOption(focusedOption);
          break;
        case "ArrowUp":
          if (menuIsOpen) {
            _this.focusOption("up");
          } else {
            _this.openMenu("last");
          }
          break;
        case "ArrowDown":
          if (menuIsOpen) {
            _this.focusOption("down");
          } else {
            _this.openMenu("first");
          }
          break;
        case "PageUp":
          if (!menuIsOpen)
            return;
          _this.focusOption("pageup");
          break;
        case "PageDown":
          if (!menuIsOpen)
            return;
          _this.focusOption("pagedown");
          break;
        case "Home":
          if (!menuIsOpen)
            return;
          _this.focusOption("first");
          break;
        case "End":
          if (!menuIsOpen)
            return;
          _this.focusOption("last");
          break;
        default:
          return;
      }
      event.preventDefault();
    };
    _this.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    if (_props.menuIsOpen && _this.state.selectValue.length) {
      var focusableOptions = _this.buildFocusableOptions();
      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusedOption = focusableOptions[optionIndex];
    }
    return _this;
  }
  _createClass(Select2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        document.addEventListener("scroll", this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }
      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (
        // ensure focus is restored correctly when the control becomes enabled
        isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
        isFocused && menuIsOpen && !prevProps.menuIsOpen
      ) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
        this.setState({
          isFocused: true
        });
      }
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener("scroll", this.onScroll, true);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef)
        return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef)
        return;
      this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function() {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (!this.props.isMulti)
        return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length)
        return;
      switch (direction) {
        case "previous":
          if (focusedIndex === 0) {
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case "next":
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first";
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options2 = this.getFocusableOptions();
      if (!options2.length)
        return;
      var nextFocus = 0;
      var focusedIndex = options2.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === "up") {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1;
      } else if (direction === "down") {
        nextFocus = (focusedIndex + 1) % options2.length;
      } else if (direction === "pageup") {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0)
          nextFocus = 0;
      } else if (direction === "pagedown") {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options2.length - 1)
          nextFocus = options2.length - 1;
      } else if (direction === "last") {
        nextFocus = options2.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options2[nextFocus],
        focusedValue: null
      });
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function getTheme2() {
        if (!this.props.theme) {
          return defaultTheme;
        }
        if (typeof this.props.theme === "function") {
          return this.props.theme(defaultTheme);
        }
        return _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme);
      }
    )
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue, cx = this.cx, getStyles2 = this.getStyles, getClassNames2 = this.getClassNames, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props;
      var isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue,
        cx,
        getStyles: getStyles2,
        getClassNames: getClassNames2,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options2,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      if (isClearable2 === void 0)
        return isMulti;
      return isClearable2;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled3(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === "function") {
        var _inputValue = this.props.inputValue;
        var _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel3(data) {
      return this.props.formatGroupLabel(data);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function startListeningComposition() {
        if (document && document.addEventListener) {
          document.addEventListener("compositionstart", this.onCompositionStart, false);
          document.addEventListener("compositionend", this.onCompositionEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener("compositionstart", this.onCompositionStart);
        document.removeEventListener("compositionend", this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function startListeningToTouch() {
        if (document && document.addEventListener) {
          document.addEventListener("touchstart", this.onTouchStart, false);
          document.addEventListener("touchmove", this.onTouchMove, false);
          document.addEventListener("touchend", this.onTouchEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener("touchstart", this.onTouchStart);
        document.removeEventListener("touchmove", this.onTouchMove);
        document.removeEventListener("touchend", this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function renderInput() {
        var _this$props8 = this.props, isDisabled = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form, menuIsOpen = _this$props8.menuIsOpen, required = _this$props8.required;
        var _this$getComponents = this.getComponents(), Input3 = _this$getComponents.Input;
        var _this$state4 = this.state, inputIsHidden = _this$state4.inputIsHidden, ariaSelection = _this$state4.ariaSelection;
        var commonProps = this.commonProps;
        var id = inputId || this.getElementId("input");
        var ariaAttributes = _objectSpread2(_objectSpread2(_objectSpread2({
          "aria-autocomplete": "list",
          "aria-expanded": menuIsOpen,
          "aria-haspopup": true,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": required,
          role: "combobox"
        }, menuIsOpen && {
          "aria-controls": this.getElementId("listbox"),
          "aria-owns": this.getElementId("listbox")
        }), !isSearchable && {
          "aria-readonly": true
        }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        if (!isSearchable) {
          return /* @__PURE__ */ React__namespace.createElement(DummyInput, _extends({
            id,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: noop$1,
            onFocus: this.onInputFocus,
            disabled: isDisabled,
            tabIndex,
            inputMode: "none",
            form,
            value: ""
          }, ariaAttributes));
        }
        return /* @__PURE__ */ React__namespace.createElement(Input3, _extends({}, commonProps, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id,
          innerRef: this.getInputRef,
          isDisabled,
          isHidden: inputIsHidden,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex,
          form,
          type: "text",
          value: inputValue
        }, ariaAttributes));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel2 = _this$getComponents2.MultiValueLabel, MultiValueRemove2 = _this$getComponents2.MultiValueRemove, SingleValue3 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder;
      var _this$state5 = this.state, selectValue = _this$state5.selectValue, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : /* @__PURE__ */ React__namespace.createElement(Placeholder3, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled,
          isFocused,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), placeholder);
      }
      if (isMulti) {
        return selectValue.map(function(opt, index2) {
          var isOptionFocused = opt === focusedValue;
          var key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return /* @__PURE__ */ React__namespace.createElement(MultiValue3, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel2,
              Remove: MultiValueRemove2
            },
            isFocused: isOptionFocused,
            isDisabled,
            key,
            index: index2,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e) {
                e.preventDefault();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, "value"));
        });
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return /* @__PURE__ */ React__namespace.createElement(SingleValue3, _extends({}, commonProps, {
        data: singleValue,
        isDisabled
      }), this.formatOptionLabel(singleValue, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator3 = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props, isDisabled = _this$props10.isDisabled, isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator3 || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ React__namespace.createElement(ClearIndicator3, _extends({}, commonProps, {
        innerProps,
        isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props, isDisabled = _this$props11.isDisabled, isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading)
        return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ React__namespace.createElement(LoadingIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator3 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator3 || !IndicatorSeparator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return /* @__PURE__ */ React__namespace.createElement(IndicatorSeparator3, _extends({}, commonProps, {
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator3 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ React__namespace.createElement(DropdownIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(), Group3 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu3 = _this$getComponents7.Menu, MenuList3 = _this$getComponents7.MenuList, MenuPortal3 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage3 = _this$getComponents7.NoOptionsMessage, Option3 = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen)
        return null;
      var render = function render2(props, id) {
        var type = props.type, data = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label = props.label, value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? void 0 : function() {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled ? void 0 : function() {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId("option"), "-").concat(id);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return /* @__PURE__ */ React__namespace.createElement(Option3, _extends({}, commonProps, {
          innerProps,
          data,
          isDisabled,
          isSelected,
          key: optionId,
          label,
          type,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function(item) {
          if (item.type === "group") {
            var _data = item.data, options2 = item.options, groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return /* @__PURE__ */ React__namespace.createElement(Group3, _extends({}, commonProps, {
              key: groupId,
              data: _data,
              options: options2,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item.data
              },
              label: _this4.formatGroupLabel(item.data)
            }), item.options.map(function(option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item.type === "option") {
            return render(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message = loadingMessage2({
          inputValue
        });
        if (message === null)
          return null;
        menuUI = /* @__PURE__ */ React__namespace.createElement(LoadingMessage3, commonProps, message);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null)
          return null;
        menuUI = /* @__PURE__ */ React__namespace.createElement(NoOptionsMessage3, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      };
      var menuElement = /* @__PURE__ */ React__namespace.createElement(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return /* @__PURE__ */ React__namespace.createElement(Menu3, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove,
            id: _this4.getElementId("listbox")
          },
          isLoading,
          placement
        }), /* @__PURE__ */ React__namespace.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return /* @__PURE__ */ React__namespace.createElement(MenuList3, _extends({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this4.getMenuListRef(instance);
              scrollTargetRef(instance);
            },
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? /* @__PURE__ */ React__namespace.createElement(MenuPortal3, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name = _this$props13.name, required = _this$props13.required;
      var selectValue = this.state.selectValue;
      if (required && !this.hasValue() && !isDisabled) {
        return /* @__PURE__ */ React__namespace.createElement(RequiredInput$1, {
          name,
          onFocus: this.onValueInputFocus
        });
      }
      if (!name || isDisabled)
        return;
      if (isMulti) {
        if (delimiter2) {
          var value = selectValue.map(function(opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter2);
          return /* @__PURE__ */ React__namespace.createElement("input", {
            name,
            type: "hidden",
            value
          });
        } else {
          var input = selectValue.length > 0 ? selectValue.map(function(opt, i) {
            return /* @__PURE__ */ React__namespace.createElement("input", {
              key: "i-".concat(i),
              name,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : /* @__PURE__ */ React__namespace.createElement("input", {
            name,
            type: "hidden",
            value: ""
          });
          return /* @__PURE__ */ React__namespace.createElement("div", null, input);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
        return /* @__PURE__ */ React__namespace.createElement("input", {
          name,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state6 = this.state, ariaSelection = _this$state6.ariaSelection, focusedOption = _this$state6.focusedOption, focusedValue = _this$state6.focusedValue, isFocused = _this$state6.isFocused, selectValue = _this$state6.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return /* @__PURE__ */ React__namespace.createElement(LiveRegion$1, _extends({}, commonProps, {
        id: this.getElementId("live-region"),
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props, className = _this$props14.className, id = _this$props14.id, isDisabled = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ React__namespace.createElement(SelectContainer3, _extends({}, commonProps, {
        className,
        innerProps: {
          id,
          onKeyDown: this.onKeyDown
        },
        isDisabled,
        isFocused
      }), this.renderLiveRegion(), /* @__PURE__ */ React__namespace.createElement(Control3, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled,
        isFocused,
        menuIsOpen
      }), /* @__PURE__ */ React__namespace.createElement(ValueContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ React__namespace.createElement(IndicatorsContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps, clearFocusValueOnUpdate = state.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate, ariaSelection = state.ariaSelection, isFocused = state.isFocused, prevWasFocused = state.prevWasFocused;
      var options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue, isMulti = props.isMulti;
      var selectValue = cleanValue(value);
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;
      if (isFocused && !hasKeptFocus) {
        newAriaSelection = {
          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: "initial-input-focus"
        };
        hasKeptFocus = !prevWasFocused;
      }
      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus") {
        newAriaSelection = null;
      }
      return _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);
  return Select2;
}(React.Component);
Select.defaultProps = defaultProps;
var StateManagedSelect = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var baseSelectProps = useStateManager(props);
  return /* @__PURE__ */ React__namespace.createElement(Select, _extends({
    ref
  }, baseSelectProps));
});
var StateManagedSelect$1 = StateManagedSelect;
const operatorsArr = [
  {
    type: "string",
    value: ["equals", "contains", "starts with", "ends with", "not equal to"]
  },
  {
    type: "number",
    value: [">", "<", ">=", "<=", "=", "!="]
  }
];
const numberOperatorEval = (var1, var2, operator) => {
  switch (operator) {
    case ">":
      return var1 > var2;
    case "<":
      return var1 < var2;
    case ">=":
      return var1 >= var2;
    case "<=":
      return var1 <= var2;
    case "=":
      return var1 == var2;
    case "!=":
      return var1 != var2;
    default:
      return false;
  }
};
const dateOperatorEval = (var1, var2, operator) => {
  switch (operator) {
    case ">":
      return var1 > var2;
    case "<":
      return var1 < var2;
    case ">=":
      return var1 >= var2;
    case "<=":
      return var1 <= var2;
    case "=":
      return var1 == var2;
    case "!=":
      return var1 != var2;
    default:
      return false;
  }
};
const stringOperatorEval = (var1, var2, operator) => {
  switch (operator) {
    case "equals":
      return (var1 == null ? void 0 : var1.toLowerCase()) == (var2 == null ? void 0 : var2.toLowerCase());
    case "contains":
      return (var1 == null ? void 0 : var1.toLowerCase().indexOf(var2 == null ? void 0 : var2.toLowerCase())) >= 0;
    case "starts with":
      return var1 == null ? void 0 : var1.toLowerCase().startsWith(var2 == null ? void 0 : var2.toLowerCase());
    case "ends with":
      return var1 == null ? void 0 : var1.toLowerCase().endsWith(var2 == null ? void 0 : var2.toLowerCase());
    case "not equal to":
      return (var1 == null ? void 0 : var1.toLowerCase()) != (var2 == null ? void 0 : var2.toLowerCase());
    default:
      return false;
  }
};
const filterGridData = (data, filters) => {
  var dataTmp = [...data];
  dataTmp.forEach((row) => {
    var isRowIncluded = true;
    filters.forEach((item) => {
      if (isRowIncluded) {
        var columnType = item.column.dataType;
        switch (columnType) {
          case "number":
            isRowIncluded = isRowIncluded && numberOperatorEval(
              row[item.column.key],
              item.value,
              item.operator
            );
            break;
          case "string":
            isRowIncluded = isRowIncluded && stringOperatorEval(
              row[item.column.key],
              item.value,
              item.operator
            );
            break;
        }
      }
    });
    if (isRowIncluded) {
      row._is_filtered_in_ = true;
    } else {
      row._is_filtered_in_ = false;
    }
  });
  return dataTmp;
};
const applyGridColumnFilter = (data, gridColumnFilterArr) => {
  var dataTmp = [...data];
  if (gridColumnFilterArr.filter((item) => item.isApplied == true).length > 0) {
    dataTmp.map((row) => row._is_filtered_in_column_filter_ = true);
  }
  gridColumnFilterArr.filter((gridColumnFilter) => gridColumnFilter.isApplied == true).forEach((gridColumnFilter, index2) => {
    dataTmp.filter((row) => row._is_filtered_in_column_filter_ == true).forEach((row, i) => {
      row._is_filtered_in_column_filter_ = gridColumnFilter.filterCalloutProps.filterList.filter((a) => a.isChecked == true).map((a) => a.text).includes(row[gridColumnFilter.column.key]);
    });
  });
  return dataTmp;
};
const isColumnDataTypeSupportedForFilter = (datatype) => {
  switch (datatype) {
    case "number":
      return true;
    case "string":
      return true;
    default:
      return false;
  }
};
const IsValidDataType = (type, text) => {
  var isValid = true;
  switch (type) {
    case "number":
      isValid = !isNaN(Number(text));
      break;
  }
  return isValid;
};
const EvaluateRule = (datatType, cellValue, styleRule) => {
  if (!styleRule) {
    return false;
  }
  switch (datatType) {
    case "number":
      return numberOperatorEval(
        Number(cellValue),
        styleRule == null ? void 0 : styleRule.rule.value,
        styleRule == null ? void 0 : styleRule.rule.operator
      );
    case "string":
      return stringOperatorEval(
        String(cellValue),
        styleRule == null ? void 0 : styleRule.rule.value,
        styleRule == null ? void 0 : styleRule.rule.operator
      );
    case "date":
      return dateOperatorEval(
        new Date(String(cellValue)),
        new Date(styleRule == null ? void 0 : styleRule.rule.value),
        styleRule == null ? void 0 : styleRule.rule.operator
      );
    default:
      return false;
  }
};
const ConvertObjectToText = (obj, columns) => {
  var text = "";
  columns.forEach((col) => {
    text += (obj[col.key] == null ? "" : obj[col.key]) + "	";
  });
  return text.substring(0, text.lastIndexOf("	"));
};
const ParseType = (type, text, isTextModified) => {
  if ((text == null ? void 0 : text.trim().length) == 0) {
    return null;
  }
  switch (type) {
    case "number":
      if (!isNaN(parseFloat(text == null ? void 0 : text.toString().replace(",", "")))) {
        const newNum = parseFloat(text == null ? void 0 : text.toString().replace(",", ""));
        return newNum;
      }
      return text;
    case "date":
      return Date.parse(text);
  }
  return isTextModified ? text == null ? void 0 : text.trim() : text;
};
function isValidDate(value) {
  const date = new Date(value);
  return !isNaN(date);
}
const GetDefault = (type) => {
  switch (type) {
    case "boolean":
      return false;
    case "date":
      return /* @__PURE__ */ new Date();
    default:
      return null;
  }
};
function isArrayOfStrings(variable) {
  if (!Array.isArray(variable)) {
    return false;
  }
  return variable.every(function(element) {
    return typeof element === "string";
  });
}
function removeFunctionsFromArrayObjects(arr) {
  return arr.map((obj) => {
    if (typeof obj === "object" && obj !== null) {
      for (let prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          if (typeof obj[prop] === "function") {
            delete obj[prop];
          } else if (typeof obj[prop] === "object") {
            obj[prop] = removeFunctionsFromArrayObjects([obj[prop]])[0];
          }
        }
      }
    }
    return obj;
  });
}
const stackStyles = { root: { width: 500 } };
const controlClass$1 = mergeStyleSets({
  control: {
    marginBottom: "10px",
    marginRight: "30px",
    maxWidth: "300px"
  },
  searchStyles: {
    marginTop: "5px"
  },
  submitStyles: {
    marginTop: "20px",
    marginLeft: "10px"
  },
  buttonStyles: {
    margin: 5
  },
  textFieldClass: {
    display: "block",
    margin: 10
  },
  spanStyles: {
    display: "inline-block",
    width: "100%",
    height: "100%"
    //lineHeight:'250%'
  },
  dialogSubMessageStyles: {
    margin: 10
  },
  dialogHeaderStyles: {
    margin: 10
  },
  submitStylesEditpanel: {
    marginTop: "20px",
    marginLeft: "10px",
    marginRight: "10px",
    maxWidth: "300px"
  },
  labelValue: {
    fontWeight: "bold"
  },
  pickerLabel: {
    color: "#323130",
    fontWeight: 600,
    padding: "5px 0px",
    margin: "5px 0px"
  },
  plainCard: {
    width: 380,
    height: 320,
    display: "flex",
    padding: "10px",
    alignItems: "center",
    justifyContent: "center"
  }
});
const GetDynamicSpanStyles = (column2, cellValue) => {
  var _a2, _b2, _c2, _d2;
  var styleRule = column2.cellStyleRule ?? void 0;
  var isRuleTrue = EvaluateRule(
    column2.dataType ?? "string",
    cellValue,
    styleRule
  );
  var styles2 = mergeStyleSets({
    dynamicSpanStyle: {
      display: "inline-block",
      width: "100%",
      height: "100%",
      textAlign: "center",
      justifyContent: "center",
      color: !column2.cellStyleRule || !column2.cellStyleRule.enable ? void 0 : isRuleTrue ? (_a2 = styleRule == null ? void 0 : styleRule.whenTrue) == null ? void 0 : _a2.textColor : (_b2 = styleRule == null ? void 0 : styleRule.whenFalse) == null ? void 0 : _b2.textColor,
      //backgroundColor: (!column.cellStyleRule || !column.cellStyleRule.enable) ? undefined : (isRuleTrue ? styleRule?.whenTrue?.backgroundColor : styleRule?.whenFalse?.backgroundColor),
      //lineHeight:'250%',
      fontWeight: !column2.cellStyleRule || !column2.cellStyleRule.enable ? void 0 : isRuleTrue ? (_c2 = styleRule == null ? void 0 : styleRule.whenTrue) == null ? void 0 : _c2.fontWeight : (_d2 = styleRule == null ? void 0 : styleRule.whenFalse) == null ? void 0 : _d2.fontWeight
    }
  });
  return styles2.dynamicSpanStyle;
};
const verticalGapStackTokens = {
  childrenGap: 15,
  padding: 10
};
const horizontalGapStackTokens = {
  childrenGap: 5,
  padding: 5
};
const textFieldStyles$1 = {
  fieldGroup: {},
  field: {
    alignContent: "center",
    alignItems: "center",
    textAlign: "center",
    justifyContent: "center"
  }
};
const dropdownStyles = {
  root: {
    alignContent: "center",
    alignItems: "center",
    textAlign: "center",
    justifyContent: "center"
  }
};
const classNames = mergeStyleSets({
  plainCard: {
    width: 200,
    height: 140,
    display: "flex",
    padding: "10px",
    alignItems: "center",
    justifyContent: "center"
  }
});
var StringOperators = /* @__PURE__ */ ((StringOperators2) => {
  StringOperators2["EQUALS"] = "equals";
  StringOperators2["CONTAINS"] = "contains";
  StringOperators2["STARTSWITH"] = "starts with";
  StringOperators2["ENDSWITH"] = "ends with";
  StringOperators2["NOTEQUALTO"] = "not equal to";
  return StringOperators2;
})(StringOperators || {});
var NumberAndDateOperators = /* @__PURE__ */ ((NumberAndDateOperators2) => {
  NumberAndDateOperators2["GREATERTHAN"] = ">";
  NumberAndDateOperators2["LESSTHAN"] = "<";
  NumberAndDateOperators2["GREATERTHANOREQUALTO"] = ">=";
  NumberAndDateOperators2["LESSTHANOREQUALTO"] = "<=";
  NumberAndDateOperators2["EQUALTO"] = "=";
  NumberAndDateOperators2["NOTEQUALTO"] = "!=";
  return NumberAndDateOperators2;
})(NumberAndDateOperators || {});
const PickerControl = (props) => {
  const [pickerTags, setPickerTags] = React.useState([]);
  const [defaultTags, setdefaultTags] = React.useState([]);
  const [pickerDescriptions, setPickerDescriptions] = React.useState([]);
  const [pickerFilteredText, setPickerFilteredText] = React.useState("");
  React.useEffect(() => {
    var _a2;
    if (props.pickerTags && props.pickerTags.length > 0) {
      setPickerTags(
        props.pickerTags.map((item) => ({ key: item, name: item }))
      );
      setdefaultTags(
        ((_a2 = props == null ? void 0 : props.defaultTags) == null ? void 0 : _a2.map((item) => ({ key: item, name: item }))) ?? []
      );
    }
  }, [props.pickerTags]);
  React.useEffect(() => {
    if (props && props.pickerDescriptionOptions && props.pickerDescriptionOptions.enabled && props.pickerDescriptionOptions.values) {
      setPickerDescriptions(props.pickerDescriptionOptions.values);
    }
  }, [props.pickerDescriptionOptions]);
  const pickerSuggestionsProps = {
    suggestionsHeaderText: !props.minCharLimitForSuggestions ? "Suggested tags" : pickerFilteredText.length >= props.minCharLimitForSuggestions ? "Suggested tags" : "",
    noResultsFoundText: !props.minCharLimitForSuggestions ? "No suggested tags found" : pickerFilteredText.length >= props.minCharLimitForSuggestions ? "No suggested tags found" : ""
  };
  const getTextFromItem = (item) => item.name;
  const listContainsTagList = (tag, tagList) => {
    if (!tagList || !tagList.length || tagList.length === 0) {
      return false;
    }
    return tagList.some((compareTag) => compareTag.key === tag.key);
  };
  const filterSuggestedTags = (filterText, tagList) => {
    setPickerFilteredText(filterText);
    if (!props.minCharLimitForSuggestions || filterText.length >= props.minCharLimitForSuggestions) {
      return GetMatchingPickerTags(
        filterText,
        pickerTags,
        props.suggestionRule,
        listContainsTagList,
        tagList
      );
    }
    return [];
  };
  const inputProps = {
    "aria-label": `${props.arialabel}`
  };
  const onFilterTagListChanged = (tagList) => {
    setdefaultTags(tagList);
    if (props.onTaglistChanged) {
      props.onTaglistChanged(tagList);
    }
  };
  const onRenderPlainCard = (item) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames.plainCard, children: pickerDescriptions.filter((x) => x.key == item.key)[0].description });
  };
  const onRenderSuggestionsItem = (tag, itemProps) => {
    const plainCardProps = {
      onRenderPlainCard,
      renderData: tag
    };
    if (pickerDescriptions && pickerDescriptions.length > 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        HoverCard,
        {
          type: HoverCardType.plain,
          plainCardProps,
          instantOpenOnClick: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "10px" }, children: tag.name }, tag.key)
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { padding: "10px" }, children: tag.name }, tag.key);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TagPicker,
    {
      removeButtonAriaLabel: "Remove",
      onResolveSuggestions: filterSuggestedTags,
      getTextFromItem,
      pickerSuggestionsProps,
      itemLimit: props.selectedItemsLimit ?? 1,
      onChange: onFilterTagListChanged,
      selectedItems: defaultTags,
      inputProps,
      onRenderSuggestionsItem
    }
  ) });
};
function GetMatchingPickerTags(filterText, pickerTags, rule, listContainsTagList, tagList) {
  return filterText ? pickerTags.filter(
    (tag) => stringOperatorEval(
      tag.name.toLowerCase(),
      filterText.toLowerCase(),
      !rule ? StringOperators.STARTSWITH : rule
    ) && !listContainsTagList(tag, tagList)
  ) : [];
}
var DepColTypes = /* @__PURE__ */ ((DepColTypes2) => {
  DepColTypes2["MustBeEmpty"] = "MustBeEmpty";
  DepColTypes2["MustHaveData"] = "MustHaveData";
  return DepColTypes2;
})(DepColTypes || {});
var DisableColTypes = /* @__PURE__ */ ((DisableColTypes2) => {
  DisableColTypes2["DisableWhenColKeyHasData"] = "DisableWhenItHasData";
  DisableColTypes2["DisableWhenColKeyIsEmpty"] = "DisableWhenEmpty";
  return DisableColTypes2;
})(DisableColTypes || {});
var EditControlType = /* @__PURE__ */ ((EditControlType2) => {
  EditControlType2[EditControlType2["None"] = 0] = "None";
  EditControlType2[EditControlType2["ComboBox"] = 1] = "ComboBox";
  EditControlType2[EditControlType2["TextField"] = 2] = "TextField";
  EditControlType2[EditControlType2["DropDown"] = 3] = "DropDown";
  EditControlType2[EditControlType2["Date"] = 4] = "Date";
  EditControlType2[EditControlType2["MultilineTextField"] = 5] = "MultilineTextField";
  EditControlType2[EditControlType2["DateTime"] = 6] = "DateTime";
  EditControlType2[EditControlType2["Picker"] = 7] = "Picker";
  EditControlType2[EditControlType2["Link"] = 8] = "Link";
  EditControlType2[EditControlType2["Password"] = 9] = "Password";
  EditControlType2[EditControlType2["CheckBox"] = 10] = "CheckBox";
  EditControlType2[EditControlType2["NumericFormat"] = 11] = "NumericFormat";
  return EditControlType2;
})(EditControlType || {});
function __rest(s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) {
      t[p] = s[p];
    }
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) {
        t[p[i]] = s[p[i]];
      }
    }
  }
  return t;
}
var SourceType;
(function(SourceType2) {
  SourceType2["event"] = "event";
  SourceType2["props"] = "prop";
})(SourceType || (SourceType = {}));
function noop2() {
}
function charIsNumber(char2) {
  return !!(char2 || "").match(/\d/);
}
function isNil(val) {
  return val === null || val === void 0;
}
function isNanValue(val) {
  return typeof val === "number" && isNaN(val);
}
function isNotValidValue(val) {
  return isNil(val) || isNanValue(val) || typeof val === "number" && !isFinite(val);
}
function escapeRegExp(str) {
  return str.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
}
function getThousandsGroupRegex(thousandsGroupStyle) {
  switch (thousandsGroupStyle) {
    case "lakh":
      return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g;
    case "wan":
      return /(\d)(?=(\d{4})+(?!\d))/g;
    case "thousand":
    default:
      return /(\d)(?=(\d{3})+(?!\d))/g;
  }
}
function applyThousandSeparator(str, thousandSeparator, thousandsGroupStyle) {
  var thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);
  var index2 = str.search(/[1-9]/);
  index2 = index2 === -1 ? str.length : index2;
  return str.substring(0, index2) + str.substring(index2, str.length).replace(thousandsGroupRegex, "$1" + thousandSeparator);
}
function usePersistentCallback(cb) {
  var callbackRef = React.useRef(cb);
  callbackRef.current = cb;
  var persistentCbRef = React.useRef(function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return callbackRef.current.apply(callbackRef, args);
  });
  return persistentCbRef.current;
}
function splitDecimal(numStr, allowNegative) {
  if (allowNegative === void 0)
    allowNegative = true;
  var hasNegation = numStr[0] === "-";
  var addNegation = hasNegation && allowNegative;
  numStr = numStr.replace("-", "");
  var parts = numStr.split(".");
  var beforeDecimal = parts[0];
  var afterDecimal = parts[1] || "";
  return {
    beforeDecimal,
    afterDecimal,
    hasNegation,
    addNegation
  };
}
function fixLeadingZero(numStr) {
  if (!numStr) {
    return numStr;
  }
  var isNegative = numStr[0] === "-";
  if (isNegative) {
    numStr = numStr.substring(1, numStr.length);
  }
  var parts = numStr.split(".");
  var beforeDecimal = parts[0].replace(/^0+/, "") || "0";
  var afterDecimal = parts[1] || "";
  return (isNegative ? "-" : "") + beforeDecimal + (afterDecimal ? "." + afterDecimal : "");
}
function limitToScale(numStr, scale, fixedDecimalScale) {
  var str = "";
  var filler = fixedDecimalScale ? "0" : "";
  for (var i = 0; i <= scale - 1; i++) {
    str += numStr[i] || filler;
  }
  return str;
}
function repeat(str, count) {
  return Array(count + 1).join(str);
}
function toNumericString(num) {
  var _num = num + "";
  var sign = _num[0] === "-" ? "-" : "";
  if (sign) {
    _num = _num.substring(1);
  }
  var ref = _num.split(/[eE]/g);
  var coefficient = ref[0];
  var exponent = ref[1];
  exponent = Number(exponent);
  if (!exponent) {
    return sign + coefficient;
  }
  coefficient = coefficient.replace(".", "");
  var decimalIndex = 1 + exponent;
  var coffiecientLn = coefficient.length;
  if (decimalIndex < 0) {
    coefficient = "0." + repeat("0", Math.abs(decimalIndex)) + coefficient;
  } else if (decimalIndex >= coffiecientLn) {
    coefficient = coefficient + repeat("0", decimalIndex - coffiecientLn);
  } else {
    coefficient = (coefficient.substring(0, decimalIndex) || "0") + "." + coefficient.substring(decimalIndex);
  }
  return sign + coefficient;
}
function roundToPrecision(numStr, scale, fixedDecimalScale) {
  if (["", "-"].indexOf(numStr) !== -1) {
    return numStr;
  }
  var shouldHaveDecimalSeparator = (numStr.indexOf(".") !== -1 || fixedDecimalScale) && scale;
  var ref = splitDecimal(numStr);
  var beforeDecimal = ref.beforeDecimal;
  var afterDecimal = ref.afterDecimal;
  var hasNegation = ref.hasNegation;
  var floatValue = parseFloat("0." + (afterDecimal || "0"));
  var floatValueStr = afterDecimal.length <= scale ? "0." + afterDecimal : floatValue.toFixed(scale);
  var roundedDecimalParts = floatValueStr.split(".");
  var intPart = beforeDecimal.split("").reverse().reduce(function(roundedStr, current, idx) {
    if (roundedStr.length > idx) {
      return (Number(roundedStr[0]) + Number(current)).toString() + roundedStr.substring(1, roundedStr.length);
    }
    return current + roundedStr;
  }, roundedDecimalParts[0]);
  var decimalPart = limitToScale(roundedDecimalParts[1] || "", scale, fixedDecimalScale);
  var negation = hasNegation ? "-" : "";
  var decimalSeparator = shouldHaveDecimalSeparator ? "." : "";
  return "" + negation + intPart + decimalSeparator + decimalPart;
}
function setCaretPosition(el, caretPos) {
  el.value = el.value;
  if (el !== null) {
    if (el.createTextRange) {
      var range = el.createTextRange();
      range.move("character", caretPos);
      range.select();
      return true;
    }
    if (el.selectionStart || el.selectionStart === 0) {
      el.focus();
      el.setSelectionRange(caretPos, caretPos);
      return true;
    }
    el.focus();
    return false;
  }
}
function findChangeRange(prevValue, newValue) {
  var i = 0, j = 0;
  var prevLength = prevValue.length;
  var newLength = newValue.length;
  while (prevValue[i] === newValue[i] && i < prevLength) {
    i++;
  }
  while (prevValue[prevLength - 1 - j] === newValue[newLength - 1 - j] && newLength - j > i && prevLength - j > i) {
    j++;
  }
  return {
    from: { start: i, end: prevLength - j },
    to: { start: i, end: newLength - j }
  };
}
function clamp(num, min2, max2) {
  return Math.min(Math.max(num, min2), max2);
}
function geInputCaretPosition(el) {
  return Math.max(el.selectionStart, el.selectionEnd);
}
function addInputMode() {
  return typeof navigator !== "undefined" && !(navigator.platform && /iPhone|iPod/.test(navigator.platform));
}
function getDefaultChangeMeta(value) {
  return {
    from: {
      start: 0,
      end: 0
    },
    to: {
      start: 0,
      end: value.length
    },
    lastValue: ""
  };
}
function getCaretPosition(newFormattedValue, lastFormattedValue, curValue, curCaretPos, boundary, isValidInputCharacter) {
  var changeRange = findChangeRange(curValue, newFormattedValue);
  var from2 = changeRange.from;
  var to = changeRange.to;
  if (from2.end - from2.start === 1 && from2.end === to.end && to.end === curCaretPos) {
    return curCaretPos;
  }
  var firstAllowedPosition = boundary.findIndex(function(b) {
    return b;
  });
  var prefixFormat = newFormattedValue.slice(0, firstAllowedPosition);
  if (!lastFormattedValue && !curValue.startsWith(prefixFormat)) {
    curValue = prefixFormat + curValue;
    curCaretPos = curCaretPos + prefixFormat.length;
  }
  var curValLn = curValue.length;
  var formattedValueLn = newFormattedValue.length;
  var addedIndexMap = {};
  var indexMap = new Array(curValLn);
  for (var i = 0; i < curValLn; i++) {
    indexMap[i] = -1;
    for (var j = 0, jLn = formattedValueLn; j < jLn; j++) {
      if (curValue[i] === newFormattedValue[j] && addedIndexMap[j] !== true) {
        indexMap[i] = j;
        addedIndexMap[j] = true;
        break;
      }
    }
  }
  var pos = curCaretPos;
  while (pos < curValLn && (indexMap[pos] === -1 || !isValidInputCharacter(curValue[pos]))) {
    pos++;
  }
  var endIndex = pos === curValLn || indexMap[pos] === -1 ? formattedValueLn : indexMap[pos];
  pos = curCaretPos - 1;
  while (pos > 0 && indexMap[pos] === -1) {
    pos--;
  }
  var startIndex = pos === -1 || indexMap[pos] === -1 ? 0 : indexMap[pos] + 1;
  if (startIndex > endIndex) {
    return endIndex;
  }
  return curCaretPos - startIndex < endIndex - curCaretPos ? startIndex : endIndex;
}
function getCaretPosInBoundary(value, caretPos, boundary, direction) {
  var valLn = value.length;
  caretPos = clamp(caretPos, 0, valLn);
  if (direction === "left") {
    while (caretPos >= 0 && !boundary[caretPos]) {
      caretPos--;
    }
    if (caretPos === -1) {
      caretPos = boundary.indexOf(true);
    }
  } else {
    while (caretPos <= valLn && !boundary[caretPos]) {
      caretPos++;
    }
    if (caretPos > valLn) {
      caretPos = boundary.lastIndexOf(true);
    }
  }
  if (caretPos === -1) {
    caretPos = valLn;
  }
  return caretPos;
}
function caretUnknownFormatBoundary(formattedValue) {
  var boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(function() {
    return true;
  });
  for (var i = 0, ln = boundaryAry.length; i < ln; i++) {
    boundaryAry[i] = Boolean(charIsNumber(formattedValue[i]) || charIsNumber(formattedValue[i - 1]));
  }
  return boundaryAry;
}
function useInternalValues(value, defaultValue, valueIsNumericString, format2, removeFormatting2, onValueChange) {
  if (onValueChange === void 0)
    onValueChange = noop2;
  var getValues = usePersistentCallback(function(value2, valueIsNumericString2) {
    var formattedValue, numAsString;
    if (isNotValidValue(value2)) {
      numAsString = "";
      formattedValue = "";
    } else if (typeof value2 === "number" || valueIsNumericString2) {
      numAsString = typeof value2 === "number" ? toNumericString(value2) : value2;
      formattedValue = format2(numAsString);
    } else {
      numAsString = removeFormatting2(value2, void 0);
      formattedValue = format2(numAsString);
    }
    return { formattedValue, numAsString };
  });
  var ref = React.useState(function() {
    return getValues(isNil(value) ? defaultValue : value, valueIsNumericString);
  });
  var values2 = ref[0];
  var setValues = ref[1];
  var _onValueChange = function(newValues2, sourceInfo) {
    if (newValues2.formattedValue !== values2.formattedValue) {
      setValues({
        formattedValue: newValues2.formattedValue,
        numAsString: newValues2.value
      });
    }
    onValueChange(newValues2, sourceInfo);
  };
  var _value = value;
  var _valueIsNumericString = valueIsNumericString;
  if (isNil(value)) {
    _value = values2.numAsString;
    _valueIsNumericString = true;
  }
  var newValues = getValues(_value, _valueIsNumericString);
  React.useMemo(function() {
    setValues(newValues);
  }, [newValues.formattedValue]);
  return [values2, _onValueChange];
}
function defaultRemoveFormatting(value) {
  return value.replace(/[^0-9]/g, "");
}
function defaultFormat(value) {
  return value;
}
function NumberFormatBase(props) {
  var type = props.type;
  if (type === void 0)
    type = "text";
  var displayType = props.displayType;
  if (displayType === void 0)
    displayType = "input";
  var customInput = props.customInput;
  var renderText = props.renderText;
  var getInputRef = props.getInputRef;
  var format2 = props.format;
  if (format2 === void 0)
    format2 = defaultFormat;
  var removeFormatting2 = props.removeFormatting;
  if (removeFormatting2 === void 0)
    removeFormatting2 = defaultRemoveFormatting;
  var defaultValue = props.defaultValue;
  var valueIsNumericString = props.valueIsNumericString;
  var onValueChange = props.onValueChange;
  var isAllowed = props.isAllowed;
  var onChange2 = props.onChange;
  if (onChange2 === void 0)
    onChange2 = noop2;
  var onKeyDown = props.onKeyDown;
  if (onKeyDown === void 0)
    onKeyDown = noop2;
  var onMouseUp = props.onMouseUp;
  if (onMouseUp === void 0)
    onMouseUp = noop2;
  var onFocus2 = props.onFocus;
  if (onFocus2 === void 0)
    onFocus2 = noop2;
  var onBlur = props.onBlur;
  if (onBlur === void 0)
    onBlur = noop2;
  var propValue = props.value;
  var getCaretBoundary2 = props.getCaretBoundary;
  if (getCaretBoundary2 === void 0)
    getCaretBoundary2 = caretUnknownFormatBoundary;
  var isValidInputCharacter = props.isValidInputCharacter;
  if (isValidInputCharacter === void 0)
    isValidInputCharacter = charIsNumber;
  var otherProps = __rest(props, ["type", "displayType", "customInput", "renderText", "getInputRef", "format", "removeFormatting", "defaultValue", "valueIsNumericString", "onValueChange", "isAllowed", "onChange", "onKeyDown", "onMouseUp", "onFocus", "onBlur", "value", "getCaretBoundary", "isValidInputCharacter"]);
  var ref = useInternalValues(propValue, defaultValue, Boolean(valueIsNumericString), format2, removeFormatting2, onValueChange);
  var ref_0 = ref[0];
  var formattedValue = ref_0.formattedValue;
  var numAsString = ref_0.numAsString;
  var onFormattedValueChange = ref[1];
  var lastUpdatedValue = React.useRef({ formattedValue, numAsString });
  var _onValueChange = function(values2, source) {
    lastUpdatedValue.current = { formattedValue: values2.formattedValue, numAsString: values2.value };
    onFormattedValueChange(values2, source);
  };
  var ref$1 = React.useState(false);
  var mounted = ref$1[0];
  var setMounted = ref$1[1];
  var focusedElm = React.useRef(null);
  var timeout = React.useRef({
    setCaretTimeout: null,
    focusTimeout: null
  });
  React.useEffect(function() {
    setMounted(true);
    return function() {
      clearTimeout(timeout.current.setCaretTimeout);
      clearTimeout(timeout.current.focusTimeout);
    };
  }, []);
  var _format = format2;
  var getValueObject = function(formattedValue2, numAsString2) {
    var floatValue = parseFloat(numAsString2);
    return {
      formattedValue: formattedValue2,
      value: numAsString2,
      floatValue: isNaN(floatValue) ? void 0 : floatValue
    };
  };
  var setPatchedCaretPosition = function(el, caretPos, currentValue) {
    if (el.selectionStart === 0 && el.selectionEnd === el.value.length) {
      return;
    }
    setCaretPosition(el, caretPos);
    timeout.current.setCaretTimeout = setTimeout(function() {
      if (el.value === currentValue && el.selectionStart !== el.selectionEnd) {
        setCaretPosition(el, caretPos);
      }
    }, 0);
  };
  var correctCaretPosition = function(value, caretPos, direction) {
    return getCaretPosInBoundary(value, caretPos, getCaretBoundary2(value), direction);
  };
  var getNewCaretPosition = function(inputValue, newFormattedValue, caretPos) {
    var caretBoundary = getCaretBoundary2(newFormattedValue);
    var updatedCaretPos = getCaretPosition(newFormattedValue, formattedValue, inputValue, caretPos, caretBoundary, isValidInputCharacter);
    updatedCaretPos = getCaretPosInBoundary(newFormattedValue, updatedCaretPos, caretBoundary);
    return updatedCaretPos;
  };
  var updateValueAndCaretPosition = function(params) {
    var newFormattedValue = params.formattedValue;
    if (newFormattedValue === void 0)
      newFormattedValue = "";
    var input = params.input;
    var setCaretPosition2 = params.setCaretPosition;
    if (setCaretPosition2 === void 0)
      setCaretPosition2 = true;
    var source = params.source;
    var event = params.event;
    var numAsString2 = params.numAsString;
    var caretPos = params.caretPos;
    if (input) {
      if (caretPos === void 0 && setCaretPosition2) {
        var inputValue = params.inputValue || input.value;
        var currentCaretPosition2 = geInputCaretPosition(input);
        input.value = newFormattedValue;
        caretPos = getNewCaretPosition(inputValue, newFormattedValue, currentCaretPosition2);
      }
      input.value = newFormattedValue;
      if (setCaretPosition2 && caretPos !== void 0) {
        setPatchedCaretPosition(input, caretPos, newFormattedValue);
      }
    }
    if (newFormattedValue !== formattedValue) {
      _onValueChange(getValueObject(newFormattedValue, numAsString2), { event, source });
    }
  };
  React.useEffect(function() {
    var ref2 = lastUpdatedValue.current;
    var lastFormattedValue = ref2.formattedValue;
    var lastNumAsString = ref2.numAsString;
    if (formattedValue !== lastFormattedValue && (formattedValue !== numAsString || lastFormattedValue !== lastNumAsString)) {
      _onValueChange(getValueObject(formattedValue, numAsString), {
        event: void 0,
        source: SourceType.props
      });
    }
  }, [formattedValue, numAsString]);
  var currentCaretPosition = focusedElm.current ? geInputCaretPosition(focusedElm.current) : void 0;
  var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
  useIsomorphicLayoutEffect2(function() {
    var input = focusedElm.current;
    if (formattedValue !== lastUpdatedValue.current.formattedValue && input) {
      var caretPos = getNewCaretPosition(lastUpdatedValue.current.formattedValue, formattedValue, currentCaretPosition);
      input.value = formattedValue;
      setPatchedCaretPosition(input, caretPos, formattedValue);
    }
  }, [formattedValue]);
  var formatInputValue = function(inputValue, event, source) {
    var changeRange = findChangeRange(formattedValue, inputValue);
    var changeMeta = Object.assign(Object.assign({}, changeRange), { lastValue: formattedValue });
    var _numAsString = removeFormatting2(inputValue, changeMeta);
    var _formattedValue = _format(_numAsString);
    _numAsString = removeFormatting2(_formattedValue, void 0);
    if (isAllowed && !isAllowed(getValueObject(_formattedValue, _numAsString))) {
      var input = event.target;
      var currentCaretPosition2 = geInputCaretPosition(input);
      var caretPos = getNewCaretPosition(inputValue, formattedValue, currentCaretPosition2);
      input.value = formattedValue;
      setPatchedCaretPosition(input, caretPos, formattedValue);
      return false;
    }
    updateValueAndCaretPosition({
      formattedValue: _formattedValue,
      numAsString: _numAsString,
      inputValue,
      event,
      source,
      setCaretPosition: true,
      input: event.target
    });
    return true;
  };
  var _onChange = function(e) {
    var el = e.target;
    var inputValue = el.value;
    var changed = formatInputValue(inputValue, e, SourceType.event);
    if (changed) {
      onChange2(e);
    }
  };
  var _onKeyDown2 = function(e) {
    var el = e.target;
    var key = e.key;
    var selectionStart = el.selectionStart;
    var selectionEnd = el.selectionEnd;
    var value = el.value;
    if (value === void 0)
      value = "";
    var expectedCaretPosition;
    if (key === "ArrowLeft" || key === "Backspace") {
      expectedCaretPosition = Math.max(selectionStart - 1, 0);
    } else if (key === "ArrowRight") {
      expectedCaretPosition = Math.min(selectionStart + 1, value.length);
    } else if (key === "Delete") {
      expectedCaretPosition = selectionStart;
    }
    if (expectedCaretPosition === void 0 || selectionStart !== selectionEnd) {
      onKeyDown(e);
      return;
    }
    var newCaretPosition = expectedCaretPosition;
    if (key === "ArrowLeft" || key === "ArrowRight") {
      var direction = key === "ArrowLeft" ? "left" : "right";
      newCaretPosition = correctCaretPosition(value, expectedCaretPosition, direction);
      if (newCaretPosition !== expectedCaretPosition) {
        e.preventDefault();
      }
    } else if (key === "Delete" && !isValidInputCharacter(value[expectedCaretPosition])) {
      newCaretPosition = correctCaretPosition(value, expectedCaretPosition, "right");
    } else if (key === "Backspace" && !isValidInputCharacter(value[expectedCaretPosition])) {
      newCaretPosition = correctCaretPosition(value, expectedCaretPosition, "left");
    }
    if (newCaretPosition !== expectedCaretPosition) {
      setPatchedCaretPosition(el, newCaretPosition, value);
    }
    if (e.isUnitTestRun) {
      setPatchedCaretPosition(el, newCaretPosition, value);
    }
    onKeyDown(e);
  };
  var _onMouseUp = function(e) {
    var el = e.target;
    var selectionStart = el.selectionStart;
    var selectionEnd = el.selectionEnd;
    var value = el.value;
    if (value === void 0)
      value = "";
    if (selectionStart === selectionEnd) {
      var caretPosition = correctCaretPosition(value, selectionStart);
      if (caretPosition !== selectionStart) {
        setPatchedCaretPosition(el, caretPosition, value);
      }
    }
    onMouseUp(e);
  };
  var _onFocus = function(e) {
    if (e.persist) {
      e.persist();
    }
    var el = e.target;
    focusedElm.current = el;
    timeout.current.focusTimeout = setTimeout(function() {
      var selectionStart = el.selectionStart;
      var selectionEnd = el.selectionEnd;
      var value = el.value;
      if (value === void 0)
        value = "";
      var caretPosition = correctCaretPosition(value, selectionStart);
      if (caretPosition !== selectionStart && !(selectionStart === 0 && selectionEnd === value.length)) {
        setPatchedCaretPosition(el, caretPosition, value);
      }
      onFocus2(e);
    }, 0);
  };
  var _onBlur = function(e) {
    focusedElm.current = null;
    clearTimeout(timeout.current.focusTimeout);
    clearTimeout(timeout.current.setCaretTimeout);
    onBlur(e);
  };
  var inputMode = mounted && addInputMode() ? "numeric" : void 0;
  var inputProps = Object.assign({ inputMode }, otherProps, {
    type,
    value: formattedValue,
    onChange: _onChange,
    onKeyDown: _onKeyDown2,
    onMouseUp: _onMouseUp,
    onFocus: _onFocus,
    onBlur: _onBlur
  });
  if (displayType === "text") {
    return renderText ? React.createElement(React.Fragment, null, renderText(formattedValue, otherProps) || null) : React.createElement("span", Object.assign({}, otherProps, { ref: getInputRef }), formattedValue);
  } else if (customInput) {
    var CustomInput = customInput;
    return React.createElement(CustomInput, Object.assign({}, inputProps, { ref: getInputRef }));
  }
  return React.createElement("input", Object.assign({}, inputProps, { ref: getInputRef }));
}
function format(numStr, props) {
  var decimalScale = props.decimalScale;
  var fixedDecimalScale = props.fixedDecimalScale;
  var prefix2 = props.prefix;
  if (prefix2 === void 0)
    prefix2 = "";
  var suffix = props.suffix;
  if (suffix === void 0)
    suffix = "";
  var allowNegative = props.allowNegative;
  var thousandsGroupStyle = props.thousandsGroupStyle;
  if (thousandsGroupStyle === void 0)
    thousandsGroupStyle = "thousand";
  if (numStr === "" || numStr === "-") {
    return numStr;
  }
  var ref = getSeparators(props);
  var thousandSeparator = ref.thousandSeparator;
  var decimalSeparator = ref.decimalSeparator;
  var hasDecimalSeparator = decimalScale !== 0 && numStr.indexOf(".") !== -1 || decimalScale && fixedDecimalScale;
  var ref$1 = splitDecimal(numStr, allowNegative);
  var beforeDecimal = ref$1.beforeDecimal;
  var afterDecimal = ref$1.afterDecimal;
  var addNegation = ref$1.addNegation;
  if (decimalScale !== void 0) {
    afterDecimal = limitToScale(afterDecimal, decimalScale, !!fixedDecimalScale);
  }
  if (thousandSeparator) {
    beforeDecimal = applyThousandSeparator(beforeDecimal, thousandSeparator, thousandsGroupStyle);
  }
  if (prefix2) {
    beforeDecimal = prefix2 + beforeDecimal;
  }
  if (suffix) {
    afterDecimal = afterDecimal + suffix;
  }
  if (addNegation) {
    beforeDecimal = "-" + beforeDecimal;
  }
  numStr = beforeDecimal + (hasDecimalSeparator && decimalSeparator || "") + afterDecimal;
  return numStr;
}
function getSeparators(props) {
  var decimalSeparator = props.decimalSeparator;
  if (decimalSeparator === void 0)
    decimalSeparator = ".";
  var thousandSeparator = props.thousandSeparator;
  var allowedDecimalSeparators = props.allowedDecimalSeparators;
  if (thousandSeparator === true) {
    thousandSeparator = ",";
  }
  if (!allowedDecimalSeparators) {
    allowedDecimalSeparators = [decimalSeparator, "."];
  }
  return {
    decimalSeparator,
    thousandSeparator,
    allowedDecimalSeparators
  };
}
function handleNegation(value, allowNegative) {
  if (value === void 0)
    value = "";
  var negationRegex = new RegExp("(-)");
  var doubleNegationRegex = new RegExp("(-)(.)*(-)");
  var hasNegation = negationRegex.test(value);
  var removeNegation = doubleNegationRegex.test(value);
  value = value.replace(/-/g, "");
  if (hasNegation && !removeNegation && allowNegative) {
    value = "-" + value;
  }
  return value;
}
function getNumberRegex(decimalSeparator, global2) {
  return new RegExp("(^-)|[0-9]|" + escapeRegExp(decimalSeparator), global2 ? "g" : void 0);
}
function isNumericString(val, prefix2, suffix) {
  if (val === "") {
    return true;
  }
  return !(prefix2 === null || prefix2 === void 0 ? void 0 : prefix2.match(/\d/)) && !(suffix === null || suffix === void 0 ? void 0 : suffix.match(/\d/)) && typeof val === "string" && !isNaN(Number(val));
}
function removeFormatting(value, changeMeta, props) {
  var assign2;
  if (changeMeta === void 0)
    changeMeta = getDefaultChangeMeta(value);
  var allowNegative = props.allowNegative;
  var prefix2 = props.prefix;
  if (prefix2 === void 0)
    prefix2 = "";
  var suffix = props.suffix;
  if (suffix === void 0)
    suffix = "";
  var decimalScale = props.decimalScale;
  var from2 = changeMeta.from;
  var to = changeMeta.to;
  var start = to.start;
  var end = to.end;
  var ref = getSeparators(props);
  var allowedDecimalSeparators = ref.allowedDecimalSeparators;
  var decimalSeparator = ref.decimalSeparator;
  var isBeforeDecimalSeparator = value[end] === decimalSeparator;
  if (charIsNumber(value) && (value === prefix2 || value === suffix) && changeMeta.lastValue === "") {
    return value;
  }
  if (end - start === 1 && allowedDecimalSeparators.indexOf(value[start]) !== -1) {
    var separator = decimalScale === 0 ? "" : decimalSeparator;
    value = value.substring(0, start) + separator + value.substring(start + 1, value.length);
  }
  var stripNegation = function(value2, start2, end2) {
    var hasNegation2 = false;
    var hasDoubleNegation = false;
    if (prefix2.startsWith("-")) {
      hasNegation2 = false;
    } else if (value2.startsWith("--")) {
      hasNegation2 = false;
      hasDoubleNegation = true;
    } else if (suffix.startsWith("-") && value2.length === suffix.length) {
      hasNegation2 = false;
    } else if (value2[0] === "-") {
      hasNegation2 = true;
    }
    var charsToRemove = hasNegation2 ? 1 : 0;
    if (hasDoubleNegation) {
      charsToRemove = 2;
    }
    if (charsToRemove) {
      value2 = value2.substring(charsToRemove);
      start2 -= charsToRemove;
      end2 -= charsToRemove;
    }
    return { value: value2, start: start2, end: end2, hasNegation: hasNegation2 };
  };
  var toMetadata = stripNegation(value, start, end);
  var hasNegation = toMetadata.hasNegation;
  assign2 = toMetadata, value = assign2.value, start = assign2.start, end = assign2.end;
  var ref$1 = stripNegation(changeMeta.lastValue, from2.start, from2.end);
  var fromStart = ref$1.start;
  var fromEnd = ref$1.end;
  var lastValue = ref$1.value;
  var updatedSuffixPart = value.substring(start, end);
  if (value.length && lastValue.length && (fromStart > lastValue.length - suffix.length || fromEnd < prefix2.length) && !(updatedSuffixPart && suffix.startsWith(updatedSuffixPart))) {
    value = lastValue;
  }
  var startIndex = 0;
  if (value.startsWith(prefix2)) {
    startIndex += prefix2.length;
  } else if (start < prefix2.length) {
    startIndex = start;
  }
  value = value.substring(startIndex);
  end -= startIndex;
  var endIndex = value.length;
  var suffixStartIndex = value.length - suffix.length;
  if (value.endsWith(suffix)) {
    endIndex = suffixStartIndex;
  } else if (end > suffixStartIndex) {
    endIndex = end;
  } else if (end > value.length - suffix.length) {
    endIndex = end;
  }
  value = value.substring(0, endIndex);
  value = handleNegation(hasNegation ? "-" + value : value, allowNegative);
  value = (value.match(getNumberRegex(decimalSeparator, true)) || []).join("");
  var firstIndex = value.indexOf(decimalSeparator);
  value = value.replace(new RegExp(escapeRegExp(decimalSeparator), "g"), function(match2, index2) {
    return index2 === firstIndex ? "." : "";
  });
  var ref$2 = splitDecimal(value, allowNegative);
  var beforeDecimal = ref$2.beforeDecimal;
  var afterDecimal = ref$2.afterDecimal;
  var addNegation = ref$2.addNegation;
  if (to.end - to.start < from2.end - from2.start && beforeDecimal === "" && isBeforeDecimalSeparator && !parseFloat(afterDecimal)) {
    value = addNegation ? "-" : "";
  }
  return value;
}
function getCaretBoundary(formattedValue, props) {
  var prefix2 = props.prefix;
  if (prefix2 === void 0)
    prefix2 = "";
  var suffix = props.suffix;
  if (suffix === void 0)
    suffix = "";
  var boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(function() {
    return true;
  });
  var hasNegation = formattedValue[0] === "-";
  boundaryAry.fill(false, 0, prefix2.length + (hasNegation ? 1 : 0));
  var valLn = formattedValue.length;
  boundaryAry.fill(false, valLn - suffix.length + 1, valLn + 1);
  return boundaryAry;
}
function validateAndUpdateProps(props) {
  var ref = getSeparators(props);
  var thousandSeparator = ref.thousandSeparator;
  var decimalSeparator = ref.decimalSeparator;
  var prefix2 = props.prefix;
  if (prefix2 === void 0)
    prefix2 = "";
  var allowNegative = props.allowNegative;
  if (allowNegative === void 0)
    allowNegative = true;
  if (thousandSeparator === decimalSeparator) {
    throw new Error("\n        Decimal separator can't be same as thousand separator.\n        thousandSeparator: " + thousandSeparator + ' (thousandSeparator = {true} is same as thousandSeparator = ",")\n        decimalSeparator: ' + decimalSeparator + " (default value for decimalSeparator is .)\n     ");
  }
  if (prefix2.startsWith("-") && allowNegative) {
    console.error("\n      Prefix can't start with '-' when allowNegative is true.\n      prefix: " + prefix2 + "\n      allowNegative: " + allowNegative + "\n    ");
    allowNegative = false;
  }
  return Object.assign(Object.assign({}, props), { allowNegative });
}
function useNumericFormat(props) {
  props = validateAndUpdateProps(props);
  var decimalSeparator = props.decimalSeparator;
  if (decimalSeparator === void 0)
    decimalSeparator = ".";
  props.allowedDecimalSeparators;
  props.thousandsGroupStyle;
  var suffix = props.suffix;
  var allowNegative = props.allowNegative;
  var allowLeadingZeros = props.allowLeadingZeros;
  var onKeyDown = props.onKeyDown;
  if (onKeyDown === void 0)
    onKeyDown = noop2;
  var onBlur = props.onBlur;
  if (onBlur === void 0)
    onBlur = noop2;
  var thousandSeparator = props.thousandSeparator;
  var decimalScale = props.decimalScale;
  var fixedDecimalScale = props.fixedDecimalScale;
  var prefix2 = props.prefix;
  if (prefix2 === void 0)
    prefix2 = "";
  var defaultValue = props.defaultValue;
  var value = props.value;
  var valueIsNumericString = props.valueIsNumericString;
  var onValueChange = props.onValueChange;
  var restProps = __rest(props, ["decimalSeparator", "allowedDecimalSeparators", "thousandsGroupStyle", "suffix", "allowNegative", "allowLeadingZeros", "onKeyDown", "onBlur", "thousandSeparator", "decimalScale", "fixedDecimalScale", "prefix", "defaultValue", "value", "valueIsNumericString", "onValueChange"]);
  var _format = function(numStr) {
    return format(numStr, props);
  };
  var _removeFormatting = function(inputValue, changeMeta) {
    return removeFormatting(inputValue, changeMeta, props);
  };
  var _value = isNil(value) ? defaultValue : value;
  var _valueIsNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : isNumericString(_value, prefix2, suffix);
  if (!isNil(value)) {
    _valueIsNumericString = valueIsNumericString || typeof value === "number";
  } else if (!isNil(defaultValue)) {
    _valueIsNumericString = valueIsNumericString || typeof defaultValue === "number";
  }
  var roundIncomingValueToPrecision = function(value2) {
    if (isNotValidValue(value2)) {
      return value2;
    }
    if (typeof value2 === "number") {
      value2 = toNumericString(value2);
    }
    if (_valueIsNumericString && typeof decimalScale === "number") {
      return roundToPrecision(value2, decimalScale, Boolean(fixedDecimalScale));
    }
    return value2;
  };
  var ref = useInternalValues(roundIncomingValueToPrecision(value), roundIncomingValueToPrecision(defaultValue), Boolean(_valueIsNumericString), _format, _removeFormatting, onValueChange);
  var ref_0 = ref[0];
  var numAsString = ref_0.numAsString;
  var formattedValue = ref_0.formattedValue;
  var _onValueChange = ref[1];
  var _onKeyDown2 = function(e) {
    var el = e.target;
    var key = e.key;
    var selectionStart = el.selectionStart;
    var selectionEnd = el.selectionEnd;
    var value2 = el.value;
    if (value2 === void 0)
      value2 = "";
    if (selectionStart !== selectionEnd) {
      onKeyDown(e);
      return;
    }
    if (key === "Backspace" && value2[0] === "-" && selectionStart === prefix2.length + 1 && allowNegative) {
      setCaretPosition(el, 1);
    }
    var ref2 = getSeparators(props);
    var decimalSeparator2 = ref2.decimalSeparator;
    var allowedDecimalSeparators = ref2.allowedDecimalSeparators;
    if (key === "Backspace" && value2[selectionStart - 1] === decimalSeparator2 && decimalScale && fixedDecimalScale) {
      setCaretPosition(el, selectionStart - 1);
      e.preventDefault();
    }
    if ((allowedDecimalSeparators === null || allowedDecimalSeparators === void 0 ? void 0 : allowedDecimalSeparators.includes(key)) && value2[selectionStart] === decimalSeparator2) {
      setCaretPosition(el, selectionStart + 1);
    }
    var _thousandSeparator = thousandSeparator === true ? "," : thousandSeparator;
    if (key === "Backspace" && value2[selectionStart - 1] === _thousandSeparator) {
      setCaretPosition(el, selectionStart - 1);
    }
    if (key === "Delete" && value2[selectionStart] === _thousandSeparator) {
      setCaretPosition(el, selectionStart + 1);
    }
    onKeyDown(e);
  };
  var _onBlur = function(e) {
    var _value2 = numAsString;
    if (!_value2.match(/\d/g)) {
      _value2 = "";
    }
    if (!allowLeadingZeros) {
      _value2 = fixLeadingZero(_value2);
    }
    if (fixedDecimalScale && decimalScale) {
      _value2 = roundToPrecision(_value2, decimalScale, fixedDecimalScale);
    }
    if (_value2 !== numAsString) {
      var formattedValue2 = format(_value2, props);
      _onValueChange({
        formattedValue: formattedValue2,
        value: _value2,
        floatValue: parseFloat(_value2)
      }, {
        event: e,
        source: SourceType.event
      });
    }
    onBlur(e);
  };
  var isValidInputCharacter = function(inputChar) {
    if (inputChar === decimalSeparator) {
      return true;
    }
    return charIsNumber(inputChar);
  };
  return Object.assign(Object.assign({}, restProps), { value: formattedValue, valueIsNumericString: false, isValidInputCharacter, onValueChange: _onValueChange, format: _format, removeFormatting: _removeFormatting, getCaretBoundary: function(formattedValue2) {
    return getCaretBoundary(formattedValue2, props);
  }, onKeyDown: _onKeyDown2, onBlur: _onBlur });
}
function NumericFormat(props) {
  var numericFormatProps = useNumericFormat(props);
  return React.createElement(NumberFormatBase, Object.assign({}, numericFormatProps));
}
const AddRowPanel = (props) => {
  React.createRef();
  const disableDropdown = React.useRef(/* @__PURE__ */ new Map());
  const disableComboBox = React.useRef(/* @__PURE__ */ new Map());
  const trackMulitSelect = React.useRef(0);
  const _comboBoxRef = React.useRef(null);
  const updateObj = {};
  const [columnValuesObj, setColumnValuesObj] = React.useState(null);
  const [error, setError] = React.useState("");
  const [confirmButtonText, setConfirmButtonText] = React.useState("");
  const [confirmButtonDisabled, setConfirmButtonDisabled] = React.useState(false);
  const GetValueOrDefault = (item) => {
    var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _i, _j;
    if (item.autoGenerate) {
      return props.autoGenId.toString();
    } else if (item.defaultOnAddRow) {
      if (item.comboBoxOptions) {
        return ((_b2 = (_a2 = item.comboBoxOptions) == null ? void 0 : _a2.filter((x) => x.text == item.defaultOnAddRow)[0]) == null ? void 0 : _b2.text) ?? ((_e2 = (_d2 = (_c2 = item.comboBoxOptions) == null ? void 0 : _c2.filter((x) => {
          var _a3;
          return ((_a3 = x.key) == null ? void 0 : _a3.toString()) == item.defaultOnAddRow;
        })[0]) == null ? void 0 : _d2.text) == null ? void 0 : _e2.toString()) ?? item.defaultOnAddRow;
      } else if (item.dropdownValues) {
        return ((_g = (_f = item.dropdownValues) == null ? void 0 : _f.filter((x) => x.text == item.defaultOnAddRow)[0]) == null ? void 0 : _g.text) ?? ((_j = (_i = (_h = item.dropdownValues) == null ? void 0 : _h.filter((x) => {
          var _a3;
          return ((_a3 = x.key) == null ? void 0 : _a3.toString()) == item.defaultOnAddRow;
        })[0]) == null ? void 0 : _i.text) == null ? void 0 : _j.toString()) ?? item.defaultOnAddRow;
      }
      return item.defaultOnAddRow;
    }
    return GetDefault(item.dataType);
  };
  React.useEffect(() => {
    let tmpColumnValuesObj = {};
    props.columnConfigurationData.forEach((item, index2) => {
      var _a2;
      tmpColumnValuesObj[item.key] = {
        value: GetValueOrDefault(item),
        isChanged: false,
        error: null,
        defaultValueOnNewRow: (item == null ? void 0 : item.defaultOnAddRow) ?? null,
        dataType: item.dataType,
        multiSelect: ((_a2 = item.comboBoxProps) == null ? void 0 : _a2.multiSelect) ?? false,
        columnEditable: (item == null ? void 0 : item.editable) ?? false
      };
    });
    setColumnValuesObj(tmpColumnValuesObj);
    setConfirmButtonText(props.addToGridButtonText ?? "Save To Grid");
  }, [props.columnConfigurationData]);
  const SetObjValues = (key, value, isChanged = true, errorMessage = null, multiSelect = false) => {
    if (error)
      setError("");
    var columnValuesObjTmp = { ...columnValuesObj };
    columnValuesObjTmp[key] = {
      ...columnValuesObjTmp[key],
      value,
      isChanged,
      error: errorMessage
    };
    if (props.onChange) {
      var changed = props.onChange(Object.assign({}, columnValuesObjTmp));
      if ((changed == null ? void 0 : changed.errorMessage) !== void 0) {
        setError(changed.errorMessage.trim());
      }
      if (changed == null ? void 0 : changed.data) {
        var objectKeys = Object.keys(changed.data);
        objectKeys.forEach((objKey) => {
          columnValuesObjTmp[objKey]["value"] = changed["data"][objKey]["value"];
        });
      }
    }
    setColumnValuesObj(columnValuesObjTmp);
  };
  const onDropDownChange = (event, selectedDropdownItem, item) => {
    SetObjValues(item.key, selectedDropdownItem == null ? void 0 : selectedDropdownItem.key);
  };
  const onComboBoxChange = (event, selectedOption, item) => {
    var _a2, _b2;
    SetObjValues(
      item.key,
      ((_a2 = item == null ? void 0 : item.comboBoxProps) == null ? void 0 : _a2.multiSelect) ? selectedOption : selectedOption == null ? void 0 : selectedOption.text,
      true,
      null,
      ((_b2 = item == null ? void 0 : item.comboBoxProps) == null ? void 0 : _b2.multiSelect) ?? false
    );
  };
  const onComboBoxChangeMultiSelect = (selectedOptions, item) => {
    SetObjValues(item.key, selectedOptions);
  };
  const onComboBoxChangeRaw = (text, item) => {
    SetObjValues(item.key, text);
  };
  const onCheckBoxChange = (ev, isChecked, item) => {
    SetObjValues(item.key, isChecked ? item == null ? void 0 : item.text : "");
  };
  const onTextUpdate = (ev, text, column2) => {
    if (!IsValidDataType(column2.dataType, text)) {
      SetObjValues(
        ev.target.id,
        text,
        false,
        `Data should be of type '${column2.dataType}'`
      );
      return;
    }
    SetObjValues(ev.target.id, ParseType(column2.dataType, text));
  };
  const onNumericFormatUpdate = (ev, text, column2) => {
    if (!IsValidDataType(column2.dataType, text)) {
      SetObjValues(
        (ev == null ? void 0 : ev.target).id,
        (text == null ? void 0 : text.toString()) ?? "0",
        false,
        `Data should be of type '${column2.dataType}'`
      );
      return;
    }
    SetObjValues(
      (ev == null ? void 0 : ev.target).id,
      ParseType(column2.dataType, (text == null ? void 0 : text.toString()) ?? "0")
    );
  };
  const Messages = React.useRef(
    /* @__PURE__ */ new Map()
  );
  const [messagesState, setMessagesState] = React.useState(
    /* @__PURE__ */ new Map()
  );
  const [messagesJSXState, setMessagesJSXState] = React.useState([]);
  const insertToMessageMap = (mapVar, key, value) => {
    mapVar.set(key, value);
    const newMap = new Map(mapVar);
    setMessagesState(newMap);
  };
  const removeFromMessageMap = (mapVar, key) => {
    mapVar.delete(key);
    const newMap = new Map(mapVar);
    setMessagesState(newMap);
  };
  const onRenderMsg = React.useCallback(() => {
    let messageTmp = [];
    messagesState.forEach(function(value, key) {
      messageTmp.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          MessageBar,
          {
            styles: { root: { marginBottom: 5 } },
            messageBarType: value.type,
            onDismiss: () => removeFromMessageMap(Messages.current, key),
            children: value.msg
          },
          key
        )
      );
    });
    return messageTmp;
  }, [messagesState]);
  React.useEffect(() => {
    Messages.current = messagesState;
    setMessagesJSXState(onRenderMsg());
  }, [messagesState]);
  const runGridValidations = () => {
    let localError = false;
    let emptyCol = [];
    let emptyReqCol = [];
    Messages.current = /* @__PURE__ */ new Map();
    setMessagesState(Messages.current);
    props.columnConfigurationData.forEach((item, row) => {
      var _a2, _b2, _c2, _d2, _e2, _f;
      const currentValue = columnValuesObj[item.key].value ?? null;
      const getValue = (key) => {
        var _a3;
        return (_a3 = columnValuesObj[key]) == null ? void 0 : _a3.value;
      };
      props.columnConfigurationData.filter(
        (x) => x.key === item.key
      );
      if (item.required && typeof item.required == "boolean" && (currentValue == null || currentValue == void 0 || (currentValue == null ? void 0 : currentValue.toString().length) <= 0 || currentValue == "" && item.dataType != "number")) {
        if (!emptyCol.includes(" " + item.name))
          emptyCol.push(" " + item.name);
      } else if (typeof item.required !== "boolean" && !item.required.requiredOnlyIfTheseColumnsAreEmpty && item.required.errorMessage && (currentValue == null || currentValue == void 0 || (currentValue == null ? void 0 : currentValue.toString().length) <= 0 || currentValue == "" && item.dataType != "number")) {
        var msg2 = `${item.name}: ${item.required.errorMessage}.`;
        insertToMessageMap(Messages.current, item.key + row + "empty", {
          msg: msg2,
          type: MessageBarType.error
        });
      } else if (typeof item.required !== "boolean" && item.required.requiredOnlyIfTheseColumnsAreEmpty && (currentValue == null || currentValue == void 0 || (currentValue == null ? void 0 : currentValue.toString().length) <= 0 || currentValue == "" && item.dataType != "number")) {
        const checkKeys = item.required.requiredOnlyIfTheseColumnsAreEmpty.colKeys;
        let skippable = false;
        for (let index2 = 0; index2 < checkKeys.length; index2++) {
          const columnKey = checkKeys[index2];
          const str = getValue(columnKey);
          if (item.required.alwaysRequired) {
            if (str == null || str == void 0 || (str == null ? void 0 : str.toString().length) <= 0 || str == "" && item.dataType != "number") {
              if (item.required.errorMessage) {
                var msg2 = `${item.name}: ${item.required.errorMessage}.`;
                insertToMessageMap(Messages.current, item.key + row + "empty", {
                  msg: msg2,
                  type: MessageBarType.error
                });
              } else if (!emptyReqCol.includes(" " + item.name)) {
                emptyReqCol.push(" " + item.name);
                break;
              }
            }
          } else {
            if ((str || (str == null ? void 0 : str.toString().trim()) == "0") && (str == null ? void 0 : str.toString().length) > 0) {
              skippable = true;
              break;
            }
          }
        }
        if (!emptyReqCol.includes(" " + item.name) && skippable == false) {
          if (item.required.errorMessage == void 0) {
            emptyReqCol.push(" " + item.name);
          } else {
            var msg2 = `${item.name}: ${item.required.errorMessage}.`;
            insertToMessageMap(Messages.current, item.key + row + "empty", {
              msg: msg2,
              type: MessageBarType.error
            });
          }
        }
      }
      if (currentValue !== null && (typeof currentValue !== item.dataType || typeof currentValue === "number")) {
        if (item.dataType === "number") {
          if (currentValue && isNaN(parseInt(currentValue)) && currentValue !== "") {
            var msg2 = `Column ${item.name}: Value is not a '${item.dataType}'.`;
            insertToMessageMap(Messages.current, item.key + row, {
              msg: msg2,
              type: MessageBarType.error
            });
            localError = true;
          } else if (item.validations && item.validations.numberBoundaries) {
            const min2 = item.validations.numberBoundaries.minRange;
            const max2 = item.validations.numberBoundaries.maxRange;
            if (min2 && max2) {
              if (!(min2 <= parseInt(currentValue) && max2 >= parseInt(currentValue))) {
                var msg2 = `Column ${item.name}: Value outside of range '${min2} - ${max2}'. Entered value ${currentValue}.`;
                insertToMessageMap(Messages.current, item.key + row, {
                  msg: msg2,
                  type: MessageBarType.error
                });
                localError = true;
              }
            } else if (min2) {
              if (!(min2 <= parseInt(currentValue))) {
                var msg2 = `Column ${item.name}: Value is lower than required range: '${min2}'. Entered value ${currentValue}.`;
                insertToMessageMap(Messages.current, item.key + row, {
                  msg: msg2,
                  type: MessageBarType.error
                });
                localError = true;
              }
            } else if (max2) {
              if (!(max2 >= parseInt(currentValue))) {
                var msg2 = `Column ${item.name}: Value is greater than required range: '${max2}'. Entered value ${currentValue}.`;
                insertToMessageMap(Messages.current, item.key + row, {
                  msg: msg2,
                  type: MessageBarType.error
                });
                localError = true;
              }
            }
          }
        } else if (item.dataType === "boolean") {
          try {
            Boolean(currentValue);
          } catch (error2) {
            var msg2 = `Column ${item.name}: Value is not a '${item.dataType}'.`;
            insertToMessageMap(Messages.current, item.key + row, {
              msg: msg2,
              type: MessageBarType.error
            });
            localError = true;
          }
        } else if (item.dataType === "date") {
          try {
            if (!isValidDate(currentValue)) {
              throw {};
            }
          } catch (error2) {
            var msg2 = `Column ${item.name}: Value is not a '${item.dataType}'.`;
            insertToMessageMap(Messages.current, item.key + row, {
              msg: msg2,
              type: MessageBarType.error
            });
            localError = true;
          }
        }
      }
      if (item.validations && item.validations.columnDependent) {
        for (let index2 = 0; index2 < item.validations.columnDependent.length; index2++) {
          const colDep = item.validations.columnDependent[index2];
          if (getValue(colDep.dependentColumnKey) || getValue(colDep.dependentColumnKey) !== void 0) {
            const str = getValue(colDep.dependentColumnKey);
            let skip = false;
            if (colDep.skipCheckIfTheseColumnsHaveData && colDep.skipCheckIfTheseColumnsHaveData.colKeys) {
              for (const skipForKey of colDep.skipCheckIfTheseColumnsHaveData.colKeys) {
                if ((_a2 = colDep.skipCheckIfTheseColumnsHaveData) == null ? void 0 : _a2.partial) {
                  const str2 = getValue(skipForKey);
                  if (str2 && str2 !== null && str2 !== void 0 && (str2 == null ? void 0 : str2.toString().length) > 0) {
                    skip = true;
                    break;
                  }
                } else {
                  const str2 = getValue(skipForKey);
                  if (str2 && str2 !== null && str2 !== void 0 && (str2 == null ? void 0 : str2.toString().length) > 0) {
                    skip = true;
                  } else {
                    skip = false;
                    break;
                  }
                }
              }
            }
            if (!skip) {
              if (str !== void 0 && str !== null) {
                if ((str == null ? void 0 : str.toString().length) > 0 && colDep.type === DepColTypes.MustBeEmpty) {
                  if (currentValue !== null && (currentValue == null ? void 0 : currentValue.toString().length) > 0) {
                    var msg2 = `Column ${item.name}: ${colDep.errorMessage ?? `Data cannot be entered in ${item.name} and in ${colDep.dependentColumnName} Column. Remove data in ${colDep.dependentColumnName} Column to enter data here.`}`;
                    insertToMessageMap(Messages.current, row + "ColDep", {
                      msg: msg2,
                      type: MessageBarType.error
                    });
                    localError = true;
                  }
                }
              }
              if ((str == void 0 || str == null || str == "" && item.dataType != "number" || str && (str == null ? void 0 : str.toString().length) <= 0) && colDep.type === DepColTypes.MustHaveData) {
                var msg2 = `Column ${item.name}: ${colDep.errorMessage ?? `Data needs to be entered in ${item.name} and in ${colDep.dependentColumnName} Column.`}`;
                insertToMessageMap(Messages.current, row + "ColDep", {
                  msg: msg2,
                  type: MessageBarType.error
                });
                localError = true;
              }
            }
          }
        }
      }
      if (item.validations && item.validations.regexValidation) {
        for (let index2 = 0; index2 < item.validations.regexValidation.length; index2++) {
          const data = item.validations.regexValidation[index2];
          if (!data.regex.test(currentValue)) {
            var msg2 = `Column ${item.name}: ${data.errorMessage}`;
            insertToMessageMap(Messages.current, item.key + row, {
              msg: msg2,
              type: MessageBarType.error
            });
            localError = true;
          }
        }
      }
      if (item.validations && item.validations.stringValidations) {
        const caseInsensitive = item.validations.stringValidations.caseInsensitive;
        if (caseInsensitive) {
          if (currentValue !== null && ((_c2 = (_b2 = item.validations.stringValidations) == null ? void 0 : _b2.conditionCantEqual) == null ? void 0 : _c2.toLowerCase()) === (currentValue == null ? void 0 : currentValue.toString().toLowerCase())) {
            var msg2 = `Column ${item.name}: ${(_d2 = item.validations.stringValidations) == null ? void 0 : _d2.errMsg}`;
            insertToMessageMap(Messages.current, item.key + row, {
              msg: msg2,
              type: MessageBarType.error
            });
            localError = true;
          } else {
            if (currentValue !== null && ((_e2 = item.validations.stringValidations) == null ? void 0 : _e2.conditionCantEqual) === (currentValue == null ? void 0 : currentValue.toString())) {
              var msg2 = `Column ${item.name}: ${(_f = item.validations.stringValidations) == null ? void 0 : _f.errMsg}`;
              insertToMessageMap(Messages.current, item.key + row, {
                msg: msg2,
                type: MessageBarType.error
              });
              localError = true;
            }
          }
        }
      }
    });
    if (emptyReqCol.length > 1) {
      var msg = `Notice: ${emptyReqCol} cannot all be empty`;
      insertToMessageMap(Messages.current, "-99erc", {
        msg,
        type: MessageBarType.error
      });
      localError = true;
    } else if (emptyReqCol.length == 1) {
      var msg = `Notice: ${emptyReqCol} cannot all be empty`;
      insertToMessageMap(Messages.current, "-99erc", {
        msg,
        type: MessageBarType.error
      });
      localError = true;
    }
    if (emptyCol.length > 1) {
      var msg = `Notice: ${emptyCol == null ? void 0 : emptyCol.toString()} cannot be empty at all`;
      insertToMessageMap(Messages.current, "-999ec", {
        msg,
        type: MessageBarType.error
      });
      localError = true;
    } else if (emptyCol.length == 1) {
      var msg = `Notice: ${emptyCol == null ? void 0 : emptyCol.toString()} cannot be empty`;
      insertToMessageMap(Messages.current, "-999ec", {
        msg,
        type: MessageBarType.error
      });
      localError = true;
    }
    return localError;
  };
  function generateCombinations(obj, currentCombination, keys2, output) {
    if (keys2.length === 0) {
      output.push(currentCombination);
      return;
    }
    var currentKey = keys2[0];
    var remainingKeys = keys2.slice(1);
    if (Array.isArray(obj[currentKey]) == false) {
      obj[currentKey] = [obj[currentKey]];
    }
    obj[currentKey].forEach(function(value) {
      generateCombinations(
        obj,
        currentCombination.concat([[currentKey, value]]),
        remainingKeys,
        output
      );
    });
  }
  function generateAllCombinations(data) {
    var keys2 = Object.keys(data);
    var output = [];
    generateCombinations(data, [], keys2, output);
    return output;
  }
  const onPanelSubmit = async () => {
    var _a2;
    var columnValuesObjTmp = { ...columnValuesObj };
    setError("");
    const submitAndClose = () => {
      var objectKeys = Object.keys(columnValuesObj);
      objectKeys.forEach((objKey) => {
        if (columnValuesObj[objKey]["isChanged"]) {
          if (columnValuesObj[objKey]["multiSelect"] == true) {
            updateObj[objKey] = columnValuesObj[objKey]["value"].map(
              (obj) => (obj == null ? void 0 : obj.key) ?? null
            );
          } else {
            updateObj[objKey] = columnValuesObj[objKey]["value"];
          }
        }
      });
      var combinations = generateAllCombinations(updateObj);
      props.onSubmit(combinations);
    };
    if (props.preSubmitCallback) {
      setConfirmButtonDisabled(true);
      if ((_a2 = props.addingToGridButtonText) == null ? void 0 : _a2.trim()) {
        setConfirmButtonText(props.addingToGridButtonText);
      }
      props.preSubmitCallback(Object.assign({}, columnValuesObjTmp)).then((changed) => {
        var _a3, _b2;
        if ((changed == null ? void 0 : changed.errorMessage) !== void 0) {
          setError(changed.errorMessage.trim());
        }
        setConfirmButtonText(props.addToGridButtonText ?? "Save To Grid");
        setConfirmButtonDisabled(false);
        if (((_b2 = (_a3 = changed == null ? void 0 : changed.errorMessage) == null ? void 0 : _a3.trim()) == null ? void 0 : _b2.length) > 0) {
          setColumnValuesObj(columnValuesObjTmp);
          return;
        }
        if (changed == null ? void 0 : changed.data) {
          var objectKeys = Object.keys(changed.data);
          if (objectKeys)
            objectKeys.forEach((objKey) => {
              columnValuesObjTmp[objKey]["value"] = changed["data"][objKey]["value"];
            });
        }
        const hasErrors = runGridValidations();
        if (!hasErrors && error == "")
          submitAndClose();
      });
    } else {
      const hasErrors = runGridValidations();
      if (!hasErrors)
        submitAndClose();
    }
  };
  const onCellPickerTagListChanged = (cellPickerTagList, item) => {
    if (cellPickerTagList && cellPickerTagList[0] && cellPickerTagList[0].name)
      SetObjValues(item.key, cellPickerTagList[0].name);
    else
      SetObjValues(item.key, "");
  };
  const onCellDateChange = (date, item) => {
    SetObjValues(item.key, date);
  };
  const filterMultiSelectOptions = (options2, item) => {
    var _a2;
    const filtered = options2.filter((x, index2) => {
      var _a3;
      return x.correspondingKey == columnValuesObj[((_a3 = item.filterDropdownOptions) == null ? void 0 : _a3.filterBasedOnThisColumnKey) ?? ""].value;
    });
    if (typeof columnValuesObj[item.key].value == "object" && JSON.stringify(trackMulitSelect.current) != JSON.stringify(filtered)) {
      const keysCurrentlySelected = new Set(
        (_a2 = columnValuesObj == null ? void 0 : columnValuesObj[item.key].value) == null ? void 0 : _a2.map((item2) => (item2 == null ? void 0 : item2.key) ?? null)
      );
      const filteredKeys = filtered.filter(
        (item2) => keysCurrentlySelected.has(item2 == null ? void 0 : item2.key)
      );
      trackMulitSelect.current = filtered;
      onComboBoxChangeMultiSelect(
        filteredKeys.length == 0 ? [null] : filteredKeys,
        item
      );
    }
    return filtered.map((item2, index2) => {
      return { value: item2.key, label: item2.text };
    });
  };
  const [comboOptions, setComboOptions] = React.useState([]);
  const [init, setInit] = React.useState(false);
  const createTextFields = () => {
    let tmpRenderObj = [];
    props.columnConfigurationData.forEach((item, rowNum) => {
      var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __, _$, _aa, _ba, _ca, _da, _ea, _fa, _ga, _ha, _ia, _ja, _ka, _la, _ma, _na, _oa, _pa, _qa, _ra, _sa, _ta, _ua, _va, _wa, _xa, _ya, _za, _Aa, _Ba, _Ca, _Da, _Ea, _Fa, _Ga, _Ha, _Ia, _Ja;
      switch (item.inputType) {
        case EditControlType.CheckBox:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox,
              {
                disabled: (!item.editable && !props.enableNonEditableColumns) ?? true,
                checked: columnValuesObj[item.key].value,
                label: item.text,
                onChange: (ev, isChecked) => {
                  if (ev && isChecked)
                    onCheckBoxChange(ev, isChecked, item);
                }
              },
              item.key
            )
          );
          break;
        case EditControlType.Date:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DatePicker,
              {
                disabled: (!item.editable && !props.enableNonEditableColumns) ?? true,
                value: columnValuesObj[item.key].value,
                label: item.text,
                strings: DayPickerStrings,
                placeholder: "Select a date...",
                ariaLabel: "Select a date",
                onSelectDate: (date) => onCellDateChange(date, item)
              },
              item.key
            )
          );
          break;
        case EditControlType.ComboBox:
          if (item.disableComboBox && typeof item.disableComboBox !== "boolean") {
            let newMap = new Map(disableComboBox.current);
            for (let index2 = 0; index2 < [item.disableComboBox].length; index2++) {
              const disableCellOptions = [item.disableComboBox][index2];
              const str = columnValuesObj[disableCellOptions.disableBasedOnThisColumnKey].value;
              if (disableCellOptions.type === DisableColTypes.DisableWhenColKeyHasData) {
                if (str && (str == null ? void 0 : str.toString().length) > 0 && (newMap.get(item.key + rowNum) ?? false) === false) {
                  newMap.set(item.key + rowNum, true);
                  disableComboBox.current = newMap;
                } else if (newMap.get(item.key + rowNum) == true && !str) {
                  newMap.set(item.key + rowNum, false);
                  disableComboBox.current = newMap;
                }
              } else if (disableCellOptions.type === DisableColTypes.DisableWhenColKeyIsEmpty) {
                if (str == "" || str && (str == null ? void 0 : str.toString().length) <= 0) {
                  newMap.set(item.key + rowNum, true);
                } else if ((str === null || str === void 0) && (newMap.get(item.key + rowNum) ?? false) === false) {
                  newMap.set(item.key + rowNum, true);
                } else if ((newMap.get(item.key + rowNum) ?? true) !== false && str && (str == null ? void 0 : str.toString().length) > 0) {
                  newMap.set(item.key + rowNum, false);
                }
              }
            }
            disableComboBox.current = newMap;
          }
          if ((_a2 = item.comboBoxProps) == null ? void 0 : _a2.multiSelect) {
            tmpRenderObj.push(
              /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { style: { marginBottom: -5 }, children: item.text }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  StateManagedSelect$1,
                  {
                    menuPlacement: "auto",
                    menuPosition: "fixed",
                    "aria-label": item.text,
                    filterOption: ((_b2 = item.comboBoxProps) == null ? void 0 : _b2.searchType) == "startswith" ? (option, inputValue) => {
                      var _a3, _b3;
                      return (_b3 = (_a3 = option.label) == null ? void 0 : _a3.toLowerCase()) == null ? void 0 : _b3.startsWith(inputValue == null ? void 0 : inputValue.toLowerCase());
                    } : void 0,
                    placeholder: ((_c2 = item.comboBoxProps) == null ? void 0 : _c2.placeholder) ?? "Select Options",
                    tabSelectsValue: false,
                    noOptionsMessage: ((_d2 = item.comboBoxProps) == null ? void 0 : _d2.noOptionsFoundMessage) ? () => {
                      var _a3;
                      return (_a3 = item.comboBoxProps) == null ? void 0 : _a3.noOptionsFoundMessage;
                    } : void 0,
                    isDisabled: disableComboBox.current.get(item.key + rowNum) ?? (typeof item.disableComboBox == "boolean" ? item.disableComboBox : (!item.editable && !props.enableNonEditableColumns) ?? false),
                    isMulti: true,
                    isClearable: true,
                    escapeClearsValue: true,
                    openMenuOnFocus: true,
                    options: item.filterDropdownOptions ? filterMultiSelectOptions(
                      item.filterDropdownOptions.filterOptions,
                      item
                    ) : item.comboBoxOptions ? item.comboBoxOptions.map((item2) => {
                      return { value: item2.key, label: item2.text };
                    }) : [],
                    hideSelectedOptions: true,
                    onChange: (options2, av) => {
                      onComboBoxChangeMultiSelect(
                        options2 ? options2.map((item2) => {
                          return { key: item2.value, text: item2.label };
                        }) : [],
                        item
                      );
                    },
                    theme: (theme) => ({
                      ...theme,
                      borderRadius: 2,
                      colors: {
                        ...theme.colors,
                        primary: "rgb(0,120,212)"
                      }
                    }),
                    styles: {
                      control: (baseStyles, state) => ({
                        ...baseStyles,
                        borderColor: state.isFocused ? "rgb(0,120,212)" : state.menuIsOpen ? "rgb(0,120,212)" : "black",
                        border: "1px solid rgba(0,0,0,0.7)"
                      })
                    }
                  },
                  `${item.key}_${((_g = (_f = (_e2 = item == null ? void 0 : item.filterDropdownOptions) == null ? void 0 : _e2.filterOptions) == null ? void 0 : _f.filter(
                    (x) => {
                      var _a3;
                      return x.correspondingKey == columnValuesObj[((_a3 = item.filterDropdownOptions) == null ? void 0 : _a3.filterBasedOnThisColumnKey) ?? ""].value;
                    }
                  )) == null ? void 0 : _g.toString()) ?? "NT"}`
                )
              ] })
            );
          } else {
            tmpRenderObj.push(
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                VirtualizedComboBox,
                {
                  componentRef: _comboBoxRef,
                  disabled: disableComboBox.current.get(item.key + rowNum) ?? (typeof item.disableComboBox == "boolean" ? item.disableComboBox : (!item.editable && !props.enableNonEditableColumns) ?? false),
                  placeholder: ((_h = item.comboBoxProps) == null ? void 0 : _h.multiSelect) ? ((_i = item.comboBoxProps) == null ? void 0 : _i.placeholder) ?? "Select Options" : ((_k = (_j = item.comboBoxOptions) == null ? void 0 : _j.filter(
                    (x) => x.text == columnValuesObj[item.key].value
                  )[0]) == null ? void 0 : _k.text) ?? ((_n = (_m = (_l = item.comboBoxOptions) == null ? void 0 : _l.filter(
                    (x) => {
                      var _a3;
                      return ((_a3 = x.key) == null ? void 0 : _a3.toString()) == columnValuesObj[item.key].value;
                    }
                  )[0]) == null ? void 0 : _m.text) == null ? void 0 : _n.toString()) ?? ((_o = item.comboBoxProps) == null ? void 0 : _o.placeholder) ?? "Start typing...",
                  label: item.text,
                  multiSelect: ((_p = item.comboBoxProps) == null ? void 0 : _p.multiSelect) ?? false,
                  openOnKeyboardFocus: true,
                  allowFreeInput: true,
                  allowFreeform: ((_q = item.comboBoxProps) == null ? void 0 : _q.allowFreeformComboBoxEntry) ?? false,
                  autoComplete: "on",
                  scrollSelectedToTop: true,
                  options: comboOptions,
                  onClick: () => {
                    if (!init) {
                      setInit(true);
                      setComboOptions(
                        [...item.comboBoxOptions ?? []].concat([
                          {
                            key: "beaddf9d-503a-4753-95d9-158f08d9d37e",
                            text: ""
                          }
                        ]) ?? []
                      );
                    }
                  },
                  onInputValueChange: (text) => {
                    var _a3, _b3, _c3;
                    try {
                      if (!((_a3 = item.comboBoxProps) == null ? void 0 : _a3.multiSelect)) {
                        const searchPattern = new RegExp(text == null ? void 0 : text.trim(), "i");
                        const searchResults = (_b3 = item.comboBoxOptions) == null ? void 0 : _b3.filter(
                          (itemInList) => {
                            var _a4, _b4, _c4, _d3, _e3, _f2;
                            if (((_a4 = item == null ? void 0 : item.comboBoxProps) == null ? void 0 : _a4.searchType) == "startswith") {
                              return (_e3 = (_c4 = (_b4 = itemInList == null ? void 0 : itemInList.text) == null ? void 0 : _b4.trim()) == null ? void 0 : _c4.toLowerCase()) == null ? void 0 : _e3.startsWith((_d3 = text == null ? void 0 : text.trim()) == null ? void 0 : _d3.toLowerCase());
                            } else {
                              return searchPattern.test((_f2 = itemInList.text) == null ? void 0 : _f2.trim());
                            }
                          }
                        );
                        setComboOptions(
                          (searchResults == null ? void 0 : searchResults.concat([
                            {
                              key: "64830f62-5ab8-490a-a0ed-971f977a3603",
                              text: ""
                            }
                          ])) ?? []
                        );
                        onComboBoxChangeRaw(text, item);
                      }
                    } catch (error2) {
                      setComboOptions(
                        ((_c3 = [...item.comboBoxOptions ?? []]) == null ? void 0 : _c3.concat([
                          {
                            key: "64830f62-5ab8-490a-a0ed-971f977a3603",
                            text: ""
                          }
                        ])) ?? []
                      );
                    }
                  },
                  onChange: (ev, option) => onComboBoxChange(ev, option, item)
                },
                item.key
              )
            );
          }
          break;
        case EditControlType.DropDown:
          if (item.disableDropdown && typeof item.disableDropdown !== "boolean") {
            let newMap = new Map(disableDropdown.current);
            for (let index2 = 0; index2 < [item.disableDropdown].length; index2++) {
              const disableCellOptions = [item.disableDropdown][index2];
              const str = columnValuesObj[disableCellOptions.disableBasedOnThisColumnKey].value;
              if (disableCellOptions.type === DisableColTypes.DisableWhenColKeyHasData) {
                if (str && (str == null ? void 0 : str.toString().length) > 0 && (newMap.get(item.key + rowNum) ?? false) === false) {
                  newMap.set(item.key + rowNum, true);
                  disableDropdown.current = newMap;
                } else if (newMap.get(item.key + rowNum) == true && !str) {
                  newMap.set(item.key + rowNum, false);
                  disableDropdown.current = newMap;
                }
              } else if (disableCellOptions.type === DisableColTypes.DisableWhenColKeyIsEmpty) {
                if (str == "" || str && (str == null ? void 0 : str.toString().length) <= 0) {
                  newMap.set(item.key + rowNum, true);
                } else if ((str === null || str === void 0) && (newMap.get(item.key + rowNum) ?? false) === false) {
                  newMap.set(item.key + rowNum, true);
                } else if ((newMap.get(item.key + rowNum) ?? true) !== false && str && (str == null ? void 0 : str.toString().length) > 0) {
                  newMap.set(item.key + rowNum, false);
                }
              }
            }
            disableDropdown.current = newMap;
          }
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Dropdown,
              {
                ariaLabel: item.key,
                placeholder: (item.filterDropdownOptions ? (_r = item.filterDropdownOptions.filterOptions.filter(
                  (x) => x.text == item.key
                )[0]) == null ? void 0 : _r.text : (_t = (_s = item.dropdownValues) == null ? void 0 : _s.filter((x) => x.text == item.key)[0]) == null ? void 0 : _t.text) ?? "Select an option",
                selectedKey: (
                  // Keys Select Text
                  item.filterDropdownOptions ? ((_w = (_v = (_u = item.filterDropdownOptions.filterOptions) == null ? void 0 : _u.filter(
                    (x) => {
                      var _a3;
                      return ((x == null ? void 0 : x.key) == columnValuesObj[item.key].value && x.correspondingKey == columnValuesObj[((_a3 = item.filterDropdownOptions) == null ? void 0 : _a3.filterBasedOnThisColumnKey) ?? ""].value) ?? item.key;
                    }
                  )[0]) == null ? void 0 : _v.key) == null ? void 0 : _w.toString()) ?? ((_z = (_y = (_x = item.filterDropdownOptions.filterOptions) == null ? void 0 : _x.filter(
                    (x) => {
                      var _a3;
                      return ((x == null ? void 0 : x.text) == columnValuesObj[item.key].value && x.correspondingKey == columnValuesObj[((_a3 = item.filterDropdownOptions) == null ? void 0 : _a3.filterBasedOnThisColumnKey) ?? ""].value) ?? item.key;
                    }
                  )[0]) == null ? void 0 : _y.key) == null ? void 0 : _z.toString()) ?? null : ((_C = (_B = (_A = item.dropdownValues) == null ? void 0 : _A.filter(
                    (x) => (x == null ? void 0 : x.key) == columnValuesObj[item.key].value
                  )[0]) == null ? void 0 : _B.key) == null ? void 0 : _C.toString()) ?? ((_F = (_E = (_D = item.dropdownValues) == null ? void 0 : _D.filter(
                    (x) => (x == null ? void 0 : x.text) == columnValuesObj[item.key].value
                  )[0]) == null ? void 0 : _E.key) == null ? void 0 : _F.toString()) ?? null
                ),
                label: item.text,
                options: item.filterDropdownOptions ? item.filterDropdownOptions.filterOptions.filter(
                  (x) => {
                    var _a3;
                    return x.correspondingKey == columnValuesObj[((_a3 = item.filterDropdownOptions) == null ? void 0 : _a3.filterBasedOnThisColumnKey) ?? ""].value;
                  }
                ) : item.dropdownValues ?? [],
                onChange: (ev, selected) => onDropDownChange(ev, selected, item),
                disabled: disableDropdown.current.get(item.key + rowNum) ?? (typeof item.disableDropdown == "boolean" ? item.disableDropdown : (!item.editable && !props.enableNonEditableColumns) ?? false)
              },
              item.key
            )
          );
          break;
        case EditControlType.Picker:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: controlClass$1.pickerLabel, children: item.text }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PickerControl,
                {
                  defaultTags: typeof item.defaultOnAddRow == "string" ? [item.defaultOnAddRow] : isArrayOfStrings(item.defaultOnAddRow) ? item.defaultOnAddRow : void 0,
                  arialabel: item.text,
                  selectedItemsLimit: 1,
                  pickerTags: ((_G = item.pickerOptions) == null ? void 0 : _G.pickerTags) ?? [],
                  minCharLimitForSuggestions: 2,
                  onTaglistChanged: (selectedItem) => {
                    if ((item.editable || props.enableNonEditableColumns) == true)
                      onCellPickerTagListChanged(selectedItem, item);
                  },
                  pickerDescriptionOptions: (_H = item.pickerOptions) == null ? void 0 : _H.pickerDescriptionOptions
                }
              )
            ] }, item.key)
          );
          break;
        case EditControlType.MultilineTextField:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                disabled: (!item.editable && !props.enableNonEditableColumns) ?? true,
                errorMessage: columnValuesObj[item.key].error,
                name: item.text,
                multiline: true,
                rows: 1,
                id: item.key,
                label: item.text,
                styles: textFieldStyles$1,
                onChange: (ev, text) => onTextUpdate(ev, text, item),
                value: columnValuesObj[item.key].value ?? void 0
              },
              item.key
            )
          );
          break;
        case EditControlType.Password:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                disabled: (!item.editable && !props.enableNonEditableColumns) ?? true,
                errorMessage: columnValuesObj[item.key].error,
                name: item.text,
                id: item.key,
                label: item.text,
                styles: textFieldStyles$1,
                onChange: (ev, text) => onTextUpdate(ev, text, item),
                value: columnValuesObj[item.key].value ?? void 0,
                type: "password",
                canRevealPassword: true
              },
              item.key
            )
          );
          break;
        case EditControlType.NumericFormat:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              NumericFormat,
              {
                id: item.key,
                disabled: (!item.editable && !props.enableNonEditableColumns) ?? true,
                value: ((_J = (_I = columnValuesObj[item.key]) == null ? void 0 : _I.value) == null ? void 0 : _J.toString()) ?? "",
                placeholder: (_M = (_L = (_K = item.validations) == null ? void 0 : _K.numericFormatProps) == null ? void 0 : _L.formatBase) == null ? void 0 : _M.placeholder,
                valueIsNumericString: (_P = (_O = (_N = item.validations) == null ? void 0 : _N.numericFormatProps) == null ? void 0 : _O.formatBase) == null ? void 0 : _P.valueIsNumericString,
                type: (_S = (_R = (_Q = item.validations) == null ? void 0 : _Q.numericFormatProps) == null ? void 0 : _R.formatBase) == null ? void 0 : _S.type,
                inputMode: (_V = (_U = (_T = item.validations) == null ? void 0 : _T.numericFormatProps) == null ? void 0 : _U.formatBase) == null ? void 0 : _V.inputMode,
                renderText: (_Y = (_X = (_W = item.validations) == null ? void 0 : _W.numericFormatProps) == null ? void 0 : _X.formatBase) == null ? void 0 : _Y.renderText,
                label: ((__ = (_Z = item.validations) == null ? void 0 : _Z.numericFormatProps) == null ? void 0 : __.label) ?? item.text,
                decimalScale: (_ba = (_aa = (_$ = item.validations) == null ? void 0 : _$.numericFormatProps) == null ? void 0 : _aa.formatProps) == null ? void 0 : _ba.decimalScale,
                fixedDecimalScale: (_ea = (_da = (_ca = item.validations) == null ? void 0 : _ca.numericFormatProps) == null ? void 0 : _da.formatProps) == null ? void 0 : _ea.fixedDecimalScale,
                decimalSeparator: (_ha = (_ga = (_fa = item.validations) == null ? void 0 : _fa.numericFormatProps) == null ? void 0 : _ga.formatProps) == null ? void 0 : _ha.decimalSeparator,
                allowedDecimalSeparators: (_ka = (_ja = (_ia = item.validations) == null ? void 0 : _ia.numericFormatProps) == null ? void 0 : _ja.formatProps) == null ? void 0 : _ka.allowedDecimalSeparators,
                thousandsGroupStyle: (_na = (_ma = (_la = item.validations) == null ? void 0 : _la.numericFormatProps) == null ? void 0 : _ma.formatProps) == null ? void 0 : _na.thousandsGroupStyle,
                thousandSeparator: (_qa = (_pa = (_oa = item.validations) == null ? void 0 : _oa.numericFormatProps) == null ? void 0 : _pa.formatProps) == null ? void 0 : _qa.thousandSeparator,
                onRenderLabel: (_sa = (_ra = item.validations) == null ? void 0 : _ra.numericFormatProps) == null ? void 0 : _sa.onRenderLabel,
                ariaLabel: ((_ua = (_ta = item.validations) == null ? void 0 : _ta.numericFormatProps) == null ? void 0 : _ua.ariaLabel) ?? item.text,
                customInput: TextField,
                suffix: (_xa = (_wa = (_va = item.validations) == null ? void 0 : _va.numericFormatProps) == null ? void 0 : _wa.formatProps) == null ? void 0 : _xa.suffix,
                prefix: (_Aa = (_za = (_ya = item.validations) == null ? void 0 : _ya.numericFormatProps) == null ? void 0 : _za.formatProps) == null ? void 0 : _Aa.prefix,
                allowLeadingZeros: (_Da = (_Ca = (_Ba = item.validations) == null ? void 0 : _Ba.numericFormatProps) == null ? void 0 : _Ca.formatProps) == null ? void 0 : _Da.allowLeadingZeros,
                allowNegative: (_Ga = (_Fa = (_Ea = item.validations) == null ? void 0 : _Ea.numericFormatProps) == null ? void 0 : _Fa.formatProps) == null ? void 0 : _Ga.allowNegative,
                isAllowed: (_Ja = (_Ia = (_Ha = item.validations) == null ? void 0 : _Ha.numericFormatProps) == null ? void 0 : _Ia.formatBase) == null ? void 0 : _Ja.isAllowed,
                onValueChange: (values2, sourceInfo) => {
                  if (sourceInfo.source == "event")
                    onNumericFormatUpdate(
                      sourceInfo.event,
                      values2.value,
                      item
                    );
                }
              },
              item.key
            )
          );
          break;
        default:
          if (item.autoGenerate) {
            tmpRenderObj.push(
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  errorMessage: columnValuesObj[item.key].error,
                  name: item.text,
                  id: item.key,
                  label: item.text,
                  styles: textFieldStyles$1,
                  value: columnValuesObj[item.key].value ?? void 0,
                  readOnly: true,
                  disabled: true
                },
                item.key
              )
            );
          } else {
            tmpRenderObj.push(
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  disabled: (!item.editable && !props.enableNonEditableColumns) ?? true,
                  value: columnValuesObj[item.key].value ?? void 0,
                  errorMessage: columnValuesObj[item.key].error,
                  name: item.text,
                  id: item.key,
                  label: item.text,
                  styles: textFieldStyles$1,
                  onChange: (ev, text) => onTextUpdate(ev, text, item)
                },
                item.key
              )
            );
          }
          break;
      }
    });
    return tmpRenderObj;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { grow: true, style: { height: "100%" }, children: [
    error && /* @__PURE__ */ jsxRuntimeExports.jsx(
      MessageBar,
      {
        styles: { root: { marginBottom: 5 } },
        messageBarType: MessageBarType.error,
        onDismiss: () => setError(""),
        children: error
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: 15 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Sticky, { children: messagesJSXState.map((element) => element) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { grow: true, tokens: verticalGapStackTokens, children: columnValuesObj && createTextFields() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { horizontal: true, tokens: horizontalGapStackTokens, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      PrimaryButton,
      {
        text: confirmButtonText,
        className: controlClass$1.submitStylesEditpanel,
        onClick: onPanelSubmit,
        allowDisabledFocus: true,
        disabled: confirmButtonDisabled || error || columnValuesObj && Object.keys(columnValuesObj).some(
          (k) => columnValuesObj[k] && columnValuesObj[k].error && columnValuesObj[k].error.length > 0
        ) || false
      }
    ) })
  ] });
};
const stackTokens$1 = { childrenGap: 20, maxWidth: 1e3 };
const styles$1 = mergeStyleSets({
  checkbox: {
    padding: 5
  },
  selectAllCheckbox: {
    padding: 5
  },
  button: {
    margin: 10
  }
});
const FilterList = (props) => {
  const [filterItemsList, setFilterItemsList] = React.useState([]);
  const [filterListContent, setFilterListContent] = React.useState([]);
  const [appliedFilters, setAppliedFilters] = React.useState([]);
  const [isSelectAllIndeterminate, setIsSelectAllIndeterminate] = React.useState(true);
  const [isSelectAllChecked, setIsSelectAllChecked] = React.useState(true);
  React.useEffect(() => {
    if (props && props.filterList && props.filterList.length > 0) {
      setFilterItemsList(
        props.filterList.map((item, index2) => {
          return {
            key: index2,
            text: item.text,
            isFilteredIn: true,
            isChecked: item.isChecked
          };
        })
      );
      setAppliedFilters(
        props.filterList.map((item, index2) => {
          return { text: item.text, isChecked: item.isChecked };
        })
      );
    } else {
      setFilterItemsList([]);
    }
  }, [props.filterList]);
  React.useEffect(() => {
  }, [appliedFilters]);
  React.useEffect(() => {
    SetIndeterminate(filterItemsList);
    if (filterItemsList && filterItemsList.length > 0) {
      let tmpRenderObj = [];
      filterItemsList.filter((item) => item.isFilteredIn == true).forEach((item, index2) => {
        tmpRenderObj.push(
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              label: item.text,
              onChange: (ev, checked) => onCheckChanged(ev, checked, item.key, item.text),
              className: styles$1.checkbox,
              checked: item.isChecked
            },
            item.key
          )
        );
      });
      setFilterListContent(tmpRenderObj);
    } else {
      setFilterListContent(void 0);
    }
  }, [filterItemsList]);
  const SetIndeterminate = (filterItemsList2) => {
    var checkedCount = filterItemsList2.filter(
      (item) => item.isChecked == true
    ).length;
    var totalCount = filterItemsList2.length;
    var uncheckedCount = totalCount - checkedCount;
    if (checkedCount == totalCount) {
      setIsSelectAllIndeterminate(false);
      setIsSelectAllChecked(true);
    } else if (uncheckedCount == totalCount) {
      setIsSelectAllIndeterminate(false);
      setIsSelectAllChecked(false);
    } else {
      setIsSelectAllIndeterminate(true);
      setIsSelectAllChecked(false);
    }
  };
  function onCheckChanged(ev, isChecked, key, text) {
    var filterItemsListTmp = [...filterItemsList];
    filterItemsListTmp.filter((item) => item.key == key).map((item) => item.isChecked = isChecked);
    setFilterItemsList(filterItemsListTmp);
    var appliedFiltersTmp = [...appliedFilters];
    appliedFiltersTmp.filter((item) => item.text == text).map((item) => item.isChecked = isChecked);
    setAppliedFilters(appliedFiltersTmp);
  }
  const onSelectAllCheckChanged = (ev, isChecked) => {
    var filterItemsListTmp = [...filterItemsList];
    filterItemsListTmp.map((item) => item.isChecked = isChecked);
    setFilterItemsList(filterItemsListTmp);
    var appliedFiltersTmp = [...appliedFilters];
    appliedFiltersTmp.map((item) => item.isChecked = isChecked);
    setAppliedFilters(appliedFiltersTmp);
  };
  const onApply = () => {
    if (props.onApply) {
      var onApplyParams = {
        columnKey: props.columnKey,
        columnName: props.columnName,
        filterList: appliedFilters
      };
      props.onApply(onApplyParams);
    }
  };
  const onFilterTextUpdate = (ev, text) => {
    if (text) {
      let searchResult = [...filterItemsList];
      searchResult.filter((_data, index2) => {
        var BreakException = {};
        try {
          if (_data.text.toString().toLowerCase().includes(text.trim().toLowerCase())) {
            _data.isFilteredIn = true;
            throw BreakException;
          } else {
            _data.isFilteredIn = false;
          }
        } catch (e) {
        }
      });
      setFilterItemsList(searchResult);
    } else {
      var filterItemsListTmp = [...filterItemsList];
      filterItemsListTmp.map((item) => item.isFilteredIn = true);
      setFilterItemsList(filterItemsListTmp);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { verticalAlign: "start", tokens: stackTokens$1, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextField,
      {
        placeholder: `Filter ${props.columnName}`,
        onChange: (ev, text) => onFilterTextUpdate(ev, text)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: mergeStyles({
          height: "25vh",
          width: "30vh",
          position: "relative"
          // backgroundColor: "white",
        }),
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ScrollablePane, { scrollbarVisibility: ScrollbarVisibility.auto, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              label: "(Select All)",
              indeterminate: isSelectAllIndeterminate,
              checked: isSelectAllChecked,
              className: styles$1.selectAllCheckbox,
              onChange: (ev, checked) => onSelectAllCheckChanged(ev, checked)
            },
            "SelectAll"
          ),
          filterListContent
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { horizontal: true, horizontalAlign: "start", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ActionButton,
        {
          className: styles$1.button,
          onClick: onApply,
          text: "Apply"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ActionButton,
        {
          text: "Cancel",
          className: styles$1.button,
          onClick: props.onCancel
        }
      )
    ] })
  ] }) });
};
const styles = mergeStyleSets({
  callout: {
    maxWidth: 500,
    padding: 30
  }
});
const FilterCallout = (props) => {
  const labelId = useId("callout-label");
  const descriptionId = useId("callout-description");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Callout,
    {
      className: styles.callout,
      ariaLabelledBy: labelId,
      ariaDescribedBy: descriptionId,
      role: "filtercallout",
      gapSpace: 5,
      target: `.${props.columnClass}`,
      isBeakVisible: true,
      directionalHint: DirectionalHint.topCenter,
      onDismiss: props.onCancel,
      setInitialFocus: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        FilterList,
        {
          onCancel: props.onCancel,
          onApply: props.onApply,
          columnKey: props.columnKey,
          columnName: props.columnName,
          filterList: props.filterList
        }
      )
    }
  ) });
};
const controlClass = mergeStyleSets({
  textFieldClass: {
    display: "block",
    margin: 10,
    width: "90%"
  },
  datePickerClass: {
    display: "block",
    margin: 10,
    width: "90%"
  },
  dialogFooterStyles: {
    display: "block",
    margin: 10,
    width: "90%"
  }
});
const stackTokens = { childrenGap: 20, maxWidth: 1e3 };
const textFieldStyles = { root: { margin: 0, width: "100%" } };
const modelProps = {
  isBlocking: false,
  styles: { main: { maxWidth: "100vh" } }
};
const ColumnFilterDialog = (props) => {
  const [gridColumn, setGridColumn] = React.useState();
  const [operator, setOperator] = React.useState("");
  const [value, setValue] = React.useState("");
  const onSelectGridColumn = (item) => {
    setGridColumn(
      props.columnConfigurationData.filter((val) => val.key == item.value)[0]
    );
  };
  const onSelectOperator = (item) => {
    setOperator(item.label.toString());
  };
  const onSelectValue = (item) => {
    setValue(item.value.toString());
  };
  const onTextUpdate = (ev, text) => {
    setValue(text);
  };
  React.useEffect(() => {
    if (gridColumn && gridColumn.key && gridColumn.key.length > 0) {
      var column2 = props.columnConfigurationData.filter(
        (x) => x.key == gridColumn.key
      );
      if (column2.length > 0) {
        setOperator("");
        setValue("");
        var valueOptions = createValueOptions(column2[0]);
        switch (column2[0].dataType) {
          case "number":
            setInputFieldContent(
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  className: controlClass.textFieldClass,
                  placeholder: "Value",
                  onChange: (ev, text) => onTextUpdate(ev, text),
                  styles: textFieldStyles
                }
              )
            );
            setOperatorDropDownContent(
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                StateManagedSelect$1,
                {
                  menuPlacement: "auto",
                  menuPosition: "fixed",
                  defaultValue: null,
                  "aria-label": "Select Filter Condition",
                  placeholder: "Select Filter Condition",
                  tabSelectsValue: false,
                  options: createCompareOptions(),
                  hideSelectedOptions: true,
                  onChange: (options22, av) => {
                    if (options22)
                      onSelectOperator(options22);
                  },
                  theme: (theme) => ({
                    ...theme,
                    borderRadius: 2,
                    colors: {
                      ...theme.colors,
                      primary: "rgb(0,120,212)"
                    }
                  }),
                  styles: {
                    control: (baseStyles, state) => ({
                      ...baseStyles,
                      borderColor: state.isFocused ? "rgb(0,120,212)" : state.menuIsOpen ? "rgb(0,120,212)" : "black",
                      border: "1px solid rgba(0,0,0,0.7)"
                    })
                  }
                },
                `${gridColumn.key}-${column2[0].dataType}_1`
              )
            );
            break;
          case "string":
            setInputFieldContent(
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  className: controlClass.textFieldClass,
                  placeholder: "Enter Value",
                  onChange: (ev, text) => onTextUpdate(ev, text),
                  styles: textFieldStyles
                }
              )
            );
            setOperatorDropDownContent(
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                StateManagedSelect$1,
                {
                  menuPlacement: "auto",
                  menuPosition: "fixed",
                  "aria-label": "Select Filter Condition",
                  placeholder: "Select Filter Condition",
                  tabSelectsValue: false,
                  options: createCompareOptions(),
                  hideSelectedOptions: true,
                  onChange: (options22, av) => {
                    if (options22)
                      onSelectOperator(options22);
                  },
                  theme: (theme) => ({
                    ...theme,
                    borderRadius: 2,
                    colors: {
                      ...theme.colors,
                      primary: "rgb(0,120,212)"
                    }
                  }),
                  styles: {
                    control: (baseStyles, state) => ({
                      ...baseStyles,
                      borderColor: state.isFocused ? "rgb(0,120,212)" : state.menuIsOpen ? "rgb(0,120,212)" : "black",
                      border: "1px solid rgba(0,0,0,0.7)"
                    })
                  }
                },
                `${gridColumn.key}-${column2[0].dataType}_1`
              )
            );
            break;
          case "date":
            setInputFieldContent(
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                StateManagedSelect$1,
                {
                  menuPlacement: "auto",
                  menuPosition: "fixed",
                  "aria-label": "Select Filter Condition",
                  placeholder: "Select Filter Condition",
                  tabSelectsValue: false,
                  options: valueOptions,
                  hideSelectedOptions: true,
                  onChange: (options22, av) => {
                    if (options22)
                      onSelectValue(options22);
                  },
                  theme: (theme) => ({
                    ...theme,
                    borderRadius: 2,
                    colors: {
                      ...theme.colors,
                      primary: "rgb(0,120,212)"
                    }
                  }),
                  styles: {
                    control: (baseStyles, state) => ({
                      ...baseStyles,
                      borderColor: state.isFocused ? "rgb(0,120,212)" : state.menuIsOpen ? "rgb(0,120,212)" : "black",
                      border: "1px solid rgba(0,0,0,0.7)"
                    })
                  }
                },
                `${gridColumn.key}-${column2[0].dataType}_1`
              )
            );
            setOperatorDropDownContent(
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                StateManagedSelect$1,
                {
                  menuPlacement: "auto",
                  menuPosition: "fixed",
                  "aria-label": "Select Filter Condition",
                  placeholder: "Select Filter Condition",
                  tabSelectsValue: false,
                  options: createCompareOptions(),
                  hideSelectedOptions: true,
                  onChange: (options22, av) => {
                    if (options22)
                      onSelectOperator(options22);
                  },
                  theme: (theme) => ({
                    ...theme,
                    borderRadius: 2,
                    colors: {
                      ...theme.colors,
                      primary: "rgb(0,120,212)"
                    }
                  }),
                  styles: {
                    control: (baseStyles, state) => ({
                      ...baseStyles,
                      borderColor: state.isFocused ? "rgb(0,120,212)" : state.menuIsOpen ? "rgb(0,120,212)" : "black",
                      border: "1px solid rgba(0,0,0,0.7)"
                    })
                  }
                },
                `${gridColumn.key}-${column2[0].dataType}_2`
              )
            );
            break;
        }
      }
    }
  }, [gridColumn]);
  const createDropDownOptions = () => {
    let dropdownOptions = [];
    props.columnConfigurationData.forEach((item, index2) => {
      dropdownOptions.push({ key: item.key, text: item.text });
    });
    return dropdownOptions;
  };
  const options2 = createDropDownOptions();
  const createCompareOptions = () => {
    if (!(gridColumn && gridColumn.key && gridColumn.key.length > 0)) {
      return [];
    }
    let dataType = props.columnConfigurationData.filter(
      (x) => x.key == gridColumn.key
    )[0].dataType;
    let dropdownOptions = [];
    let operatorsOptions = [];
    switch (dataType) {
      case "string":
        operatorsOptions = operatorsArr.filter(
          (item) => item.type == "string"
        )[0].value;
        break;
      case "number":
        operatorsOptions = operatorsArr.filter(
          (item) => item.type == "number"
        )[0].value;
        break;
    }
    operatorsOptions.forEach((item, index2) => {
      dropdownOptions.push({ value: item + index2, label: item });
    });
    return dropdownOptions;
  };
  const createValueOptions = (column2) => {
    var columnData = props.gridData.map((item) => item[column2.key]);
    let dropdownOptions = [];
    columnData.forEach((item, index2) => {
      dropdownOptions.push({ value: item + index2, label: item });
    });
    return dropdownOptions;
  };
  const [inputFieldContent, setInputFieldContent] = React.useState(
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      StateManagedSelect$1,
      {
        menuPlacement: "auto",
        menuPosition: "fixed",
        "aria-label": "Enter/Select Value",
        placeholder: "Enter/Select Value",
        tabSelectsValue: false,
        options: [],
        hideSelectedOptions: true,
        onChange: (options22, av) => {
          if (options22)
            onSelectValue(options22);
        },
        theme: (theme) => ({
          ...theme,
          borderRadius: 2,
          colors: {
            ...theme.colors,
            primary: "rgb(0,120,212)"
          }
        }),
        styles: {
          control: (baseStyles, state) => ({
            ...baseStyles,
            borderColor: state.isFocused ? "rgb(0,120,212)" : state.menuIsOpen ? "rgb(0,120,212)" : "black",
            border: "1px solid rgba(0,0,0,0.7)"
          })
        }
      }
    )
  );
  const [operatorDropDownContent, setOperatorDropDownContent] = React.useState(
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      StateManagedSelect$1,
      {
        menuPlacement: "auto",
        menuPosition: "fixed",
        "aria-label": "Select Filter Condition",
        placeholder: "Select Filter Condition",
        tabSelectsValue: false,
        options: createCompareOptions(),
        hideSelectedOptions: true,
        onChange: (options22, av) => {
          if (options22)
            onSelectValue(options22);
        },
        theme: (theme) => ({
          ...theme,
          borderRadius: 2,
          colors: {
            ...theme.colors,
            primary: "rgb(0,120,212)"
          }
        }),
        styles: {
          control: (baseStyles, state) => ({
            ...baseStyles,
            borderColor: state.isFocused ? "rgb(0,120,212)" : state.menuIsOpen ? "rgb(0,120,212)" : "black",
            border: "1px solid rgba(0,0,0,0.7)"
          })
        }
      }
    )
  );
  const closeDialog = React.useCallback(() => {
    if (props.onDialogCancel) {
      props.onDialogCancel();
    }
    setInputFieldContent(void 0);
  }, []);
  const saveDialog = () => {
    var filterObj = {
      column: gridColumn,
      operator,
      value
    };
    if (props.onDialogSave) {
      props.onDialogSave(filterObj);
    }
    setInputFieldContent(void 0);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      dialogContentProps: { title: "Column Filter" },
      modalProps: modelProps,
      hidden: !inputFieldContent,
      onDismiss: closeDialog,
      closeButtonAriaLabel: "Close",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { verticalAlign: "space-between", tokens: stackTokens, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(StackItem, { grow: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            StateManagedSelect$1,
            {
              menuPlacement: "auto",
              menuPosition: "fixed",
              "aria-label": "Select the Column",
              filterOption: (option, inputValue) => {
                var _a2, _b2;
                return (_b2 = (_a2 = option.label) == null ? void 0 : _a2.toLowerCase()) == null ? void 0 : _b2.startsWith(inputValue == null ? void 0 : inputValue.toLowerCase());
              },
              placeholder: "Select the Column",
              tabSelectsValue: false,
              options: options2.map((item) => {
                return { value: item.key, label: item.text };
              }),
              hideSelectedOptions: true,
              onChange: (options22, av) => {
                if (options22)
                  onSelectGridColumn(options22);
              },
              theme: (theme) => ({
                ...theme,
                borderRadius: 2,
                colors: {
                  ...theme.colors,
                  primary: "rgb(0,120,212)"
                }
              }),
              styles: {
                control: (baseStyles, state) => ({
                  ...baseStyles,
                  borderColor: state.isFocused ? "rgb(0,120,212)" : state.menuIsOpen ? "rgb(0,120,212)" : "black",
                  border: "1px solid rgba(0,0,0,0.7)"
                })
              }
            }
          ) }),
          gridColumn != void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(StackItem, { grow: true, children: operatorDropDownContent }),
          operator != "" && /* @__PURE__ */ jsxRuntimeExports.jsx(StackItem, { grow: true, children: inputFieldContent })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(StackItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { className: controlClass.dialogFooterStyles, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            PrimaryButton,
            {
              onClick: saveDialog,
              disabled: gridColumn == void 0 || operator == "",
              text: "Filter"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultButton, { onClick: closeDialog, text: "Cancel" })
        ] }) })
      ]
    }
  );
};
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options2, buf, offset) {
  if (native.randomUUID && !buf && !options2) {
    return native.randomUUID();
  }
  options2 = options2 || {};
  const rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
const ColumnUpdateDialog = (props) => {
  const controlClass2 = mergeStyleSets({
    inputClass: {
      display: "block",
      width: "100%"
    },
    dialogClass: {
      padding: 20
    }
  });
  const textFieldStyles2 = { fieldGroup: {} };
  const [gridColumn, setGridColumn] = React.useState("");
  const [inputValue, setInputValue] = React.useState(null);
  const stackTokens2 = { childrenGap: 10 };
  const dropdownStyles2 = {
    dropdown: { width: "100%" }
  };
  React.useEffect(() => {
    let tmpColumnValuesObj = {};
    props.columnConfigurationData.filter((x) => x.editable == true).forEach((item, index2) => {
      tmpColumnValuesObj[item.key] = {
        value: GetDefault(item.dataType),
        isChanged: false,
        error: null
      };
    });
    setInputValue(tmpColumnValuesObj);
  }, [props.columnConfigurationData]);
  const SetObjValues = (key, value, isChanged = true, errorMessage = null) => {
    var inputValueTmp = { ...inputValue };
    var objectKeys = Object.keys(inputValueTmp);
    objectKeys.forEach((objKey) => {
      inputValueTmp[objKey]["isChanged"] = false;
    });
    inputValueTmp[key] = {
      value,
      isChanged,
      error: errorMessage
    };
    setInputValue(inputValueTmp);
  };
  const onTextUpdate = (ev, text, column2) => {
    if (!IsValidDataType(column2 == null ? void 0 : column2.dataType, text)) {
      SetObjValues(
        ev.target.id,
        text,
        false,
        `Data should be of type '${column2.dataType}'`
      );
      return;
    }
    SetObjValues(ev.target.id, ParseType(column2.dataType, text));
  };
  const [inputFieldContent, setInputFieldContent] = React.useState(/* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}));
  const onSelectDate = (date, item) => {
    SetObjValues(item.key, date);
  };
  const onCellPickerTagListChanged = (cellPickerTagList, item) => {
    if (cellPickerTagList && cellPickerTagList[0] && cellPickerTagList[0].name)
      SetObjValues(item.key, cellPickerTagList[0].name);
    else
      SetObjValues(item.key, "");
  };
  const onDropDownChange = (event, selectedDropdownItem, item) => {
    SetObjValues(item.key, selectedDropdownItem == null ? void 0 : selectedDropdownItem.key);
  };
  const onNumericFormatUpdate = (ev, text, item) => {
    SetObjValues(item.key, text);
  };
  const onComboBoxChange = (event, selectedOption, item) => {
    SetObjValues(item.key, selectedOption == null ? void 0 : selectedOption.text);
  };
  const onComboBoxChangeRaw = (text, item) => {
    SetObjValues(item.key, text);
  };
  const onCheckBoxChange = (ev, isChecked, item) => {
    SetObjValues(item.key, isChecked ? item == null ? void 0 : item.text : "");
  };
  const onSelectGridColumn = (event, item) => {
    setGridColumn(item.key.toString());
  };
  const closeDialog = React.useCallback(() => {
    if (props.onDialogCancel) {
      props.onDialogCancel();
    }
    setInputFieldContent(void 0);
  }, []);
  const saveDialog = () => {
    if (props.onDialogSave) {
      var inputValueTmp = {};
      var objectKeys = Object.keys(inputValue);
      var BreakException = {};
      try {
        objectKeys.forEach((objKey) => {
          if (inputValue[objKey]["isChanged"]) {
            inputValueTmp[objKey] = inputValue[objKey]["value"];
            throw BreakException;
          }
        });
      } catch (e) {
      }
      props.onDialogSave(inputValueTmp);
    }
    setInputFieldContent(void 0);
  };
  const createDropDownOptions = () => {
    let dropdownOptions = [];
    props.columnConfigurationData.forEach((item, index2) => {
      if (item.editable == true) {
        dropdownOptions.push({ key: item.key, text: item.text });
      }
    });
    return dropdownOptions;
  };
  const options2 = createDropDownOptions();
  const [comboOptions, setComboOptions] = React.useState([]);
  const [init, setInit] = React.useState(false);
  const GetInputFieldContent = () => {
    var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __, _$, _aa, _ba, _ca;
    var column2 = props.columnConfigurationData.filter(
      (x) => x.key == gridColumn
    );
    if (column2.length > 0) {
      switch (column2[0].inputType) {
        case EditControlType.Date:
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            DatePicker,
            {
              strings: DayPickerStrings,
              placeholder: "Select a date...",
              ariaLabel: "Select a date",
              className: controlClass2.inputClass,
              onSelectDate: (date) => onSelectDate(date, column2[0])
            }
          );
        case EditControlType.Picker:
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            PickerControl,
            {
              arialabel: column2[0].text,
              selectedItemsLimit: 1,
              pickerTags: ((_a2 = column2[0].pickerOptions) == null ? void 0 : _a2.pickerTags) ?? [],
              minCharLimitForSuggestions: 2,
              onTaglistChanged: (selectedItem) => onCellPickerTagListChanged(selectedItem, column2[0]),
              pickerDescriptionOptions: (_b2 = column2[0].pickerOptions) == null ? void 0 : _b2.pickerDescriptionOptions
            }
          ) });
        case EditControlType.CheckBox:
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              label: column2[0].text,
              onChange: (ev, isChecked) => {
                if (ev && isChecked)
                  onCheckBoxChange(ev, isChecked, column2[0]);
              }
            }
          );
        case EditControlType.DropDown:
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Dropdown,
            {
              label: column2[0].text,
              options: column2[0].filterDropdownOptions ? column2[0].filterDropdownOptions.filterOptions.filter(
                (x) => {
                  var _a3;
                  return x.correspondingKey == inputValue[((_a3 = column2[0].filterDropdownOptions) == null ? void 0 : _a3.filterBasedOnThisColumnKey) ?? ""].value;
                }
              ) : column2[0].dropdownValues ?? [],
              onChange: (ev, selected) => onDropDownChange(ev, selected, column2[0])
            }
          );
        case EditControlType.ComboBox:
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            VirtualizedComboBox,
            {
              label: column2[0].text,
              options: comboOptions,
              onClick: () => {
                if (!init) {
                  setInit(true);
                  setComboOptions(
                    [...column2[0].comboBoxOptions ?? []].concat([
                      { key: "beaddf9d-503a-4753-95d9-158f08d9d37e", text: "" }
                    ]) ?? []
                  );
                }
              },
              onInputValueChange: (text) => {
                var _a3, _b3;
                try {
                  const searchPattern = new RegExp(text == null ? void 0 : text.trim(), "i");
                  const searchResults = (_a3 = column2[0].comboBoxOptions) == null ? void 0 : _a3.filter(
                    (item) => {
                      var _a4, _b4, _c3, _d3, _e3, _f2, _g2;
                      if (((_b4 = (_a4 = column2[0]) == null ? void 0 : _a4.comboBoxProps) == null ? void 0 : _b4.searchType) == "startswith") {
                        return (_f2 = (_d3 = (_c3 = item == null ? void 0 : item.text) == null ? void 0 : _c3.trim()) == null ? void 0 : _d3.toLowerCase()) == null ? void 0 : _f2.startsWith((_e3 = text == null ? void 0 : text.trim()) == null ? void 0 : _e3.toLowerCase());
                      } else {
                        return searchPattern.test((_g2 = item.text) == null ? void 0 : _g2.trim());
                      }
                    }
                  );
                  setComboOptions(
                    (searchResults == null ? void 0 : searchResults.concat([
                      { key: "64830f62-5ab8-490a-a0ed-971f977a3603", text: "" }
                    ])) ?? []
                  );
                  onComboBoxChangeRaw(text, column2[0]);
                } catch (error) {
                  setComboOptions(
                    ((_b3 = [...column2[0].comboBoxOptions ?? []]) == null ? void 0 : _b3.concat([
                      { key: "64830f62-5ab8-490a-a0ed-971f977a3603", text: "" }
                    ])) ?? []
                  );
                }
              },
              onChange: (ev, option) => onComboBoxChange(ev, option, column2[0]),
              allowFreeInput: true,
              allowFreeform: ((_c2 = column2[0].comboBoxProps) == null ? void 0 : _c2.allowFreeformComboBoxEntry) ?? false ?? false,
              autoComplete: "on"
            },
            v4()
          );
        case EditControlType.MultilineTextField:
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              errorMessage: inputValue[column2[0].key].error,
              className: controlClass2.inputClass,
              multiline: true,
              rows: 1,
              placeholder: `Enter '${column2[0].text}'...`,
              id: column2[0].key,
              styles: textFieldStyles2,
              onChange: (ev, text) => onTextUpdate(ev, text, column2[0]),
              value: inputValue[column2[0].key].value || ""
            }
          );
        case EditControlType.NumericFormat:
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            NumericFormat,
            {
              value: inputValue[column2[0].key].value || "",
              placeholder: (_f = (_e2 = (_d2 = column2[0].validations) == null ? void 0 : _d2.numericFormatProps) == null ? void 0 : _e2.formatBase) == null ? void 0 : _f.placeholder,
              valueIsNumericString: (_i = (_h = (_g = column2[0].validations) == null ? void 0 : _g.numericFormatProps) == null ? void 0 : _h.formatBase) == null ? void 0 : _i.valueIsNumericString,
              type: (_l = (_k = (_j = column2[0].validations) == null ? void 0 : _j.numericFormatProps) == null ? void 0 : _k.formatBase) == null ? void 0 : _l.type,
              inputMode: (_o = (_n = (_m = column2[0].validations) == null ? void 0 : _m.numericFormatProps) == null ? void 0 : _n.formatBase) == null ? void 0 : _o.inputMode,
              renderText: (_r = (_q = (_p = column2[0].validations) == null ? void 0 : _p.numericFormatProps) == null ? void 0 : _q.formatBase) == null ? void 0 : _r.renderText,
              label: ((_t = (_s = column2[0].validations) == null ? void 0 : _s.numericFormatProps) == null ? void 0 : _t.label) ?? column2[0].text,
              decimalScale: (_w = (_v = (_u = column2[0].validations) == null ? void 0 : _u.numericFormatProps) == null ? void 0 : _v.formatProps) == null ? void 0 : _w.decimalScale,
              fixedDecimalScale: (_z = (_y = (_x = column2[0].validations) == null ? void 0 : _x.numericFormatProps) == null ? void 0 : _y.formatProps) == null ? void 0 : _z.fixedDecimalScale,
              decimalSeparator: (_C = (_B = (_A = column2[0].validations) == null ? void 0 : _A.numericFormatProps) == null ? void 0 : _B.formatProps) == null ? void 0 : _C.decimalSeparator,
              allowedDecimalSeparators: (_F = (_E = (_D = column2[0].validations) == null ? void 0 : _D.numericFormatProps) == null ? void 0 : _E.formatProps) == null ? void 0 : _F.allowedDecimalSeparators,
              thousandsGroupStyle: (_I = (_H = (_G = column2[0].validations) == null ? void 0 : _G.numericFormatProps) == null ? void 0 : _H.formatProps) == null ? void 0 : _I.thousandsGroupStyle,
              thousandSeparator: (_L = (_K = (_J = column2[0].validations) == null ? void 0 : _J.numericFormatProps) == null ? void 0 : _K.formatProps) == null ? void 0 : _L.thousandSeparator,
              onRenderLabel: (_N = (_M = column2[0].validations) == null ? void 0 : _M.numericFormatProps) == null ? void 0 : _N.onRenderLabel,
              ariaLabel: ((_P = (_O = column2[0].validations) == null ? void 0 : _O.numericFormatProps) == null ? void 0 : _P.ariaLabel) ?? column2[0].text,
              customInput: TextField,
              suffix: (_S = (_R = (_Q = column2[0].validations) == null ? void 0 : _Q.numericFormatProps) == null ? void 0 : _R.formatProps) == null ? void 0 : _S.suffix,
              prefix: (_V = (_U = (_T = column2[0].validations) == null ? void 0 : _T.numericFormatProps) == null ? void 0 : _U.formatProps) == null ? void 0 : _V.prefix,
              allowLeadingZeros: (_Y = (_X = (_W = column2[0].validations) == null ? void 0 : _W.numericFormatProps) == null ? void 0 : _X.formatProps) == null ? void 0 : _Y.allowLeadingZeros,
              allowNegative: (_$ = (__ = (_Z = column2[0].validations) == null ? void 0 : _Z.numericFormatProps) == null ? void 0 : __.formatProps) == null ? void 0 : _$.allowNegative,
              isAllowed: (_ca = (_ba = (_aa = column2[0].validations) == null ? void 0 : _aa.numericFormatProps) == null ? void 0 : _ba.formatBase) == null ? void 0 : _ca.isAllowed,
              onValueChange: (values2, sourceInfo) => onNumericFormatUpdate(
                sourceInfo.event,
                values2.formattedValue ?? values2.value,
                column2[0]
              )
            },
            column2[0].key
          );
        default:
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextField,
            {
              errorMessage: inputValue[column2[0].key].error,
              className: controlClass2.inputClass,
              placeholder: `Enter '${column2[0].text}'...`,
              onChange: (ev, text) => onTextUpdate(ev, text, column2[0]),
              styles: textFieldStyles2,
              id: column2[0].key,
              value: inputValue[column2[0].key].value || ""
            }
          );
      }
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Dialog,
    {
      hidden: !inputFieldContent,
      onDismiss: closeDialog,
      closeButtonAriaLabel: "Close",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { grow: true, verticalAlign: "space-between", tokens: stackTokens2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Stack.Item, { grow: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dropdown,
          {
            placeholder: "Select the Column",
            options: options2,
            styles: dropdownStyles2,
            onChange: onSelectGridColumn
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Stack.Item, { grow: 1, children: GetInputFieldContent() }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Stack.Item, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { className: controlClass2.inputClass, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            PrimaryButton,
            {
              onClick: saveDialog,
              text: "Save",
              disabled: gridColumn ? inputValue[gridColumn].error != null && inputValue[gridColumn].error.length > 0 : false
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultButton, { onClick: closeDialog, text: "Cancel" })
        ] }) })
      ] })
    }
  );
};
var _Operation = /* @__PURE__ */ ((_Operation2) => {
  _Operation2[_Operation2["None"] = 1] = "None";
  _Operation2[_Operation2["Add"] = 2] = "Add";
  _Operation2[_Operation2["Update"] = 3] = "Update";
  _Operation2[_Operation2["Delete"] = 4] = "Delete";
  return _Operation2;
})(_Operation || {});
initializeIcons(void 0, { disableWarnings: true });
const InternalEditableGridPropertiesKeys = [
  "_grid_row_id_",
  "_grid_row_operation_",
  "_is_filtered_in_",
  "_is_filtered_in_grid_search_",
  "_is_filtered_in_column_filter_",
  "_is_data_transformed"
];
const InitializeInternalGrid = (items, customOperationsKey) => {
  return items.map((obj, index2) => {
    if (Object.keys(obj).indexOf("_grid_row_id_") == -1 && Object.keys(obj).indexOf("_grid_row_operation_") == -1) {
      obj._grid_row_id_ = index2;
      obj._is_filtered_in_ = true;
      obj._is_filtered_in_grid_search_ = true;
      obj._is_filtered_in_column_filter_ = true;
      obj._is_data_transformed = false;
      if (customOperationsKey && items[index2][customOperationsKey.colKey] !== void 0) {
        switch (items[index2][customOperationsKey.colKey]) {
          case customOperationsKey.options.Add:
            obj._grid_row_operation_ = _Operation.Add;
            break;
          case customOperationsKey.options.Update:
            obj._grid_row_operation_ = _Operation.Update;
            break;
          case customOperationsKey.options.Delete:
            obj._grid_row_operation_ = _Operation.Delete;
            break;
          default:
            obj._grid_row_operation_ = _Operation.None;
            break;
        }
      } else {
        obj._grid_row_operation_ = _Operation.None;
      }
    }
    return obj;
  });
};
const ResetGridRowID = (items) => {
  return items.map((obj, index2) => {
    obj._grid_row_id_ = index2;
    return obj;
  });
};
const InitializeInternalGridEditStructure = (items) => {
  let activateCellEditTmp = [];
  items.forEach((item, index2) => {
    let activateCellEditRowTmp = { isActivated: false, properties: {} };
    var objectKeys = Object.keys(item);
    objectKeys.forEach((objKey) => {
      activateCellEditRowTmp.properties[objKey] = {
        activated: false,
        value: item[objKey],
        error: null
      };
    });
    activateCellEditTmp.push(activateCellEditRowTmp);
  });
  return activateCellEditTmp;
};
const ShallowCopyDefaultGridToEditGrid = (defaultGrid, editGrid) => {
  for (let index2 = 0; index2 < defaultGrid.length; index2++) {
    const item = defaultGrid[index2];
    const objectKeys = Object.keys(item);
    for (let j = 0; j < objectKeys.length; j++) {
      const objKey = objectKeys[j];
      editGrid[index2].properties[objKey]["value"] = item[objKey];
    }
  }
  return editGrid;
};
const ShallowCopyEditGridToDefaultGrid = (defaultGrid, editGrid, customOperationsKey) => {
  editGrid.forEach((item) => {
    var index2 = defaultGrid.findIndex(
      (row) => row._grid_row_id_ == item.properties._grid_row_id_.value
    );
    if (index2 >= 0) {
      var objectKeys = Object.keys(item.properties);
      objectKeys.forEach((objKey) => {
        var _a2;
        if (defaultGrid[index2][objKey] != item.properties[objKey].value) {
          defaultGrid[index2][objKey] = item.properties[objKey].value;
          if (defaultGrid[index2]["_grid_row_operation_"] != _Operation.Add && defaultGrid[index2]["_grid_row_operation_"] != _Operation.Update) {
            defaultGrid[index2]["_grid_row_operation_"] = _Operation.Update;
            if (customOperationsKey && defaultGrid[index2][customOperationsKey.colKey] !== void 0)
              defaultGrid[index2][customOperationsKey.colKey] = ((_a2 = customOperationsKey.options) == null ? void 0 : _a2.Update) ?? _Operation.Update;
          }
        }
      });
    }
  });
  return defaultGrid;
};
const EditPanel = (props) => {
  const updateObj = {};
  const [columnValuesObj, setColumnValuesObj] = React.useState(null);
  React.useEffect(() => {
    let tmpColumnValuesObj = {};
    props.columnConfigurationData.filter((x) => x.editable == true).forEach((item, index2) => {
      tmpColumnValuesObj[item.key] = {
        value: GetDefault(item.dataType),
        isChanged: false,
        error: null
      };
    });
    setColumnValuesObj(tmpColumnValuesObj);
  }, [props.columnConfigurationData]);
  const SetObjValues = (key, value, isChanged = true, errorMessage = null) => {
    setColumnValuesObj({
      ...columnValuesObj,
      [key]: { value, isChanged, error: errorMessage }
    });
  };
  const onDropDownChange = (event, selectedDropdownItem, item) => {
    SetObjValues(item.key, selectedDropdownItem == null ? void 0 : selectedDropdownItem.key);
  };
  const onComboBoxChange = (event, selectedOption, item) => {
    SetObjValues(item.key, selectedOption == null ? void 0 : selectedOption.text);
  };
  const onComboBoxChangeRaw = (text, item) => {
    SetObjValues(item.key, text);
  };
  const onNumericFormatUpdate = (ev, text, item) => {
    SetObjValues(item.key, text);
  };
  const onCheckBoxChange = (ev, isChecked, item) => {
    SetObjValues(item.key, isChecked ? item == null ? void 0 : item.text : "");
  };
  const onTextUpdate = (ev, text, column2) => {
    if (!IsValidDataType(column2.dataType, text)) {
      SetObjValues(
        ev.target.id,
        text,
        false,
        `Data should be of type '${column2.dataType}'`
      );
      return;
    }
    SetObjValues(ev.target.id, ParseType(column2.dataType, text));
  };
  const onPanelSubmit = () => {
    var objectKeys = Object.keys(columnValuesObj);
    objectKeys.forEach((objKey) => {
      if (columnValuesObj[objKey]["isChanged"]) {
        updateObj[objKey] = columnValuesObj[objKey]["value"];
      }
    });
    props.onChange(updateObj);
  };
  const onCellDateChange = (date, item) => {
    SetObjValues(item.key, date);
  };
  const onCellPickerTagListChanged = (cellPickerTagList, item) => {
    if (cellPickerTagList && cellPickerTagList[0] && cellPickerTagList[0].name)
      SetObjValues(item.key, cellPickerTagList[0].name);
    else
      SetObjValues(item.key, "");
  };
  const [comboOptions, setComboOptions] = React.useState([]);
  const [init, setInit] = React.useState(false);
  const createTextFields = () => {
    let tmpRenderObj = [];
    props.columnConfigurationData.filter((x) => x.editable == true).forEach((item) => {
      var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __, _$, _aa, _ba, _ca, _da;
      switch (item.inputType) {
        case EditControlType.Date:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DatePicker,
              {
                label: item.text,
                strings: DayPickerStrings,
                placeholder: "Select a date...",
                ariaLabel: "Select a date",
                onSelectDate: (date) => onCellDateChange(date, item),
                value: /* @__PURE__ */ new Date()
              },
              item.key
            )
          );
          break;
        case EditControlType.Picker:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: controlClass$1.pickerLabel, children: item.text }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PickerControl,
                {
                  arialabel: item.text,
                  selectedItemsLimit: 1,
                  pickerTags: ((_a2 = item.pickerOptions) == null ? void 0 : _a2.pickerTags) ?? [],
                  minCharLimitForSuggestions: 2,
                  onTaglistChanged: (selectedItem) => onCellPickerTagListChanged(selectedItem, item),
                  pickerDescriptionOptions: (_b2 = item.pickerOptions) == null ? void 0 : _b2.pickerDescriptionOptions
                }
              )
            ] }, item.key)
          );
          break;
        case EditControlType.DropDown:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Dropdown,
              {
                label: item.text,
                options: item.filterDropdownOptions ? item.filterDropdownOptions.filterOptions.filter(
                  (x) => {
                    var _a3;
                    return x.correspondingKey == columnValuesObj[((_a3 = item.filterDropdownOptions) == null ? void 0 : _a3.filterBasedOnThisColumnKey) ?? ""].value;
                  }
                ) : item.dropdownValues ?? [],
                onChange: (ev, selected) => onDropDownChange(ev, selected, item)
              },
              item.key
            )
          );
          break;
        case EditControlType.ComboBox:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              VirtualizedComboBox,
              {
                label: item.text,
                options: comboOptions,
                onClick: () => {
                  if (!init) {
                    setInit(true);
                    setComboOptions(
                      [...item.comboBoxOptions ?? []].concat([
                        {
                          key: "beaddf9d-503a-4753-95d9-158f08d9d37e",
                          text: ""
                        }
                      ]) ?? []
                    );
                  }
                },
                onInputValueChange: (text) => {
                  var _a3, _b3;
                  try {
                    const searchPattern = new RegExp(text == null ? void 0 : text.trim(), "i");
                    const searchResults = (_a3 = item.comboBoxOptions) == null ? void 0 : _a3.filter(
                      (itemInList) => {
                        var _a4, _b4, _c3, _d3, _e3, _f2;
                        if (((_a4 = item == null ? void 0 : item.comboBoxProps) == null ? void 0 : _a4.searchType) == "startswith") {
                          return (_e3 = (_c3 = (_b4 = itemInList == null ? void 0 : itemInList.text) == null ? void 0 : _b4.trim()) == null ? void 0 : _c3.toLowerCase()) == null ? void 0 : _e3.startsWith((_d3 = text == null ? void 0 : text.trim()) == null ? void 0 : _d3.toLowerCase());
                        } else {
                          return searchPattern.test((_f2 = itemInList.text) == null ? void 0 : _f2.trim());
                        }
                      }
                    );
                    setComboOptions(
                      (searchResults == null ? void 0 : searchResults.concat([
                        {
                          key: "64830f62-5ab8-490a-a0ed-971f977a3603",
                          text: ""
                        }
                      ])) ?? []
                    );
                    onComboBoxChangeRaw(text, item);
                  } catch (error) {
                    setComboOptions(
                      ((_b3 = [...item.comboBoxOptions ?? []]) == null ? void 0 : _b3.concat([
                        {
                          key: "64830f62-5ab8-490a-a0ed-971f977a3603",
                          text: ""
                        }
                      ])) ?? []
                    );
                  }
                },
                onChange: (ev, option) => onComboBoxChange(ev, option, item),
                allowFreeInput: true,
                allowFreeform: ((_c2 = item.comboBoxProps) == null ? void 0 : _c2.allowFreeformComboBoxEntry) ?? false,
                autoComplete: "on"
              },
              item.key
            )
          );
          break;
        case EditControlType.CheckBox:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox,
              {
                label: item.text,
                onChange: (ev, isChecked) => {
                  if (ev && isChecked)
                    onCheckBoxChange(ev, isChecked, item);
                }
              },
              item.key
            )
          );
          break;
        case EditControlType.NumericFormat:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              NumericFormat,
              {
                value: ((_d2 = columnValuesObj[item.key].value) == null ? void 0 : _d2.toString()) || "",
                placeholder: (_g = (_f = (_e2 = item.validations) == null ? void 0 : _e2.numericFormatProps) == null ? void 0 : _f.formatBase) == null ? void 0 : _g.placeholder,
                valueIsNumericString: (_j = (_i = (_h = item.validations) == null ? void 0 : _h.numericFormatProps) == null ? void 0 : _i.formatBase) == null ? void 0 : _j.valueIsNumericString,
                type: (_m = (_l = (_k = item.validations) == null ? void 0 : _k.numericFormatProps) == null ? void 0 : _l.formatBase) == null ? void 0 : _m.type,
                inputMode: (_p = (_o = (_n = item.validations) == null ? void 0 : _n.numericFormatProps) == null ? void 0 : _o.formatBase) == null ? void 0 : _p.inputMode,
                renderText: (_s = (_r = (_q = item.validations) == null ? void 0 : _q.numericFormatProps) == null ? void 0 : _r.formatBase) == null ? void 0 : _s.renderText,
                label: ((_u = (_t = item.validations) == null ? void 0 : _t.numericFormatProps) == null ? void 0 : _u.label) ?? item.text,
                decimalScale: (_x = (_w = (_v = item.validations) == null ? void 0 : _v.numericFormatProps) == null ? void 0 : _w.formatProps) == null ? void 0 : _x.decimalScale,
                fixedDecimalScale: (_A = (_z = (_y = item.validations) == null ? void 0 : _y.numericFormatProps) == null ? void 0 : _z.formatProps) == null ? void 0 : _A.fixedDecimalScale,
                decimalSeparator: (_D = (_C = (_B = item.validations) == null ? void 0 : _B.numericFormatProps) == null ? void 0 : _C.formatProps) == null ? void 0 : _D.decimalSeparator,
                allowedDecimalSeparators: (_G = (_F = (_E = item.validations) == null ? void 0 : _E.numericFormatProps) == null ? void 0 : _F.formatProps) == null ? void 0 : _G.allowedDecimalSeparators,
                thousandsGroupStyle: (_J = (_I = (_H = item.validations) == null ? void 0 : _H.numericFormatProps) == null ? void 0 : _I.formatProps) == null ? void 0 : _J.thousandsGroupStyle,
                thousandSeparator: (_M = (_L = (_K = item.validations) == null ? void 0 : _K.numericFormatProps) == null ? void 0 : _L.formatProps) == null ? void 0 : _M.thousandSeparator,
                onRenderLabel: (_O = (_N = item.validations) == null ? void 0 : _N.numericFormatProps) == null ? void 0 : _O.onRenderLabel,
                ariaLabel: ((_Q = (_P = item.validations) == null ? void 0 : _P.numericFormatProps) == null ? void 0 : _Q.ariaLabel) ?? item.text,
                customInput: TextField,
                suffix: (_T = (_S = (_R = item.validations) == null ? void 0 : _R.numericFormatProps) == null ? void 0 : _S.formatProps) == null ? void 0 : _T.suffix,
                prefix: (_W = (_V = (_U = item.validations) == null ? void 0 : _U.numericFormatProps) == null ? void 0 : _V.formatProps) == null ? void 0 : _W.prefix,
                allowLeadingZeros: (_Z = (_Y = (_X = item.validations) == null ? void 0 : _X.numericFormatProps) == null ? void 0 : _Y.formatProps) == null ? void 0 : _Z.allowLeadingZeros,
                allowNegative: (_aa = (_$ = (__ = item.validations) == null ? void 0 : __.numericFormatProps) == null ? void 0 : _$.formatProps) == null ? void 0 : _aa.allowNegative,
                isAllowed: (_da = (_ca = (_ba = item.validations) == null ? void 0 : _ba.numericFormatProps) == null ? void 0 : _ca.formatBase) == null ? void 0 : _da.isAllowed,
                onValueChange: (values2, sourceInfo) => onNumericFormatUpdate(
                  sourceInfo.event,
                  values2.formattedValue ?? values2.value,
                  item
                )
              },
              item.key
            )
          );
          break;
        case EditControlType.MultilineTextField:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                errorMessage: columnValuesObj[item.key].error,
                name: item.text,
                multiline: true,
                rows: 1,
                id: item.key,
                label: item.text,
                styles: textFieldStyles$1,
                onChange: (ev, text) => onTextUpdate(ev, text, item),
                value: columnValuesObj[item.key].value || ""
              },
              item.key
            )
          );
          break;
        default:
          tmpRenderObj.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField,
              {
                errorMessage: columnValuesObj[item.key].error,
                name: item.text,
                id: item.key,
                label: item.text,
                styles: textFieldStyles$1,
                onChange: (ev, text) => onTextUpdate(ev, text, item),
                value: columnValuesObj[item.key].value || ""
              },
              item.key
            )
          );
          break;
      }
    });
    return tmpRenderObj;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { tokens: verticalGapStackTokens, children: columnValuesObj && createTextFields() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Stack,
      {
        horizontal: true,
        disableShrink: true,
        styles: stackStyles,
        tokens: horizontalGapStackTokens,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PrimaryButton,
          {
            text: "Save To Grid",
            className: controlClass$1.submitStylesEditpanel,
            onClick: onPanelSubmit,
            allowDisabledFocus: true,
            disabled: columnValuesObj && Object.keys(columnValuesObj).some(
              (k) => columnValuesObj[k] && columnValuesObj[k].error && columnValuesObj[k].error.length > 0
            ) || false
          }
        )
      }
    )
  ] });
};
var FileSaver_min = { exports: {} };
(function(module2, exports2) {
  (function(a, b) {
    b();
  })(commonjsGlobal, function() {
    function b(a2, b2) {
      return "undefined" == typeof b2 ? b2 = { autoBom: false } : "object" != typeof b2 && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
    }
    function c(a2, b2, c2) {
      var d2 = new XMLHttpRequest();
      d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
        g(d2.response, b2, c2);
      }, d2.onerror = function() {
        console.error("could not download file");
      }, d2.send();
    }
    function d(a2) {
      var b2 = new XMLHttpRequest();
      b2.open("HEAD", a2, false);
      try {
        b2.send();
      } catch (a3) {
      }
      return 200 <= b2.status && 299 >= b2.status;
    }
    function e(a2) {
      try {
        a2.dispatchEvent(new MouseEvent("click"));
      } catch (c2) {
        var b2 = document.createEvent("MouseEvents");
        b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
      }
    }
    var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof commonjsGlobal && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h) {
      var i = f.URL || f.webkitURL, j = document.createElement("a");
      g2 = g2 || b2.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b2 ? (j.href = b2, j.origin === location.origin ? e(j) : d(j.href) ? c(b2, g2, h) : e(j, j.target = "_blank")) : (j.href = i.createObjectURL(b2), setTimeout(function() {
        i.revokeObjectURL(j.href);
      }, 4e4), setTimeout(function() {
        e(j);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
      if (g2 = g2 || f2.name || "download", "string" != typeof f2)
        navigator.msSaveOrOpenBlob(b(f2, h), g2);
      else if (d(f2))
        c(f2, g2, h);
      else {
        var i = document.createElement("a");
        i.href = f2, i.target = "_blank", setTimeout(function() {
          e(i);
        });
      }
    } : function(b2, d2, e2, g2) {
      if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b2)
        return c(b2, d2, e2);
      var h = "application/octet-stream" === b2.type, i = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((j || h && i || a) && "undefined" != typeof FileReader) {
        var k = new FileReader();
        k.onloadend = function() {
          var a2 = k.result;
          a2 = j ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
        }, k.readAsDataURL(b2);
      } else {
        var l = f.URL || f.webkitURL, m = l.createObjectURL(b2);
        g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
          l.revokeObjectURL(m);
        }, 4e4);
      }
    });
    f.saveAs = g.saveAs = g, module2.exports = g;
  });
})(FileSaver_min);
var FileSaver_minExports = FileSaver_min.exports;
const ExportToExcelUtil = (exportData, fileName) => {
  let fileType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8";
  const ws = utils.json_to_sheet(exportData);
  const wb = { Sheets: { GridData: ws }, SheetNames: ["GridData"] };
  const excelBuffer = writeSync(wb, { bookType: "xlsx", type: "array" });
  const data = new Blob([excelBuffer], { type: fileType });
  FileSaver_minExports.saveAs(data, fileName);
};
const ExportToCSVUtil = (exportData, fileName) => {
  if (!exportData || !exportData.length) {
    return;
  }
  const separator = ",";
  const keys2 = Object.keys(exportData[0]);
  const csvContent = keys2.join(separator) + "\n" + exportData.map((row) => {
    return keys2.map((k) => {
      let cell = row[k] === null || row[k] === void 0 ? "" : row[k];
      cell = cell instanceof Date ? cell.toLocaleString() : cell.toString().replace(/"/g, '""');
      if (cell.search(/("|,|\n)/g) >= 0) {
        cell = `"${cell}"`;
      }
      return cell;
    }).join(separator);
  }).join("\n");
  const blob2 = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  if (navigator.msSaveBlob) {
    navigator.msSaveBlob(blob2, fileName);
  } else {
    const link = document.createElement("a");
    if (link.download !== void 0) {
      const url = URL.createObjectURL(blob2);
      link.setAttribute("href", url);
      link.setAttribute("download", fileName);
      link.style.visibility = "hidden";
      link.dataset.interception = "off";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }
};
const MessageDialog = (props) => {
  const [messageDialogContent, setMessageDialogContent] = React.useState(void 0);
  const closeDialog = React.useCallback(() => {
    if (props.onDialogClose) {
      props.onDialogClose();
    }
    setMessageDialogContent(void 0);
  }, []);
  const controlClass2 = mergeStyleSets({
    dialogSubMessageStyles: {
      margin: 10
    },
    dialogHeaderStyles: {
      margin: 10
    }
  });
  React.useEffect(() => {
    setMessageDialogContent(
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: controlClass2.dialogHeaderStyles, children: props && props.message ? props.message : "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: controlClass2.dialogSubMessageStyles, children: props && props.subMessage ? props.subMessage : "" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultButton, { onClick: () => closeDialog(), text: "Close" }) })
      ] })
    );
  }, [props]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Dialog,
    {
      hidden: !messageDialogContent,
      onDismiss: closeDialog,
      closeButtonAriaLabel: "Close",
      children: messageDialogContent
    }
  );
};
const EventType = {
  onSearch: "onSearch",
  onClick: "onClick"
};
const EventEmitter = {
  events: {},
  subscribe: function(event, callback) {
    if (!this.events[event])
      this.events[event] = [];
    if (this.events[event].some((c) => c === callback)) {
      console.warn(event + " Already subscribed by ");
      return;
    }
    this.events[event].push(callback);
  },
  unsubscribe: function(event, callback) {
    this.events[event] = this.events[event].filter((c) => c !== callback);
  },
  dispatch: function(event, data) {
    if (!this.events[event])
      return;
    this.events[event].forEach((callback) => callback(data));
  }
};
var EditType = /* @__PURE__ */ ((EditType2) => {
  EditType2[EditType2["None"] = 0] = "None";
  EditType2[EditType2["ColumnEdit"] = 1] = "ColumnEdit";
  EditType2[EditType2["BulkEdit"] = 2] = "BulkEdit";
  EditType2[EditType2["RowEdit"] = 3] = "RowEdit";
  EditType2[EditType2["DeleteRow"] = 4] = "DeleteRow";
  EditType2[EditType2["AddRow"] = 5] = "AddRow";
  EditType2[EditType2["ColumnFilter"] = 6] = "ColumnFilter";
  EditType2[EditType2["AddRowWithData"] = 7] = "AddRowWithData";
  return EditType2;
})(EditType || {});
var ExportType = /* @__PURE__ */ ((ExportType2) => {
  ExportType2[ExportType2["XLSX"] = 0] = "XLSX";
  ExportType2[ExportType2["CSV"] = 1] = "CSV";
  return ExportType2;
})(ExportType || {});
var ImportType = /* @__PURE__ */ ((ImportType2) => {
  ImportType2[ImportType2["XLSX"] = 0] = "XLSX";
  return ImportType2;
})(ImportType || {});
const internalDialogContentStyles = {
  title: { fontSize: 20, color: "#201F1E", fontWeight: FontWeights.regular }
};
const EditableGrid = (props) => {
  var _a2, _b2, _c2;
  const [editMode, setEditMode] = React.useState(false);
  const [gridInError, setGridInError] = React.useState(false);
  const [importingStarted, setImportingStarted] = React.useState(false);
  const CommandBarTitles = props == null ? void 0 : props.renameCommandBarItemsActions;
  const [isOpenForEdit, setIsOpenForEdit] = React.useState(false);
  const dismissPanelForEdit = React.useCallback(() => setIsOpenForEdit(false), []);
  const [isOpenForAdd, setIsOpenForAdd] = React.useState(false);
  const dismissPanelForAdd = React.useCallback(() => setIsOpenForAdd(false), []);
  const [gridData, setGridData] = React.useState([]);
  const [defaultGridData, setDefaultGridData] = React.useState([]);
  const [backupDefaultGridData, setBackupDefaultGridData] = React.useState([]);
  const [editChangeCompareData, setEditChangeCompareData] = React.useState([]);
  const [activateCellEdit, setActivateCellEdit] = React.useState([]);
  const [selectionDetails, setSelectionDetails] = React.useState("");
  const [selectedItems, setSelectedItems] = React.useState();
  const [cancellableRows, setCancellableRows] = React.useState([]);
  const [selectedIndices, setSelectedIndices] = React.useState([]);
  const [isGridInEdit, setIsGridInEdit] = React.useState(false);
  const [dialogContent, setDialogContent] = React.useState(
    void 0
  );
  const [announced, setAnnounced] = React.useState(
    void 0
  );
  const [isUpdateColumnClicked, setIsUpdateColumnClicked] = React.useState(false);
  const [isColumnFilterClicked, setIsColumnFilterClicked] = React.useState(false);
  const [showSpinner, setShowSpinner] = React.useState(false);
  const [isGridStateEdited, setIsGridStateEdited] = React.useState(false);
  const [defaultTag, setDefaultTag] = React.useState([]);
  const [filteredColumns, setFilteredColumns] = React.useState([]);
  const gridColumnFilterArrRef = React.useRef([]);
  const [filterCalloutComponent, setFilterCalloutComponent] = React__namespace.useState(void 0);
  const [showFilterCallout, setShowFilterCallout] = React.useState(false);
  const [messageDialogProps, setMessageDialogProps] = React.useState({
    visible: false,
    message: "",
    subMessage: ""
  });
  const [sortColObj, setSortColObj] = React__namespace.useState({
    key: "",
    isAscending: false,
    isEnabled: false
  });
  let SpinRef = React__namespace.createRef();
  let filterStoreRef = React__namespace.useRef([]);
  const indentiferColumn = React.useRef(null);
  const [_selection, _setSelection] = React__namespace.useState(
    new Selection({
      onSelectionChanged: () => setSelectionDetails(_getSelectionDetails())
    })
  );
  const [cursorFlashing, setCursorFlashing] = React.useState(false);
  const columnToResize = React__namespace.useRef(null);
  const textfieldResizeRef = React__namespace.useRef(null);
  const inputResizeRef = React__namespace.useRef(null);
  const confirmResizeDialog = () => {
    const detailsList = props.componentRef.current;
    if (textfieldResizeRef.current) {
      inputResizeRef.current = Number(textfieldResizeRef.current.value);
    }
    if (columnToResize.current && inputResizeRef.current && detailsList) {
      const width = inputResizeRef.current;
      detailsList.updateColumn(columnToResize.current, { width });
    }
    inputResizeRef.current = null;
    setDialogContent(void 0);
  };
  const resizeColumn = (column2) => {
    if (column2)
      columnToResize.current = column2;
    setDialogContent(
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "Resize Column", className: "internal", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          NumericFormat,
          {
            componentRef: textfieldResizeRef,
            ariaLabel: "Enter desired column width pixels:",
            onRenderLabel: (props2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              Text,
              {
                style: {
                  color: "#555555",
                  fontWeight: FontWeights.regular,
                  fontFamily: "Segoe UI"
                },
                children: props2 == null ? void 0 : props2.ariaLabel
              }
            ),
            customInput: TextField,
            allowLeadingZeros: false,
            allowNegative: false,
            onKeyDown: (event) => {
              if (event.key == "Enter") {
                confirmResizeDialog();
              }
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(PrimaryButton, { onClick: confirmResizeDialog, text: "Resize" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DefaultButton,
            {
              onClick: () => setDialogContent(void 0),
              text: "Cancel"
            }
          )
        ] })
      ] })
    );
  };
  const [contextualMenuProps, setContextualMenuProps] = React__namespace.useState(void 0);
  const onHideContextualMenu = React__namespace.useCallback(
    () => setContextualMenuProps(void 0),
    []
  );
  const sortColumns = (column2) => {
    var newColumns = GridColumns.slice();
    const currColumn = newColumns.filter(
      (currCol) => column2.key === currCol.key
    )[0];
    newColumns.forEach((newCol) => {
      if (newCol === currColumn) {
        currColumn.isSortedDescending = !currColumn.isSortedDescending;
        currColumn.isSorted = true;
      } else {
        newCol.isSorted = false;
        newCol.isSortedDescending = true;
      }
    });
    const newItems = _copyAndSort(
      defaultGridData,
      currColumn.fieldName,
      currColumn.isSortedDescending
    );
    SetGridItems(newItems);
    setSortColObj({
      key: column2.key,
      isAscending: !currColumn.isSortedDescending,
      isEnabled: true
    });
  };
  const getContextualMenuProps = (ev, column2) => {
    const items = [
      { key: "resize", text: "Resize", onClick: () => resizeColumn(column2) },
      { key: "sort", text: "Sort", onClick: () => sortColumns(column2) }
    ];
    return {
      items,
      target: ev == null ? void 0 : ev.currentTarget,
      gapSpace: 10,
      isBeakVisible: true,
      onDismiss: onHideContextualMenu
    };
  };
  const columnKeyPasteRef = React.useRef(null);
  const handleFocus = (columnKey, editControlType, _grid_row_id_) => {
    setCursorFlashing(true);
    columnKeyPasteRef.current = {
      key: columnKey,
      inputType: editControlType,
      _grid_row_id_
    };
  };
  const handleBlur = () => {
    setCursorFlashing(false);
    columnKeyPasteRef.current = null;
  };
  const clearSelectedItems = () => {
    _selection.setAllSelected(false);
    columnKeyPasteRef.current = null;
    setCursorFlashing(false);
  };
  const resetFilters = () => {
    ClearFilters();
  };
  const onSearchHandler = (event) => {
    if (event && event.target) {
      let queryText = event.target.value;
      if (queryText) {
        let searchableColumns = props.columns.filter((x) => x.includeColumnInSearch == true).map((x) => x.key);
        let searchResult = [...defaultGridData];
        searchResult.filter((_gridData, index2) => {
          var BreakException = {};
          try {
            searchableColumns.forEach((item2, index22) => {
              var _a3, _b3, _c3, _d2;
              if (_gridData[item2] && ((_b3 = (_a3 = _gridData[item2]) == null ? void 0 : _a3.toString()) == null ? void 0 : _b3.toLowerCase()) && ((_d2 = (_c3 = _gridData[item2]) == null ? void 0 : _c3.toString()) == null ? void 0 : _d2.toLowerCase().includes(queryText.trim().toLowerCase()))) {
                _gridData._is_filtered_in_grid_search_ = true;
                throw BreakException;
              } else {
                _gridData._is_filtered_in_grid_search_ = false;
              }
            });
          } catch (e) {
          }
        });
        setDefaultGridData(searchResult);
        onGridFiltered();
      } else {
        var gridDataTmp = [...defaultGridData];
        gridDataTmp.map((item) => item._is_filtered_in_grid_search_ = true);
        setDefaultGridData(gridDataTmp);
        onGridFiltered();
      }
    } else {
      var gridDataTmp = [...defaultGridData];
      gridDataTmp.map((item) => item._is_filtered_in_grid_search_ = true);
      setDefaultGridData(gridDataTmp);
      onGridFiltered();
    }
  };
  React__namespace.useEffect(() => {
    EventEmitter.subscribe(EventType.onSearch, onSearchHandler);
    return function cleanup() {
      EventEmitter.unsubscribe(EventType.onSearch, onSearchHandler);
    };
  });
  React.useEffect(() => {
    var data = InitializeInternalGrid(
      JSON.parse(JSON.stringify(props.items)),
      props.customOperationsKey
    );
    setGridData(data);
    setBackupDefaultGridData(data.map((obj) => ({ ...obj })));
    setGridEditState(false);
    if (indentiferColumn.current && data && data.length <= 50) {
      const newItems = _copyAndSort(data, indentiferColumn.current, false);
      SetGridItems(newItems);
    } else {
      SetGridItems(data);
    }
  }, [props.items]);
  React.useEffect(() => {
    var _a3, _b3;
    indentiferColumn.current = ((_b3 = (_a3 = props.columns.filter((x) => x.autoGenerate == true)) == null ? void 0 : _a3[0]) == null ? void 0 : _b3.key) ?? null;
  }, [props.columns]);
  React.useEffect(() => {
  }, [backupDefaultGridData]);
  const triggeredOnGridUpdateOnMount = React.useRef(false);
  React.useEffect(() => {
    const CheckOnUpdate = async () => {
      let ran = false;
      if (defaultGridData.filter((x) => x._grid_row_operation_ != _Operation.None).length > 0) {
        ran = true;
        await onGridUpdate();
      }
      if (!ran && props.triggerOnGridUpdateOnMount && defaultGridData.length > 0 && triggeredOnGridUpdateOnMount.current == false) {
        triggeredOnGridUpdateOnMount.current = true;
        await onGridUpdate();
      }
    };
    CheckOnUpdate();
  }, [defaultGridData]);
  React.useEffect(() => {
    UpdateGridEditStatus();
    if (props.enableDefaultEditMode) {
      setDefaultGridData(
        ShallowCopyEditGridToDefaultGrid(
          defaultGridData,
          activateCellEdit,
          props.customOperationsKey
        )
      );
    }
  }, [activateCellEdit]);
  React.useEffect(() => {
  }, [isGridInEdit]);
  React.useEffect(() => {
    SetFilteredGridData(getFilterStoreRef());
  }, [filteredColumns]);
  React.useEffect(() => {
    if (filterCalloutComponent) {
      setShowFilterCallout(true);
    }
  }, [filterCalloutComponent]);
  const forceKeyMapping = (data, mapOn = "key", looseMapping = true) => {
    const mapping = data.map((x) => {
      if (trackTransformedData.current) {
        trackTransformedData.current.forEach(function(value, key) {
          var _a3, _b3, _c3, _d2, _e2, _f;
          for (let index2 = 0; index2 < value.values.length; index2++) {
            const element = value.values[index2];
            const compareWith = mapOn == "key" ? (_b3 = (_a3 = element == null ? void 0 : element.key) == null ? void 0 : _a3.toString()) == null ? void 0 : _b3.toLowerCase() : (_d2 = (_c3 = element == null ? void 0 : element.text) == null ? void 0 : _c3.toString()) == null ? void 0 : _d2.toLowerCase();
            if (compareWith === (((_f = (_e2 = x[key]) == null ? void 0 : _e2.toString()) == null ? void 0 : _f.toLowerCase()) ?? "")) {
              x[key] = looseMapping ? element == null ? void 0 : element.text : element == null ? void 0 : element.key;
            }
          }
        });
      }
      return x;
    });
    return mapping;
  };
  const forceKeyMappingOptimized = (key, valueToCompare, mapOn = "key", looseMapping = true) => {
    var _a3, _b3, _c3, _d2, _e2, _f;
    if (trackTransformedData.current) {
      const quickGrab = (_a3 = trackTransformedData.current) == null ? void 0 : _a3.get(key);
      if (quickGrab) {
        for (let index2 = 0; index2 < quickGrab.values.length; index2++) {
          const element = quickGrab.values[index2];
          const compareWith = mapOn == "key" ? (_c3 = (_b3 = element == null ? void 0 : element.key) == null ? void 0 : _b3.toString()) == null ? void 0 : _c3.toLowerCase() : (_e2 = (_d2 = element == null ? void 0 : element.text) == null ? void 0 : _d2.toString()) == null ? void 0 : _e2.toLowerCase();
          if (compareWith === (((_f = valueToCompare == null ? void 0 : valueToCompare.toString()) == null ? void 0 : _f.toLowerCase()) ?? "")) {
            valueToCompare = looseMapping ? element == null ? void 0 : element.text : element == null ? void 0 : element.key;
          }
        }
      }
    }
    return valueToCompare;
  };
  const onGridFiltered = () => {
    if (props.onGridFiltered) {
      if ((defaultGridData == null ? void 0 : defaultGridData.length) == 0) {
        props.onGridFiltered(null);
      } else {
        props.onGridFiltered(
          forceKeyMapping(defaultGridData, "text", false).filter((x) => {
            return x._grid_row_operation_ != _Operation.Delete && x._is_filtered_in_ == true && x._is_filtered_in_grid_search_ == true && x._is_filtered_in_column_filter_ == true;
          })
        );
        if (props.triggerOnGridUpdateCallbackWhenOnGridFilteredIsCalled) {
          if (props.onGridUpdate) {
            onGridUpdate();
          }
        }
      }
    }
    clearSelectedItems();
  };
  const Messages = React.useRef(
    /* @__PURE__ */ new Map()
  );
  const [GlobalMessagesState, SetGlobalMessagesState] = React.useState(/* @__PURE__ */ new Map());
  const GlobalMessages = React.useRef(/* @__PURE__ */ new Map());
  const insertToMessageMap = (mapVar, key, value) => {
    mapVar.set(key, value);
    const newMap = new Map(mapVar);
    setMessagesState(newMap);
    if (props.enableMessageBarErrors && props.enableMessageBarErrors.enableSendGroupedErrorsToCallback && !GlobalMessages.current.has(props.id.toString())) {
      var message = `${props.gridLocation} has errors`;
      GlobalMessages.current.set(
        props.id.toString(),
        props.customGroupedMsgError ?? message
      );
      SetGlobalMessagesState(GlobalMessages.current);
    }
  };
  const removeFromMessageMap = (mapVar, key) => {
    mapVar.delete(key);
    const newMap = new Map(mapVar);
    setMessagesState(newMap);
  };
  React.useRef(/* @__PURE__ */ new Map());
  React.useEffect(() => {
    if (props.onGridInErrorCallback && gridInError)
      props.onGridInErrorCallback(gridInError, GlobalMessagesState);
  }, [gridInError, GlobalMessagesState]);
  function isRowBlank(obj) {
    if (!obj || obj.length < 0)
      return;
    const ignoredProperties = [...InternalEditableGridPropertiesKeys];
    if (indentiferColumn.current !== null) {
      ignoredProperties.push(indentiferColumn.current);
    }
    if (props.customOperationsKey) {
      ignoredProperties.push(props.customOperationsKey.colKey);
    }
    if (props.customKeysToAddOnNewRow) {
      for (let index2 = 0; index2 < props.customKeysToAddOnNewRow.length; index2++) {
        const element = props.customKeysToAddOnNewRow[index2];
        if ((element.ignoreKeyWhenDeterminingBlankRows ?? true) == true)
          ignoredProperties.push(element.key);
      }
    }
    const properties = Object.keys(obj).filter((key) => !ignoredProperties.includes(key)).sort();
    for (const key of properties) {
      if (obj[key] !== null && obj[key] !== void 0 && obj[key] !== "" && obj[key] !== " " && obj[key] !== false) {
        return false;
      }
    }
    return true;
  }
  React.useEffect(() => {
    if (props.GridSaveAction && defaultGridData !== void 0) {
      props.GridSaveAction(() => onGridSave);
    }
  }, [defaultGridData]);
  const onGridSave = () => {
    GlobalMessages.current = /* @__PURE__ */ new Map();
    SetGlobalMessagesState(GlobalMessages.current);
    Messages.current = /* @__PURE__ */ new Map();
    setMessagesState(Messages.current);
    setGridInError(false);
    setInteralMessagesState(/* @__PURE__ */ new Map());
    setEditMode(false);
    setGridEditState(false);
    const msgMap = /* @__PURE__ */ new Map();
    const tmpInsertToMessageMap = (key, value) => {
      msgMap.set(key, value);
    };
    if (!props.enableSaveGridOnCellValueChange) {
      ShowGridEditMode(false);
    }
    let blankNonDeletedRowsCount = 0;
    const blankNonDeletedObjects = defaultGridData.filter((x) => x._grid_row_operation_ != _Operation.Delete).filter((obj) => isRowBlank(obj));
    blankNonDeletedObjects.forEach((element) => {
      if ((element == null ? void 0 : element["_grid_row_id_"]) != void 0) {
        HandleRowSingleDelete(Number(element["_grid_row_id_"]));
        blankNonDeletedRowsCount = blankNonDeletedRowsCount + 1;
      }
    });
    if (blankNonDeletedRowsCount > 0) {
      var msg = `Auto Deleted ${blankNonDeletedRowsCount} Blank Row${blankNonDeletedRowsCount == 1 ? "" : "s"}`;
      tmpInsertToMessageMap("blanks", {
        msg,
        type: MessageBarType.warning
      });
    }
    const defaultGridDataTmpWithDeletedData = [...defaultGridData];
    const ignoredProperties = [...InternalEditableGridPropertiesKeys];
    const removeIgnoredProperties = (obj) => {
      return Object.keys(obj).reduce((acc, key) => {
        if (!ignoredProperties.includes(key)) {
          acc[key] = obj[key];
        }
        return acc;
      }, {});
    };
    const defaultGridDataTmpWithInternalPropsIgnored = defaultGridDataTmpWithDeletedData.map(removeIgnoredProperties);
    let localError = false;
    return new Promise((resolve, reject) => {
      if (parseInt(getGridRecordLength(true)) > 0) {
        const runGridValidationsWorker = new WorkerWrapper();
        const defaultGridDataTmp = defaultGridData.length > 0 ? defaultGridData.filter(
          (x) => x._grid_row_operation_ != _Operation.Delete
        ) : [];
        try {
          const args = {
            messages: msgMap,
            defaultGridDataTmp,
            indentiferColumn: indentiferColumn.current,
            props: {
              // Any property in the column object that has a typeof == 'function' will be drop from the columns sent to the worker
              columns: removeFunctionsFromArrayObjects(props.columns),
              customKeysToAddOnNewRow: props.customKeysToAddOnNewRow,
              customOperationsKey: props.customOperationsKey
            },
            ignoredColProperties: ignoredProperties,
            MessageBarType,
            DepColTypes
          };
          runGridValidationsWorker.onmessageerror = function(event) {
            console.error(event);
            reject("error with message returned by 'runGridValidationsWorker'");
          };
          runGridValidationsWorker.onerror = function(event) {
            console.error(event);
            reject("error with 'runGridValidationsWorker'");
          };
          runGridValidationsWorker.postMessage(args);
          runGridValidationsWorker.onmessage = function(event) {
            localError = event.data.isError;
            event.data.messages.forEach(function(value, key) {
              insertToMessageMap(Messages.current, key, value);
            });
            if (localError === true)
              setGridInError(true);
            if (!localError) {
              if (props.onBeforeGridSave) {
                props.onBeforeGridSave(
                  defaultGridDataTmpWithInternalPropsIgnored
                );
              }
              if (props.onGridSave) {
                props.onGridSave(
                  defaultGridData,
                  defaultGridDataTmpWithInternalPropsIgnored
                );
              }
              onGridFiltered();
            }
            resolve(localError);
          };
        } catch (error) {
          console.error(error);
          reject(error);
        }
      } else {
        resolve(false);
      }
    });
  };
  const onGridUpdate = async () => {
    if (props.onGridUpdate) {
      let updatedItems = defaultGridData;
      if (props.ignoreInternalPropertiesOnGridUpdateCallback) {
        const ignoredProperties = [
          ...InternalEditableGridPropertiesKeys
        ];
        const removeIgnoredProperties = (obj) => {
          return Object.keys(obj).reduce((acc, key) => {
            if (!ignoredProperties.includes(key)) {
              acc[key] = obj[key];
            }
            return acc;
          }, {});
        };
        updatedItems = defaultGridData.map(removeIgnoredProperties);
      }
      await props.onGridUpdate(forceKeyMapping(updatedItems, "text", false));
    }
  };
  const UpdateGridEditStatus = () => {
    var gridEditStatus = false;
    var BreakException = {};
    try {
      activateCellEdit.forEach((item, index2) => {
        gridEditStatus = gridEditStatus || item.isActivated;
        if (gridEditStatus) {
          throw BreakException;
        }
        var objectKeys = Object.keys(item.properties);
        objectKeys.filter(
          (key) => key != "_grid_row_id_" && key != "_grid_row_operation_"
        ).forEach((objKey) => {
          gridEditStatus = gridEditStatus || item["properties"][objKey]["activated"];
          if (gridEditStatus) {
            throw BreakException;
          }
        });
      });
    } catch (e) {
    }
    if (!isGridInEdit && gridEditStatus || isGridInEdit && !gridEditStatus) {
      setIsGridInEdit(gridEditStatus);
    }
  };
  const SetGridItems = (data) => {
    data = ResetGridRowID(data);
    setEditChangeCompareData(data.map((obj) => ({ ...obj })));
    setDefaultGridData(data);
    setActivateCellEdit(InitializeInternalGridEditStructure(data));
  };
  const setGridEditState = (editState) => {
    if (isGridStateEdited != editState) {
      setIsGridStateEdited(editState);
    }
  };
  const SetFilteredGridData = (filters) => {
    var filteredData = filterGridData(defaultGridData, filters);
    var activateCellEditTmp = ShallowCopyDefaultGridToEditGrid(
      defaultGridData,
      activateCellEdit
    );
    setDefaultGridData(filteredData);
    setActivateCellEdit(activateCellEditTmp);
    setGridData(filteredData);
    onGridFiltered();
  };
  const onEditPanelChange = (item) => {
    var defaultGridDataTmp = UpdateBulkData(item, defaultGridData);
    dismissPanelForEdit();
    defaultGridDataTmp = CheckBulkUpdateOnChangeCallBack(
      item,
      defaultGridDataTmp
    );
    SetGridItems(defaultGridDataTmp);
    resetFilters();
  };
  const UpdateBulkData = (data, defaultGridDataArr) => {
    let newDefaultGridData = [...defaultGridDataArr];
    selectedItems.forEach((item, index2) => {
      newDefaultGridData.filter((x) => x._grid_row_id_ == item._grid_row_id_).map((row) => {
        var objectKeys = Object.keys(data);
        objectKeys.forEach((objKey) => {
          var _a3;
          row[objKey] = data[objKey];
          if (row._grid_row_operation_ != _Operation.Add) {
            row._grid_row_operation_ = _Operation.Update;
            if (props.customOperationsKey)
              row[props.customOperationsKey.colKey] = ((_a3 = props.customOperationsKey.options) == null ? void 0 : _a3.Update) ?? _Operation.Update;
          }
        });
        return row;
      });
    });
    setGridEditState(true);
    return newDefaultGridData;
  };
  const CheckBulkUpdateOnChangeCallBack = (data, defaultGridDataTmp, pastedData) => {
    var columns = [];
    for (var key in data) {
      var column2 = props.columns.filter((item) => item.key == key)[0];
      if (column2.onChange) {
        columns.push(column2);
      }
    }
    if (pastedData) {
      try {
        columns.forEach((column22) => {
          defaultGridDataTmp = CheckCellOnChangeCallBack(
            defaultGridDataTmp,
            pastedData.map((item) => item._grid_row_id_),
            column22
          );
        });
      } catch (error) {
      }
    } else {
      columns.forEach((column22) => {
        defaultGridDataTmp = CheckCellOnChangeCallBack(
          defaultGridDataTmp,
          selectedItems.map((item) => item._grid_row_id_),
          column22
        );
      });
    }
    return defaultGridDataTmp;
  };
  const UpdateGridColumnData = (data) => {
    var defaultGridDataTmp = UpdateBulkData(data, defaultGridData);
    CloseColumnUpdateDialog();
    defaultGridDataTmp = CheckBulkUpdateOnChangeCallBack(
      data,
      defaultGridDataTmp
    );
    SetGridItems(defaultGridDataTmp);
  };
  const CloseColumnUpdateDialog = () => {
    setIsUpdateColumnClicked(false);
  };
  const ShowColumnUpdate = () => {
    setIsUpdateColumnClicked((s) => !s);
  };
  const CloseDialog = React__namespace.useCallback(() => {
    setDialogContent(void 0);
  }, []);
  const tempAutoGenId = React.useRef(0);
  const GetDefaultRowObject = (rowCount, _tmp_overide_grid_row_id_) => {
    var _a3;
    let obj = {};
    let addedRows = [];
    let _new_grid_row_id_ = _tmp_overide_grid_row_id_ !== null && _tmp_overide_grid_row_id_ !== void 0 ? _tmp_overide_grid_row_id_ : Math.max.apply(
      Math,
      defaultGridData.map(function(o) {
        return o._grid_row_id_;
      })
    );
    let _autoGenId = tempAutoGenId.current;
    if (indentiferColumn.current != void 0 && indentiferColumn.current !== null) {
      _autoGenId = Math.max.apply(
        Math,
        defaultGridData.map(function(o) {
          if (indentiferColumn.current != void 0 && indentiferColumn.current !== null)
            return o[indentiferColumn.current];
        })
      ) ?? 0;
      if (_autoGenId < tempAutoGenId.current) {
        _autoGenId = tempAutoGenId.current;
      }
    }
    for (var i = 1; i <= rowCount; i++) {
      obj = {};
      props.columns.forEach((item, index2) => {
        if (item.autoGenerate) {
          obj[item.key] = _autoGenId + i;
          tempAutoGenId.current = _autoGenId + i;
        } else if (item.defaultOnAddRow)
          obj[item.key] = item.defaultOnAddRow;
        else {
          obj[item.key] = GetDefault(item.dataType);
        }
      });
      if (props.customOperationsKey)
        obj[props.customOperationsKey.colKey] = ((_a3 = props.customOperationsKey.options) == null ? void 0 : _a3.Add) ?? _Operation.Add;
      if (props.customKeysToAddOnNewRow) {
        for (let index2 = 0; index2 < props.customKeysToAddOnNewRow.length; index2++) {
          const hiddenKey = props.customKeysToAddOnNewRow[index2];
          obj[hiddenKey.key] = hiddenKey.defaultValue;
        }
      }
      obj._grid_row_id_ = _new_grid_row_id_;
      obj._grid_row_operation_ = _Operation.Add;
      obj._is_filtered_in_ = true;
      obj._is_filtered_in_grid_search_ = true;
      obj._is_filtered_in_column_filter_ = true;
      addedRows.push(obj);
    }
    return addedRows;
  };
  const [AddRowActive, SetAddRowActive] = React.useState(false);
  React.useEffect(() => {
    if (AddRowActive && props.enableInlineGridAdd && !props.enableEditAllOnCellClick) {
      ShowRowEditMode(
        defaultGridData[0],
        Number(defaultGridData[0]["_grid_row_id_"]),
        true
      );
      SetAddRowActive(false);
    }
  }, [activateCellEdit, defaultGridData]);
  const AddRowsToGrid = () => {
    const updateItemName = () => {
      if (SpinRef && SpinRef.current.value) {
        setDialogContent(void 0);
        setAnnounced(/* @__PURE__ */ jsxRuntimeExports.jsx(Announced, { message: "Rows Added", "aria-live": "assertive" }));
        let rowCount = parseInt(SpinRef.current.value, 10);
        var addedRows2 = GetDefaultRowObject(rowCount);
        var newGridData2 = [...addedRows2, ...defaultGridData];
        setGridEditState(true);
        SetGridItems(newGridData2);
      }
    };
    if (!props.enableInlineGridAdd) {
      setDialogContent(
        /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SpinButton,
            {
              componentRef: SpinRef,
              defaultValue: "0",
              label: "Row Count:",
              min: 0,
              max: 100,
              step: 1,
              incrementButtonAriaLabel: "Increase value by 1",
              decrementButtonAriaLabel: "Decrease value by 1"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PrimaryButton, { onClick: updateItemName, text: "Save" }) })
        ] })
      );
    } else {
      var addedRows = GetDefaultRowObject(1);
      var newGridData = [...addedRows, ...defaultGridData];
      setGridEditState(true);
      SetGridItems(newGridData);
      SetAddRowActive(true);
    }
    clearSelectedItems();
  };
  const onAddPanelSubmit = (combinations) => {
    dismissPanelForAdd();
    var newGridData = [...defaultGridData];
    combinations.forEach(function(combination, index2) {
      var _a3;
      const item = Object.fromEntries(combinations[index2]);
      var addedRows = GetDefaultRowObject(1);
      if (Object.keys(item).length > 0) {
        addedRows.map((row) => {
          var objectKeys = Object.keys(item);
          objectKeys.forEach((key) => {
            row[key] = item[key];
          });
          return row;
        });
      }
      if ((_a3 = props.enableGridRowAddWithValues) == null ? void 0 : _a3.showInsertedRowAtTopWhenAddedFromPanel) {
        newGridData.splice(0, 0, addedRows[0]);
      } else {
        newGridData.splice(newGridData.length, 0, addedRows[0]);
      }
    });
    setGridEditState(true);
    SetGridItems(newGridData);
  };
  const CloseMessageDialog = () => {
    setMessageDialogProps({
      visible: false,
      message: "",
      subMessage: ""
    });
  };
  const DeleteSelectedRows = () => {
    let defaultGridDataTmp = [...defaultGridData];
    selectedItems.forEach((item, index2) => {
      defaultGridDataTmp.filter((x) => x._grid_row_id_ == item._grid_row_id_).map((x) => {
        var _a3;
        x._grid_row_operation_ = _Operation.Delete;
        if (props.customOperationsKey)
          x[props.customOperationsKey.colKey] = ((_a3 = props.customOperationsKey.options) == null ? void 0 : _a3.Delete) ?? _Operation.Delete;
      });
    });
    if (props.enableSaveGridOnCellValueChange) {
      setDefaultGridData(defaultGridDataTmp);
    } else {
      setGridEditState(true);
      SetGridItems(defaultGridDataTmp);
    }
  };
  const getExportableData = () => {
    let exportableColumns = props.columns.filter(
      (x) => x.includeColumnInExport == true
    );
    let exportableData = [];
    let exportableObj = {};
    if (!selectedItems || selectedItems.length == 0) {
      defaultGridData.filter(
        (item) => item._grid_row_operation_ != _Operation.Delete && item._is_filtered_in_ && item._is_filtered_in_column_filter_ && item._is_filtered_in_grid_search_
      ).forEach((item1, index1) => {
        exportableColumns.forEach((item2, index2) => {
          exportableObj[item2.key] = item1[item2.key];
        });
        exportableData.push(exportableObj);
        exportableObj = {};
      });
    } else {
      selectedItems.forEach((sel, index2) => {
        defaultGridData.filter(
          (item) => item._grid_row_operation_ != _Operation.Delete && item._is_filtered_in_ && item._is_filtered_in_column_filter_ && item._is_filtered_in_grid_search_
        ).forEach((item1, index1) => {
          if (sel._grid_row_id_ == item1._grid_row_id_) {
            exportableColumns.forEach((item2, index22) => {
              exportableObj[item2.text] = item1[item2.key];
            });
            exportableData.push(exportableObj);
            exportableObj = {};
          }
        });
      });
    }
    return exportableData;
  };
  const ExportToCSV = (dataRows, fileName) => {
    if (!props.onExcelExport) {
      ExportToCSVUtil(dataRows, fileName);
    } else {
      props.onExcelExport(ExportType.CSV);
    }
  };
  const ExportToExcel = (dataRows, fileName) => {
    if (!props.onExcelExport) {
      ExportToExcelUtil(dataRows, fileName);
    } else {
      props.onExcelExport(ExportType.XLSX);
    }
  };
  const onExportClick = (type) => {
    let fileName = props.exportFileName != null && props.exportFileName.length > 0 ? props.exportFileName : "ExcelExport";
    switch (type) {
      case ExportType.XLSX:
        ExportToExcel(getExportableData(), fileName + ".xlsx");
        break;
      case ExportType.CSV:
        ExportToCSV(getExportableData(), fileName + ".csv");
        break;
    }
  };
  const hiddenFileInput = React__namespace.useRef(null);
  const renderItem = () => {
    const handleClick = (event) => {
      var _a3;
      (_a3 = hiddenFileInput.current) == null ? void 0 : _a3.click();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { horizontal: true, horizontalAlign: "center", verticalAlign: "center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          onClick: handleClick,
          label: "Import From Excel",
          "aria-label": "Import From Excel",
          iconProps: { iconName: "PageCheckedOut" }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "label",
        {
          onClick: handleClick,
          "aria-label": "Import From Excel",
          style: { cursor: "pointer" },
          children: "Import From Excel"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          "aria-hidden": true,
          ref: hiddenFileInput,
          style: { display: "none" },
          type: "file",
          name: "file",
          className: "custom-file-input",
          id: "inputGroupFile",
          onChange: (ev) => {
            setImportingStarted(true);
            onImportClick(ImportType.XLSX, ev);
          },
          accept: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel"
        }
      )
    ] });
  };
  const [columnValuesObj, setColumnValuesObj] = React.useState(null);
  React.useEffect(() => {
    let tmpColumnValuesObj = {};
    props.columns.forEach((item, index2) => {
      var _a3;
      tmpColumnValuesObj[item.key] = {
        value: GetDefault(item.dataType),
        isChanged: false,
        error: null,
        columnEditable: (item == null ? void 0 : item.editable) ?? false,
        defaultValueOnNewRow: (item == null ? void 0 : item.defaultOnAddRow) ?? null,
        dataType: item.dataType,
        validations: {
          numberBoundaries: (_a3 = item.validations) == null ? void 0 : _a3.numberBoundaries
        }
      };
    });
    setColumnValuesObj(tmpColumnValuesObj);
  }, [props.columns]);
  const setupImportedData = (excelKeys, addedRows) => {
    addedRows.map((row) => {
      var objectKeys = Object.keys(excelKeys);
      objectKeys.forEach((key) => {
        row[key] = excelKeys[key];
      });
      return row;
    });
    return addedRows;
  };
  const verifyColumnsOnImport = (excelKeys) => {
    var _a3;
    var ImportedHeader = Object.keys(excelKeys);
    var CurrentHeaders = Object.keys(columnValuesObj);
    const autoGenerateCol = props.columns.filter(
      (x) => x.autoGenerate === true
    );
    const unImportableCol = props.columns.filter(
      (x) => x.columnNeededInImport === false
    );
    for (let index2 = 0; index2 < ImportedHeader.length; index2++) {
      const header = ImportedHeader[index2];
      if (!(CurrentHeaders.includes(header) || CurrentHeaders.includes(header == null ? void 0 : header.toLowerCase()) && (CurrentHeaders.length === ImportedHeader.length || CurrentHeaders.length === ImportedHeader.length - unImportableCol.length - autoGenerateCol.length || CurrentHeaders.length === ImportedHeader.length + unImportableCol.length + autoGenerateCol.length))) {
        const newMap = new Map(interalMessagesState).set((_a3 = props.id) == null ? void 0 : _a3.toString(), {
          msg: "Make sure XLS file includes all columns. Even if you leave them blank. Import Terminated. Rename / Add  `" + header + "` column",
          type: MessageBarType.error
        });
        setInteralMessagesState(newMap);
        return false;
      }
    }
    return true;
  };
  const verifyColumnsDataOnImport = (excelData) => {
    let errMsg = [];
    var ImportedHeader = Object.keys(excelData);
    for (let index2 = 0; index2 < ImportedHeader.length; index2++) {
      const header = ImportedHeader[index2];
      const rowCol = excelData[ImportedHeader[index2]];
      const currentCol = props.columns.filter((x) => x.key === header);
      for (let j = 0; j < currentCol.length; j++) {
        const element = currentCol[j];
        if (typeof rowCol !== element.dataType) {
          if (element.dataType === "number") {
            if (isNaN(parseInt(rowCol))) {
              errMsg.push(
                `Data type error, Column: ${element.name}. Expected ${element.dataType}. Got ${typeof rowCol}`
              );
            }
          } else if (element.dataType === "boolean") {
            try {
              Boolean(rowCol);
            } catch (error) {
              errMsg.push(
                `Data type error, Column: ${element.name}. Expected ${element.dataType}. Got ${typeof rowCol}`
              );
            }
          } else if (element.dataType === "date") {
            try {
              if (!isValidDate(rowCol)) {
                throw {};
              } else {
                continue;
              }
            } catch (error) {
              errMsg.push(
                `Data type error, Column: ${element.name}. Expected ${element.dataType}. Got ${typeof rowCol}`
              );
            }
          } else if (typeof rowCol !== element.dataType) {
            errMsg.push(
              `Data type error, Column: ${element.name}. Expected ${element.dataType}. Got ${typeof rowCol}`
            );
          } else {
            errMsg.push(`Data type error, Column: ${element.name}.`);
          }
        }
      }
    }
    return errMsg;
  };
  const ImportFromExcelUtil = (event) => {
    var _a3;
    const files = event.target.files;
    if (files.length) {
      const file = files[0];
      const reader = new FileReader();
      reader.onload = (event2) => {
        var _a4, _b3, _c3;
        const wb = readSync((_a4 = event2.target) == null ? void 0 : _a4.result);
        const sheets = wb.SheetNames;
        let ui = [];
        if (sheets.length) {
          const excelJSON = utils.sheet_to_json(wb.Sheets[sheets[0]]);
          if (excelJSON.length <= 0) {
            const newMap2 = new Map(interalMessagesState).set(
              (_b3 = props.id) == null ? void 0 : _b3.toString(),
              {
                msg: "Selected file has 0 rows of data. Please try again.",
                type: MessageBarType.error
              }
            );
            setInteralMessagesState(newMap2);
            setImportingStarted(false);
            return;
          }
          for (let index2 = 0; index2 < 1; index2++) {
            if (!verifyColumnsOnImport(excelJSON[index2])) {
              setImportingStarted(false);
              return;
            }
          }
          for (let index2 = 0; index2 < excelJSON.length; index2++) {
            const verifyDataTypes = verifyColumnsDataOnImport(excelJSON[index2]);
            if (verifyDataTypes.length <= 0)
              ui.push(
                setupImportedData(excelJSON[index2], GetDefaultRowObject(1))
              );
            else {
              verifyDataTypes.forEach((str) => {
                var _a5;
                const newMap2 = new Map(interalMessagesState).set(
                  (_a5 = props.id) == null ? void 0 : _a5.toString(),
                  { msg: `Import Error: ${str}`, type: MessageBarType.error }
                );
                setInteralMessagesState(newMap2);
              });
              setImportingStarted(false);
              return;
            }
          }
          var newGridData = [...defaultGridData];
          ui.forEach((i) => {
            newGridData.splice(0, 0, i[0]);
          });
          const newMap = new Map(interalMessagesState).set(
            (_c3 = props.id) == null ? void 0 : _c3.toString(),
            {
              msg: `Imported ${ui.length} Rows From File`,
              type: MessageBarType.success
            }
          );
          setInteralMessagesState(newMap);
          SetGridItems(newGridData);
          setGridEditState(true);
          setImportingStarted(false);
        }
      };
      reader.readAsArrayBuffer(file);
    } else {
      const newMap = new Map(interalMessagesState).set((_a3 = props.id) == null ? void 0 : _a3.toString(), {
        msg: `Error Processing File`,
        type: MessageBarType.error
      });
      setInteralMessagesState(newMap);
      setImportingStarted(false);
    }
    event.target.value = null;
  };
  const ImportFromExcel = (event, dataRows) => {
    if (!props.onExcelImport) {
      ImportFromExcelUtil(event);
    } else {
      props.onExcelImport(ImportType.XLSX);
    }
    clearSelectedItems();
  };
  const onImportClick = (type, event) => {
    switch (type) {
      case ImportType.XLSX:
        ImportFromExcel(event);
        break;
    }
  };
  const SaveSingleCellValue = (key, rowNum, defaultGridDataArr) => {
    var _a3, _b3;
    let defaultGridDataTmp = [];
    defaultGridDataTmp = [...defaultGridDataArr];
    var internalRowNumDefaultGrid = defaultGridDataTmp.findIndex(
      (row) => row._grid_row_id_ == rowNum
    );
    var internalRowNumActivateGrid = activateCellEdit.findIndex(
      (row) => row["properties"]["_grid_row_id_"]["value"] == rowNum
    );
    defaultGridDataTmp[internalRowNumDefaultGrid][key] = activateCellEdit[internalRowNumActivateGrid]["properties"][key]["value"];
    if (defaultGridDataTmp[internalRowNumDefaultGrid]["_grid_row_operation_"] != _Operation.Add) {
      if (JSON.stringify(defaultGridDataTmp) === JSON.stringify(editChangeCompareData)) {
        defaultGridDataTmp[internalRowNumDefaultGrid]["_grid_row_operation_"] = _Operation.None;
        if (props.customOperationsKey)
          defaultGridDataTmp[internalRowNumDefaultGrid][props.customOperationsKey.colKey] = ((_a3 = props.customOperationsKey.options) == null ? void 0 : _a3.None) ?? _Operation.None;
      } else {
        defaultGridDataTmp[internalRowNumDefaultGrid]["_grid_row_operation_"] = _Operation.Update;
        if (props.customOperationsKey)
          defaultGridDataTmp[internalRowNumDefaultGrid][props.customOperationsKey.colKey] = ((_b3 = props.customOperationsKey.options) == null ? void 0 : _b3.Update) ?? _Operation.Update;
      }
      setGridEditState(true);
    }
    return defaultGridDataTmp;
  };
  const [messagesState, setMessagesState] = React.useState(
    /* @__PURE__ */ new Map()
  );
  const [messagesJSXState, setMessagesJSXState] = React.useState([]);
  const onRenderMsg = React.useCallback(() => {
    let messageTmp = [];
    messagesState.forEach(function(value, key) {
      messageTmp.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          MessageBar,
          {
            styles: { root: { marginBottom: 5 } },
            messageBarType: value.type,
            onDismiss: () => removeFromMessageMap(Messages.current, key),
            children: value.msg
          },
          key
        )
      );
    });
    return messageTmp;
  }, [messagesState]);
  React.useEffect(() => {
    Messages.current = messagesState;
    setMessagesJSXState(onRenderMsg());
  }, [messagesState]);
  const [interalMessagesState, setInteralMessagesState] = React.useState(/* @__PURE__ */ new Map());
  const [interalMsgJSXState, setinteralMsgJSXState] = React.useState(
    []
  );
  const onRenderInternalMsg = React.useCallback(() => {
    let interalMsgTmp = [];
    interalMessagesState.forEach(function(value, key) {
      interalMsgTmp.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          MessageBar,
          {
            styles: { root: { marginBottom: 5 } },
            messageBarType: value.type,
            onDismiss: () => {
              const newMap = new Map(interalMessagesState);
              newMap.delete(key);
              setInteralMessagesState(newMap);
            },
            children: value.msg
          },
          key
        )
      );
    });
    return interalMsgTmp;
  }, [interalMessagesState]);
  React.useEffect(() => {
    setinteralMsgJSXState(onRenderInternalMsg());
  }, [interalMessagesState]);
  React.useState(false);
  React.useRef(/* @__PURE__ */ new Map());
  React.useState(
    /* @__PURE__ */ new Map()
  );
  const onCellValueChange = (ev, text, item, row, key, column2) => {
    let activateCellEditTmp = [...activateCellEdit];
    let clearThisDependent = [];
    activateCellEditTmp = [];
    activateCellEdit.forEach((item2, index2) => {
      var _a3, _b3, _c3;
      if (row == index2) {
        let isTextModified = true;
        let modifyText = text;
        if ((_a3 = columnKeyPasteRef.current) == null ? void 0 : _a3.inputType) {
          switch (columnKeyPasteRef.current.inputType) {
            case EditControlType.MultilineTextField:
              isTextModified = false;
              break;
            case EditControlType.Password:
              isTextModified = false;
              break;
            case EditControlType.Date:
              isTextModified = false;
              break;
            default:
              isTextModified = true;
              modifyText = cursorFlashing ? (_b3 = text == null ? void 0 : text.toString()) == null ? void 0 : _b3.split(" ")[0].trim() : (_c3 = text == null ? void 0 : text.toString()) == null ? void 0 : _c3.split(/[\t\r]+/).map((part) => part.trim())[0].trim();
              break;
          }
        }
        item2.properties[key].value = ParseType(column2.dataType, modifyText, isTextModified) ?? "";
        if (clearThisDependent.length > 0) {
          clearThisDependent.forEach((element) => {
            item2.properties[element].error = null;
          });
        } else {
          {
            item2.properties[key].error = null;
          }
        }
      }
      activateCellEditTmp.push(item2);
    });
    if (column2.onChange) {
      HandleColumnOnChange(activateCellEditTmp, row, column2);
    }
    setActivateCellEdit(activateCellEditTmp);
    if (props.enableSaveGridOnCellValueChange) {
      let defaultGridDataTmp = SaveRowValue(item, row, defaultGridData);
      setDefaultGridData(defaultGridDataTmp);
    } else {
      setGridEditState(true);
    }
  };
  const CheckCellOnChangeCallBack = (defaultGridDataTmp, row, column2) => {
    var callbackRequestparams = {
      data: defaultGridDataTmp,
      rowindex: row,
      triggerkey: column2.key,
      activatetriggercell: false
    };
    var defaultGridBck = [...defaultGridDataTmp];
    defaultGridDataTmp = column2.onChange(callbackRequestparams);
    if (!defaultGridDataTmp)
      defaultGridDataTmp = defaultGridBck;
    return defaultGridDataTmp;
  };
  const onKeyDownEvent = (event, column2, rowNum, activateCurrentCell) => {
    if (event.key == "Enter" && !props.disableInlineCellEdit) {
      if (!activateCellEdit[rowNum].isActivated) {
        EditCellValue(column2.key, rowNum, activateCurrentCell);
        event.preventDefault();
      }
    }
  };
  const onKeyDownEventFull = (event, item, _grid_row_id_) => {
    if (event.key == "Enter" && !props.disableInlineCellEdit) {
      ShowRowEditMode(item, _grid_row_id_, false);
      event.preventDefault();
    }
  };
  const onCellDateChange = (date, item1, row, column2) => {
    let activateCellEditTmp = [];
    activateCellEdit.forEach((item, index2) => {
      if (row == index2) {
        item.properties[column2.key].value = dateToISOLikeButLocal(date);
      }
      activateCellEditTmp.push(item);
    });
    if (column2.onChange) {
      HandleColumnOnChange(activateCellEditTmp, row, column2);
    }
    setActivateCellEdit(activateCellEditTmp);
    if (props.enableSaveGridOnCellValueChange) {
      let defaultGridDataTmp = SaveRowValue(item1, row, defaultGridData);
      setDefaultGridData(defaultGridDataTmp);
    } else {
      setGridEditState(true);
    }
  };
  const onCellPickerTagListChanged = (cellPickerTagList, row, column2, item) => {
    let activateCellEditTmp = [];
    activateCellEdit.forEach((item2, index2) => {
      if (row == index2) {
        item2.properties[column2.key].value = "";
        if (cellPickerTagList && cellPickerTagList.length > 0) {
          cellPickerTagList.forEach((tag) => {
            item2.properties[column2.key].value += tag.name + ";";
          });
        }
        let str = item2.properties[column2.key].value;
        item2.properties[column2.key].value = str.length > 0 ? str.substring(0, str.length - 1) : str;
      }
      activateCellEditTmp.push(item2);
    });
    if (column2.onChange) {
      HandleColumnOnChange(activateCellEditTmp, row, column2);
    }
    setActivateCellEdit(activateCellEditTmp);
    if (props.enableSaveGridOnCellValueChange) {
      let defaultGridDataTmp = SaveRowValue(item, row, defaultGridData);
      setDefaultGridData(defaultGridDataTmp);
    } else {
      setGridEditState(true);
    }
  };
  const onDropDownChange = (event, selectedDropdownItem, row, column2, item) => {
    let activateCellEditTmp = [];
    activateCellEdit.forEach((item2, index2) => {
      if (row == index2) {
        item2.properties[column2.key].value = selectedDropdownItem == null ? void 0 : selectedDropdownItem.key;
      }
      activateCellEditTmp.push(item2);
    });
    if (column2.onChange) {
      HandleColumnOnChange(activateCellEditTmp, row, column2);
    }
    setActivateCellEdit(activateCellEditTmp);
    if (props.enableSaveGridOnCellValueChange) {
      let defaultGridDataTmp = SaveRowValue(item, row, defaultGridData);
      setDefaultGridData(defaultGridDataTmp);
    } else {
      setGridEditState(true);
    }
  };
  const onComboBoxChange = (event, selectedOption, row, column2, item) => {
    let activateCellEditTmp = [];
    activateCellEdit.forEach((item2, index2) => {
      if (row == index2) {
        item2.properties[column2.key].value = selectedOption == null ? void 0 : selectedOption.text;
      }
      activateCellEditTmp.push(item2);
    });
    if (column2.onChange) {
      HandleColumnOnChange(activateCellEditTmp, row, column2);
    }
    setActivateCellEdit(activateCellEditTmp);
    if (props.enableSaveGridOnCellValueChange) {
      let defaultGridDataTmp = SaveRowValue(item, row, defaultGridData);
      setDefaultGridData(defaultGridDataTmp);
    } else {
      setGridEditState(true);
    }
  };
  const onComboBoxChangeRaw = (text, row, column2, item) => {
    let activateCellEditTmp = [];
    activateCellEdit.forEach((item2, index2) => {
      if (row == index2) {
        item2.properties[column2.key].value = text;
      }
      activateCellEditTmp.push(item2);
    });
    if (column2.onChange) {
      HandleColumnOnChange(activateCellEditTmp, row, column2);
    }
    setActivateCellEdit(activateCellEditTmp);
    if (props.enableSaveGridOnCellValueChange) {
      let defaultGridDataTmp = SaveRowValue(item, row, defaultGridData);
      setDefaultGridData(defaultGridDataTmp);
    } else {
      setGridEditState(true);
    }
  };
  const onCheckBoxChange = (ev, row, column2, isChecked, item) => {
    let activateCellEditTmp = [];
    activateCellEdit.forEach((item2, index2) => {
      if (row == index2) {
        item2.properties[column2.key].value = isChecked;
      }
      activateCellEditTmp.push(item2);
    });
    if (column2.onChange) {
      HandleColumnOnChange(activateCellEditTmp, row, column2);
    }
    setActivateCellEdit(activateCellEditTmp);
    if (props.enableSaveGridOnCellValueChange) {
      let defaultGridDataTmp = SaveRowValue(item, row, defaultGridData);
      setDefaultGridData(defaultGridDataTmp);
    } else {
      setGridEditState(true);
    }
  };
  const ChangeCellState = (key, rowNum, activateCurrentCell, activateCellEditArr) => {
    let activateCellEditTmp = [];
    try {
      activateCellEditTmp = [...activateCellEditArr];
      activateCellEditTmp[rowNum]["properties"][key]["activated"] = activateCurrentCell;
      activateCellEditTmp[rowNum]["properties"][key]["error"] = !activateCurrentCell ? null : activateCellEditTmp[rowNum]["properties"][key]["error"];
      return activateCellEditTmp;
    } catch (error) {
      return activateCellEditArr;
    }
  };
  const EditCellValue = (key, rowNum, activateCurrentCell) => {
    let activateCellEditTmp = ChangeCellState(
      key,
      rowNum,
      activateCurrentCell,
      activateCellEdit
    );
    setActivateCellEdit(activateCellEditTmp);
    if (!activateCurrentCell) {
      let defaultGridDataTmp = SaveSingleCellValue(
        key,
        rowNum,
        defaultGridData
      );
      setDefaultGridData(defaultGridDataTmp);
    }
  };
  const HandleColumnOnChange = (activateCellEditTmp, row, column2) => {
    var arr = [];
    activateCellEditTmp.forEach((item, index2) => {
      var rowObj = {};
      var objectKeys = Object.keys(item.properties);
      objectKeys.forEach((objKey) => {
        rowObj[objKey] = item.properties[objKey].value;
      });
      arr.push(rowObj);
    });
    var defaultGridDataTmp = CheckCellOnChangeCallBack(arr, [row], column2);
    setDefaultGridData(defaultGridDataTmp);
    activateCellEditTmp = ShallowCopyDefaultGridToEditGrid(
      defaultGridDataTmp,
      activateCellEditTmp
    );
  };
  const ChangeRowState = (item, rowNum, enableTextField) => {
    let activateCellEditTmp = [...activateCellEdit];
    var objectKeys = Object.keys(item);
    objectKeys.filter((key) => key != "_grid_row_id_" && key != "_grid_row_operation_").forEach((objKey) => {
      activateCellEditTmp = ChangeCellState(
        objKey,
        rowNum,
        enableTextField,
        activateCellEditTmp
      );
    });
    activateCellEditTmp[rowNum]["isActivated"] = enableTextField;
    return activateCellEditTmp;
  };
  const SaveRowValue = (item, rowNum, defaultGridDataArr) => {
    let defaultGridDataTmp = [];
    defaultGridDataTmp = [...defaultGridDataArr];
    var objectKeys = Object.keys(item);
    objectKeys.filter((key) => key != "_grid_row_id_" && key != "_grid_row_operation_").forEach((objKey) => {
      defaultGridDataTmp = SaveSingleCellValue(
        objKey,
        rowNum,
        defaultGridData
      );
    });
    return defaultGridDataTmp;
  };
  const ShowRowEditMode = (item, rowNum, enableTextField) => {
    if (enableTextField) {
      setCancellableRows((cancellableRows2) => [...cancellableRows2, item]);
    } else {
      setCancellableRows(
        cancellableRows.filter((row) => row._grid_row_id_ != item._grid_row_id_)
      );
    }
    let activateCellEditTmp = ChangeRowState(
      item,
      rowNum,
      enableTextField
    );
    setActivateCellEdit(activateCellEditTmp);
    if (!enableTextField) {
      let defaultGridDataTmp = SaveRowValue(
        item,
        rowNum,
        defaultGridData
      );
      setDefaultGridData(defaultGridDataTmp);
    }
  };
  const CancelRowEditMode = (item, rowNum) => {
    let activateCellEditTmp = ChangeRowState(item, rowNum, false);
    activateCellEditTmp = RevertRowEditValues(rowNum, activateCellEditTmp);
    setActivateCellEdit(activateCellEditTmp);
    setDefaultGridData(
      ShallowCopyEditGridToDefaultGrid(
        defaultGridData,
        activateCellEditTmp,
        props.customOperationsKey
      )
    );
  };
  const RevertRowEditValues = (rowNum, activateCellEditArr) => {
    var activateCellEditTmp = [...activateCellEditArr];
    var baseRow = cancellableRows.filter((x) => x._grid_row_id_ == rowNum)[0];
    var objectKeys = Object.keys(baseRow);
    var targetRow = activateCellEditTmp.filter(
      (x) => x.properties["_grid_row_id_"].value == rowNum
    )[0];
    objectKeys.forEach((objKey) => {
      if ([objKey != "_grid_row_id_"]) {
        targetRow["properties"][objKey]["value"] = baseRow[objKey];
      }
    });
    setCancellableRows(
      cancellableRows.filter((row) => row._grid_row_id_ != rowNum)
    );
    return activateCellEditTmp;
  };
  const ShowGridEditMode = (close) => {
    var newEditModeValue = close ?? !editMode;
    if (newEditModeValue) {
      setCancellableRows(defaultGridData);
    } else {
      setCancellableRows([]);
    }
    let activateCellEditTmp = [];
    let defaultGridDataTmp = [];
    defaultGridData.forEach((item, rowNum) => {
      activateCellEditTmp = ChangeRowState(
        item,
        item["_grid_row_id_"],
        newEditModeValue
      );
    });
    setActivateCellEdit(activateCellEditTmp);
    if (!props.enableSaveGridOnCellValueChange) {
      if (!newEditModeValue) {
        defaultGridData.forEach((item, rowNum) => {
          defaultGridDataTmp = SaveRowValue(
            item,
            item["_grid_row_id_"],
            defaultGridData
          );
        });
        setDefaultGridData(defaultGridDataTmp);
      }
    }
    setEditMode(newEditModeValue);
  };
  const CancelGridEditMode = () => {
    SetGridItems(cancellableRows);
    setCancellableRows([]);
    setEditMode(false);
  };
  const activateEditRef = React.useRef(null);
  React.useEffect(() => {
    const handleCopy = (event) => {
      var _a3;
      if (event.key === "Enter" && !cursorFlashing && selectedItems) {
        if (!props.disableInlineCellEdit) {
          ShowRowEditMode(
            selectedItems[0],
            (_a3 = selectedItems[0]) == null ? void 0 : _a3["_grid_row_id_"],
            !activateCellEdit[selectedItems[0]["_grid_row_id_"]].isActivated
          );
        }
      }
    };
    const activate = copyRef.current;
    if (activate) {
      activate.addEventListener("keydown", handleCopy);
    }
    return () => {
      if (activate) {
        activate.removeEventListener("keydown", handleCopy);
      }
    };
  }, [cursorFlashing, selectedIndices]);
  const copyRef = React.useRef(null);
  React.useEffect(() => {
    const handleCopy = (event) => {
      if (event.ctrlKey && event.key === "c" && !cursorFlashing) {
        if (props.gridCopyOptions && props.gridCopyOptions.enableGridCopy) {
          CopyGridRows();
        }
      }
    };
    const copyOutGrid = copyRef.current;
    if (copyOutGrid) {
      copyOutGrid.addEventListener("keydown", handleCopy);
    }
    return () => {
      if (copyOutGrid) {
        copyOutGrid.removeEventListener("keydown", handleCopy);
      }
    };
  }, [cursorFlashing, selectedIndices]);
  const CopyGridRows = () => {
    var _a3;
    if (selectedIndices.length == 0) {
      const newMap = new Map(interalMessagesState).set((_a3 = props.id) == null ? void 0 : _a3.toString(), {
        msg: "No Rows Selected - Please select some rows to perform this operation ",
        type: MessageBarType.info
      });
      setInteralMessagesState(newMap);
      return;
    }
    var copyText = "";
    selectedItems.forEach((i) => {
      copyText += ConvertObjectToText(
        forceKeyMapping(defaultGridData, "key").filter(
          (x) => x["_grid_row_id_"] == i["_grid_row_id_"]
        )[0],
        props.columns.filter((x) => x.includeColumnInCopy ?? true)
      ) + "\r\n";
    });
    navigator.clipboard.writeText(copyText).then(
      function() {
        const newMap = new Map(interalMessagesState).set(props.id.toString(), {
          msg: selectedIndices.length + ` ${selectedIndices.length == 1 ? "Row" : "Rows"} Copied To Clipboard`,
          type: MessageBarType.success
        });
        setInteralMessagesState(newMap);
      },
      function() {
      }
    );
  };
  const isClipboardEmpty = async () => {
    try {
      const clipboardItems = await navigator.clipboard.read();
      return clipboardItems.length === 0;
    } catch (error) {
      const newMap = new Map(interalMessagesState).set(props.id.toString(), {
        msg: "Failed To Get Clipboard. Make sure permissions have been given. If you just now pressed allow, then please re-paste the data ",
        type: MessageBarType.error
      });
      setInteralMessagesState(newMap);
      return true;
    }
  };
  const setupPastedData = (rowData, addedRows) => {
    var _a3, _b3, _c3, _d2, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
    const newColObj = {};
    var colKeys = Object.keys(columnValuesObj);
    if (columnKeyPasteRef.current && ((_a3 = columnKeyPasteRef.current) == null ? void 0 : _a3.key)) {
      const valueIndex = colKeys.findIndex(
        (element) => {
          var _a4;
          return element == ((_a4 = columnKeyPasteRef.current) == null ? void 0 : _a4.key);
        }
      );
      const copyRowData = [...rowData];
      for (let index2 = 0; index2 < colKeys.length; index2++) {
        const element = colKeys[index2];
        if (index2 == valueIndex) {
          for (let j = 0; j < copyRowData.length; j++) {
            rowData.splice(index2 + j - 1, 1, copyRowData[j]);
          }
          break;
        } else if (element != ((_b3 = columnKeyPasteRef.current) == null ? void 0 : _b3.key))
          rowData.splice(index2, 1, "");
      }
    }
    if (indentiferColumn.current) {
      rowData.splice(0, 0, indentiferColumn.current);
    }
    for (let index2 = 0; index2 < rowData.length; index2++) {
      const currentVal = rowData[index2];
      const colKeysVal = colKeys[index2];
      if (indentiferColumn.current && colKeysVal == indentiferColumn.current) {
        continue;
      }
      const trimmedCurrentVal = (_d2 = (_c3 = currentVal == null ? void 0 : currentVal.toString()) == null ? void 0 : _c3.toLowerCase()) == null ? void 0 : _d2.trim();
      if ((_e2 = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _e2.columnEditable) {
        if (trimmedCurrentVal === "false") {
          newColObj[colKeysVal] = false;
        } else if (trimmedCurrentVal === "true") {
          newColObj[colKeysVal] = true;
        } else if (((_f = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _f.dataType) == "number") {
          const modifiedValue = parseFloat(
            (trimmedCurrentVal ?? "0").replaceAll(",", "") ?? "0"
          );
          let value = Number(Number(modifiedValue ?? 0).toFixed(4)) ?? 0;
          if (isNaN(value) == false) {
            if ((_h = (_g = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _g.validations) == null ? void 0 : _h.numberBoundaries) {
              const minRange = (_j = (_i = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _i.validations) == null ? void 0 : _j.numberBoundaries.minRange;
              const maxRange = (_l = (_k = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _k.validations) == null ? void 0 : _l.numberBoundaries.maxRange;
              if (value < minRange) {
                value = minRange;
              } else if (value > maxRange) {
                value = maxRange;
              }
            }
          } else {
            value = 0;
          }
          newColObj[colKeysVal] = value;
        } else {
          if (((_m = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _m.dataType) == "boolean") {
            if (trimmedCurrentVal == "1" || trimmedCurrentVal == "0") {
              newColObj[colKeysVal] = trimmedCurrentVal == "1" ? true : false;
            } else if (trimmedCurrentVal == "y" || trimmedCurrentVal == "n") {
              newColObj[colKeysVal] = trimmedCurrentVal == "y" ? true : false;
            }
          } else {
            newColObj[colKeysVal] = ((_n = currentVal == null ? void 0 : currentVal.toString()) == null ? void 0 : _n.trim()) ?? null;
          }
        }
      } else {
        if (((_o = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _o.dataType) == "boolean") {
          newColObj[colKeysVal] = ((_p = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _p.defaultValueOnNewRow) ?? false;
        } else if (((_q = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _q.dataType) == "number") {
          const modifiedValue = parseFloat(
            (((_s = (_r = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _r.defaultValueOnNewRow) == null ? void 0 : _s.toString()) ?? "0").replaceAll(",", "") ?? "0"
          );
          const value = Number(Number(modifiedValue ?? 0).toFixed(4)) ?? 0;
          newColObj[colKeysVal] = isNaN(value) ? 0 : value;
        } else if (((_t = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _t.dataType) == "string") {
          newColObj[colKeysVal] = ((_u = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _u.defaultValueOnNewRow) ?? "";
        } else {
          newColObj[colKeysVal] = ((_v = columnValuesObj == null ? void 0 : columnValuesObj[colKeysVal]) == null ? void 0 : _v.defaultValueOnNewRow) ?? null;
        }
      }
    }
    if (trackTransformedData.current) {
      trackTransformedData.current.forEach(function(value, key) {
        var _a4, _b4, _c4, _d3;
        for (let index2 = 0; index2 < value.values.length; index2++) {
          const element = value.values[index2];
          if (((_b4 = (_a4 = element == null ? void 0 : element.text) == null ? void 0 : _a4.toString()) == null ? void 0 : _b4.toLowerCase()) === (((_d3 = (_c4 = newColObj[key]) == null ? void 0 : _c4.toString()) == null ? void 0 : _d3.toLowerCase()) ?? "")) {
            newColObj[key] = element == null ? void 0 : element.key;
          }
        }
      });
    }
    addedRows.map((row) => {
      var objectKeys = Object.keys(newColObj);
      objectKeys.forEach((key) => {
        row[key] = newColObj[key];
      });
      return row;
    });
    return addedRows[0];
  };
  const pasteRef = React.useRef(null);
  React.useEffect(() => {
    const handlePaste = (event) => {
      if (event.ctrlKey && event.key === "v") {
        if (props.gridCopyOptions && props.gridCopyOptions.enableGridPaste && !props.enableDefaultEditMode) {
          PasteGridRows(cursorFlashing);
        }
      }
    };
    const gridToPasteInto = pasteRef.current;
    if (gridToPasteInto) {
      gridToPasteInto.addEventListener("keydown", handlePaste);
    }
    return () => {
      if (gridToPasteInto) {
        gridToPasteInto.removeEventListener("keydown", handlePaste);
      }
    };
  }, [columnValuesObj, indentiferColumn, cursorFlashing, defaultGridData]);
  const startPasting = async (overwriteFirstRow) => {
    let ui = [];
    let pastedData = "";
    let lines = [];
    let rowData = [];
    let singleColChange = false;
    try {
      var newGridData = [...defaultGridData];
      await navigator.clipboard.readText().then((text) => {
        pastedData = text;
        lines = text.split("\n");
        if (lines.length <= 0) {
          const newMap2 = new Map(interalMessagesState).set(
            props.id.toString(),
            {
              msg: "Unable To Add This Data - Please try again. Data is not sufficient ",
              type: MessageBarType.error
            }
          );
          setInteralMessagesState(newMap2);
          return;
        }
        var colKeys = Object.keys(columnValuesObj).filter(
          (item) => item !== indentiferColumn.current
        );
        for (let index2 = 0; index2 < lines.length; index2++) {
          const row = lines[index2];
          if (row.length <= 0)
            continue;
          if (!row.includes("	") && !row.includes("\r")) {
            setGridEditState(false);
            return;
          }
          rowData = row.split("	");
          if (overwriteFirstRow && index2 == 0 && columnKeyPasteRef.current !== null) {
            var colKeys = Object.keys(columnValuesObj);
            const valueIndex = colKeys.findIndex(
              (element) => {
                var _a3;
                return element == ((_a3 = columnKeyPasteRef.current) == null ? void 0 : _a3.key);
              }
            );
            let currentElement = 0;
            props.columns.forEach((column2, i) => {
              var _a3, _b3, _c3, _d2, _e2, _f;
              if (columnKeyPasteRef.current) {
                if (i >= valueIndex) {
                  if (column2.editable) {
                    const trimmedRowValue = (_c3 = (_b3 = (_a3 = rowData[currentElement]) == null ? void 0 : _a3.toString()) == null ? void 0 : _b3.toLowerCase()) == null ? void 0 : _c3.trim();
                    singleColChange = true;
                    if (trimmedRowValue === "false") {
                      newGridData[columnKeyPasteRef.current._grid_row_id_][column2.key] = false;
                    } else if (trimmedRowValue === "true") {
                      newGridData[columnKeyPasteRef.current._grid_row_id_][column2.key] = true;
                    } else if ((column2 == null ? void 0 : column2.dataType) == "number") {
                      const modifiedValue = parseFloat(
                        (trimmedRowValue ?? "0").replaceAll(",", "") ?? "0"
                      );
                      let value = Number(Number(modifiedValue ?? 0).toFixed(4)) ?? 0;
                      if (isNaN(value) == false) {
                        if ((_d2 = column2 == null ? void 0 : column2.validations) == null ? void 0 : _d2.numberBoundaries) {
                          const minRange = (_e2 = column2 == null ? void 0 : column2.validations) == null ? void 0 : _e2.numberBoundaries.minRange;
                          const maxRange = (_f = column2 == null ? void 0 : column2.validations) == null ? void 0 : _f.numberBoundaries.maxRange;
                          if (value < minRange) {
                            value = minRange;
                          } else if (value > maxRange) {
                            value = maxRange;
                          }
                        }
                      } else {
                        value = 0;
                      }
                      newGridData[columnKeyPasteRef.current._grid_row_id_][column2.key] = value;
                    } else {
                      if (column2.dataType == "boolean") {
                        if (trimmedRowValue == "1" || trimmedRowValue == "0") {
                          newGridData[columnKeyPasteRef.current._grid_row_id_][column2.key] = trimmedRowValue == "1" ? true : false;
                        } else if (trimmedRowValue == "y" || trimmedRowValue == "n") {
                          newGridData[columnKeyPasteRef.current._grid_row_id_][column2.key] = trimmedRowValue == "y" ? true : false;
                        }
                      } else {
                        newGridData[columnKeyPasteRef.current._grid_row_id_][column2.key] = forceKeyMappingOptimized(
                          column2.key,
                          rowData[currentElement],
                          "text",
                          false
                        ) ?? newGridData[columnKeyPasteRef.current._grid_row_id_][column2.key];
                      }
                    }
                  }
                  currentElement++;
                }
              }
            });
            continue;
          }
          var pushSingleRow = void 0;
          if (columnKeyPasteRef.current && overwriteFirstRow && singleColChange)
            pushSingleRow = newGridData[columnKeyPasteRef.current._grid_row_id_];
          let _temp_new_grid_row_id_ = Math.max.apply(
            Math,
            defaultGridData.map(function(o) {
              return o._grid_row_id_ + index2 + 1;
            })
          );
          const startPush = setupPastedData(
            [...rowData],
            GetDefaultRowObject(1, _temp_new_grid_row_id_)
          );
          if (startPush !== null) {
            ui.push(startPush);
          } else {
            return;
          }
        }
        ui.forEach((i) => {
          newGridData.splice(0, 0, i);
        });
        let newMap = new Map(interalMessagesState);
        if ((ui == null ? void 0 : ui.length) > 0) {
          if (rowData.length > colKeys.length) {
            newMap.set(props.id.toString(), {
              msg: `Pasted ${ui.length} ${ui.length > 1 ? "rows" : "row"} from clipboard. You pasted in more columns than this grid contains. ${rowData.length - colKeys.length} ${rowData.length - colKeys.length > 1 ? "columns have" : "column has"} been removed.`,
              type: MessageBarType.success
            });
          } else {
            newMap.set(props.id.toString(), {
              msg: `Pasted ${ui.length} ${ui.length > 1 ? "Rows" : "Row"} From Clipboard`,
              type: MessageBarType.success
            });
          }
          setInteralMessagesState(newMap);
          if (singleColChange && pushSingleRow) {
            ui.push(pushSingleRow);
          }
          SetGridItems(
            CheckBulkUpdateOnChangeCallBack(
              Object.keys(columnValuesObj).reduce(
                (a, v) => ({ ...a, [v]: v }),
                {}
              ),
              newGridData,
              ui
            )
          );
          clearSelectedItems();
          setGridEditState(true);
        } else if (singleColChange) {
          try {
            SetGridItems(
              CheckBulkUpdateOnChangeCallBack(
                Object.keys(columnValuesObj).reduce(
                  (a, v) => ({ ...a, [v]: v }),
                  {}
                ),
                newGridData,
                [
                  newGridData.filter(
                    (x) => {
                      var _a3;
                      return x._grid_row_id_ == ((_a3 = columnKeyPasteRef.current) == null ? void 0 : _a3._grid_row_id_);
                    }
                  )[0]
                ]
              )
            );
          } catch (error) {
            SetGridItems(newGridData);
          }
          clearSelectedItems();
          setGridEditState(true);
        }
        return;
      }).catch((error) => {
        console.error(error);
        setGridEditState(false);
        const newMap = new Map(interalMessagesState).set(
          props.id.toString(),
          {
            msg: "Failed To Paste Rows From Clipboard",
            type: MessageBarType.error
          }
        );
        setInteralMessagesState(newMap);
        return;
      });
    } catch (error) {
      return;
    }
  };
  const PasteGridRows = (overwriteFirstRow) => {
    isClipboardEmpty().then((empty) => {
      var _a3;
      if (empty) {
        const newMap = new Map(interalMessagesState).set(props.id.toString(), {
          msg: "Nothing In Clipboard - Please copy this grid or an excel with the same columns and try again ",
          type: MessageBarType.info
        });
        setInteralMessagesState(newMap);
        return;
      } else {
        let proceedWithColumnPasting = true;
        if (((_a3 = columnKeyPasteRef.current) == null ? void 0 : _a3.inputType) && overwriteFirstRow) {
          switch (columnKeyPasteRef.current.inputType) {
            case EditControlType.MultilineTextField:
              proceedWithColumnPasting = false;
              break;
            case EditControlType.Date:
              proceedWithColumnPasting = false;
              break;
            case EditControlType.Password:
              proceedWithColumnPasting = false;
              break;
            default:
              proceedWithColumnPasting = true;
              break;
          }
        }
        if (proceedWithColumnPasting) {
          startPasting(overwriteFirstRow).then((success) => {
            return;
          });
        } else {
          return;
        }
      }
    });
  };
  const getGridRecordLength = React.useCallback(
    (justLength) => {
      var _a3;
      if (justLength) {
        if (defaultGridData) {
          const deletedRows2 = defaultGridData.filter(
            (x) => x._grid_row_operation_ === _Operation.Delete
          ).length;
          return (_a3 = defaultGridData.length - deletedRows2) == null ? void 0 : _a3.toString();
        } else {
          return "0";
        }
      }
      const deletedRows = defaultGridData.filter(
        (x) => x._grid_row_operation_ === _Operation.Delete
      ).length;
      return `${defaultGridData.filter(
        (x) => x._grid_row_operation_ != _Operation.Delete && x._is_filtered_in_ == true && x._is_filtered_in_grid_search_ == true && x._is_filtered_in_column_filter_ == true
      ).length}/${defaultGridData.length - deletedRows}`;
    },
    [defaultGridData]
  );
  const HandleRowSingleDelete = (rowNum) => {
    let defaultGridDataTmp = [...defaultGridData];
    if (props.enableSaveGridOnCellValueChange) {
      defaultGridDataTmp.filter((x) => x._grid_row_id_ === rowNum).map((x) => {
        var _a3;
        x._grid_row_operation_ = _Operation.Delete;
        if (props.customOperationsKey)
          x[props.customOperationsKey.colKey] = ((_a3 = props.customOperationsKey.options) == null ? void 0 : _a3.Delete) ?? _Operation.Delete;
      });
      setDefaultGridData(defaultGridDataTmp);
    } else {
      defaultGridDataTmp.filter((x) => x._grid_row_id_ == rowNum).map((x) => {
        var _a3;
        x._grid_row_operation_ = _Operation.Delete;
        if (props.customOperationsKey)
          x[props.customOperationsKey.colKey] = ((_a3 = props.customOperationsKey.options) == null ? void 0 : _a3.Delete) ?? _Operation.Delete;
      });
      SetGridItems(defaultGridDataTmp);
      setGridEditState(true);
    }
  };
  const RowSelectOperations = (type, item) => {
    switch (type) {
      case EditType.BulkEdit:
        if (selectedIndices.length > 0) {
          setIsOpenForEdit(true);
        } else {
          const newMap = new Map(interalMessagesState).set(
            props.id.toString(),
            {
              msg: "No Rows Selected - Please select some rows to perform this operation ",
              type: MessageBarType.info
            }
          );
          setInteralMessagesState(newMap);
        }
        break;
      case EditType.ColumnEdit:
        if (selectedIndices.length > 0) {
          ShowColumnUpdate();
        } else {
          const newMap = new Map(interalMessagesState).set(
            props.id.toString(),
            {
              msg: "No Rows Selected - Please select some rows to perform this operation ",
              type: MessageBarType.info
            }
          );
          setInteralMessagesState(newMap);
          return false;
        }
        break;
      case EditType.AddRow:
        AddRowsToGrid();
        break;
      case EditType.DeleteRow:
        if (selectedIndices.length > 0) {
          DeleteSelectedRows();
          clearSelectedItems();
        } else {
          const newMap = new Map(interalMessagesState).set(
            props.id.toString(),
            {
              msg: "No Rows Selected - Please select some rows to perform this operation ",
              type: MessageBarType.info
            }
          );
          setInteralMessagesState(newMap);
        }
        break;
      case EditType.ColumnFilter:
        ShowColumnFilterDialog();
        break;
      case EditType.AddRowWithData:
        if (!props.enableInlineGridAdd) {
          setIsOpenForAdd(true);
        } else {
          AddRowsToGrid();
        }
        break;
    }
    return true;
  };
  const ResetGridData = () => {
    var _a3, _b3, _c3, _d2;
    if (props.showASaveButtonInCommandbar || !props.enableSaveGridOnCellValueChange) {
      setDialogContent(
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            id: ((_b3 = (_a3 = CommandBarTitles == null ? void 0 : CommandBarTitles.ResetData) == null ? void 0 : _a3.dialogBox) == null ? void 0 : _b3.title) ?? "Confirmation",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text, { children: ((_d2 = (_c3 = CommandBarTitles == null ? void 0 : CommandBarTitles.ResetData) == null ? void 0 : _c3.dialogBox) == null ? void 0 : _d2.msg) ?? "This action will reset any unsaved changes, if this is not intended please press 'Cancel'" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  PrimaryButton,
                  {
                    onClick: () => {
                      setGridEditState(false);
                      ClearFilters();
                      SetGridItems(backupDefaultGridData.map((obj) => ({ ...obj })));
                      CloseDialog();
                    },
                    text: "Ok"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DefaultButton,
                  {
                    text: "Cancel",
                    onClick: () => CloseDialog()
                  }
                )
              ] })
            ]
          }
        )
      );
    } else {
      setGridEditState(false);
      ClearFilters();
      SetGridItems(backupDefaultGridData.map((obj) => ({ ...obj })));
    }
  };
  const onColumnContextMenu = (ev, column2, index2) => {
    if (ev && column2) {
      ev.preventDefault();
      ShowFilterForColumn(column2, index2);
    }
  };
  const onColumnClick = (column2, ev) => {
    setContextualMenuProps(getContextualMenuProps(ev, column2));
  };
  function _copyAndSort(items, columnKey, isSortedDescending) {
    const key = columnKey;
    return items.slice(0).sort(
      (a, b) => (isSortedDescending ? a[key] < b[key] : a[key] > b[key]) ? 1 : -1
    );
  }
  const getFilterStoreRef = () => {
    return filterStoreRef.current;
  };
  const setFilterStoreRef = (value) => {
    filterStoreRef.current = value;
  };
  const clearFilterStoreRef = () => {
    filterStoreRef.current = [];
  };
  const CloseColumnFilterDialog = () => {
    setIsColumnFilterClicked(false);
  };
  const ShowColumnFilterDialog = () => {
    setIsColumnFilterClicked((s) => !s);
  };
  const onFilterApplied = (filter) => {
    var tags = [...defaultTag];
    tags.push({
      name: "'" + filter.column.name + "' " + filter.operator + " '" + filter.value + "'",
      key: filter.column.key
    });
    var filterStoreTmp = getFilterStoreRef();
    filterStoreTmp.push(filter);
    setFilterStoreRef(filterStoreTmp);
    setFilteredColumns((filteredColumns2) => [
      ...filteredColumns2,
      filter.column
    ]);
    setDefaultTag(tags);
    CloseColumnFilterDialog();
  };
  const ClearFilters = () => {
    setDefaultTag([]);
    clearFilterStoreRef();
    setFilteredColumns([]);
  };
  const onFilterTagListChanged = React.useCallback(
    (tagList) => {
      if (tagList != null && tagList.length == 0) {
        ClearFilters();
        return;
      }
      var filterStoreTmp = [];
      tagList.forEach((item) => {
        var storeRow = getFilterStoreRef().filter(
          (val) => val.column.key == item.key
        );
        if (storeRow.length > 0) {
          filterStoreTmp.push(storeRow[0]);
        }
      });
      setFilterStoreRef(filterStoreTmp);
      var filteredColumnsTmp = [];
      filteredColumnsTmp = props.columns.filter(
        (item) => tagList.filter((val) => val.key == item.key).length > 0
      );
      setFilteredColumns(filteredColumnsTmp);
      setDefaultTag(tagList);
    },
    []
  );
  const onFilterChanged = React.useCallback(
    (filterText, tagList) => {
      var emptyITag = [];
      return emptyITag;
    },
    []
  );
  const getTextFromItem = (item) => {
    return item.name;
  };
  const pickerSuggestionsProps = {
    suggestionsHeaderText: "Suggested tags",
    noResultsFoundText: "No item tags found"
  };
  const inputProps = {
    "aria-label": "Tag Picker"
  };
  const onFilterApply = (filter) => {
    UpdateColumnFilterValues(filter);
    var GridColumnFilterArr = getColumnFiltersRef();
    var filteredData = applyGridColumnFilter(
      forceKeyMapping(defaultGridData, "key"),
      GridColumnFilterArr
    );
    getColumnFiltersRefForColumnKey(filter.columnKey).isApplied = filter.filterList.filter((i) => i.isChecked).length > 0 && filter.filterList.filter((i) => i.isChecked).length < filter.filterList.length ? true : false;
    var activateCellEditTmp = ShallowCopyDefaultGridToEditGrid(
      forceKeyMapping(defaultGridData, "key"),
      activateCellEdit
    );
    setDefaultGridData(filteredData);
    setActivateCellEdit(activateCellEditTmp);
    setGridData(filteredData);
    setFilterCalloutComponent(void 0);
    onGridFiltered();
  };
  const UpdateColumnFilterValues = (filter) => {
    var gridColumnFilter = getColumnFiltersRefForColumnKey(
      filter.columnKey
    );
    gridColumnFilter.filterCalloutProps.filterList = filter.filterList;
    gridColumnFilter.isHidden = true;
    gridColumnFilter.isApplied = true;
  };
  const ShowFilterForColumn = (column2, index2) => {
    var filter = getColumnFiltersRefAtIndex(index2);
    filter.isHidden = !filter.isHidden;
    if (filter.isHidden) {
      setFilterCalloutComponent(void 0);
      return;
    }
    var filters = getColumnFiltersRef();
    filters.filter(
      (item) => item.index != filter.index && item.column.key != filter.column.key
    ).map((item) => item.isHidden = true);
    filter.filterCalloutProps.filterList = GetUniqueColumnValues(
      column2,
      filter.filterCalloutProps.filterList
    );
    setFilterCalloutComponent(
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FilterCallout,
        {
          onCancel: () => {
            setFilterCalloutComponent(void 0);
          },
          onApply: onFilterApply,
          columnKey: filter.filterCalloutProps.columnKey,
          columnName: filter.filterCalloutProps.columnName,
          filterList: filter.filterCalloutProps.filterList,
          columnClass: filter.filterCalloutProps.columnClass
        }
      )
    );
  };
  const GetUniqueColumnValues = (column2, prevFilters) => {
    var uniqueVals = [
      ...new Set(
        defaultGridData.filter(
          (x) => x._grid_row_operation_ != _Operation.Delete && x._is_filtered_in_column_filter_ == true && x._is_filtered_in_grid_search_ == true
        ).map((item) => item[column2.fieldName]).map((x) => {
          return forceKeyMappingOptimized(column2.fieldName, x, "key");
        }).sort()
      )
    ];
    var hiddenUniqueVals = [
      ...new Set(
        defaultGridData.filter(
          (x) => x._grid_row_operation_ != _Operation.Delete && (x._is_filtered_in_column_filter_ == false || x._is_filtered_in_grid_search_ == false)
        ).map((item) => item[column2.fieldName]).map((x) => {
          return forceKeyMappingOptimized(column2.fieldName, x, "key");
        }).sort()
      )
    ];
    var filterItemArr = [];
    if (!prevFilters || prevFilters.length == 0) {
      filterItemArr = uniqueVals.map((item) => {
        return { text: item, isChecked: true };
      });
    } else {
      filterItemArr = uniqueVals.map((item) => {
        var filters = prevFilters.filter((i) => i.text == item);
        return {
          text: item,
          isChecked: filters.length > 0 ? filters[0].isChecked : true
        };
      });
    }
    return [
      ...filterItemArr,
      ...hiddenUniqueVals.filter((i) => !uniqueVals.includes(i)).map((i) => {
        return { text: i, isChecked: false };
      })
    ];
  };
  const getColumnFiltersRef = () => {
    return gridColumnFilterArrRef.current;
  };
  const getColumnFiltersRefAtIndex = (index2) => {
    return gridColumnFilterArrRef.current[index2];
  };
  const getColumnFiltersRefForColumnKey = (key) => {
    var gridColumnFilterArr = [
      ...gridColumnFilterArrRef.current
    ];
    return gridColumnFilterArr.filter((item) => item.column.key == key)[0];
  };
  const setColumnFiltersRef = (value) => {
    gridColumnFilterArrRef.current = value;
  };
  const [comboOptions, setComboOptions] = React.useState(/* @__PURE__ */ new Map());
  const [init, setInit] = React.useState(/* @__PURE__ */ new Map());
  const disableDropdown = React.useRef(/* @__PURE__ */ new Map());
  const disableComboBox = React.useRef(/* @__PURE__ */ new Map());
  const initalComboBoxOptions = React.useRef(
    /* @__PURE__ */ new Map()
  );
  const trackTransformedData = React.useRef(/* @__PURE__ */ new Map());
  const CreateColumnConfigs = () => {
    let columnConfigs = [];
    let columnFilterArrTmp = [];
    props.columns.forEach((column2, index2) => {
      var colHeaderClassName = "id-" + props.id + "-col-" + index2;
      var colKey = "col" + index2;
      var isDataTypeSupportedForFilter = isColumnDataTypeSupportedForFilter(column2.dataType);
      columnConfigs.push({
        key: colKey,
        name: column2.text,
        headerClassName: colHeaderClassName,
        data: column2.data,
        ariaLabel: column2.text,
        fieldName: column2.key,
        isResizable: column2.isResizable,
        minWidth: column2.minWidth,
        maxWidth: column2.maxWidth,
        flexGrow: column2.flexGrow,
        targetWidthProportion: column2.targetWidthProportion,
        calculatedWidth: column2.calculatedWidth,
        isPadded: column2.isPadded,
        onColumnContextMenu: (
          // !(isGridInEdit || editMode) &&
          isDataTypeSupportedForFilter && !editMode && column2.applyColumnFilter && props.enableColumnFilters ? !props.enableSaveGridOnCellValueChange && isGridInEdit ? void 0 : (col, ev) => onColumnContextMenu(ev, col, index2) : void 0
        ),
        onColumnClick: !column2.disableSort && !editMode ? !props.enableSaveGridOnCellValueChange && isGridInEdit ? void 0 : (ev, col) => onColumnClick(col, ev) : void 0,
        isSorted: sortColObj.isEnabled && sortColObj.key == colKey,
        isSortedDescending: !(sortColObj.isEnabled && sortColObj.key == colKey) || !sortColObj.isAscending,
        isFiltered: isDataTypeSupportedForFilter && column2.applyColumnFilter && props.enableColumnFilters && getColumnFiltersRef() && getColumnFiltersRef().length > 0 && getColumnFiltersRef().filter((i) => i.column.key == column2.key).length > 0 && getColumnFiltersRef().filter((i) => i.column.key == column2.key)[0].isApplied ? true : false,
        sortAscendingAriaLabel: "Sorted A to Z",
        sortDescendingAriaLabel: "Sorted Z to A",
        onRender: column2.onRender ? column2.onRender : (item, rowNum) => {
          var _a3, _b3, _c3, _d2, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __, _$, _aa, _ba, _ca, _da, _ea, _fa, _ga, _ha, _ia, _ja, _ka, _la, _ma, _na, _oa, _pa, _qa, _ra, _sa, _ta, _ua, _va, _wa, _xa, _ya, _za, _Aa, _Ba, _Ca, _Da, _Ea, _Fa, _Ga, _Ha, _Ia, _Ja, _Ka, _La, _Ma, _Na, _Oa, _Pa, _Qa, _Ra, _Sa, _Ta, _Ua, _Va, _Wa, _Xa, _Ya, _Za;
          rowNum = Number(item["_grid_row_id_"]);
          if (column2.dropdownValues && column2.inputType == EditControlType.DropDown) {
            trackTransformedData.current = new Map(
              trackTransformedData.current
            ).set(column2.key, {
              colkey: column2.key,
              values: column2.dropdownValues
            });
            if (column2.filterDropdownOptions) {
              for (let index22 = 0; index22 < column2.filterDropdownOptions.filterOptions.length; index22++) {
                column2.filterDropdownOptions.filterOptions[index22];
              }
            }
          }
          if (column2.precision) {
            const checkNaN = parseFloat(item[column2.key]).toFixed(
              column2.precision
            );
            item[column2.key] = isNaN(parseFloat(checkNaN)) ? item[column2.key] : checkNaN;
          }
          if (column2.dataType == "date" && item[column2.key]) {
            item[column2.key] = new Date(item[column2.key]).toDateString();
          }
          if (column2.autoGenerate) {
            tempAutoGenId.current = isNaN(parseInt(item[column2.key])) === false ? parseInt(item[column2.key]) : tempAutoGenId.current + 1;
          }
          if (column2.comboBoxOptions) {
            const newMap = /* @__PURE__ */ new Map();
            newMap.set(column2.key + rowNum, column2.comboBoxOptions ?? []);
            initalComboBoxOptions.current = newMap;
          }
          switch (column2.inputType) {
            case EditControlType.MultilineTextField:
              return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ShouldRenderSpan() ? ((_a3 = column2 == null ? void 0 : column2.hoverComponentOptions) == null ? void 0 : _a3.enable) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                HoverCard,
                {
                  type: HoverCardType.plain,
                  plainCardProps: {
                    onRenderPlainCard: () => onRenderPlainCard(column2, rowNum, item)
                  },
                  instantOpenOnClick: true,
                  children: RenderMultilineTextFieldSpan(
                    props,
                    index2,
                    rowNum,
                    column2,
                    item,
                    EditCellValue
                  )
                }
              ) : RenderMultilineTextFieldSpan(
                props,
                index2,
                rowNum,
                column2,
                item,
                EditCellValue
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  errorMessage: (_b3 = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _b3.error,
                  label: item.text,
                  ariaLabel: column2.key,
                  multiline: true,
                  rows: 1,
                  styles: textFieldStyles$1,
                  onChange: (ev, text) => onCellValueChange(
                    ev,
                    text,
                    item,
                    rowNum,
                    column2.key,
                    column2
                  ),
                  autoFocus: !props.enableDefaultEditMode && !editMode && !(activateCellEdit && activateCellEdit[Number(item["_grid_row_id_"])] && activateCellEdit[Number(item["_grid_row_id_"])]["isActivated"]),
                  value: ((_c3 = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _c3.value) ?? "",
                  maxLength: column2.maxLength != null ? column2.maxLength : 1e4,
                  onFocus: (ev) => handleFocus(
                    column2.key,
                    EditControlType.MultilineTextField,
                    Number(item["_grid_row_id_"])
                  ),
                  onBlur: (ev) => handleBlur()
                }
              ) });
            case EditControlType.Date:
              return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ShouldRenderSpan() ? ((_d2 = column2 == null ? void 0 : column2.hoverComponentOptions) == null ? void 0 : _d2.enable) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                HoverCard,
                {
                  type: HoverCardType.plain,
                  plainCardProps: {
                    onRenderPlainCard: () => onRenderPlainCard(column2, rowNum, item)
                  },
                  instantOpenOnClick: true,
                  children: RenderDateSpan(
                    props,
                    index2,
                    rowNum,
                    column2,
                    item,
                    EditCellValue
                  )
                }
              ) : RenderDateSpan(
                props,
                index2,
                rowNum,
                column2,
                item,
                EditCellValue
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                DatePicker,
                {
                  strings: DayPickerStrings,
                  placeholder: "Select a date...",
                  ariaLabel: column2.key,
                  value: new Date(
                    activateCellEdit[rowNum].properties[column2.key].value
                  ),
                  onSelectDate: (date) => onCellDateChange(date, item, rowNum, column2),
                  onFocus: (ev) => handleFocus(
                    column2.key,
                    EditControlType.Date,
                    Number(item["_grid_row_id_"])
                  ),
                  onBlur: (ev) => handleBlur()
                }
              ) });
            case EditControlType.CheckBox:
              return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "row-" + rowNum + "-col-" + index2, children: ShouldRenderSpan() ? ((_e2 = column2 == null ? void 0 : column2.hoverComponentOptions) == null ? void 0 : _e2.enable) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                HoverCard,
                {
                  type: HoverCardType.plain,
                  plainCardProps: {
                    onRenderPlainCard: () => onRenderPlainCard(column2, rowNum, item)
                  },
                  instantOpenOnClick: true,
                  children: RenderCheckboxSpan(
                    props,
                    index2,
                    rowNum,
                    column2,
                    item,
                    EditCellValue
                  )
                }
              ) : RenderCheckboxSpan(
                props,
                index2,
                rowNum,
                column2,
                item,
                EditCellValue
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                Checkbox,
                {
                  styles: { root: { justifyContent: "center" } },
                  ariaLabel: column2.key,
                  checked: (_f = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _f.value,
                  onChange: (ev, isChecked) => {
                    onCheckBoxChange(
                      ev,
                      rowNum,
                      column2,
                      isChecked,
                      item
                    );
                  }
                }
              ) });
            case EditControlType.DropDown:
              if (column2.disableDropdown && typeof column2.disableDropdown !== "boolean") {
                let newMap = new Map(disableDropdown.current);
                for (let index22 = 0; index22 < [column2.disableDropdown].length; index22++) {
                  const disableCellOptions = [column2.disableDropdown][index22];
                  const str = item[disableCellOptions.disableBasedOnThisColumnKey];
                  if (disableCellOptions.type === DisableColTypes.DisableWhenColKeyHasData) {
                    if (str && (str == null ? void 0 : str.toString().length) > 0 && (newMap.get(column2.key + rowNum) ?? false) === false) {
                      newMap.set(column2.key + rowNum, true);
                      disableDropdown.current = newMap;
                    } else if (newMap.get(column2.key + rowNum) == true && !str) {
                      newMap.set(column2.key + rowNum, false);
                      disableDropdown.current = newMap;
                    }
                  } else if (disableCellOptions.type === DisableColTypes.DisableWhenColKeyIsEmpty) {
                    if (str == "" || str && (str == null ? void 0 : str.toString().length) <= 0) {
                      newMap.set(column2.key + rowNum, true);
                    } else if ((str === null || str === void 0) && (newMap.get(column2.key + rowNum) ?? false) === false) {
                      newMap.set(column2.key + rowNum, true);
                    } else if ((newMap.get(column2.key + rowNum) ?? true) !== false && str && (str == null ? void 0 : str.toString().length) > 0) {
                      newMap.set(column2.key + rowNum, false);
                    }
                  }
                }
                disableDropdown.current = newMap;
              }
              return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "row-" + rowNum + "-col-" + index2, children: ShouldRenderSpan() ? ((_g = column2 == null ? void 0 : column2.hoverComponentOptions) == null ? void 0 : _g.enable) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                HoverCard,
                {
                  type: HoverCardType.plain,
                  plainCardProps: {
                    onRenderPlainCard: () => onRenderPlainCard(column2, rowNum, item)
                  },
                  instantOpenOnClick: true,
                  children: RenderDropdownSpan(
                    props,
                    index2,
                    rowNum,
                    column2,
                    item,
                    EditCellValue
                  )
                }
              ) : RenderDropdownSpan(
                props,
                index2,
                rowNum,
                column2,
                item,
                EditCellValue
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                Dropdown,
                {
                  ariaLabel: column2.key,
                  placeholder: column2.filterDropdownOptions ? (_i = (_h = column2.filterDropdownOptions.filterOptions) == null ? void 0 : _h.filter(
                    (x) => x.text == item[column2.key]
                  )[0]) == null ? void 0 : _i.text : ((_k = (_j = column2.dropdownValues) == null ? void 0 : _j.filter(
                    (x) => x.text == item[column2.key]
                  )[0]) == null ? void 0 : _k.text) ?? "Select an option",
                  selectedKey: (
                    // Keys Select Text
                    column2.filterDropdownOptions ? ((_n = (_m = (_l = column2.filterDropdownOptions.filterOptions) == null ? void 0 : _l.filter(
                      (x) => {
                        var _a4;
                        return (x == null ? void 0 : x.key) == ((_a4 = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _a4.value);
                      }
                    )[0]) == null ? void 0 : _m.key) == null ? void 0 : _n.toString()) ?? ((_q = (_p = (_o = column2.filterDropdownOptions.filterOptions) == null ? void 0 : _o.filter(
                      (x) => {
                        var _a4;
                        return (x == null ? void 0 : x.text) == ((_a4 = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _a4.value);
                      }
                    )[0]) == null ? void 0 : _p.key) == null ? void 0 : _q.toString()) : ((_t = (_s = (_r = column2.dropdownValues) == null ? void 0 : _r.filter(
                      (x) => {
                        var _a4;
                        return (x == null ? void 0 : x.key) == ((_a4 = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _a4.value);
                      }
                    )[0]) == null ? void 0 : _s.key) == null ? void 0 : _t.toString()) ?? ((_w = (_v = (_u = column2.dropdownValues) == null ? void 0 : _u.filter(
                      (x) => {
                        var _a4;
                        return (x == null ? void 0 : x.text) == ((_a4 = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _a4.value);
                      }
                    )[0]) == null ? void 0 : _v.key) == null ? void 0 : _w.toString()) ?? null
                  ),
                  options: column2.filterDropdownOptions ? column2.filterDropdownOptions.filterOptions.filter(
                    (x) => {
                      var _a4, _b4, _c4, _d3, _e3, _f2;
                      return ((_b4 = (_a4 = x.correspondingKey) == null ? void 0 : _a4.toString()) == null ? void 0 : _b4.toLowerCase()) == ((_f2 = (_e3 = (_d3 = activateCellEdit[rowNum]["properties"][((_c4 = item.filterDropdownOptions) == null ? void 0 : _c4.filterBasedOnThisColumnKey) ?? ""]) == null ? void 0 : _d3.value) == null ? void 0 : _e3.toString()) == null ? void 0 : _f2.toLowerCase());
                    }
                  ) : column2.dropdownValues ?? [],
                  styles: dropdownStyles,
                  dropdownWidth: "auto",
                  onChange: (ev, selectedItem) => onDropDownChange(
                    ev,
                    selectedItem,
                    rowNum,
                    column2,
                    item
                  ),
                  disabled: disableDropdown.current.get(column2.key + rowNum) ?? (typeof column2.disableDropdown == "boolean" ? column2.disableDropdown : false)
                }
              ) });
            case EditControlType.ComboBox:
              if (column2.disableComboBox && typeof column2.disableComboBox !== "boolean") {
                let newMap = new Map(disableComboBox.current);
                for (let index22 = 0; index22 < [column2.disableComboBox].length; index22++) {
                  const disableCellOptions = [column2.disableComboBox][index22];
                  const str = item[disableCellOptions.disableBasedOnThisColumnKey];
                  if (disableCellOptions.type === DisableColTypes.DisableWhenColKeyHasData) {
                    if (str && (str == null ? void 0 : str.toString().length) > 0 && (newMap.get(column2.key + rowNum) ?? false) === false) {
                      newMap.set(column2.key + rowNum, true);
                      disableComboBox.current = newMap;
                    } else if (newMap.get(column2.key + rowNum) == true && !str) {
                      newMap.set(column2.key + rowNum, false);
                      disableComboBox.current = newMap;
                    }
                  } else if (disableCellOptions.type === DisableColTypes.DisableWhenColKeyIsEmpty) {
                    if (str == "" || str && (str == null ? void 0 : str.toString().length) <= 0) {
                      newMap.set(column2.key + rowNum, true);
                    } else if ((str === null || str === void 0) && (newMap.get(column2.key + rowNum) ?? false) === false) {
                      newMap.set(column2.key + rowNum, true);
                    } else if ((newMap.get(column2.key + rowNum) ?? true) !== false && str && (str == null ? void 0 : str.toString().length) > 0) {
                      newMap.set(column2.key + rowNum, false);
                    }
                  }
                }
                disableComboBox.current = newMap;
              }
              return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "row-" + rowNum + "-col-" + index2, children: ShouldRenderSpan() ? ((_x = column2 == null ? void 0 : column2.hoverComponentOptions) == null ? void 0 : _x.enable) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                HoverCard,
                {
                  type: HoverCardType.plain,
                  plainCardProps: {
                    onRenderPlainCard: () => onRenderPlainCard(column2, rowNum, item)
                  },
                  instantOpenOnClick: true,
                  children: RenderComboBoxSpan(
                    props,
                    index2,
                    rowNum,
                    column2,
                    item,
                    EditCellValue
                  )
                }
              ) : RenderComboBoxSpan(
                props,
                index2,
                rowNum,
                column2,
                item,
                EditCellValue
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                VirtualizedComboBox,
                {
                  disabled: disableComboBox.current.get(column2.key + rowNum) ?? (typeof column2.disableComboBox == "boolean" ? column2.disableComboBox : false),
                  openOnKeyboardFocus: true,
                  ariaLabel: column2.key,
                  placeholder: ((_z = (_y = column2.comboBoxOptions) == null ? void 0 : _y.filter(
                    (x) => {
                      var _a4;
                      return x.text == ((_a4 = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _a4.value);
                    }
                  )[0]) == null ? void 0 : _z.text) ?? ((_C = (_B = (_A = column2.comboBoxOptions) == null ? void 0 : _A.filter(
                    (x) => {
                      var _a4, _b4;
                      return ((_a4 = x.key) == null ? void 0 : _a4.toString()) == ((_b4 = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _b4.value);
                    }
                  )[0]) == null ? void 0 : _B.text) == null ? void 0 : _C.toString()) ?? "Start typing...",
                  calloutProps: {
                    calloutMaxHeight: 300,
                    directionalHint: DirectionalHint.bottomCenter
                  },
                  allowFreeInput: true,
                  allowFreeform: ((_D = column2.comboBoxProps) == null ? void 0 : _D.allowFreeformComboBoxEntry) ?? false,
                  autoComplete: "on",
                  scrollSelectedToTop: true,
                  options: comboOptions.get(column2.key + rowNum) ?? column2.comboBoxOptions ?? [],
                  onClick: () => {
                    if (!init.get(column2.key + rowNum)) {
                      const newInitMap = /* @__PURE__ */ new Map();
                      newInitMap.set(column2.key + rowNum, true);
                      setInit(newInitMap);
                      const safeCopy = column2.comboBoxOptions ? [...column2.comboBoxOptions] : [];
                      const newMap = /* @__PURE__ */ new Map();
                      newMap.set(
                        column2.key + rowNum,
                        safeCopy.concat([
                          {
                            key: "8509984a-3d7f-45ff-90dc-b560f5b321d9",
                            text: ""
                          }
                        ]) ?? []
                      );
                      setComboOptions(newMap);
                    }
                  },
                  onInputValueChange: (text) => {
                    var _a4, _b4;
                    try {
                      const searchPattern = new RegExp(
                        text == null ? void 0 : text.trim(),
                        "i"
                      );
                      const searchResults = (_a4 = column2.comboBoxOptions) == null ? void 0 : _a4.filter((item2) => {
                        var _a5, _b5, _c4, _d3, _e3, _f2;
                        if (((_a5 = column2 == null ? void 0 : column2.comboBoxProps) == null ? void 0 : _a5.searchType) == "startswith") {
                          return (_e3 = (_c4 = (_b5 = item2 == null ? void 0 : item2.text) == null ? void 0 : _b5.trim()) == null ? void 0 : _c4.toLowerCase()) == null ? void 0 : _e3.startsWith((_d3 = text == null ? void 0 : text.trim()) == null ? void 0 : _d3.toLowerCase());
                        } else {
                          return searchPattern.test(
                            (_f2 = item2.text) == null ? void 0 : _f2.trim()
                          );
                        }
                      });
                      const newMap = /* @__PURE__ */ new Map();
                      newMap.set(
                        column2.key + rowNum,
                        (searchResults == null ? void 0 : searchResults.concat([
                          {
                            key: "64830f62-5ab8-490a-a0ed-971f977a3603",
                            text: ""
                          }
                        ])) ?? []
                      );
                      setComboOptions(newMap);
                      onComboBoxChangeRaw(text, rowNum, column2, item);
                    } catch (error) {
                      const newMap = /* @__PURE__ */ new Map();
                      newMap.set(
                        column2.key + rowNum,
                        ((_b4 = [...column2.comboBoxOptions ?? []]) == null ? void 0 : _b4.concat([
                          {
                            key: "64830f62-5ab8-490a-a0ed-971f977a3603",
                            text: ""
                          }
                        ])) ?? []
                      );
                      setComboOptions(newMap);
                    }
                  },
                  onChange: (ev, option) => onComboBoxChange(ev, option, rowNum, column2, item),
                  onKeyDown: (event) => {
                    if (props.enableSingleCellEditOnDoubleClick === true)
                      onKeyDownEvent(event, column2, rowNum, false);
                    else if (props.enableSingleCellEditOnDoubleClick === false)
                      onKeyDownEventFull(
                        event,
                        item,
                        Number(item["_grid_row_id_"])
                      );
                  },
                  onFocus: (ev) => handleFocus(
                    column2.key,
                    EditControlType.ComboBox,
                    Number(item["_grid_row_id_"])
                  ),
                  onBlur: (ev) => handleBlur()
                }
              ) });
            case EditControlType.Picker:
              return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ShouldRenderSpan() ? ((_E = column2 == null ? void 0 : column2.hoverComponentOptions) == null ? void 0 : _E.enable) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                HoverCard,
                {
                  type: HoverCardType.plain,
                  plainCardProps: {
                    onRenderPlainCard: () => onRenderPlainCard(column2, rowNum, item)
                  },
                  instantOpenOnClick: true,
                  children: RenderPickerSpan(
                    props,
                    index2,
                    rowNum,
                    column2,
                    item,
                    EditCellValue
                  )
                }
              ) : RenderPickerSpan(
                props,
                index2,
                rowNum,
                column2,
                item,
                EditCellValue
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                PickerControl,
                {
                  arialabel: column2.key,
                  selectedItemsLimit: (_F = column2.pickerOptions) == null ? void 0 : _F.tagsLimit,
                  pickerTags: ((_G = column2.pickerOptions) == null ? void 0 : _G.pickerTags) ?? [],
                  defaultTags: item[column2.key] ? item[column2.key].split(";") : [],
                  minCharLimitForSuggestions: (_H = column2.pickerOptions) == null ? void 0 : _H.minCharLimitForSuggestions,
                  onTaglistChanged: (selectedItem) => onCellPickerTagListChanged(
                    selectedItem,
                    rowNum,
                    column2,
                    item
                  ),
                  pickerDescriptionOptions: (_I = column2.pickerOptions) == null ? void 0 : _I.pickerDescriptionOptions,
                  suggestionRule: (_J = column2.pickerOptions) == null ? void 0 : _J.suggestionsRule
                }
              ) }) });
            case EditControlType.Link:
              return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ((_K = column2 == null ? void 0 : column2.hoverComponentOptions) == null ? void 0 : _K.enable) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                HoverCard,
                {
                  type: HoverCardType.plain,
                  plainCardProps: {
                    onRenderPlainCard: () => onRenderPlainCard(column2, rowNum, item)
                  },
                  instantOpenOnClick: true,
                  children: RenderLinkSpan(
                    props,
                    index2,
                    rowNum,
                    column2,
                    item,
                    EditCellValue
                  )
                }
              ) : RenderLinkSpan(
                props,
                index2,
                rowNum,
                column2,
                item,
                EditCellValue
              ) });
            case EditControlType.Password:
              return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ShouldRenderSpan() ? ((_L = column2 == null ? void 0 : column2.hoverComponentOptions) == null ? void 0 : _L.enable) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                HoverCard,
                {
                  type: HoverCardType.plain,
                  plainCardProps: {
                    onRenderPlainCard: () => onRenderPlainCard(column2, rowNum, item)
                  },
                  instantOpenOnClick: true,
                  children: RenderPasswordFieldSpan(
                    props,
                    index2,
                    rowNum,
                    column2,
                    item,
                    EditCellValue
                  )
                }
              ) : RenderPasswordFieldSpan(
                props,
                index2,
                rowNum,
                column2,
                item,
                EditCellValue
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  errorMessage: (_M = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _M.error,
                  label: item.text,
                  ariaLabel: column2.key,
                  styles: textFieldStyles$1,
                  onChange: (ev, text) => onCellValueChange(
                    ev,
                    text,
                    item,
                    rowNum,
                    column2.key,
                    column2
                  ),
                  autoFocus: !props.enableDefaultEditMode && !editMode && !((_N = activateCellEdit == null ? void 0 : activateCellEdit[Number(item["_grid_row_id_"])]) == null ? void 0 : _N["isActivated"]),
                  value: ((_O = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _O.value) ?? "",
                  onKeyDown: (event) => {
                    if (props.enableSingleCellEditOnDoubleClick === true)
                      onKeyDownEvent(event, column2, rowNum, false);
                    else if (props.enableSingleCellEditOnDoubleClick === false)
                      onKeyDownEventFull(
                        event,
                        item,
                        Number(item["_grid_row_id_"])
                      );
                  },
                  maxLength: column2.maxLength != null ? column2.maxLength : 1e3,
                  type: "password",
                  canRevealPassword: true,
                  onFocus: (ev) => handleFocus(
                    column2.key,
                    EditControlType.Password,
                    Number(item["_grid_row_id_"])
                  ),
                  onBlur: (ev) => handleBlur()
                }
              ) });
            case EditControlType.NumericFormat:
              if (!!(((_P = item[column2.key]) == null ? void 0 : _P.toString()) || "").match(/\d/) == false)
                item[column2.key] = 0;
              return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ShouldRenderSpan() ? ((_Q = column2 == null ? void 0 : column2.hoverComponentOptions) == null ? void 0 : _Q.enable) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                HoverCard,
                {
                  type: HoverCardType.plain,
                  plainCardProps: {
                    onRenderPlainCard: () => onRenderPlainCard(column2, rowNum, item)
                  },
                  instantOpenOnClick: true,
                  children: RenderTextFieldSpan(
                    props,
                    index2,
                    rowNum,
                    column2,
                    item,
                    EditCellValue
                  )
                }
              ) : RenderTextFieldSpan(
                props,
                index2,
                rowNum,
                column2,
                item,
                EditCellValue
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                NumericFormat,
                {
                  value: ((_S = (_R = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _R.value) == null ? void 0 : _S.toString()) ?? "",
                  placeholder: (_V = (_U = (_T = column2.validations) == null ? void 0 : _T.numericFormatProps) == null ? void 0 : _U.formatBase) == null ? void 0 : _V.placeholder,
                  valueIsNumericString: ((_Y = (_X = (_W = column2.validations) == null ? void 0 : _W.numericFormatProps) == null ? void 0 : _X.formatBase) == null ? void 0 : _Y.valueIsNumericString) ?? false,
                  type: (_$ = (__ = (_Z = column2.validations) == null ? void 0 : _Z.numericFormatProps) == null ? void 0 : __.formatBase) == null ? void 0 : _$.type,
                  inputMode: (_ca = (_ba = (_aa = column2.validations) == null ? void 0 : _aa.numericFormatProps) == null ? void 0 : _ba.formatBase) == null ? void 0 : _ca.inputMode,
                  renderText: (_fa = (_ea = (_da = column2.validations) == null ? void 0 : _da.numericFormatProps) == null ? void 0 : _ea.formatBase) == null ? void 0 : _fa.renderText,
                  label: ((_ha = (_ga = column2.validations) == null ? void 0 : _ga.numericFormatProps) == null ? void 0 : _ha.label) ?? item.text,
                  "aria-label": ((_ja = (_ia = column2.validations) == null ? void 0 : _ia.numericFormatProps) == null ? void 0 : _ja.label) ?? item.text,
                  decimalScale: (_ma = (_la = (_ka = column2.validations) == null ? void 0 : _ka.numericFormatProps) == null ? void 0 : _la.formatProps) == null ? void 0 : _ma.decimalScale,
                  fixedDecimalScale: (_pa = (_oa = (_na = column2.validations) == null ? void 0 : _na.numericFormatProps) == null ? void 0 : _oa.formatProps) == null ? void 0 : _pa.fixedDecimalScale,
                  decimalSeparator: (_sa = (_ra = (_qa = column2.validations) == null ? void 0 : _qa.numericFormatProps) == null ? void 0 : _ra.formatProps) == null ? void 0 : _sa.decimalSeparator,
                  allowedDecimalSeparators: (_va = (_ua = (_ta = column2.validations) == null ? void 0 : _ta.numericFormatProps) == null ? void 0 : _ua.formatProps) == null ? void 0 : _va.allowedDecimalSeparators,
                  thousandsGroupStyle: (_ya = (_xa = (_wa = column2.validations) == null ? void 0 : _wa.numericFormatProps) == null ? void 0 : _xa.formatProps) == null ? void 0 : _ya.thousandsGroupStyle,
                  thousandSeparator: (_Ba = (_Aa = (_za = column2.validations) == null ? void 0 : _za.numericFormatProps) == null ? void 0 : _Aa.formatProps) == null ? void 0 : _Ba.thousandSeparator,
                  onRenderLabel: (_Da = (_Ca = column2.validations) == null ? void 0 : _Ca.numericFormatProps) == null ? void 0 : _Da.onRenderLabel,
                  ariaLabel: ((_Fa = (_Ea = column2.validations) == null ? void 0 : _Ea.numericFormatProps) == null ? void 0 : _Fa.ariaLabel) ?? item.text,
                  customInput: TextField,
                  suffix: (_Ia = (_Ha = (_Ga = column2.validations) == null ? void 0 : _Ga.numericFormatProps) == null ? void 0 : _Ha.formatProps) == null ? void 0 : _Ia.suffix,
                  prefix: (_La = (_Ka = (_Ja = column2.validations) == null ? void 0 : _Ja.numericFormatProps) == null ? void 0 : _Ka.formatProps) == null ? void 0 : _La.prefix,
                  allowLeadingZeros: (_Oa = (_Na = (_Ma = column2.validations) == null ? void 0 : _Ma.numericFormatProps) == null ? void 0 : _Na.formatProps) == null ? void 0 : _Oa.allowLeadingZeros,
                  allowNegative: (_Ra = (_Qa = (_Pa = column2.validations) == null ? void 0 : _Pa.numericFormatProps) == null ? void 0 : _Qa.formatProps) == null ? void 0 : _Ra.allowNegative,
                  isAllowed: (_Ua = (_Ta = (_Sa = column2.validations) == null ? void 0 : _Sa.numericFormatProps) == null ? void 0 : _Ta.formatBase) == null ? void 0 : _Ua.isAllowed,
                  errorMessage: (_Va = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _Va.error,
                  onValueChange: (values2, sourceInfo) => {
                    onCellValueChange(
                      sourceInfo.event,
                      values2.formattedValue ?? values2.value,
                      item,
                      rowNum,
                      column2.key,
                      column2
                    );
                  },
                  onKeyDown: (event) => {
                    if (props.enableSingleCellEditOnDoubleClick === true)
                      onKeyDownEvent(event, column2, rowNum, false);
                    else if (props.enableSingleCellEditOnDoubleClick === false)
                      onKeyDownEventFull(
                        event,
                        item,
                        Number(item["_grid_row_id_"])
                      );
                  },
                  onFocus: (ev) => handleFocus(
                    column2.key,
                    EditControlType.NumericFormat,
                    Number(item["_grid_row_id_"])
                  ),
                  onBlur: (ev) => handleBlur()
                },
                item.key
              ) });
            default:
              return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: ShouldRenderSpan() ? ((_Wa = column2 == null ? void 0 : column2.hoverComponentOptions) == null ? void 0 : _Wa.enable) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                HoverCard,
                {
                  type: HoverCardType.plain,
                  plainCardProps: {
                    onRenderPlainCard: () => onRenderPlainCard(column2, rowNum, item)
                  },
                  instantOpenOnClick: true,
                  children: RenderTextFieldSpan(
                    props,
                    index2,
                    rowNum,
                    column2,
                    item,
                    EditCellValue
                  )
                }
              ) : RenderTextFieldSpan(
                props,
                index2,
                rowNum,
                column2,
                item,
                EditCellValue
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  errorMessage: (_Xa = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _Xa.error,
                  label: item.text,
                  ariaLabel: column2.key,
                  styles: textFieldStyles$1,
                  onChange: (ev, text) => onCellValueChange(
                    ev,
                    text,
                    item,
                    rowNum,
                    column2.key,
                    column2
                  ),
                  autoFocus: !props.enableDefaultEditMode && !editMode && !((_Ya = activateCellEdit == null ? void 0 : activateCellEdit[Number(item["_grid_row_id_"])]) == null ? void 0 : _Ya["isActivated"]),
                  value: ((_Za = activateCellEdit[rowNum]["properties"][column2.key]) == null ? void 0 : _Za.value) ?? "",
                  onKeyDown: (event) => {
                    if (props.enableSingleCellEditOnDoubleClick === true)
                      onKeyDownEvent(event, column2, rowNum, false);
                    else if (props.enableSingleCellEditOnDoubleClick === false)
                      onKeyDownEventFull(
                        event,
                        item,
                        Number(item["_grid_row_id_"])
                      );
                  },
                  maxLength: column2.maxLength != null ? column2.maxLength : 1e3,
                  onFocus: (ev) => handleFocus(
                    column2.key,
                    EditControlType.TextField,
                    Number(item["_grid_row_id_"])
                  ),
                  onBlur: (ev) => handleBlur()
                }
              ) });
          }
          function ShouldRenderSpan() {
            var _a4, _b4, _c4;
            return !column2.editable || !props.enableDefaultEditMode && !((_a4 = activateCellEdit == null ? void 0 : activateCellEdit[rowNum]) == null ? void 0 : _a4.isActivated) && !((_c4 = (_b4 = activateCellEdit == null ? void 0 : activateCellEdit[rowNum]) == null ? void 0 : _b4["properties"][column2.key]) == null ? void 0 : _c4.activated);
          }
        }
      });
      if (getColumnFiltersRef().length == 0) {
        columnFilterArrTmp.push({
          index: index2,
          column: column2,
          isApplied: false,
          isHidden: true,
          filterCalloutProps: {
            columnKey: column2.key,
            columnClass: colHeaderClassName,
            columnName: column2.text,
            filterList: []
          }
        });
      }
    });
    if (getColumnFiltersRef().length == 0) {
      setColumnFiltersRef(columnFilterArrTmp);
    }
    if (!props.disableAllRowActions) {
      columnConfigs.push({
        key: "actions",
        name: "Actions",
        ariaLabel: "Actions",
        fieldName: "Actions",
        isResizable: false,
        isIconOnly: false,
        minWidth: props.actionsColumnMinWidth ?? 100,
        onRender: (item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { horizontal: true, horizontalAlign: "center", children: [
          props.enableRowEdit && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: !props.enableSaveGridOnCellValueChange && activateCellEdit && activateCellEdit[Number(item["_grid_row_id_"])] && activateCellEdit[Number(item["_grid_row_id_"])]["isActivated"] ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                disabled: editMode,
                onClick: () => {
                  ShowRowEditMode(
                    item,
                    Number(item["_grid_row_id_"]),
                    false
                  );
                },
                iconProps: { iconName: "Save" },
                title: "Save",
                styles: props.actionIconStylesInGrid
              }
            ),
            props.enableRowEditCancel ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                disabled: editMode,
                onClick: () => CancelRowEditMode(
                  item,
                  Number(item["_grid_row_id_"])
                ),
                iconProps: { iconName: "RemoveFilter" },
                title: "Cancel",
                styles: props.actionIconStylesInGrid
              }
            ) : null
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: !props.enableDefaultEditMode && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              onClick: () => {
                if (activateCellEdit && activateCellEdit[Number(item["_grid_row_id_"])] && activateCellEdit[Number(item["_grid_row_id_"])]["isActivated"]) {
                  if (!props.enableInlineGridAdd) {
                    CancelRowEditMode(
                      item,
                      Number(item["_grid_row_id_"])
                    );
                  } else {
                    ShowRowEditMode(
                      item,
                      Number(item["_grid_row_id_"]),
                      false
                    );
                  }
                } else {
                  ShowRowEditMode(
                    item,
                    Number(item["_grid_row_id_"]),
                    true
                  );
                }
              },
              iconProps: {
                iconName: activateCellEdit && activateCellEdit[Number(item["_grid_row_id_"])] && activateCellEdit[Number(item["_grid_row_id_"])]["isActivated"] ? "Cancel" : "EditSolid12"
              },
              title: activateCellEdit && activateCellEdit[Number(item["_grid_row_id_"])] && activateCellEdit[Number(item["_grid_row_id_"])]["isActivated"] ? "Close Row" : "Edit Row",
              styles: props.actionIconStylesInGrid
            }
          ) }) }),
          props.enableRowEditDelete && !props.enableDefaultEditMode && /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              onClick: () => {
                HandleRowSingleDelete(Number(item["_grid_row_id_"]));
                clearSelectedItems();
              },
              disabled: !props.enableSaveGridOnCellValueChange && activateCellEdit && activateCellEdit[Number(item["_grid_row_id_"])] && activateCellEdit[Number(item["_grid_row_id_"])]["isActivated"],
              iconProps: { iconName: "ErrorBadge" },
              title: "Delete Row",
              styles: props.actionIconStylesInGrid
            }
          )
        ] })
      });
    }
    return columnConfigs;
  };
  const CreateCommandBarItemProps = () => {
    var _a3;
    let commandBarItems = [];
    if (props.enableExcelExport && !props.enableCSVExport && !editMode) {
      commandBarItems.push({
        key: "exportToExcel",
        text: (CommandBarTitles == null ? void 0 : CommandBarTitles.ExcelExport) ?? "Export To Excel",
        ariaLabel: (CommandBarTitles == null ? void 0 : CommandBarTitles.ExcelExport) ?? "Export To Excel",
        disabled: isGridInEdit && !props.enableSaveGridOnCellValueChange || editMode,
        cacheKey: "myCacheKey",
        iconProps: { iconName: "ExcelDocument" },
        onClick: () => onExportClick(ExportType.XLSX)
      });
    } else if (props.enableCSVExport && !props.enableExcelExport && !editMode) {
      commandBarItems.push({
        id: "export",
        key: "exportToCSV",
        text: (CommandBarTitles == null ? void 0 : CommandBarTitles.CSVExport) ?? "CSV Export",
        ariaLabel: (CommandBarTitles == null ? void 0 : CommandBarTitles.CSVExport) ?? "CSV Export",
        disabled: isGridInEdit && !props.enableSaveGridOnCellValueChange || editMode,
        cacheKey: "myCacheKey",
        iconProps: { iconName: "LandscapeOrientation" },
        onClick: () => onExportClick(ExportType.CSV)
      });
    } else if (props.enableExcelExport && props.enableCSVExport && !editMode) {
      commandBarItems.push({
        key: "exportGrid",
        text: (CommandBarTitles == null ? void 0 : CommandBarTitles.Export) ?? "Export",
        ariaLabel: (CommandBarTitles == null ? void 0 : CommandBarTitles.Export) ?? "Export",
        disabled: isGridInEdit && !props.enableSaveGridOnCellValueChange || editMode,
        cacheKey: "myCacheKey",
        iconProps: { iconName: "Download" },
        subMenuProps: {
          items: [
            {
              key: "exportToExcel",
              text: "Excel Export",
              iconProps: { iconName: "ExcelDocument" },
              onClick: () => onExportClick(ExportType.XLSX)
            },
            {
              key: "exportToCSV",
              text: "CSV Export",
              iconProps: { iconName: "LandscapeOrientation" },
              onClick: () => onExportClick(ExportType.CSV)
            }
          ]
        }
      });
    }
    if (props.enableExcelImport && !editMode && !props.enableDefaultEditMode) {
      commandBarItems.push({
        key: "importFromExcel",
        text: (CommandBarTitles == null ? void 0 : CommandBarTitles.ImportFromExcel) ?? "Import From Excel",
        ariaLabel: (CommandBarTitles == null ? void 0 : CommandBarTitles.ImportFromExcel) ?? "Import From Excel",
        disabled: isGridInEdit && !props.enableSaveGridOnCellValueChange || editMode,
        cacheKey: "myCacheKey",
        onRender: renderItem
      });
    }
    if (props.gridCopyOptions && props.gridCopyOptions.enableGridCopy && !editMode) {
      commandBarItems.push({
        key: "copy",
        text: (CommandBarTitles == null ? void 0 : CommandBarTitles.CopyGrid) ?? "Copy Grid",
        disabled: props.enableSaveGridOnCellValueChange ? void 0 : isGridInEdit || editMode || _selection.count == 0,
        ariaLabel: isGridInEdit || editMode || _selection.count == 0 ? "Make A Selection In The Grid To Copy" : "Copy Selected Grid Row",
        title: isGridInEdit || editMode || _selection.count == 0 ? "Make A Selection In The Grid To Copy" : "Copy Selected Grid Row",
        iconProps: { iconName: "Documentation" },
        onClick: () => CopyGridRows()
      });
    }
    if (props.gridCopyOptions && props.gridCopyOptions.enableGridPaste && !editMode && !props.enableDefaultEditMode) {
      commandBarItems.push({
        key: "paste",
        text: (CommandBarTitles == null ? void 0 : CommandBarTitles.PasteIntoGrid) ?? "Paste Into Grid",
        ariaLabel: "Paste Copied Grid Rows",
        title: "Paste Copied Grid Rows",
        iconProps: { iconName: "Paste" },
        onClick: () => PasteGridRows(false)
      });
    }
    if (props.enableGridRowAddWithValues && props.enableGridRowAddWithValues.enable && !editMode && !props.enableDefaultEditMode) {
      commandBarItems.push({
        key: "addrowswithdata",
        text: props.enableInlineGridAdd ? (CommandBarTitles == null ? void 0 : CommandBarTitles.AddRow) ?? "Add Row" : (CommandBarTitles == null ? void 0 : CommandBarTitles.AddRowWithData) ?? "Add Rows With Data",
        disabled: editMode && !props.enableEditAllOnCellClick,
        iconProps: { iconName: "Add" },
        onClick: () => {
          RowSelectOperations(EditType.AddRowWithData);
          if (props.enableEditAllOnCellClick && props.enableInlineGridAdd && !editMode)
            ShowGridEditMode(false);
        }
      });
    }
    if (props.enableGridRowsDelete && !editMode && !props.enableDefaultEditMode) {
      commandBarItems.push({
        key: "deleterows",
        text: _selection.count > 1 ? (CommandBarTitles == null ? void 0 : CommandBarTitles.DeleteRow) ?? "Delete Rows" : (CommandBarTitles == null ? void 0 : CommandBarTitles.DeleteRow) ?? "Delete Row",
        disabled: props.enableSaveGridOnCellValueChange ? void 0 : editMode || _selection.count == 0,
        iconProps: { iconName: "trash" },
        onClick: () => RowSelectOperations(EditType.DeleteRow)
      });
    }
    if (props.enableColumnFilterRules && !editMode) {
      commandBarItems.push({
        key: "columnFilters",
        text: (CommandBarTitles == null ? void 0 : CommandBarTitles.Filter) ?? "Filter",
        ariaLabel: "Filter",
        disabled: editMode || isGridInEdit && !props.enableSaveGridOnCellValueChange,
        cacheKey: "myColumnFilterCacheKey",
        iconProps: { iconName: "QueryList" },
        subMenuProps: {
          items: [
            {
              key: "columnFilter",
              text: "Column Filter",
              iconProps: { iconName: "Filter" },
              onClick: () => RowSelectOperations(EditType.ColumnFilter)
            },
            {
              key: "clearFilters",
              text: "Clear Filters",
              iconProps: { iconName: "ClearFilter" },
              onClick: () => ClearFilters()
            }
          ]
        }
      });
    }
    if ((!props.enableDefaultEditMode || props.enableEditAllOnCellClick) && props.enableEditMode) {
      commandBarItems.push({
        key: "editmode",
        disabled: isGridInEdit && editMode,
        text: !editMode ? (CommandBarTitles == null ? void 0 : CommandBarTitles.EditMode) ?? "Edit Mode" : (CommandBarTitles == null ? void 0 : CommandBarTitles.Editing) ?? "Editing",
        iconProps: { iconName: !editMode ? "Edit" : "Save" },
        onClick: () => ShowGridEditMode()
      });
    }
    if ((!props.enableDefaultEditMode || props.enableEditAllOnCellClick) && editMode) {
      commandBarItems.push({
        key: "saveEdits",
        disabled: isGridInEdit && !editMode,
        text: props.enableSaveGridOnCellValueChange ? "Exit" : (CommandBarTitles == null ? void 0 : CommandBarTitles.SaveEdits) ?? "Save Edits",
        iconProps: {
          iconName: props.enableSaveGridOnCellValueChange ? "Cancel" : "Save"
        },
        onClick: () => {
          ShowGridEditMode();
          if (!props.enableSaveGridOnCellValueChange)
            onGridSave();
        }
      });
    }
    if (!editMode && props.showASaveButtonInCommandbar && !props.enableSaveGridOnCellValueChange) {
      commandBarItems.push({
        key: "saveEditsPermButton",
        disabled: !props.enableSaveGridOnCellValueChange ? !isGridStateEdited : false,
        text: (CommandBarTitles == null ? void 0 : CommandBarTitles.SaveEdits) ?? "Save Edits",
        iconProps: {
          iconName: "Save"
        },
        onClick: () => {
          onGridSave();
        }
      });
      commandBarItems.push({
        key: "resetGrid",
        disabled: editMode || !isGridStateEdited,
        text: "Cancel",
        iconProps: { iconName: "Cancel" },
        onClick: () => ResetGridData()
      });
    }
    if (!props.enableSaveGridOnCellValueChange && (!props.enableDefaultEditMode || props.enableEditAllOnCellClick) && props.enableEditModeCancel && editMode) {
      commandBarItems.push({
        key: "editmodecancel",
        disabled: isGridInEdit && !editMode,
        text: "Cancel",
        iconProps: { iconName: "Cancel" },
        //onClick: () => {SetGridItems(defaultGridData); setEditMode(false)}
        onClick: () => {
          CancelGridEditMode();
        }
      });
    }
    if (props.enableBulkEdit && !editMode) {
      commandBarItems.push({
        key: "bulkedit",
        text: (CommandBarTitles == null ? void 0 : CommandBarTitles.BulkEdit) ?? "Bulk Edit",
        disabled: isGridInEdit && !props.enableSaveGridOnCellValueChange || editMode || _selection.count == 0,
        iconProps: { iconName: "TripleColumnEdit" },
        onClick: () => RowSelectOperations(EditType.BulkEdit)
      });
    }
    if (props.enableGridRowsAdd && !props.enableInlineGridAdd && !props.enableDefaultEditMode) {
      commandBarItems.push({
        key: "addrows",
        text: (CommandBarTitles == null ? void 0 : CommandBarTitles.AddRow) ?? "Add Rows",
        disabled: editMode,
        iconProps: { iconName: "AddTo" },
        onClick: () => {
          RowSelectOperations(EditType.AddRow);
        }
      });
    }
    if (props.enableColumnEdit && !editMode) {
      commandBarItems.push({
        key: "updatecolumn",
        disabled: isGridInEdit && !props.enableSaveGridOnCellValueChange || editMode || _selection.count == 0,
        text: !isUpdateColumnClicked ? "Update Column" : "Save Column Update",
        iconProps: { iconName: "SingleColumnEdit" },
        onClick: () => RowSelectOperations(EditType.ColumnEdit)
      });
    }
    if (props.enableGridReset && !editMode && !props.showASaveButtonInCommandbar) {
      commandBarItems.push({
        key: "resetGrid",
        disabled: editMode || !isGridStateEdited,
        text: ((_a3 = CommandBarTitles == null ? void 0 : CommandBarTitles.ResetData) == null ? void 0 : _a3.actionTitle) ?? "Reset Data",
        iconProps: { iconName: "Refresh" },
        onClick: () => ResetGridData()
      });
    }
    if (props.customCommandBarItems && props.customCommandBarItems.length > 0 && !editMode) {
      return [...commandBarItems, ...props.customCommandBarItems];
    }
    return commandBarItems;
  };
  const CreateCommandBarFarItemProps = () => {
    let commandBarItems = [];
    commandBarItems.push({
      key: "filteredrecs",
      text: getGridRecordLength(),
      ariaLabel: "Filtered Records",
      title: "Summary Count",
      iconOnly: false,
      iconProps: { iconName: "PageListFilter" }
    });
    if (!props.enableSaveGridOnCellValueChange && !props.showASaveButtonInCommandbar && !editMode && (!props.disableInlineCellEdit || !props.enableEditMode)) {
      commandBarItems.push({
        key: "info",
        text: isGridStateEdited ? "Grid has unsaved data. Click on 'Submit' to save" : "",
        ariaLabel: "Commit Changes",
        disabled: !isGridStateEdited,
        onRender: (item, index2) => {
          if (parseInt(getGridRecordLength(true)) <= 0) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              PrimaryButton,
              {
                disabled: !isGridStateEdited,
                style: { marginTop: 5 },
                styles: { rootDisabled: { backgroundColor: "#4C4E52" } },
                text: isGridStateEdited ? "0 Rows, Commit Changes" : parseInt(getGridRecordLength(true)) + " Rows, " + props.zeroRowsMsg,
                title: isGridStateEdited ? "0 Rows, Commit Changes" : parseInt(getGridRecordLength(true)) + " Rows, " + props.zeroRowsMsg,
                onClick: () => {
                  if (isGridStateEdited)
                    onGridSave();
                }
              }
            );
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            PrimaryButton,
            {
              style: { marginTop: 5 },
              disabled: !isGridStateEdited,
              text: isGridStateEdited ? "Commit Changes" : "No Changes",
              title: isGridStateEdited ? "Grid has unsaved data. Click on 'Commit' to save" : "No Changes To Commit",
              onClick: () => {
                onGridSave();
              }
            }
          );
        }
      });
    }
    return commandBarItems;
  };
  const CreateCommandBarOverflowItemsProps = () => {
    if (props.customCommandBarOverflowItems && props.customCommandBarOverflowItems.length > 0) {
      return [...props.customCommandBarOverflowItems];
    }
    return [];
  };
  const GridColumns = CreateColumnConfigs();
  const CommandBarItemProps = CreateCommandBarItemProps();
  const CommandBarFarItemProps = CreateCommandBarFarItemProps();
  const CommandBarOverflowItemsProps = CreateCommandBarOverflowItemsProps();
  function _getSelectionDetails() {
    const count = _selection.getSelectedCount();
    setSelectedItems(_selection.getSelection());
    setSelectedIndices(_selection.getSelectedIndices());
    if (props.onGridSelectionChange) {
      props.onGridSelectionChange(_selection.getSelection());
    }
    switch (count) {
      case 0:
        return "No items selected";
      case 1:
        return "1 item selected: ";
      default:
        return `${count} items selected`;
    }
  }
  const onRenderPlainCard = (column2, rowNum, rowData) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: controlClass$1.plainCard, children: column2.hoverComponentOptions && column2.hoverComponentOptions.hoverChildComponent && React__namespace.cloneElement(column2.hoverComponentOptions.hoverChildComponent, {
      column: column2,
      rowNum,
      rowData
    }) });
  };
  const RenderLinkSpan = (props2, index2, rowNum, column2, item, EditCellValue2) => {
    var _a3, _b3, _c3, _d2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        id: `id-${props2.id}-col-${index2}-row-${rowNum}`,
        className: GetDynamicSpanStyles(column2, item[column2.key]),
        onClick: HandleCellOnClick(props2, column2, EditCellValue2, rowNum),
        onDoubleClick: HandleCellOnDoubleClick(
          item,
          Number(item["_grid_row_id_"]),
          props2,
          column2,
          EditCellValue2,
          rowNum
        ),
        children: ((_a3 = column2.linkOptions) == null ? void 0 : _a3.onClick) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            target: "_blank",
            disabled: (_b3 = column2.linkOptions) == null ? void 0 : _b3.disabled,
            underline: true,
            onClick: () => {
              var _a4;
              let params = {
                rowindex: [rowNum],
                data: defaultGridData,
                triggerkey: column2.key,
                activatetriggercell: false
              };
              if ((_a4 = column2.linkOptions) == null ? void 0 : _a4.onClick)
                column2.linkOptions.onClick(params);
            },
            children: item[column2.key]
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            target: "_blank",
            disabled: (_c3 = column2.linkOptions) == null ? void 0 : _c3.disabled,
            underline: true,
            href: (_d2 = column2.linkOptions) == null ? void 0 : _d2.href,
            children: item[column2.key]
          }
        )
      }
    );
  };
  const RenderTextFieldSpan = (props2, index2, rowNum, column2, item, EditCellValue2) => {
    return RenderSpan(
      props2,
      index2,
      rowNum,
      column2,
      item,
      HandleCellOnClick,
      EditCellValue2,
      HandleCellOnDoubleClick
    );
  };
  const RenderPasswordFieldSpan = (props2, index2, rowNum, column2, item, EditCellValue2) => {
    var _a3;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        id: `id-${props2.id}-col-${index2}-row-${rowNum}`,
        className: GetDynamicSpanStyles(column2, item[column2.key]),
        onClick: HandleCellOnClick(props2, column2, EditCellValue2, rowNum),
        onDoubleClick: HandleCellOnDoubleClick(
          item,
          Number(item["_grid_row_id_"]),
          props2,
          column2,
          EditCellValue2,
          rowNum
        ),
        children: (_a3 = item[column2.key]) == null ? void 0 : _a3.replace(/./g, "*")
      }
    );
  };
  const RenderPickerSpan = (props2, index2, rowNum, column2, item, EditCellValue2) => {
    return RenderSpan(
      props2,
      index2,
      rowNum,
      column2,
      item,
      HandleCellOnClick,
      EditCellValue2,
      HandleCellOnDoubleClick
    );
  };
  const RenderDropdownSpan = (props2, index2, rowNum, column2, item, EditCellValue2) => {
    var _a3, _b3, _c3;
    let maskText = item[column2.key];
    if (column2.dropdownValues) {
      maskText = ((_c3 = (_b3 = (_a3 = column2.dropdownValues) == null ? void 0 : _a3.filter((x) => (x == null ? void 0 : x.key) == item[column2.key])[0]) == null ? void 0 : _b3.text) == null ? void 0 : _c3.toString()) ?? item[column2.key];
    }
    return RenderSpan(
      props2,
      index2,
      rowNum,
      column2,
      item,
      HandleCellOnClick,
      EditCellValue2,
      HandleCellOnDoubleClick,
      maskText
    );
  };
  const RenderComboBoxSpan = (props2, index2, rowNum, column2, item, EditCellValue2) => {
    var _a3, _b3, _c3, _d2;
    let maskText = item[column2.key];
    if (column2.comboBoxOptions && !((_a3 = column2 == null ? void 0 : column2.comboBoxProps) == null ? void 0 : _a3.nonStrictMaskingRequired)) {
      maskText = ((_d2 = (_c3 = (_b3 = column2.comboBoxOptions) == null ? void 0 : _b3.filter((x) => (x == null ? void 0 : x.key) == item[column2.key])[0]) == null ? void 0 : _c3.text) == null ? void 0 : _d2.toString()) ?? item[column2.key];
    }
    return RenderSpan(
      props2,
      index2,
      rowNum,
      column2,
      item,
      HandleCellOnClick,
      EditCellValue2,
      HandleCellOnDoubleClick,
      maskText
    );
  };
  const RenderCheckboxSpan = (props2, index2, rowNum, column2, item, EditCellValue2) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Stack,
      {
        horizontalAlign: "center",
        id: `id-${props2.id}-col-${index2}-row-${rowNum}`,
        onClick: HandleCellOnClick(props2, column2, EditCellValue2, rowNum),
        onDoubleClick: HandleCellOnDoubleClick(
          item,
          Number(item["_grid_row_id_"]),
          props2,
          column2,
          EditCellValue2,
          rowNum
        ),
        children: item && item[column2.key] ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            ariaLabel: column2.key,
            styles: {
              root: {
                selectors: {
                  ".ms-Checkbox": {
                    backgroundColor: "rgb(0, 120, 212)"
                  },
                  ".ms-Checkbox-checkbox": {
                    backgroundColor: "rgb(0, 120, 212)"
                  },
                  ".ms-Checkbox-checkmark": {
                    color: "white"
                  }
                }
              }
            },
            checked: item[column2.key],
            disabled: true
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            ariaLabel: column2.key,
            checked: item[column2.key],
            disabled: true
          }
        )
      }
    );
  };
  const RenderDateSpan = (props2, index2, rowNum, column2, item, EditCellValue2) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        id: `id-${props2.id}-col-${index2}-row-${rowNum}`,
        className: GetDynamicSpanStyles(column2, item[column2.key]),
        onClick: HandleCellOnClick(props2, column2, EditCellValue2, rowNum),
        onDoubleClick: HandleCellOnDoubleClick(
          item,
          Number(item["_grid_row_id_"]),
          props2,
          column2,
          EditCellValue2,
          rowNum
        ),
        children: item && item[column2.key] ? new Date(item[column2.key]).toDateString() : null
      }
    );
  };
  const RenderMultilineTextFieldSpan = (props2, index2, rowNum, column2, item, EditCellValue2) => {
    return RenderSpan(
      props2,
      index2,
      rowNum,
      column2,
      item,
      HandleCellOnClick,
      EditCellValue2,
      HandleCellOnDoubleClick
    );
  };
  const RenderSpan = (props2, index2, rowNum, column2, item, HandleCellOnClick2, EditCellValue2, HandleCellOnDoubleClick2, maskText) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        id: `id-${props2.id}-col-${index2}-row-${rowNum}`,
        className: GetDynamicSpanStyles(column2, item[column2.key]),
        onClick: HandleCellOnClick2(props2, column2, EditCellValue2, rowNum),
        onDoubleClick: HandleCellOnDoubleClick2(
          item,
          Number(item["_grid_row_id_"]),
          props2,
          column2,
          EditCellValue2,
          rowNum
        ),
        children: maskText ? maskText : item[column2.key]
      }
    );
  };
  function HandleCellOnDoubleClick(item, _grid_row_id_, props2, column2, EditCellValue2, rowNum) {
    if (props2.enableSingleCellEditOnDoubleClick == true) {
      return () => !props2.disableInlineCellEdit && props2.enableSingleCellEditOnDoubleClick == true && column2.editable == true ? EditCellValue2(column2.key, rowNum, true) : null;
    } else if (!props2.disableInlineCellEdit && props2.enableSingleCellEditOnDoubleClick == false) {
      return () => ShowRowEditMode(item, Number(item["_grid_row_id_"]), true);
    }
  }
  function HandleCellOnClick(props2, column2, EditCellValue2, rowNum) {
    return () => !props2.disableInlineCellEdit && props2.enableSingleCellEditOnDoubleClick == true && column2.editable == true ? props2.enableEditAllOnCellClick ? ShowGridEditMode() : EditCellValue2(column2.key, rowNum, true) : null;
  }
  const RenderNoRowsMsg = React.useCallback(() => {
    if (props.enableSaveGridOnCellValueChange || props.showASaveButtonInCommandbar)
      if (parseInt(getGridRecordLength(true)) <= 0)
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { horizontal: true, horizontalAlign: "end", style: { marginBottom: 15 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Text, { style: { borderBottom: "1px solid #d44040" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#d44040" }, children: "0 Rows, " }),
          props.zeroRowsMsg
        ] }) });
      else
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  }, [defaultGridData, props.enableSaveGridOnCellValueChange]);
  const clearAllMessages = () => {
    GlobalMessages.current = /* @__PURE__ */ new Map();
    SetGlobalMessagesState(GlobalMessages.current);
    Messages.current = /* @__PURE__ */ new Map();
    setMessagesState(Messages.current);
    setGridInError(false);
    setInteralMessagesState(/* @__PURE__ */ new Map());
  };
  React.useEffect(() => {
    if (props.clearAllGridMessages) {
      if (props.clearAllGridMessages[0] == true) {
        clearAllMessages();
        clearSelectedItems();
        props.clearAllGridMessages[1](false);
      }
    }
  }, [(_a2 = props.clearAllGridMessages) == null ? void 0 : _a2[0]]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: activateEditRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: copyRef, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: pasteRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Panel,
      {
        isOpen: isOpenForEdit,
        onDismiss: dismissPanelForEdit,
        isLightDismiss: true,
        headerText: "Edit Grid Data",
        closeButtonAriaLabel: "Close",
        type: PanelType.smallFixedFar,
        styles: props.editPanelStyles,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          EditPanel,
          {
            onChange: onEditPanelChange,
            columnConfigurationData: props.columns
          }
        )
      }
    ),
    props.enableGridRowAddWithValues && props.enableGridRowAddWithValues.enable ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Panel,
      {
        isOpen: isOpenForAdd,
        onDismiss: dismissPanelForAdd,
        isLightDismiss: true,
        headerText: props.enableGridRowAddWithValues.panelHeader ?? "Add Rows",
        closeButtonAriaLabel: "Close",
        type: PanelType.smallFixedFar,
        styles: props.addRowPanelStyles,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          AddRowPanel,
          {
            onSubmit: onAddPanelSubmit,
            preSubmitCallback: async (data) => {
              var _a3, _b3;
              var callbackRequestparams = {
                data,
                gridData: defaultGridData
              };
              if ((_a3 = props.enableGridRowAddWithValues) == null ? void 0 : _a3.onPreSubmit)
                return await ((_b3 = props.enableGridRowAddWithValues) == null ? void 0 : _b3.onPreSubmit(
                  callbackRequestparams
                ));
              else {
                return void 0;
              }
            },
            columnConfigurationData: props.columns,
            onChange: (data) => {
              var _a3, _b3;
              var callbackRequestparams = {
                data,
                gridData: defaultGridData
              };
              if ((_a3 = props.enableGridRowAddWithValues) == null ? void 0 : _a3.onChange)
                return (_b3 = props.enableGridRowAddWithValues) == null ? void 0 : _b3.onChange(
                  callbackRequestparams
                );
            },
            addingToGridButtonText: props.enableGridRowAddWithValues.addingToGridButtonText,
            addToGridButtonText: props.enableGridRowAddWithValues.addToGridButtonText,
            enableNonEditableColumns: props.enableGridRowAddWithValues.enableNonEditableColumns,
            autoGenId: (Math.max.apply(
              Math,
              defaultGridData.map(function(o) {
                if (indentiferColumn.current != void 0 && indentiferColumn.current !== null)
                  return o[indentiferColumn.current];
              })
            ) ?? 0) + 1
          }
        )
      }
    ) : null,
    defaultTag.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      TagPicker,
      {
        onResolveSuggestions: onFilterChanged,
        getTextFromItem,
        pickerSuggestionsProps,
        inputProps,
        selectedItems: defaultTag,
        onChange: onFilterTagListChanged
      }
    ) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: 15 }, children: interalMsgJSXState.map((element) => element) }),
    props.enableMessageBarErrors ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: 15 }, children: messagesJSXState.map((element) => element) }) : null,
    RenderNoRowsMsg(),
    props.enableCommandBar === void 0 || props.enableCommandBar === true ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      CommandBar,
      {
        items: CommandBarItemProps,
        ariaLabel: "Command Bar",
        overflowItems: CommandBarOverflowItemsProps,
        overflowButtonProps: { ariaLabel: "Overflow" },
        farItems: CommandBarFarItemProps,
        styles: props.commandBarStyles
      }
    ) : null,
    showSpinner ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Spinner,
      {
        label: "Updating...",
        ariaLive: "assertive",
        labelPosition: "right",
        size: SpinnerSize.large
      }
    ) : null,
    showFilterCallout && filterCalloutComponent,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: mergeStyles({
          height: props.height != null ? props.height : "250px",
          width: props.width != null ? props.width : "100%",
          position: "relative"
        }),
        children: importingStarted ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Spinner,
          {
            label: "Updating...",
            ariaLive: "assertive",
            labelPosition: "right",
            size: SpinnerSize.large
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
          ScrollablePane,
          {
            styles: props.scrollablePaneStyles,
            scrollbarVisibility: ScrollbarVisibility.auto,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(MarqueeSelection, { selection: _selection, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                DetailsList,
                {
                  componentRef: props.componentRef,
                  compact: props.compact ?? true,
                  focusZoneProps: props.focusZoneProps ?? {
                    direction: FocusZoneDirection.bidirectional,
                    handleTabKey: FocusZoneTabbableElements.none,
                    isCircularNavigation: true
                  },
                  items: defaultGridData.length > 0 ? defaultGridData.filter(
                    (x) => x._grid_row_operation_ != _Operation.Delete && x._is_filtered_in_ == true && x._is_filtered_in_grid_search_ == true && x._is_filtered_in_column_filter_ == true
                  ) : [],
                  columns: GridColumns,
                  selectionMode: props.selectionMode,
                  layoutMode: props.layoutMode ?? DetailsListLayoutMode.justified,
                  constrainMode: props.constrainMode ?? ConstrainMode.unconstrained,
                  selection: _selection,
                  setKey: "none",
                  onRenderDetailsHeader: props.onRenderDetailsHeader,
                  ariaLabelForSelectAllCheckbox: "Toggle selection for all items",
                  ariaLabelForSelectionColumn: "Toggle selection",
                  checkButtonAriaLabel: "Row checkbox",
                  ariaLabelForGrid: props.ariaLabelForGrid,
                  ariaLabelForListHeader: props.ariaLabelForListHeader,
                  cellStyleProps: props.cellStyleProps,
                  checkboxCellClassName: props.checkboxCellClassName,
                  checkboxVisibility: props.checkboxVisibility,
                  className: props.className,
                  columnReorderOptions: props.columnReorderOptions,
                  disableSelectionZone: props.disableSelectionZone,
                  dragDropEvents: props.dragDropEvents,
                  enableUpdateAnimations: props.enableUpdateAnimations,
                  enterModalSelectionOnTouch: props.enterModalSelectionOnTouch,
                  getCellValueKey: props.getCellValueKey,
                  getGroupHeight: props.getGroupHeight,
                  getKey: props.getKey,
                  getRowAriaDescribedBy: props.getRowAriaDescribedBy,
                  getRowAriaLabel: props.getRowAriaLabel,
                  groupProps: props.groupProps,
                  groups: props.groups,
                  indentWidth: props.indentWidth,
                  initialFocusedIndex: props.initialFocusedIndex,
                  isHeaderVisible: props.isHeaderVisible,
                  isPlaceholderData: props.isPlaceholderData,
                  listProps: props.listProps,
                  minimumPixelsForDrag: props.minimumPixelsForDrag,
                  onActiveItemChanged: props.onActiveItemChanged,
                  onColumnHeaderClick: props.onColumnHeaderClick,
                  onColumnHeaderContextMenu: props.onColumnHeaderContextMenu,
                  onColumnResize: props.onColumnResize,
                  onDidUpdate: props.onDidUpdate,
                  onItemContextMenu: props.onItemContextMenu,
                  onItemInvoked: props.onItemInvoked,
                  onRenderCheckbox: props.onRenderCheckbox,
                  onRenderDetailsFooter: props.onRenderDetailsFooter,
                  onRenderItemColumn: props.onRenderItemColumn,
                  onRenderMissingItem: props.onRenderMissingItem,
                  onRenderRow: props.onRenderRow,
                  onRowDidMount: props.onRowDidMount,
                  onRowWillUnmount: props.onRowWillUnmount,
                  onShouldVirtualize: props.onShouldVirtualize,
                  rowElementEventMap: props.rowElementEventMap,
                  selectionPreservedOnEmptyClick: props.selectionPreservedOnEmptyClick,
                  selectionZoneProps: props.selectionZoneProps,
                  styles: props.styles,
                  useFastIcons: props.useFastIcons,
                  usePageCache: props.usePageCache,
                  useReducedRowRenderer: props.useReducedRowRenderer,
                  viewport: props.viewport
                }
              ) }),
              contextualMenuProps && /* @__PURE__ */ jsxRuntimeExports.jsx(ContextualMenu, { ...contextualMenuProps })
            ]
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Dialog,
      {
        ...(_b2 = props == null ? void 0 : props.dialogProps) == null ? void 0 : _b2.props,
        hidden: !dialogContent,
        onDismiss: CloseDialog,
        closeButtonAriaLabel: "Close",
        dialogContentProps: {
          title: dialogContent == null ? void 0 : dialogContent.props.id,
          styles: (dialogContent == null ? void 0 : dialogContent.props.className) == "internal" ? internalDialogContentStyles : (_c2 = props == null ? void 0 : props.dialogProps) == null ? void 0 : _c2.dialogContentStyles
        },
        children: dialogContent
      }
    ),
    messageDialogProps.visible ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      MessageDialog,
      {
        message: messageDialogProps.message,
        subMessage: messageDialogProps.subMessage,
        onDialogClose: CloseMessageDialog
      }
    ) : null,
    props.enableColumnEdit && isUpdateColumnClicked ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      ColumnUpdateDialog,
      {
        columnConfigurationData: props.columns,
        onDialogCancel: CloseColumnUpdateDialog,
        onDialogSave: UpdateGridColumnData
      }
    ) : null,
    props.enableColumnFilterRules && isColumnFilterClicked ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      ColumnFilterDialog,
      {
        columnConfigurationData: props.columns.filter(
          (item) => filteredColumns.indexOf(item) < 0 && isColumnDataTypeSupportedForFilter(item.dataType)
        ),
        onDialogCancel: CloseColumnFilterDialog,
        onDialogSave: onFilterApplied,
        gridData: forceKeyMapping(defaultGridData, "key")
      }
    ) : null
  ] }) }) }) });
};
const CellHoverComponent = (props) => {
  var _a2;
  React.useEffect(() => {
  }, [props.rowNum]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    ScrollablePane,
    {
      style: { margin: "10px" },
      scrollbarVisibility: ScrollbarVisibility.auto,
      id: "griddataid",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { color: "green" }, children: "Custom Hover Component" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h6", { children: [
          "Row Number: ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "blue" }, children: props.rowNum })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h6", { children: [
          "Column: ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "blue" }, children: (_a2 = props.column) == null ? void 0 : _a2.name })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h6", { children: [
          "ID: ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "blue" }, children: props.rowData["id"] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h6", { children: [
          "Name: ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "blue" }, children: props.rowData["name"] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h6", { children: [
          "Age: ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "blue" }, children: props.rowData["age"] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h6", { children: [
          "Designation:",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "blue" }, children: props.rowData["designation"] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h6", { children: [
          "Salary:",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "blue" }, children: props.rowData["salary"] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h6", { children: [
          "Date Of Joining:",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "blue" }, children: props.rowData["dateofjoining"] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h6", { children: [
          "Payroll Type:",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "blue" }, children: props.rowData["payrolltype"] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h6", { children: [
          "Employment Type:",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "blue" }, children: props.rowData["employmenttype"] })
        ] })
      ]
    }
  ) });
};
var GridToastTypes = /* @__PURE__ */ ((GridToastTypes2) => {
  GridToastTypes2["INFO"] = "info";
  GridToastTypes2["SUCCESS"] = "success";
  GridToastTypes2["ERROR"] = "error";
  GridToastTypes2["WARNING"] = "warning";
  GridToastTypes2["DARK"] = "dark";
  GridToastTypes2["WARN"] = "warn";
  return GridToastTypes2;
})(GridToastTypes || {});
exports.CellHover = CellHoverComponent;
exports.DepColTypes = DepColTypes;
exports.DisableColTypes = DisableColTypes;
exports.EditControlType = EditControlType;
exports.EditableGrid = EditableGrid;
exports.EventEmitter = EventEmitter;
exports.EventType = EventType;
exports.GridToastTypes = GridToastTypes;
exports.InternalEditableGridPropertiesKeys = InternalEditableGridPropertiesKeys;
exports.NumberAndDateOperators = NumberAndDateOperators;
exports.StringOperators = StringOperators;
exports._Operation = _Operation;
//# sourceMappingURL=fluentui.editablegrid.lib.cjs.map
